#include "E2AP.h"


/*****************************************/
/*           TransactionID                */
/*****************************************/
//5 mau integer
//mau 5 integer size(a .. b..) mau la nrfreqencyband
EXTERN int asn1PE_e2ap_TransactionID (OSCTXT* pctxt, e2ap_TransactionID value){
    int stat =0;
    OSBOOL extbit = FALSE;
    RTXCTCXTPUSHTYPENAME (pctxt, "TransactionID");
    if(value>0 && value<=255){
        extbit = 0;
    }
    else extbit =1;
    stat = rtxEncBit (pctxt, extbit);
    if (stat != 0) return LOG_RTERR (pctxt, stat);
    if(extbit){
        stat = pe_UnconsUnsigned (pctxt, value);
        if(stat != 0) return LOG_RTERR (pctxt, stat);
    }
    else{
        stat = pe_ConsUnsigned (pctxt, value, 0, 255);
        if (stat != 0) return LOG_RTERR (pctxt, stat);
    }
    RTXCTXTPOPTYPENAME (pctxt);
    return stat;
}
EXTERN int asn1PD_e2ap_TransactionID (OSCTXT* pctxt, e2ap_TransactionID* pvalue){
    int stat =0;
    OSBOOL extbit = FALSE;
    RTXCTCXTPUSHTYPENAME (pctxt, "TransactionID");
    /*extensiobit*/
    stat = DECBIT (pctxt, &extbit);
    if (stat != 0) return LOG_RTERR (pctxt, stat);
    if(extbit==0){
        stat = pd_ConsUnsigned (pctxt, pvalue, 0, 255);
        if (stat != 0) return LOG_RTERR (pctxt, stat);
    }else{
        stat = pd_UnconsUnsigned (pctxt, pvalue);
        if (stat != 0) return LOG_RTERR (pctxt, stat);
    }
    RTXCTXTPOPTYPENAME (pctxt);
    return stat;
}
//EXTERN int asn1Print_e2ap_TransactionID (const char* name, const e2ap_TransactionID* pvalue);
//EXTERN int asn1PrtToStr_e2ap_TransactionID (const char* name, e2ap_TransactionID* pvalue, char* buffer, OSSIZE bufSize);
//EXTERN int asn1PrtToStrm_e2ap_TransactionID (OSCTXT* pctxt, const char* name, const e2ap_TransactionID* pvalue);
EXTERN int asn1Init_e2ap_TransactionID (e2ap_TransactionID* pvalue){
    //if (pvalue == 0) return RTERR_NULLPTR;
    //*pvalue = 0;
    return 0;
}
EXTERN int asn1Free_e2ap_TransactionID (OSCTXT* pctxt, e2ap_TransactionID* pvalue){
    // No dynamic memory to free for integer
    return 0;
}

/*****************************************/
/*           TNLinformation                */
/*****************************************/
//sequence normal
// Các nội dung cần thiết cho template seq_normal.c.j2
    // Nội dung của file .c cho primitive BIT STRING (SIZE(1..160,...))
    /* bitstring intergrate header file */
//metadata.parsed.primitive_id == 2


//mau Transportlayeraddress xn bitstring (a..b,..)

EXTERN int asn1PE_e2ap_TNLinformation_tnlAddress(OSCTXT* pctxt, e2ap_TNLinformation_tnlAddress value){
    int stat =0;
    //RTXCTXTPUSHTYPENAME(pctxt, "tnlAddress");
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(1), OSUINTCONST(160), OSUINTCONST(0), OSUINT32_MAX);
    stat = pe_BitString (pctxt, OS_MIN(value.numbits, 160), value.data);
    if(stat != 0) return LOG_RTERR (pctxt, stat);
    //RTXCTXTPOPTYPENAME(pctxt);
    return stat;
}
EXTERN int asn1PD_e2ap_TNLinformation_tnlAddress(OSCTXT* pctxt, e2ap_TNLinformation_tnlAddress* pvalue){
    int stat =0;
    //RTXCTXTPUSHTYPENAME(pctxt, "tnlAddress");
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(1), OSUINTCONST(160), OSUINTCONST(0), OSUINT32_MAX);
    stat =  pd_DynBitString (pctxt, pvalue);
    if(stat != 0) return LOG_RTERR (pctxt, stat);
    //RTXCTXTPOPTYPENAME(pctxt);
    return stat;
}
EXTERN int asn1PrtToStr_e2ap_TNLinformation_tnlAddress (const char* name, e2ap_TNLinformation_tnlAddress *pvalue, char* buffer, OSSIZE bufSize){
    if(rtPrintToStringIndent(buffer, bufSize) < 0) return -1;
    if(rtPrintToStringBitStrBraceText(name, OS_MIN(pvalue->numbits, 160), pvalue->data, buffer, bufSize) < 0) return -1;
    return 0;
}
//EXTERN int asn1PrtToStrm_e2ap_TNLinformation_tnlAddress (OSCTXT* pctxt, const char* name, const e2ap_TNLinformation_tnlAddress* pvalue);
//EXTERN int asn1Copy_e2ap_TNLinformation_tnlAddress(OSCTXT* pctxt,const e2ap_TNLinformation_tnlAddress* pSrcValue,  e2ap_TNLinformation_tnlAddress* pDstValue);
EXTERN int asn1Init_e2ap_TNLinformation_tnlAddress(e2ap_TNLinformation_tnlAddress* pvalue){
    if(0==pvalue) return RTERR_NULLPTR;
    pvalue->numbits=0;
    pvalue->data =0;
    return 0;
}
EXTERN void asn1Free_e2ap_TNLinformation_tnlAddress(OSCTXT* pctxt, e2ap_TNLinformation_tnlAddress* pvalue){
    if(0==pvalue) return;   
    if(pvalue->numbits >0){
        rtxMemFreePtr(pctxt, (void*)pvalue->data);
        pvalue->data =0;
        pvalue->numbits=0;
    }
}


    // Nội dung của file .c cho primitive BIT STRING (SIZE(16))
    /* bitstring intergrate header file */
//metadata.parsed.primitive_id == 3

//mau rnti_full ben xn  bitstring (n)

EXTERN int asn1PE_e2ap_TNLinformation_tnlPort(OSCTXT* pctxt, e2ap_TNLinformation_tnlPort* pvalue){
    int stat =0;
    //RTXCTXTPUSHTYPENAME(pctxt, "tnlPort");
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(16), OSUINTCONST(16), 0, 0);
    stat = pe_BitString (pctxt, OS_MIN(pvalue->numbits, 16), pvalue->data);
    if(stat != 0) return LOG_RTERR (pctxt, stat);
    //RTXCTXTPOPTYPENAME(pctxt);
    return stat;
}
EXTERN int asn1PD_e2ap_TNLinformation_tnlPort(OSCTXT* pctxt, e2ap_TNLinformation_tnlPort* pvalue){
    int stat =0;
    //RTXCTXTPUSHTYPENAME(pctxt, "tnlPort");
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(16), OSUINTCONST(16), 0, 0);
    stat = pd_BitString (pctxt, &pvalue->numbits, pvalue->data, sizeof(pvalue->data));
    if(stat != 0) return LOG_RTERR (pctxt, stat);
    //RTXCTXTPOPTYPENAME(pctxt);
    return stat;
}
EXTERN int asn1PrtToStr_e2ap_TNLinformation_tnlPort (const char* name, e2ap_TNLinformation_tnlPort* pvalue, char* buffer, OSSIZE bufSize){
    if(rtPrintToStringIndent(buffer, bufSize) < 0) return -1;
    if(rtPrintToStringBitStrBraceText (name, OS_MIN(pvalue->numbits, 16), pvalue->data, buffer, bufSize) < 0) return -1;
    return 0;
}
//EXTERN int asn1PrtToStrm_e2ap_TNLinformation_tnlPort (OSCTXT* pctxt, const char* name, const e2ap_TNLinformation_tnlPort* pvalue);
//EXTERN int asn1Copy_e2ap_TNLinformation_tnlPort(OSCTXT* pctxt,const e2ap_TNLinformation_tnlPort* pSrcValue,  e2ap_TNLinformation_tnlPort* pDstValue);
EXTERN int asn1Init_e2ap_TNLinformation_tnlPort(e2ap_TNLinformation_tnlPort* pvalue){
    if(0==pvalue) return RTERR_NULLPTR;
    pvalue->numbits=0;
    return 0;
}
EXTERN void asn1Free_e2ap_TNLinformation_tnlPort(OSCTXT* pctxt, e2ap_TNLinformation_tnlPort* pvalue){
    // No dynamic memory to free for fixed-size BIT STRING
    return;
}




// Các phần còn lại của template seq_normal.c.j2
//contain extensition bit -> theo mau cua GlobalgNB-ID
int asn1PE_e2ap_TNLinformation (OSCTXT* pctxt, e2ap_TNLinformation* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "TNLinformation");

   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);

   /*optional bit for field tnlPort*/
   stat = rtxEncBit (pctxt, pvalue->m_tnlPortPresent);
   if (stat != 0) return LOG_RTERR(pctxt, stat);

   /*encode root elements*/   
   /* encode field tnlAddress - id = 2*/  
   RTXCTXTPUSHELEMNAME(pctxt, "tnlAddress");
   stat = asn1PE_e2ap_TNLinformation_tnlAddress(pctxt, pvalue->tnlAddress); //primitive
  
  
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /* encode field tnlPort - id = 3*/  
   if (pvalue->m_tnlPortPresent) {//OPTIONAL FIELD
   RTXCTXTPUSHELEMNAME(pctxt, "tnlPort");
   stat = asn1PE_e2ap_TNLinformation_tnlPort(pctxt, &pvalue->tnlPort); //primitive
  
  
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   }


   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_TNLinformation (OSCTXT* pctxt, e2ap_TNLinformation* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME(pctxt, "TNLinformation");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field tnlAddress */
   RTXCTXTPUSHELEMNAME(pctxt, "tnlAddress");
      stat = asn1PD_e2ap_TNLinformation_tnlAddress (pctxt, &pvalue->tnlAddress); //primitive
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field tnlPort */
   RTXCTXTPUSHELEMNAME(pctxt, "tnlPort");
   if (optbits[0]) {
      pvalue->m_tnlPortPresent = TRUE;
      stat = asn1PD_e2ap_TNLinformation_tnlPort (pctxt, &pvalue->tnlPort); //primitive
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   } else {
      pvalue->m_tnlPortPresent = FALSE;
   }
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_TNLinformation (e2ap_TNLinformation* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_TNLinformation_tnlAddress (&pvalue->tnlAddress); //primitive delete &
   asn1Init_e2ap_TNLinformation_tnlPort (&pvalue->tnlPort); //primitive delete &
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_TNLinformation (OSCTXT* pctxt, e2ap_TNLinformation* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_TNLinformation_tnlAddress (pctxt, &pvalue->tnlAddress); //primitive delete &
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_TNLinformation (const char* name, e2ap_TNLinformation* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }

   if(asn1PrtToStr_e2ap_TNLinformation_tnlAddress ("tnlAddress", &pvalue->tnlAddress, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_TNLinformation_tnlPort ("tnlPort", &pvalue->tnlPort, buffer, bufSize) < 0)
   {
      return -1;
   }


   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/******************************************************/
/*                                                    */
/*    TNLusage                          */
/*                                                    */
/******************************************************/
//enumerated


const OSEnumItem e2ap_TNLusage_ENUMTAB[] = {
    { OSUTF8("ric_service"), 0, 11, 0 },
    { OSUTF8("support_function"), 1, 16, 1 },
    { OSUTF8("both"), 2, 4, 2 }
};


const OSUTF8CHAR* e2ap_TNLusage_ToString (OSUINT32 value){
   OSINT32 idx = value;
   if(idx >=0 && idx < e2ap_TNLusage_ENUMTABSIZE){
      return e2ap_TNLusage_ENUMTAB[e2ap_TNLusage_ENUMTAB[idx].transidx].name;
   }else{
      return OSUTF8("_UNKNOWN_");
   }
}


int e2ap_TNLusage_ToEnum (OSCTXT* pctxt, const OSUTF8CHAR* value,e2ap_TNLusage* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes(value);
   return e2ap_TNLusage_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int e2ap_TNLusage_ToEnum2 (OSCTXT* pctxt, const OSUTF8CHAR* value, OSSIZE valueLen,e2ap_TNLusage* pvalue)
{
   OSINT32 idx = rtxLookupEnum(value, valueLen,
      e2ap_TNLusage_ENUMTAB, e2ap_TNLusage_ENUMTABSIZE);
   if (idx >= 0) {
      *pvalue = (e2ap_TNLusage)e2ap_TNLusage_ENUMTAB[idx].value;
      return 0;
   } else {
      rtxErrAddIntParm (pctxt, (const char*)value);//dungnm23 check xem là Str hay Int
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_e2ap_TNLusage (OSCTXT* pctxt, e2ap_TNLusage value)
{
   int stat = 0;
   RTXCTXTPUSHTYPENAME (pctxt, "TNLusage");
   if (value >= 3) {
      rtxErrAddIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(2));
   if(stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}

EXTERN int asn1PD_e2ap_TNLusage (OSCTXT* pctxt, e2ap_TNLusage* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TNLusage");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(2));
   if(stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return stat;
}

EXTERN int asn1PrtToStr_e2ap_TNLusage (const char* name, e2ap_TNLusage* pvalue, char* buffer, OSSIZE bufSize)
{
   int stat;

   if(rtPrintToStringIndent(buffer, bufSize) < 0) return -1;
   if(rtPrintToString(name, buffer, bufSize) < 0) return -1;

   switch(*pvalue) {
      case 0:
         stat = rtPrintToString(" = ric_service \n", buffer, bufSize);
         break;
      case 1:
         stat = rtPrintToString(" = support_function \n", buffer, bufSize);
         break;
      case 2:
         stat = rtPrintToString(" = both \n", buffer, bufSize);
         break;
      default:
         stat = rtPrintToString(" = ???\n", buffer, bufSize);
   }

   if (stat < 0) return -1;
   return 0;

}

/*Init*/
EXTERN int asn1Init_e2ap_TNLusage (e2ap_TNLusage* pvalue){
      //if (pvalue == 0) return RTERR_NULLPTR;
      //*pvalue = 0;
      return 0;
}
/*****************************************/
/*           E2connectionUpdate-Item                */
/*****************************************/
//sequence normal
// Các nội dung cần thiết cho template seq_normal.c.j2

// Các phần còn lại của template seq_normal.c.j2
//contain extensition bit -> theo mau cua GlobalgNB-ID
int asn1PE_e2ap_E2connectionUpdate_Item (OSCTXT* pctxt, e2ap_E2connectionUpdate_Item* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "E2connectionUpdate-Item");

   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field tnlInformation - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "tnlInformation");
   stat = asn1PE_e2ap_TNLinformation (pctxt, pvalue->tnlInformation);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /* encode field tnlUsage - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "tnlUsage");
   stat = asn1PE_e2ap_TNLusage (pctxt, pvalue->tnlUsage);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);



   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_E2connectionUpdate_Item (OSCTXT* pctxt, e2ap_E2connectionUpdate_Item* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME(pctxt, "E2connectionUpdate-Item");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field tnlInformation */
   RTXCTXTPUSHELEMNAME(pctxt, "tnlInformation");
      stat = asn1PD_e2ap_TNLinformation (pctxt, &pvalue->tnlInformation);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field tnlUsage */
   RTXCTXTPUSHELEMNAME(pctxt, "tnlUsage");
      stat = asn1PD_e2ap_TNLusage (pctxt, &pvalue->tnlUsage);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_E2connectionUpdate_Item (e2ap_E2connectionUpdate_Item* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_TNLinformation (&pvalue->tnlInformation);
   asn1Init_e2ap_TNLusage (&pvalue->tnlUsage);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_E2connectionUpdate_Item (OSCTXT* pctxt, e2ap_E2connectionUpdate_Item* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_TNLinformation (pctxt, &pvalue->tnlInformation);
   asn1Free_e2ap_TNLusage (pctxt, &pvalue->tnlUsage);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_E2connectionUpdate_Item (const char* name, e2ap_E2connectionUpdate_Item* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }
   if(asn1PrtToStr_e2ap_TNLinformation ("tnlInformation", &pvalue->tnlInformation, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_TNLusage ("tnlUsage", &pvalue->tnlUsage, buffer, bufSize) < 0)
   {
      return -1;
   }



   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           E2connectionUpdate_ItemIEs                */
/*****************************************/
/* ie.c.j2 */
/*ie thường*/
int asn1PE_e2ap_E2connectionUpdate_ItemIEs (OSCTXT* pctxt, e2ap_E2connectionUpdate_ItemIEs* pvalue)
{
   int stat = 0;
   //RTXCTXTPUSHTYPENAME (pctxt, "E2connectionUpdate-ItemIEs");

   /* encode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");
   stat = asn1PE_e2ap_ProtocolIE_ID (pctxt, pvalue->id);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");
   stat = asn1PE_e2ap_Criticality (pctxt, pvalue->criticality);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   {
      OSCTXT ictxt;
      OSOCTET* pDynamicEncodeBuffer;
      ASN1OpenType openType;
      OSBOOL  encoded = TRUE;

      openType.numocts = 0;
      openType.data = 0;

      rtxCopyContext (&ictxt, pctxt);
      pctxt->pStream = 0;

      stat = rtxInitContextBuffer (pctxt, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_E2connectionUpdate_ItemIEs_id_E2connectionUpdate_Item:
         
        // RTXCTXTPUSHELEMNAME (pctxt, "E2connectionUpdate_ItemIEs_id_E2connectionUpdate_Item");
         RTXCTXTPUSHELEMNAME (pctxt, "E2connectionUpdate-Item");
         stat = asn1PE_e2ap_E2connectionUpdate_Item (pctxt, pvalue->value.u._e2apE2connectionUpdate_ItemIEs_id_E2connectionUpdate_Item);
         RTXCTXTPOPELEMNAME (pctxt);
      
         break;

      case T_E2AP_PDU_Contents_e2ap_E2connectionUpdate_ItemIEs_UNDEF_:
      {
          if(0!=pvalue->value.u.extElem1){
              openType.numocts = pvalue->value.u.extElem1->numocts;
              openType.data = pvalue->value.u.extElem1->data;
          } else {
              /* No extension element to encode */
          }
          encoded = FALSE;
          break;
      }
      default:
         encoded = FALSE;
         stat = RTERR_INVOPT;
      }

      if (encoded) {
         openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
         openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
      }
      rtxCopyContext (pctxt, &ictxt);
      if(stat ==0) stat = pe_OpenType(pctxt, openType.numocts, openType.data);
      /*free dynamic encode buffer*/
      if(encoded){
          rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
      }
   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);
   //RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

int asn1PD_e2ap_E2connectionUpdate_ItemIEs (OSCTXT* pctxt, e2ap_E2connectionUpdate_ItemIEs* pvalue)
{
   int stat =0;
   /*deode root element id*/
   RTXCTXTPUSHELEMNAME(pctxt, "id");
   stat = asn1PD_e2ap_ProtocolIE_ID (pctxt, &pvalue->id);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*decode root element criticality*/
   RTXCTXTPUSHELEMNAME(pctxt, "criticality");
   stat = asn1PD_e2ap_Criticality (pctxt, &pvalue->criticality);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   /*decode root element value*/
   RTXCTXTPUSHELEMNAME(pctxt, "value");
   {
      OSUINT32 openTypeLen;
      size_t bitStartOffset, bitLength;
      stat = pd_UnconsLength(pctxt, &openTypeLen);
      if(stat <0) return LOG_RTERR(pctxt, stat);
      else if(stat == RT_OK_FRAG){
         rtxErrAddStrParm(pctxt, "open type with fragmented length use - perindef");
         return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
      }
      bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
      bitLength = openTypeLen * 8;
      switch (pvalue->id){
         case T_E2AP_PDU_Contents_e2ap_E2connectionUpdate_ItemIEs_id_E2connectionUpdate_Item:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_E2connectionUpdate_ItemIEs_id_E2connectionUpdate_Item;
            RTXCTXTPUSHELEMNAME(pctxt, "E2connectionUpdate-Item");
            //pvalue->value.u._e2ap_E2connectionUpdate_ItemIEs_id_id_E2connectionUpdate_Item 
             pvalue->value.u._e2apE2connectionUpdate_ItemIEs_id_E2connectionUpdate_Item 
                    = rtxMemAllocType(pctxt, e2ap_E2connectionUpdate_Item);
            //asn1Init_e2ap_E2connectionUpdate_Item(pvalue->value.u._e2ap_E2connectionUpdate_ItemIEs_id_id_E2connectionUpdate_Item);
            asn1Init_e2ap_E2connectionUpdate_Item(pvalue->value.u._e2apE2connectionUpdate_ItemIEs_id_E2connectionUpdate_Item);
            stat = asn1PD_e2ap_E2connectionUpdate_Item (pctxt,
                    (e2ap_E2connectionUpdate_Item*)pvalue->value.
                    u._e2apE2connectionUpdate_ItemIEs_id_E2connectionUpdate_Item);
            if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_E2connectionUpdate_ItemIEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*)rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
      }
      {
      size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
      size_t bitsConsumed = bitEndOffset - bitStartOffset;
      if(bitsConsumed < bitLength){
         stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
      } else {
         stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
      }
      }
   }
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   return stat;
}

void asn1Init_e2ap_E2connectionUpdate_ItemIEs (e2ap_E2connectionUpdate_ItemIEs* pvalue)
{
   if (!pvalue) return;
   OSCRTLMEMSET (pvalue, 0, sizeof(e2ap_E2connectionUpdate_ItemIEs));
}

#if 0
void asn1Free_e2ap_E2connectionUpdate_ItemIEs (OSCTXT* pctxt, e2ap_E2connectionUpdate_ItemIEs* pvalue)
{
   if (!pvalue) return;
   if (pvalue->extElem1) {
      rtxMemFreeArray (pctxt, pvalue->extElem1);
      pvalue->extElem1 = 0;
      pvalue->extElem1_n = 0;
   }
}
#endif
void asn1Free_e2ap_E2connectionUpdate_ItemIEs (OSCTXT* pctxt, e2ap_E2connectionUpdate_ItemIEs* pvalue)
{
   if(0==pvalue) return;
   switch(pvalue->value.t){
      case T_E2AP_PDU_Contents_e2ap_E2connectionUpdate_ItemIEs_id_E2connectionUpdate_Item:
         asn1Free_e2ap_E2connectionUpdate_Item (pctxt, pvalue->value.u._e2apE2connectionUpdate_ItemIEs_id_E2connectionUpdate_Item);
         rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2apE2connectionUpdate_ItemIEs_id_E2connectionUpdate_Item);
         pvalue->value.u._e2apE2connectionUpdate_ItemIEs_id_E2connectionUpdate_Item = 0;
         break;
      case T_E2AP_PDU_Contents_e2ap_E2connectionUpdate_ItemIEs_UNDEF_:
         if(0!=pvalue->value.u.extElem1){
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1->data);
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
             pvalue->value.u.extElem1 =0;
         }
         break;
         default:;
   }
}

int  asn1PrtToStr_e2ap_E2connectionUpdate_ItemIEs (const char * name, e2ap_E2connectionUpdate_ItemIEs* pvalue, char * buffer, OSSIZE bufSize){
   if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
       return -1;

      if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
         return -1;

      if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
         return -1;
      if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
         return -1;
      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_E2connectionUpdate_ItemIEs_id_E2connectionUpdate_Item:
         if(asn1PrtToStr_e2ap_E2connectionUpdate_Item("E2connectionUpdate-Item",
                pvalue->value.u._e2apE2connectionUpdate_ItemIEs_id_E2connectionUpdate_Item, buffer, bufSize)<0)// dungnm23 check lai nhe xem la
            return -1;
         break;
      default:
         if(0!=pvalue -> value.u.extElem1){
             rtPrintToStringIndent(buffer, bufSize);
             rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

         }
      }
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

      return 0;

}
 

/*****************************************/
/*           E2connectionUpdate_List                */
/*****************************************/
//seq_of_single_container


int asn1PE_e2ap_E2connectionUpdate_List (OSCTXT* pctxt, e2ap_E2connectionUpdate_List* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_E2connectionUpdate_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "E2connectionUpdate-List");

   /* encode length determinant */
   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;
   for (xx1 = 0; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next, xx1++) {
      pdata = (e2ap_E2connectionUpdate_ItemIEs*) pnode->data;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_e2ap_E2connectionUpdate_ItemIEs (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      //xx1++;
      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}

int asn1PD_e2ap_E2connectionUpdate_List (OSCTXT* pctxt, e2ap_E2connectionUpdate_List* ppvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_E2connectionUpdate_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "E2connectionUpdate-List");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (ppvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      pdata = rtxMemAllocType (pctxt, e2ap_E2connectionUpdate_ItemIEs);
      if (!pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);
      asn1Init_e2ap_E2connectionUpdate_ItemIEs (pdata);
      stat = asn1PD_e2ap_E2connectionUpdate_ItemIEs (pctxt, pdata);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         return LOG_RTERR (pctxt, stat);
      }

      rtxDListAppendNode (ppvalue, pdata);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

void asn1Init_e2ap_E2connectionUpdate_List (e2ap_E2connectionUpdate_List* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
}

void asn1Free_e2ap_E2connectionUpdate_List (OSCTXT* pctxt, e2ap_E2connectionUpdate_List* pvalue)
{
   if(pvalue==0) return;
   OSRTDListNode* pnode = pvalue->head;
   while (pnode) {
      e2ap_E2connectionUpdate_ItemIEs* pdata = (e2ap_E2connectionUpdate_ItemIEs*) pnode->data;
      if (pdata) {
         asn1Free_e2ap_E2connectionUpdate_ItemIEs (pctxt, pdata);
         rtxMemFreePtr (pctxt, pdata);
      }
      pnode = pnode->next;
   }
      rtxDListFreeAll(pctxt, pvalue);
}

#if 0
void asn1Free_e2ap_E2connectionUpdate_List (OSCTXT* pctxt, e2ap_E2connectionUpdate_List* pvalue){
   if(0==pvalue ) return;
   {
      e2ap_E2connectionUpdate_ItemIEs * pdata;
      OSRTDListNode *pnode = pvalue->head;
      while(0!=pnode){
         pdata = (e2ap_E2connectionUpdate_ItemIEs*)pnode->data;
         asn1Free_e2ap_E2connectionUpdate_ItemIEs(pctxt, pdata);
         pnode = pnode->next;
      }
      rtxDListFreeAll(pctxt, pvalue);
   }
}
#endif


int asn1PrtToStr_e2ap_E2connectionUpdate_List(const char* name, e2ap_E2connectionUpdate_List* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_E2connectionUpdate_ItemIEs* pdata;
    OSRTDListNode* pnode;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode = pvalue->head;  xx1 < pvalue->count && pnode != 0; pnode = pnode->next, xx1++){
        pdata = (e2ap_E2connectionUpdate_ItemIEs*)pnode->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 1
        if(asn1PrtToStr_e2ap_E2connectionUpdate_ItemIEs(nameBuf, pdata, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}
/*****************************************/
/*           E2connectionUpdateRemove-Item                */
/*****************************************/
//sequence normal
// Các nội dung cần thiết cho template seq_normal.c.j2

// Các phần còn lại của template seq_normal.c.j2
//contain extensition bit -> theo mau cua GlobalgNB-ID
int asn1PE_e2ap_E2connectionUpdateRemove_Item (OSCTXT* pctxt, e2ap_E2connectionUpdateRemove_Item* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "E2connectionUpdateRemove-Item");

   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field tnlInformation - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "tnlInformation");
   stat = asn1PE_e2ap_TNLinformation (pctxt, pvalue->tnlInformation);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);



   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_E2connectionUpdateRemove_Item (OSCTXT* pctxt, e2ap_E2connectionUpdateRemove_Item* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME(pctxt, "E2connectionUpdateRemove-Item");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field tnlInformation */
   RTXCTXTPUSHELEMNAME(pctxt, "tnlInformation");
      stat = asn1PD_e2ap_TNLinformation (pctxt, &pvalue->tnlInformation);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_E2connectionUpdateRemove_Item (e2ap_E2connectionUpdateRemove_Item* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_TNLinformation (&pvalue->tnlInformation);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_E2connectionUpdateRemove_Item (OSCTXT* pctxt, e2ap_E2connectionUpdateRemove_Item* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_TNLinformation (pctxt, &pvalue->tnlInformation);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_E2connectionUpdateRemove_Item (const char* name, e2ap_E2connectionUpdateRemove_Item* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }
   if(asn1PrtToStr_e2ap_TNLinformation ("tnlInformation", &pvalue->tnlInformation, buffer, bufSize) < 0)
   {
      return -1;
   }



   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           E2connectionUpdateRemove_ItemIEs                */
/*****************************************/
/* ie.c.j2 */
/*ie thường*/
int asn1PE_e2ap_E2connectionUpdateRemove_ItemIEs (OSCTXT* pctxt, e2ap_E2connectionUpdateRemove_ItemIEs* pvalue)
{
   int stat = 0;
   //RTXCTXTPUSHTYPENAME (pctxt, "E2connectionUpdateRemove-ItemIEs");

   /* encode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");
   stat = asn1PE_e2ap_ProtocolIE_ID (pctxt, pvalue->id);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");
   stat = asn1PE_e2ap_Criticality (pctxt, pvalue->criticality);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   {
      OSCTXT ictxt;
      OSOCTET* pDynamicEncodeBuffer;
      ASN1OpenType openType;
      OSBOOL  encoded = TRUE;

      openType.numocts = 0;
      openType.data = 0;

      rtxCopyContext (&ictxt, pctxt);
      pctxt->pStream = 0;

      stat = rtxInitContextBuffer (pctxt, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_E2connectionUpdateRemove_ItemIEs_id_E2connectionUpdateRemove_Item:
         
        // RTXCTXTPUSHELEMNAME (pctxt, "E2connectionUpdateRemove_ItemIEs_id_E2connectionUpdateRemove_Item");
         RTXCTXTPUSHELEMNAME (pctxt, "E2connectionUpdateRemove-Item");
         stat = asn1PE_e2ap_E2connectionUpdateRemove_Item (pctxt, pvalue->value.u._e2apE2connectionUpdateRemove_ItemIEs_id_E2connectionUpdateRemove_Item);
         RTXCTXTPOPELEMNAME (pctxt);
      
         break;

      case T_E2AP_PDU_Contents_e2ap_E2connectionUpdateRemove_ItemIEs_UNDEF_:
      {
          if(0!=pvalue->value.u.extElem1){
              openType.numocts = pvalue->value.u.extElem1->numocts;
              openType.data = pvalue->value.u.extElem1->data;
          } else {
              /* No extension element to encode */
          }
          encoded = FALSE;
          break;
      }
      default:
         encoded = FALSE;
         stat = RTERR_INVOPT;
      }

      if (encoded) {
         openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
         openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
      }
      rtxCopyContext (pctxt, &ictxt);
      if(stat ==0) stat = pe_OpenType(pctxt, openType.numocts, openType.data);
      /*free dynamic encode buffer*/
      if(encoded){
          rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
      }
   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);
   //RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

int asn1PD_e2ap_E2connectionUpdateRemove_ItemIEs (OSCTXT* pctxt, e2ap_E2connectionUpdateRemove_ItemIEs* pvalue)
{
   int stat =0;
   /*deode root element id*/
   RTXCTXTPUSHELEMNAME(pctxt, "id");
   stat = asn1PD_e2ap_ProtocolIE_ID (pctxt, &pvalue->id);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*decode root element criticality*/
   RTXCTXTPUSHELEMNAME(pctxt, "criticality");
   stat = asn1PD_e2ap_Criticality (pctxt, &pvalue->criticality);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   /*decode root element value*/
   RTXCTXTPUSHELEMNAME(pctxt, "value");
   {
      OSUINT32 openTypeLen;
      size_t bitStartOffset, bitLength;
      stat = pd_UnconsLength(pctxt, &openTypeLen);
      if(stat <0) return LOG_RTERR(pctxt, stat);
      else if(stat == RT_OK_FRAG){
         rtxErrAddStrParm(pctxt, "open type with fragmented length use - perindef");
         return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
      }
      bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
      bitLength = openTypeLen * 8;
      switch (pvalue->id){
         case T_E2AP_PDU_Contents_e2ap_E2connectionUpdateRemove_ItemIEs_id_E2connectionUpdateRemove_Item:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_E2connectionUpdateRemove_ItemIEs_id_E2connectionUpdateRemove_Item;
            RTXCTXTPUSHELEMNAME(pctxt, "E2connectionUpdateRemove-Item");
            //pvalue->value.u._e2ap_E2connectionUpdateRemove_ItemIEs_id_id_E2connectionUpdateRemove_Item 
             pvalue->value.u._e2apE2connectionUpdateRemove_ItemIEs_id_E2connectionUpdateRemove_Item 
                    = rtxMemAllocType(pctxt, e2ap_E2connectionUpdateRemove_Item);
            //asn1Init_e2ap_E2connectionUpdateRemove_Item(pvalue->value.u._e2ap_E2connectionUpdateRemove_ItemIEs_id_id_E2connectionUpdateRemove_Item);
            asn1Init_e2ap_E2connectionUpdateRemove_Item(pvalue->value.u._e2apE2connectionUpdateRemove_ItemIEs_id_E2connectionUpdateRemove_Item);
            stat = asn1PD_e2ap_E2connectionUpdateRemove_Item (pctxt,
                    (e2ap_E2connectionUpdateRemove_Item*)pvalue->value.
                    u._e2apE2connectionUpdateRemove_ItemIEs_id_E2connectionUpdateRemove_Item);
            if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_E2connectionUpdateRemove_ItemIEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*)rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
      }
      {
      size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
      size_t bitsConsumed = bitEndOffset - bitStartOffset;
      if(bitsConsumed < bitLength){
         stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
      } else {
         stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
      }
      }
   }
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   return stat;
}

void asn1Init_e2ap_E2connectionUpdateRemove_ItemIEs (e2ap_E2connectionUpdateRemove_ItemIEs* pvalue)
{
   if (!pvalue) return;
   OSCRTLMEMSET (pvalue, 0, sizeof(e2ap_E2connectionUpdateRemove_ItemIEs));
}

#if 0
void asn1Free_e2ap_E2connectionUpdateRemove_ItemIEs (OSCTXT* pctxt, e2ap_E2connectionUpdateRemove_ItemIEs* pvalue)
{
   if (!pvalue) return;
   if (pvalue->extElem1) {
      rtxMemFreeArray (pctxt, pvalue->extElem1);
      pvalue->extElem1 = 0;
      pvalue->extElem1_n = 0;
   }
}
#endif
void asn1Free_e2ap_E2connectionUpdateRemove_ItemIEs (OSCTXT* pctxt, e2ap_E2connectionUpdateRemove_ItemIEs* pvalue)
{
   if(0==pvalue) return;
   switch(pvalue->value.t){
      case T_E2AP_PDU_Contents_e2ap_E2connectionUpdateRemove_ItemIEs_id_E2connectionUpdateRemove_Item:
         asn1Free_e2ap_E2connectionUpdateRemove_Item (pctxt, pvalue->value.u._e2apE2connectionUpdateRemove_ItemIEs_id_E2connectionUpdateRemove_Item);
         rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2apE2connectionUpdateRemove_ItemIEs_id_E2connectionUpdateRemove_Item);
         pvalue->value.u._e2apE2connectionUpdateRemove_ItemIEs_id_E2connectionUpdateRemove_Item = 0;
         break;
      case T_E2AP_PDU_Contents_e2ap_E2connectionUpdateRemove_ItemIEs_UNDEF_:
         if(0!=pvalue->value.u.extElem1){
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1->data);
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
             pvalue->value.u.extElem1 =0;
         }
         break;
         default:;
   }
}

int  asn1PrtToStr_e2ap_E2connectionUpdateRemove_ItemIEs (const char * name, e2ap_E2connectionUpdateRemove_ItemIEs* pvalue, char * buffer, OSSIZE bufSize){
   if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
       return -1;

      if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
         return -1;

      if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
         return -1;
      if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
         return -1;
      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_E2connectionUpdateRemove_ItemIEs_id_E2connectionUpdateRemove_Item:
         if(asn1PrtToStr_e2ap_E2connectionUpdateRemove_Item("E2connectionUpdateRemove-Item",
                pvalue->value.u._e2apE2connectionUpdateRemove_ItemIEs_id_E2connectionUpdateRemove_Item, buffer, bufSize)<0)// dungnm23 check lai nhe xem la
            return -1;
         break;
      default:
         if(0!=pvalue -> value.u.extElem1){
             rtPrintToStringIndent(buffer, bufSize);
             rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

         }
      }
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

      return 0;

}
 

/*****************************************/
/*           E2connectionUpdateRemove_List                */
/*****************************************/
//seq_of_single_container


int asn1PE_e2ap_E2connectionUpdateRemove_List (OSCTXT* pctxt, e2ap_E2connectionUpdateRemove_List* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_E2connectionUpdateRemove_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "E2connectionUpdateRemove-List");

   /* encode length determinant */
   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;
   for (xx1 = 0; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next, xx1++) {
      pdata = (e2ap_E2connectionUpdateRemove_ItemIEs*) pnode->data;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_e2ap_E2connectionUpdateRemove_ItemIEs (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      //xx1++;
      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}

int asn1PD_e2ap_E2connectionUpdateRemove_List (OSCTXT* pctxt, e2ap_E2connectionUpdateRemove_List* ppvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_E2connectionUpdateRemove_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "E2connectionUpdateRemove-List");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (ppvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      pdata = rtxMemAllocType (pctxt, e2ap_E2connectionUpdateRemove_ItemIEs);
      if (!pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);
      asn1Init_e2ap_E2connectionUpdateRemove_ItemIEs (pdata);
      stat = asn1PD_e2ap_E2connectionUpdateRemove_ItemIEs (pctxt, pdata);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         return LOG_RTERR (pctxt, stat);
      }

      rtxDListAppendNode (ppvalue, pdata);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

void asn1Init_e2ap_E2connectionUpdateRemove_List (e2ap_E2connectionUpdateRemove_List* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
}

void asn1Free_e2ap_E2connectionUpdateRemove_List (OSCTXT* pctxt, e2ap_E2connectionUpdateRemove_List* pvalue)
{
   if(pvalue==0) return;
   OSRTDListNode* pnode = pvalue->head;
   while (pnode) {
      e2ap_E2connectionUpdateRemove_ItemIEs* pdata = (e2ap_E2connectionUpdateRemove_ItemIEs*) pnode->data;
      if (pdata) {
         asn1Free_e2ap_E2connectionUpdateRemove_ItemIEs (pctxt, pdata);
         rtxMemFreePtr (pctxt, pdata);
      }
      pnode = pnode->next;
   }
      rtxDListFreeAll(pctxt, pvalue);
}

#if 0
void asn1Free_e2ap_E2connectionUpdateRemove_List (OSCTXT* pctxt, e2ap_E2connectionUpdateRemove_List* pvalue){
   if(0==pvalue ) return;
   {
      e2ap_E2connectionUpdateRemove_ItemIEs * pdata;
      OSRTDListNode *pnode = pvalue->head;
      while(0!=pnode){
         pdata = (e2ap_E2connectionUpdateRemove_ItemIEs*)pnode->data;
         asn1Free_e2ap_E2connectionUpdateRemove_ItemIEs(pctxt, pdata);
         pnode = pnode->next;
      }
      rtxDListFreeAll(pctxt, pvalue);
   }
}
#endif


int asn1PrtToStr_e2ap_E2connectionUpdateRemove_List(const char* name, e2ap_E2connectionUpdateRemove_List* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_E2connectionUpdateRemove_ItemIEs* pdata;
    OSRTDListNode* pnode;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode = pvalue->head;  xx1 < pvalue->count && pnode != 0; pnode = pnode->next, xx1++){
        pdata = (e2ap_E2connectionUpdateRemove_ItemIEs*)pnode->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 1
        if(asn1PrtToStr_e2ap_E2connectionUpdateRemove_ItemIEs(nameBuf, pdata, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}/*****************************************/
/*           E2connectionUpdate_IEs                */
/*****************************************/
/* ie.c.j2 */
 /* d là con của msg */
EXTERN int asn1PE_e2ap_E2connectionUpdate_protocolIEs_element (OSCTXT* pctxt, e2ap_E2connectionUpdate_protocolIEs_element* pvalue)
{
    int stat =0;

    /*encode id*/

    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PE_e2ap_ProtocolIE_ID(pctxt, pvalue->id);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PE_e2ap_Criticality(pctxt, pvalue->criticality);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
    {
        OSCTXT lctxt;
        OSOCTET *pDynamicEncodeBuffer;
        ASN1OpenType openType;
        OSBOOL encoded = TRUE;

        openType.numocts = 0;
        openType.data =0;

        rtxCopyContext(&lctxt, pctxt);
        pctxt->pStream =0;

        stat = rtxInitContextBuffer(pctxt, 0, 0);
        if(stat!=0) return LOG_RTERR(pctxt, stat);

        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_E2connectionUpdate_IEs_id_TransactionID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-TransactionID");
                    stat = asn1PE_e2ap_TransactionID (pctxt, pvalue->value.u._e2ap_E2connectionUpdate_IEs_id_TransactionID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_E2connectionUpdate_IEs_id_E2connectionUpdateAdd:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-E2connectionUpdateAdd");
                    stat = asn1PE_e2ap_E2connectionUpdate_List (pctxt, pvalue->value.u._e2ap_E2connectionUpdate_IEs_id_E2connectionUpdateAdd);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_E2connectionUpdate_IEs_id_E2connectionUpdateRemove:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-E2connectionUpdateRemove");
                    stat = asn1PE_e2ap_E2connectionUpdateRemove_List (pctxt, pvalue->value.u._e2ap_E2connectionUpdate_IEs_id_E2connectionUpdateRemove);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_E2connectionUpdate_IEs_id_E2connectionUpdateModify:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-E2connectionUpdateModify");
                    stat = asn1PE_e2ap_E2connectionUpdate_List (pctxt, pvalue->value.u._e2ap_E2connectionUpdate_IEs_id_E2connectionUpdateModify);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_E2connectionUpdate_IEs_UNDEF_:
            {
                if(0!=pvalue->value.u.extElem1){
                    openType.numocts = pvalue->value.u.extElem1->numocts;
                    openType.data = pvalue->value.u.extElem1->data;
                } else {
                    /* No extension element to encode */
                }
                encoded = FALSE;
                break;
            }

            default:
                encoded = FALSE;
                stat = RTERR_INVOPT;
                break;
        } 

        if(encoded){
            openType.numocts = (OSUINT32)pe_GetMsgLen(pctxt);
            openType.data = pDynamicEncodeBuffer = pctxt -> buffer.data;
        }
        rtxCopyContext(pctxt, &lctxt);

        if(stat == 0) {
            stat = pe_OpenType (pctxt, openType.numocts, openType.data);
        }
    #if 1
        if(encoded){//dungnm23 check lai nhe
            rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
        }
    #endif

    }

    if(stat!=0) return LOG_RTERR(pctxt, stat);  
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}

EXTERN int  asn1PD_e2ap_E2connectionUpdate_protocolIEs_element (OSCTXT* pctxt, e2ap_E2connectionUpdate_protocolIEs_element* pvalue){
    int stat =0;

    /*decode id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PD_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PD_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");

    {
        OSUINT32 openTypeLen;
        size_t bitStartOffset, bitLength;

        stat = pd_UnconsLength(pctxt, &openTypeLen);
        if(stat<0) return LOG_RTERR(pctxt, stat);
        else if(stat == RT_OK_FRAG){
            rtxErrAddStrParm(pctxt, "open type with fragment length");
            return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
        }
        bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
        bitLength = openTypeLen * 8;

        switch(pvalue->id){//dungnm23 check case lai nhe
        
            case ASN1V_e2ap_id_TransactionID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_E2connectionUpdate_IEs_id_TransactionID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-TransactionID");
                pvalue->value.u._e2ap_E2connectionUpdate_IEs_id_TransactionID 
                    = rtxMemAllocType(pctxt, e2ap_TransactionID);

                asn1Init_e2ap_TransactionID(pvalue->value.u._e2ap_E2connectionUpdate_IEs_id_TransactionID);

                stat = asn1PD_e2ap_TransactionID (pctxt,
                        (e2ap_TransactionID*)pvalue->value.
                        u._e2ap_E2connectionUpdate_IEs_id_TransactionID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_E2connectionUpdateAdd:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_E2connectionUpdate_IEs_id_E2connectionUpdateAdd;
            RTXCTXTPUSHELEMNAME(pctxt, "id-E2connectionUpdateAdd");
                pvalue->value.u._e2ap_E2connectionUpdate_IEs_id_E2connectionUpdateAdd 
                    = rtxMemAllocType(pctxt, e2ap_E2connectionUpdate_List);

                asn1Init_e2ap_E2connectionUpdate_List(pvalue->value.u._e2ap_E2connectionUpdate_IEs_id_E2connectionUpdateAdd);

                stat = asn1PD_e2ap_E2connectionUpdate_List (pctxt,
                        (e2ap_E2connectionUpdate_List*)pvalue->value.
                        u._e2ap_E2connectionUpdate_IEs_id_E2connectionUpdateAdd);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_E2connectionUpdateRemove:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_E2connectionUpdate_IEs_id_E2connectionUpdateRemove;
            RTXCTXTPUSHELEMNAME(pctxt, "id-E2connectionUpdateRemove");
                pvalue->value.u._e2ap_E2connectionUpdate_IEs_id_E2connectionUpdateRemove 
                    = rtxMemAllocType(pctxt, e2ap_E2connectionUpdateRemove_List);

                asn1Init_e2ap_E2connectionUpdateRemove_List(pvalue->value.u._e2ap_E2connectionUpdate_IEs_id_E2connectionUpdateRemove);

                stat = asn1PD_e2ap_E2connectionUpdateRemove_List (pctxt,
                        (e2ap_E2connectionUpdateRemove_List*)pvalue->value.
                        u._e2ap_E2connectionUpdate_IEs_id_E2connectionUpdateRemove);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_E2connectionUpdateModify:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_E2connectionUpdate_IEs_id_E2connectionUpdateModify;
            RTXCTXTPUSHELEMNAME(pctxt, "id-E2connectionUpdateModify");
                pvalue->value.u._e2ap_E2connectionUpdate_IEs_id_E2connectionUpdateModify 
                    = rtxMemAllocType(pctxt, e2ap_E2connectionUpdate_List);

                asn1Init_e2ap_E2connectionUpdate_List(pvalue->value.u._e2ap_E2connectionUpdate_IEs_id_E2connectionUpdateModify);

                stat = asn1PD_e2ap_E2connectionUpdate_List (pctxt,
                        (e2ap_E2connectionUpdate_List*)pvalue->value.
                        u._e2ap_E2connectionUpdate_IEs_id_E2connectionUpdateModify);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_E2connectionUpdate_IEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*) rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
    }
    {
    size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
    size_t bitsConsumed = bitEndOffset-bitStartOffset;
    if(bitsConsumed<bitLength){
        stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
    }
    else stat =(bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
    }}
    if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}


int asn1Init_e2ap_E2connectionUpdate_protocolIEs_element(e2ap_E2connectionUpdate_protocolIEs_element* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    OSCRTLMEMSET (&pvalue->value, 0, sizeof(pvalue->value));
    return 0;
}


//-----> chuaw có template rtxFreeASN1OpenType

#if 0
void asn1Free_e2ap_E2connectionUpdate_protocolIEs_element(OSCTXT* pctxt, e2ap_E2connectionUpdate_protocolIEs_element* pvalue)
{
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_E2connectionUpdate_IEs_id_id_TransactionID:
            // rtxFreeE2ap_TransactionID(pvalue->value.u._e2ap_E2connectionUpdate_IEs_id_id_TransactionID);

            if(pvalue->value.i._e2ap_E2connectionUpdate_id_TransactionID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_TransactionID(pctxt, pvalue->value.u._e2ap_E2connectionUpdate_IEs_id_id_TransactionID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2connectionUpdate_IEs_id_id_TransactionID);
           // pvalue->value.u._e2ap_E2connectionUpdate_IEs_id_id_TransactionID = NULL;
           pvalue->value.u._e2ap_E2connectionUpdate_IEs_id_TransactionID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_E2connectionUpdate_IEs_id_id_E2connectionUpdateAdd:
            // rtxFreeE2ap_E2connectionUpdate_List(pvalue->value.u._e2ap_E2connectionUpdate_IEs_id_id_E2connectionUpdateAdd);

            if(pvalue->value.i._e2ap_E2connectionUpdate_id_E2connectionUpdate_List!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_E2connectionUpdate_List(pctxt, pvalue->value.u._e2ap_E2connectionUpdate_IEs_id_id_E2connectionUpdateAdd);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2connectionUpdate_IEs_id_id_E2connectionUpdateAdd);
           // pvalue->value.u._e2ap_E2connectionUpdate_IEs_id_id_E2connectionUpdateAdd = NULL;
           pvalue->value.u._e2ap_E2connectionUpdate_IEs_id_E2connectionUpdateAdd = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_E2connectionUpdate_IEs_id_id_E2connectionUpdateRemove:
            // rtxFreeE2ap_E2connectionUpdateRemove_List(pvalue->value.u._e2ap_E2connectionUpdate_IEs_id_id_E2connectionUpdateRemove);

            if(pvalue->value.i._e2ap_E2connectionUpdate_id_E2connectionUpdateRemove_List!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_E2connectionUpdateRemove_List(pctxt, pvalue->value.u._e2ap_E2connectionUpdate_IEs_id_id_E2connectionUpdateRemove);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2connectionUpdate_IEs_id_id_E2connectionUpdateRemove);
           // pvalue->value.u._e2ap_E2connectionUpdate_IEs_id_id_E2connectionUpdateRemove = NULL;
           pvalue->value.u._e2ap_E2connectionUpdate_IEs_id_E2connectionUpdateRemove = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_E2connectionUpdate_IEs_id_id_E2connectionUpdateModify:
            // rtxFreeE2ap_E2connectionUpdate_List(pvalue->value.u._e2ap_E2connectionUpdate_IEs_id_id_E2connectionUpdateModify);

            if(pvalue->value.i._e2ap_E2connectionUpdate_id_E2connectionUpdate_List!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_E2connectionUpdate_List(pctxt, pvalue->value.u._e2ap_E2connectionUpdate_IEs_id_id_E2connectionUpdateModify);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2connectionUpdate_IEs_id_id_E2connectionUpdateModify);
           // pvalue->value.u._e2ap_E2connectionUpdate_IEs_id_id_E2connectionUpdateModify = NULL;
           pvalue->value.u._e2ap_E2connectionUpdate_IEs_id_E2connectionUpdateModify = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_E2connectionUpdate_IEs_UNDEF_:
            rtxFreeASN1OpenType(pvalue->value.u.extElem1);
            break;
        default:
            break;
    }
}

int asn1PrtToStr_e2ap_E2connectionUpdate_protocolIEs_element(OSCTXT* pctxt, e2ap_E2connectionUpdate_protocolIEs_element* pvalue)
{
    int stat =0;
    RTXCTXTPUSHELEMNAME(pctxt, "e2ap_E2connectionUpdate_protocolIEs_element");

    /*print id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PrtToStr_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PrtToStr_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_E2connectionUpdate_IEs_id_id_TransactionID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "TransactionID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_TransactionID (pctxt, pvalue->value.u._e2ap_E2connectionUpdate_IEs_id_id_TransactionID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_E2connectionUpdate_IEs_id_id_E2connectionUpdateAdd:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "E2connectionUpdate-List");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_E2connectionUpdate_List (pctxt, pvalue->value.u._e2ap_E2connectionUpdate_IEs_id_id_E2connectionUpdateAdd);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_E2connectionUpdate_IEs_id_id_E2connectionUpdateRemove:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "E2connectionUpdateRemove-List");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_E2connectionUpdateRemove_List (pctxt, pvalue->value.u._e2ap_E2connectionUpdate_IEs_id_id_E2connectionUpdateRemove);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_E2connectionUpdate_IEs_id_id_E2connectionUpdateModify:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "E2connectionUpdate-List");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_E2connectionUpdate_List (pctxt, pvalue->value.u._e2ap_E2connectionUpdate_IEs_id_id_E2connectionUpdateModify);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_E2connectionUpdate_IEs_UNDEF_:
            {
                rtxPLogMsg(pctxt, "Extension element present - raw data not printed.\n");
                break;
            }

            default:
                stat = RTERR_INVOPT;
                return LOG_RTERR(pctxt, stat);
        }
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);
}
#endif


int asn1PrtToStr_e2ap_E2connectionUpdate_protocolIEs_element (const char * name,
 e2ap_E2connectionUpdate_protocolIEs_element* pvalue, 
 char * buffer, OSSIZE bufSize){
    if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
        return -1;
    if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
        return -1;

    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_E2connectionUpdate_IEs_id_TransactionID:
            if(asn1PrtToStr_e2ap_TransactionID("TransactionID", 
                    pvalue->value.u._e2ap_E2connectionUpdate_IEs_id_TransactionID, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_E2connectionUpdate_IEs_id_E2connectionUpdateAdd:
            if(asn1PrtToStr_e2ap_E2connectionUpdate_List("E2connectionUpdate-List", 
                    pvalue->value.u._e2ap_E2connectionUpdate_IEs_id_E2connectionUpdateAdd, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_E2connectionUpdate_IEs_id_E2connectionUpdateRemove:
            if(asn1PrtToStr_e2ap_E2connectionUpdateRemove_List("E2connectionUpdateRemove-List", 
                    pvalue->value.u._e2ap_E2connectionUpdate_IEs_id_E2connectionUpdateRemove, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_E2connectionUpdate_IEs_id_E2connectionUpdateModify:
            if(asn1PrtToStr_e2ap_E2connectionUpdate_List("E2connectionUpdate-List", 
                    pvalue->value.u._e2ap_E2connectionUpdate_IEs_id_E2connectionUpdateModify, buffer, bufSize)<0)
                return -1;
            break;    
        default:
        if(0!=pvalue -> value.u.extElem1){
            rtPrintToStringIndent(buffer, bufSize);
            rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

        }
        }
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

    return 0;

 }

 void asn1Free_e2ap_E2connectionUpdate_protocolIEs_element(OSCTXT* pctxt, e2ap_E2connectionUpdate_protocolIEs_element* pvalue){
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_E2connectionUpdate_IEs_id_TransactionID:
            if(pvalue->value.u._e2ap_E2connectionUpdate_IEs_id_TransactionID!=NULL){
            asn1Free_e2ap_TransactionID(pctxt, pvalue->value.u._e2ap_E2connectionUpdate_IEs_id_TransactionID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2connectionUpdate_IEs_id_TransactionID);
            pvalue->value.u._e2ap_E2connectionUpdate_IEs_id_TransactionID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_E2connectionUpdate_IEs_id_E2connectionUpdateAdd:
            if(pvalue->value.u._e2ap_E2connectionUpdate_IEs_id_E2connectionUpdateAdd!=NULL){
            asn1Free_e2ap_E2connectionUpdate_List(pctxt, pvalue->value.u._e2ap_E2connectionUpdate_IEs_id_E2connectionUpdateAdd);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2connectionUpdate_IEs_id_E2connectionUpdateAdd);
            pvalue->value.u._e2ap_E2connectionUpdate_IEs_id_E2connectionUpdateAdd = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_E2connectionUpdate_IEs_id_E2connectionUpdateRemove:
            if(pvalue->value.u._e2ap_E2connectionUpdate_IEs_id_E2connectionUpdateRemove!=NULL){
            asn1Free_e2ap_E2connectionUpdateRemove_List(pctxt, pvalue->value.u._e2ap_E2connectionUpdate_IEs_id_E2connectionUpdateRemove);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2connectionUpdate_IEs_id_E2connectionUpdateRemove);
            pvalue->value.u._e2ap_E2connectionUpdate_IEs_id_E2connectionUpdateRemove = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_E2connectionUpdate_IEs_id_E2connectionUpdateModify:
            if(pvalue->value.u._e2ap_E2connectionUpdate_IEs_id_E2connectionUpdateModify!=NULL){
            asn1Free_e2ap_E2connectionUpdate_List(pctxt, pvalue->value.u._e2ap_E2connectionUpdate_IEs_id_E2connectionUpdateModify);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2connectionUpdate_IEs_id_E2connectionUpdateModify);
            pvalue->value.u._e2ap_E2connectionUpdate_IEs_id_E2connectionUpdateModify = NULL;
            }
            break;
        default:
            break;


    }
 }

 

/*****************************************/
/*           E2connectionUpdate                */
/*****************************************/
//2_container.c
/* 1. xxx_ProtocolIE -> mẫu cũ ở ie_big_msg */
EXTERN int asn1PE_e2ap_E2connectionUpdate_protocolIEs (OSCTXT* pctxt, e2ap_E2connectionUpdate_protocolIEs* pvalue)
{
    int stat =0;
    OSRTDListNode* pnode;
    OSUINT32 xx1;

    /*encode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pe_Length(pctxt, pvalue->count);
    if(stat<0) return LOG_RTERR(pctxt, stat);

    /*encode each element*/
    xx1 =0;
    for(pnode = pvalue->head; pnode != 0 && xx1<pvalue->count; pnode = pnode->next){
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE", xx1);
        stat = asn1PE_e2ap_E2connectionUpdate_protocolIEs_element (pctxt, ((e2ap_E2connectionUpdate_protocolIEs_element*)pnode->data));
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        xx1++;
        RTXCTXTPOPARRAYELEMNAME(pctxt);
    }

    return (stat);
}

EXTERN int  asn1PD_e2ap_E2connectionUpdate_protocolIEs(OSCTXT* pctxt, e2ap_E2connectionUpdate_protocolIEs* pvalue)
{
     int stat =0;
     OSRTDListNode* pnode;
     OSSIZE count =0;
     OSSIZE xx1=0;


     /*decode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pd_Length64(pctxt, &count); //tai sao lai 64
    if(stat!=0) return LOG_RTERR(pctxt, stat);

    /*decode each element*/
    rtxDListInit(pvalue);

    for(xx1=0; xx1 < count; xx1++){
        e2ap_E2connectionUpdate_protocolIEs_element* pdata;
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE",xx1);

        if(pnode == NULL) return LOG_RTERR(pctxt, RTERR_NOMEM);

        asn1Init_e2ap_E2connectionUpdate_protocolIEs_element(pdata);
        rtxDListAppendNode(pvalue, pnode);
        stat = asn1PD_e2ap_E2connectionUpdate_protocolIEs_element (pctxt, pdata);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        RTXCTXTPOPARRAYELEMNAME(pctxt);

    }
    return (stat);
}


int asn1Init_e2ap_E2connectionUpdate_protocolIEs(e2ap_E2connectionUpdate_protocolIEs* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    rtxDListFastInit (pvalue);
    return 0;
}
#if 1 //ao that day
void asn1Free_e2ap_E2connectionUpdate_protocolIEs(OSCTXT* pctxt, e2ap_E2connectionUpdate_protocolIEs* pvalue)
{
    if(0==pvalue) return;   
    e2ap_E2connectionUpdate_protocolIEs_element* pdata;
    OSRTDListNode* pnode=pvalue->head;
    while(0!=pnode){
        pdata = (e2ap_E2connectionUpdate_protocolIEs_element*)pnode->data;
       // asn1Free_e2ap_E2connectionUpdate_protocolIEs_element(pctxt, pdata);
        pnode = pnode->next;
    }
    rtxDListFreeAll(pctxt, pvalue);
}
#endif


EXTERN int asn1PrtToStr_e2ap_E2connectionUpdate_protocolIEs(const char* name, e2ap_E2connectionUpdate_protocolIEs* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_E2connectionUpdate_protocolIEs_element* pdata0;
    OSRTDListNode* pnode0;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode0 = pvalue->head;  xx1 < pvalue->count && pnode0 != 0; pnode0 = pnode0->next, xx1++){
        pdata0 = (e2ap_E2connectionUpdate_protocolIEs_element*)pnode0->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 0
        if(asn1PrtToStr_e2ap_E2connectionUpdate_protocolIEs_element(nameBuf, pdata0, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}


/*2 . E2connectionUpdate -> mẫu cũ ở seq_normal*/

int asn1PE_e2ap_E2connectionUpdate (OSCTXT* pctxt, e2ap_E2connectionUpdate* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "E2connectionUpdate");
   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field protocolIEs - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
   stat = asn1PE_e2ap_E2connectionUpdate_protocolIEs (pctxt, &pvalue->protocolIEs);
   if(stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_E2connectionUpdate (OSCTXT* pctxt, e2ap_E2connectionUpdate* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME(pctxt, "E2connectionUpdate");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field protocolIEs */
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
      stat = asn1PD_e2ap_E2connectionUpdate_protocolIEs (pctxt, &pvalue->protocolIEs);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_E2connectionUpdate (e2ap_E2connectionUpdate* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_E2connectionUpdate_protocolIEs(&pvalue->protocolIEs);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_E2connectionUpdate (OSCTXT* pctxt, e2ap_E2connectionUpdate* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_E2connectionUpdate_protocolIEs(pctxt, &pvalue->protocolIEs);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_E2connectionUpdate (const char* name, e2ap_E2connectionUpdate* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }

   if(asn1PrtToStr_e2ap_E2connectionUpdate_protocolIEs("protocolIEs", &pvalue->protocolIEs, buffer, bufSize) <0){
      return -1;
   }

   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/******************************************************/
/*                                                    */
/*    CauseRICrequest                          */
/*                                                    */
/******************************************************/
//enumerated


const OSEnumItem e2ap_CauseRICrequest_ENUMTAB[] = {
    { OSUTF8("ran_function_id_invalid"), 0, 23, 0 },
    { OSUTF8("action_not_supported"), 1, 20, 1 },
    { OSUTF8("excessive_actions"), 2, 17, 2 },
    { OSUTF8("duplicate_action"), 3, 16, 3 },
    { OSUTF8("duplicate_event_trigger"), 4, 23, 4 },
    { OSUTF8("function_resource_limit"), 5, 23, 5 },
    { OSUTF8("request_id_unknown"), 6, 18, 6 },
    { OSUTF8("inconsistent_action_subsequent_action_sequence"), 7, 46, 7 },
    { OSUTF8("control_message_invalid"), 8, 23, 8 },
    { OSUTF8("ric_call_process_id_invalid"), 9, 27, 9 },
    { OSUTF8("control_timer_expired"), 10, 21, 10 },
    { OSUTF8("control_failed_to_execute"), 11, 25, 11 },
    { OSUTF8("system_not_ready"), 12, 16, 12 },
    { OSUTF8("unspecified"), 13, 11, 13 },
    { OSUTF8("ric_subscription_end_time_expired"), 14, 33, 14 },
    { OSUTF8("ric_subscription_end_time_invalid"), 15, 33, 15 },
    { OSUTF8("duplicate_ric_request_id"), 16, 24, 16 },
    { OSUTF8("eventTriggerNotSupported"), 17, 24, 17 },
    { OSUTF8("requested_information_unavailable"), 18, 33, 18 },
    { OSUTF8("invalid_information_request"), 19, 27, 19 }
};


const OSUTF8CHAR* e2ap_CauseRICrequest_ToString (OSUINT32 value){
   OSINT32 idx = value;
   if(idx >=0 && idx < e2ap_CauseRICrequest_ENUMTABSIZE){
      return e2ap_CauseRICrequest_ENUMTAB[e2ap_CauseRICrequest_ENUMTAB[idx].transidx].name;
   }else{
      return OSUTF8("_UNKNOWN_");
   }
}


int e2ap_CauseRICrequest_ToEnum (OSCTXT* pctxt, const OSUTF8CHAR* value,e2ap_CauseRICrequest* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes(value);
   return e2ap_CauseRICrequest_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int e2ap_CauseRICrequest_ToEnum2 (OSCTXT* pctxt, const OSUTF8CHAR* value, OSSIZE valueLen,e2ap_CauseRICrequest* pvalue)
{
   OSINT32 idx = rtxLookupEnum(value, valueLen,
      e2ap_CauseRICrequest_ENUMTAB, e2ap_CauseRICrequest_ENUMTABSIZE);
   if (idx >= 0) {
      *pvalue = (e2ap_CauseRICrequest)e2ap_CauseRICrequest_ENUMTAB[idx].value;
      return 0;
   } else {
      rtxErrAddIntParm (pctxt, (const char*)value);//dungnm23 check xem là Str hay Int
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_e2ap_CauseRICrequest (OSCTXT* pctxt, e2ap_CauseRICrequest value)
{
   int stat = 0;
   RTXCTXTPUSHTYPENAME (pctxt, "CauseRICrequest");
   if (value >= 20) {
      rtxErrAddIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(19));
   if(stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}

EXTERN int asn1PD_e2ap_CauseRICrequest (OSCTXT* pctxt, e2ap_CauseRICrequest* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CauseRICrequest");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(19));
   if(stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return stat;
}

EXTERN int asn1PrtToStr_e2ap_CauseRICrequest (const char* name, e2ap_CauseRICrequest* pvalue, char* buffer, OSSIZE bufSize)
{
   int stat;

   if(rtPrintToStringIndent(buffer, bufSize) < 0) return -1;
   if(rtPrintToString(name, buffer, bufSize) < 0) return -1;

   switch(*pvalue) {
      case 0:
         stat = rtPrintToString(" = ran_function_id_invalid \n", buffer, bufSize);
         break;
      case 1:
         stat = rtPrintToString(" = action_not_supported \n", buffer, bufSize);
         break;
      case 2:
         stat = rtPrintToString(" = excessive_actions \n", buffer, bufSize);
         break;
      case 3:
         stat = rtPrintToString(" = duplicate_action \n", buffer, bufSize);
         break;
      case 4:
         stat = rtPrintToString(" = duplicate_event_trigger \n", buffer, bufSize);
         break;
      case 5:
         stat = rtPrintToString(" = function_resource_limit \n", buffer, bufSize);
         break;
      case 6:
         stat = rtPrintToString(" = request_id_unknown \n", buffer, bufSize);
         break;
      case 7:
         stat = rtPrintToString(" = inconsistent_action_subsequent_action_sequence \n", buffer, bufSize);
         break;
      case 8:
         stat = rtPrintToString(" = control_message_invalid \n", buffer, bufSize);
         break;
      case 9:
         stat = rtPrintToString(" = ric_call_process_id_invalid \n", buffer, bufSize);
         break;
      case 10:
         stat = rtPrintToString(" = control_timer_expired \n", buffer, bufSize);
         break;
      case 11:
         stat = rtPrintToString(" = control_failed_to_execute \n", buffer, bufSize);
         break;
      case 12:
         stat = rtPrintToString(" = system_not_ready \n", buffer, bufSize);
         break;
      case 13:
         stat = rtPrintToString(" = unspecified \n", buffer, bufSize);
         break;
      case 14:
         stat = rtPrintToString(" = ric_subscription_end_time_expired \n", buffer, bufSize);
         break;
      case 15:
         stat = rtPrintToString(" = ric_subscription_end_time_invalid \n", buffer, bufSize);
         break;
      case 16:
         stat = rtPrintToString(" = duplicate_ric_request_id \n", buffer, bufSize);
         break;
      case 17:
         stat = rtPrintToString(" = eventTriggerNotSupported \n", buffer, bufSize);
         break;
      case 18:
         stat = rtPrintToString(" = requested_information_unavailable \n", buffer, bufSize);
         break;
      case 19:
         stat = rtPrintToString(" = invalid_information_request \n", buffer, bufSize);
         break;
      default:
         stat = rtPrintToString(" = ???\n", buffer, bufSize);
   }

   if (stat < 0) return -1;
   return 0;

}

/*Init*/
EXTERN int asn1Init_e2ap_CauseRICrequest (e2ap_CauseRICrequest* pvalue){
      //if (pvalue == 0) return RTERR_NULLPTR;
      //*pvalue = 0;
      return 0;
}/******************************************************/
/*                                                    */
/*    CauseRICservice                          */
/*                                                    */
/******************************************************/
//enumerated


const OSEnumItem e2ap_CauseRICservice_ENUMTAB[] = {
    { OSUTF8("ran_function_not_supported"), 0, 26, 0 },
    { OSUTF8("excessive_functions"), 1, 19, 1 },
    { OSUTF8("ric_resource_limit"), 2, 18, 2 }
};


const OSUTF8CHAR* e2ap_CauseRICservice_ToString (OSUINT32 value){
   OSINT32 idx = value;
   if(idx >=0 && idx < e2ap_CauseRICservice_ENUMTABSIZE){
      return e2ap_CauseRICservice_ENUMTAB[e2ap_CauseRICservice_ENUMTAB[idx].transidx].name;
   }else{
      return OSUTF8("_UNKNOWN_");
   }
}


int e2ap_CauseRICservice_ToEnum (OSCTXT* pctxt, const OSUTF8CHAR* value,e2ap_CauseRICservice* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes(value);
   return e2ap_CauseRICservice_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int e2ap_CauseRICservice_ToEnum2 (OSCTXT* pctxt, const OSUTF8CHAR* value, OSSIZE valueLen,e2ap_CauseRICservice* pvalue)
{
   OSINT32 idx = rtxLookupEnum(value, valueLen,
      e2ap_CauseRICservice_ENUMTAB, e2ap_CauseRICservice_ENUMTABSIZE);
   if (idx >= 0) {
      *pvalue = (e2ap_CauseRICservice)e2ap_CauseRICservice_ENUMTAB[idx].value;
      return 0;
   } else {
      rtxErrAddIntParm (pctxt, (const char*)value);//dungnm23 check xem là Str hay Int
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_e2ap_CauseRICservice (OSCTXT* pctxt, e2ap_CauseRICservice value)
{
   int stat = 0;
   RTXCTXTPUSHTYPENAME (pctxt, "CauseRICservice");
   if (value >= 3) {
      rtxErrAddIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(2));
   if(stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}

EXTERN int asn1PD_e2ap_CauseRICservice (OSCTXT* pctxt, e2ap_CauseRICservice* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CauseRICservice");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(2));
   if(stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return stat;
}

EXTERN int asn1PrtToStr_e2ap_CauseRICservice (const char* name, e2ap_CauseRICservice* pvalue, char* buffer, OSSIZE bufSize)
{
   int stat;

   if(rtPrintToStringIndent(buffer, bufSize) < 0) return -1;
   if(rtPrintToString(name, buffer, bufSize) < 0) return -1;

   switch(*pvalue) {
      case 0:
         stat = rtPrintToString(" = ran_function_not_supported \n", buffer, bufSize);
         break;
      case 1:
         stat = rtPrintToString(" = excessive_functions \n", buffer, bufSize);
         break;
      case 2:
         stat = rtPrintToString(" = ric_resource_limit \n", buffer, bufSize);
         break;
      default:
         stat = rtPrintToString(" = ???\n", buffer, bufSize);
   }

   if (stat < 0) return -1;
   return 0;

}

/*Init*/
EXTERN int asn1Init_e2ap_CauseRICservice (e2ap_CauseRICservice* pvalue){
      //if (pvalue == 0) return RTERR_NULLPTR;
      //*pvalue = 0;
      return 0;
}/******************************************************/
/*                                                    */
/*    CauseE2node                          */
/*                                                    */
/******************************************************/
//enumerated


const OSEnumItem e2ap_CauseE2node_ENUMTAB[] = {
    { OSUTF8("e2node_component_unknown"), 0, 24, 0 }
};


const OSUTF8CHAR* e2ap_CauseE2node_ToString (OSUINT32 value){
   OSINT32 idx = value;
   if(idx >=0 && idx < e2ap_CauseE2node_ENUMTABSIZE){
      return e2ap_CauseE2node_ENUMTAB[e2ap_CauseE2node_ENUMTAB[idx].transidx].name;
   }else{
      return OSUTF8("_UNKNOWN_");
   }
}


int e2ap_CauseE2node_ToEnum (OSCTXT* pctxt, const OSUTF8CHAR* value,e2ap_CauseE2node* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes(value);
   return e2ap_CauseE2node_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int e2ap_CauseE2node_ToEnum2 (OSCTXT* pctxt, const OSUTF8CHAR* value, OSSIZE valueLen,e2ap_CauseE2node* pvalue)
{
   OSINT32 idx = rtxLookupEnum(value, valueLen,
      e2ap_CauseE2node_ENUMTAB, e2ap_CauseE2node_ENUMTABSIZE);
   if (idx >= 0) {
      *pvalue = (e2ap_CauseE2node)e2ap_CauseE2node_ENUMTAB[idx].value;
      return 0;
   } else {
      rtxErrAddIntParm (pctxt, (const char*)value);//dungnm23 check xem là Str hay Int
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_e2ap_CauseE2node (OSCTXT* pctxt, e2ap_CauseE2node value)
{
   int stat = 0;
   RTXCTXTPUSHTYPENAME (pctxt, "CauseE2node");
   if (value >= 1) {
      rtxErrAddIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(0));
   if(stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}

EXTERN int asn1PD_e2ap_CauseE2node (OSCTXT* pctxt, e2ap_CauseE2node* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CauseE2node");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(0));
   if(stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return stat;
}

EXTERN int asn1PrtToStr_e2ap_CauseE2node (const char* name, e2ap_CauseE2node* pvalue, char* buffer, OSSIZE bufSize)
{
   int stat;

   if(rtPrintToStringIndent(buffer, bufSize) < 0) return -1;
   if(rtPrintToString(name, buffer, bufSize) < 0) return -1;

   switch(*pvalue) {
      case 0:
         stat = rtPrintToString(" = e2node_component_unknown \n", buffer, bufSize);
         break;
      default:
         stat = rtPrintToString(" = ???\n", buffer, bufSize);
   }

   if (stat < 0) return -1;
   return 0;

}

/*Init*/
EXTERN int asn1Init_e2ap_CauseE2node (e2ap_CauseE2node* pvalue){
      //if (pvalue == 0) return RTERR_NULLPTR;
      //*pvalue = 0;
      return 0;
}/******************************************************/
/*                                                    */
/*    CauseTransport                          */
/*                                                    */
/******************************************************/
//enumerated


const OSEnumItem e2ap_CauseTransport_ENUMTAB[] = {
    { OSUTF8("unspecified"), 0, 11, 0 },
    { OSUTF8("transport_resource_unavailable"), 1, 30, 1 }
};


const OSUTF8CHAR* e2ap_CauseTransport_ToString (OSUINT32 value){
   OSINT32 idx = value;
   if(idx >=0 && idx < e2ap_CauseTransport_ENUMTABSIZE){
      return e2ap_CauseTransport_ENUMTAB[e2ap_CauseTransport_ENUMTAB[idx].transidx].name;
   }else{
      return OSUTF8("_UNKNOWN_");
   }
}


int e2ap_CauseTransport_ToEnum (OSCTXT* pctxt, const OSUTF8CHAR* value,e2ap_CauseTransport* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes(value);
   return e2ap_CauseTransport_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int e2ap_CauseTransport_ToEnum2 (OSCTXT* pctxt, const OSUTF8CHAR* value, OSSIZE valueLen,e2ap_CauseTransport* pvalue)
{
   OSINT32 idx = rtxLookupEnum(value, valueLen,
      e2ap_CauseTransport_ENUMTAB, e2ap_CauseTransport_ENUMTABSIZE);
   if (idx >= 0) {
      *pvalue = (e2ap_CauseTransport)e2ap_CauseTransport_ENUMTAB[idx].value;
      return 0;
   } else {
      rtxErrAddIntParm (pctxt, (const char*)value);//dungnm23 check xem là Str hay Int
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_e2ap_CauseTransport (OSCTXT* pctxt, e2ap_CauseTransport value)
{
   int stat = 0;
   RTXCTXTPUSHTYPENAME (pctxt, "CauseTransport");
   if (value >= 2) {
      rtxErrAddIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
   if(stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}

EXTERN int asn1PD_e2ap_CauseTransport (OSCTXT* pctxt, e2ap_CauseTransport* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CauseTransport");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
   if(stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return stat;
}

EXTERN int asn1PrtToStr_e2ap_CauseTransport (const char* name, e2ap_CauseTransport* pvalue, char* buffer, OSSIZE bufSize)
{
   int stat;

   if(rtPrintToStringIndent(buffer, bufSize) < 0) return -1;
   if(rtPrintToString(name, buffer, bufSize) < 0) return -1;

   switch(*pvalue) {
      case 0:
         stat = rtPrintToString(" = unspecified \n", buffer, bufSize);
         break;
      case 1:
         stat = rtPrintToString(" = transport_resource_unavailable \n", buffer, bufSize);
         break;
      default:
         stat = rtPrintToString(" = ???\n", buffer, bufSize);
   }

   if (stat < 0) return -1;
   return 0;

}

/*Init*/
EXTERN int asn1Init_e2ap_CauseTransport (e2ap_CauseTransport* pvalue){
      //if (pvalue == 0) return RTERR_NULLPTR;
      //*pvalue = 0;
      return 0;
}/******************************************************/
/*                                                    */
/*    CauseProtocol                          */
/*                                                    */
/******************************************************/
//enumerated


const OSEnumItem e2ap_CauseProtocol_ENUMTAB[] = {
    { OSUTF8("transfer_syntax_error"), 0, 21, 0 },
    { OSUTF8("abstract_syntax_error_reject"), 1, 28, 1 },
    { OSUTF8("abstract_syntax_error_ignore_and_notify"), 2, 39, 2 },
    { OSUTF8("message_not_compatible_with_receiver_state"), 3, 42, 3 },
    { OSUTF8("semantic_error"), 4, 14, 4 },
    { OSUTF8("abstract_syntax_error_falsely_constructed_message"), 5, 49, 5 },
    { OSUTF8("unspecified"), 6, 11, 6 }
};


const OSUTF8CHAR* e2ap_CauseProtocol_ToString (OSUINT32 value){
   OSINT32 idx = value;
   if(idx >=0 && idx < e2ap_CauseProtocol_ENUMTABSIZE){
      return e2ap_CauseProtocol_ENUMTAB[e2ap_CauseProtocol_ENUMTAB[idx].transidx].name;
   }else{
      return OSUTF8("_UNKNOWN_");
   }
}


int e2ap_CauseProtocol_ToEnum (OSCTXT* pctxt, const OSUTF8CHAR* value,e2ap_CauseProtocol* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes(value);
   return e2ap_CauseProtocol_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int e2ap_CauseProtocol_ToEnum2 (OSCTXT* pctxt, const OSUTF8CHAR* value, OSSIZE valueLen,e2ap_CauseProtocol* pvalue)
{
   OSINT32 idx = rtxLookupEnum(value, valueLen,
      e2ap_CauseProtocol_ENUMTAB, e2ap_CauseProtocol_ENUMTABSIZE);
   if (idx >= 0) {
      *pvalue = (e2ap_CauseProtocol)e2ap_CauseProtocol_ENUMTAB[idx].value;
      return 0;
   } else {
      rtxErrAddIntParm (pctxt, (const char*)value);//dungnm23 check xem là Str hay Int
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_e2ap_CauseProtocol (OSCTXT* pctxt, e2ap_CauseProtocol value)
{
   int stat = 0;
   RTXCTXTPUSHTYPENAME (pctxt, "CauseProtocol");
   if (value >= 7) {
      rtxErrAddIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(6));
   if(stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}

EXTERN int asn1PD_e2ap_CauseProtocol (OSCTXT* pctxt, e2ap_CauseProtocol* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CauseProtocol");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(6));
   if(stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return stat;
}

EXTERN int asn1PrtToStr_e2ap_CauseProtocol (const char* name, e2ap_CauseProtocol* pvalue, char* buffer, OSSIZE bufSize)
{
   int stat;

   if(rtPrintToStringIndent(buffer, bufSize) < 0) return -1;
   if(rtPrintToString(name, buffer, bufSize) < 0) return -1;

   switch(*pvalue) {
      case 0:
         stat = rtPrintToString(" = transfer_syntax_error \n", buffer, bufSize);
         break;
      case 1:
         stat = rtPrintToString(" = abstract_syntax_error_reject \n", buffer, bufSize);
         break;
      case 2:
         stat = rtPrintToString(" = abstract_syntax_error_ignore_and_notify \n", buffer, bufSize);
         break;
      case 3:
         stat = rtPrintToString(" = message_not_compatible_with_receiver_state \n", buffer, bufSize);
         break;
      case 4:
         stat = rtPrintToString(" = semantic_error \n", buffer, bufSize);
         break;
      case 5:
         stat = rtPrintToString(" = abstract_syntax_error_falsely_constructed_message \n", buffer, bufSize);
         break;
      case 6:
         stat = rtPrintToString(" = unspecified \n", buffer, bufSize);
         break;
      default:
         stat = rtPrintToString(" = ???\n", buffer, bufSize);
   }

   if (stat < 0) return -1;
   return 0;

}

/*Init*/
EXTERN int asn1Init_e2ap_CauseProtocol (e2ap_CauseProtocol* pvalue){
      //if (pvalue == 0) return RTERR_NULLPTR;
      //*pvalue = 0;
      return 0;
}/******************************************************/
/*                                                    */
/*    CauseMisc                          */
/*                                                    */
/******************************************************/
//enumerated


const OSEnumItem e2ap_CauseMisc_ENUMTAB[] = {
    { OSUTF8("control_processing_overload"), 0, 27, 0 },
    { OSUTF8("hardware_failure"), 1, 16, 1 },
    { OSUTF8("om_intervention"), 2, 15, 2 },
    { OSUTF8("unspecified"), 3, 11, 3 }
};


const OSUTF8CHAR* e2ap_CauseMisc_ToString (OSUINT32 value){
   OSINT32 idx = value;
   if(idx >=0 && idx < e2ap_CauseMisc_ENUMTABSIZE){
      return e2ap_CauseMisc_ENUMTAB[e2ap_CauseMisc_ENUMTAB[idx].transidx].name;
   }else{
      return OSUTF8("_UNKNOWN_");
   }
}


int e2ap_CauseMisc_ToEnum (OSCTXT* pctxt, const OSUTF8CHAR* value,e2ap_CauseMisc* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes(value);
   return e2ap_CauseMisc_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int e2ap_CauseMisc_ToEnum2 (OSCTXT* pctxt, const OSUTF8CHAR* value, OSSIZE valueLen,e2ap_CauseMisc* pvalue)
{
   OSINT32 idx = rtxLookupEnum(value, valueLen,
      e2ap_CauseMisc_ENUMTAB, e2ap_CauseMisc_ENUMTABSIZE);
   if (idx >= 0) {
      *pvalue = (e2ap_CauseMisc)e2ap_CauseMisc_ENUMTAB[idx].value;
      return 0;
   } else {
      rtxErrAddIntParm (pctxt, (const char*)value);//dungnm23 check xem là Str hay Int
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_e2ap_CauseMisc (OSCTXT* pctxt, e2ap_CauseMisc value)
{
   int stat = 0;
   RTXCTXTPUSHTYPENAME (pctxt, "CauseMisc");
   if (value >= 4) {
      rtxErrAddIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(3));
   if(stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}

EXTERN int asn1PD_e2ap_CauseMisc (OSCTXT* pctxt, e2ap_CauseMisc* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CauseMisc");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(3));
   if(stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return stat;
}

EXTERN int asn1PrtToStr_e2ap_CauseMisc (const char* name, e2ap_CauseMisc* pvalue, char* buffer, OSSIZE bufSize)
{
   int stat;

   if(rtPrintToStringIndent(buffer, bufSize) < 0) return -1;
   if(rtPrintToString(name, buffer, bufSize) < 0) return -1;

   switch(*pvalue) {
      case 0:
         stat = rtPrintToString(" = control_processing_overload \n", buffer, bufSize);
         break;
      case 1:
         stat = rtPrintToString(" = hardware_failure \n", buffer, bufSize);
         break;
      case 2:
         stat = rtPrintToString(" = om_intervention \n", buffer, bufSize);
         break;
      case 3:
         stat = rtPrintToString(" = unspecified \n", buffer, bufSize);
         break;
      default:
         stat = rtPrintToString(" = ???\n", buffer, bufSize);
   }

   if (stat < 0) return -1;
   return 0;

}

/*Init*/
EXTERN int asn1Init_e2ap_CauseMisc (e2ap_CauseMisc* pvalue){
      //if (pvalue == 0) return RTERR_NULLPTR;
      //*pvalue = 0;
      return 0;
}/*****************************************/
/*           ServiceLayerCause                */
/*****************************************/
//9 mau octet string
//type 9  mau la octet string no size mau la pdusessioncommonnetworkinstance

EXTERN int asn1PE_e2ap_ServiceLayerCause (OSCTXT* pctxt, e2ap_ServiceLayerCause value){
   int stat = 0
   RTXCTCXTPUSHTYPENAME (pctxt, "ServiceLayerCause");
   stat = pe_OctetString(pctxt, value.numocts, value.data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPTYPENAME (pctxt);

}
EXTERN int asn1PD_e2ap_ServiceLayerCause (OSCTXT* pctxt, e2ap_ServiceLayerCause* pvalue){
   int stat = 0;
   RTXCTCXTPUSHTYPENAME (pctxt, "ServiceLayerCause");
   stat = pd_DynOctetString(pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}
EXTERN int asn1PrtToStr_e2ap_ServiceLayerCause (const char* name, e2ap_ServiceLayerCause *pvalue, char* buffer, OSSIZE bufSize){
   if(rtPrintToStringIndent(buffer, bufSize) < 0) return -1;
   if(rtPrintToStringHexStr(name, pvalue->numocts, pvalue->data, buffer, bufSize) < 0) return -1;
   return 0;
}
EXTERN int asn1PrtToStrm_e2ap_ServiceLayerCause (OSCTXT* pctxt, const char* name, const e2ap_ServiceLayerCause* pvalue){
   int stat =0;
   stat = rtPrintToStreamIndent(pctxt);
   if(stat !=0) return LOG_RTERR(pctxt, stat);
   stat = rtPrintToStreamHexStr(pctxt, name, pvalue->numocts, pvalue->data);
   if(stat !=0) return LOG_RTERR(pctxt, stat);
   return stat;
}
//EXTERN int asn1Copy_e2ap_ServiceLayerCause (OSCTXT* pctxt, const e2ap_ServiceLayerCause* pSrcValue, e2ap_ServiceLayerCause* pDstValue);
 int asn1Init_e2ap_ServiceLayerCause (e2ap_ServiceLayerCause* pvalue){
   if (pvalue == 0) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   pvalue->data = 0;
   return 0;
}
 void asn1Free_e2ap_ServiceLayerCause (OSCTXT* pctxt, e2ap_ServiceLayerCause* pvalue){
   if (pvalue == 0) return;
   if(pvalue->numocts>0){
       rtxMemFreePtr(pctxt, (void*)pvalue->data);
       pvalue->data = 0;
       pvalue->numocts = 0;
   }
}
int asn1Init_e2ap_ServiceLayerCause (e2ap_ServiceLayerCause* pvalue){
   if (pvalue == 0) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   pvalue->data = 0;
   return 0;
}

/*****************************************/
/*           CauseServiceLayer                */
/*****************************************/
//sequence normal
// Các nội dung cần thiết cho template seq_normal.c.j2

// Các phần còn lại của template seq_normal.c.j2
//contain extensition bit -> theo mau cua GlobalgNB-ID
int asn1PE_e2ap_CauseServiceLayer (OSCTXT* pctxt, e2ap_CauseServiceLayer* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "CauseServiceLayer");

   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field serviceLayerCause - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "serviceLayerCause");
   stat = asn1PE_e2ap_ServiceLayerCause (pctxt, pvalue->serviceLayerCause);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);



   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_CauseServiceLayer (OSCTXT* pctxt, e2ap_CauseServiceLayer* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME(pctxt, "CauseServiceLayer");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field serviceLayerCause */
   RTXCTXTPUSHELEMNAME(pctxt, "serviceLayerCause");
      stat = asn1PD_e2ap_ServiceLayerCause (pctxt, &pvalue->serviceLayerCause);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_CauseServiceLayer (e2ap_CauseServiceLayer* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_ServiceLayerCause (&pvalue->serviceLayerCause);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_CauseServiceLayer (OSCTXT* pctxt, e2ap_CauseServiceLayer* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_ServiceLayerCause (pctxt, &pvalue->serviceLayerCause);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_CauseServiceLayer (const char* name, e2ap_CauseServiceLayer* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }
   if(asn1PrtToStr_e2ap_ServiceLayerCause ("serviceLayerCause", &pvalue->serviceLayerCause, buffer, bufSize) < 0)
   {
      return -1;
   }



   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/* e2ap_Cause.c */

/*****************************************/
/*           Cause                */
/*****************************************/
// choice
// Các nội dung cần thiết cho template choice.c.j2

// Các phần còn lại của template choice.c.j2
// choice without extension

EXTERN int asn1PE_e2ap_Cause (OSCTXT* pctxt, e2ap_Cause* pvalue)
{
   int stat = 0;
   RTXCTXTPUSHTYPENAME (pctxt, "Cause");
   RTXCTXTPUSHELEMNAME (pctxt, "t");
 
   stat = rtxEncBits (pctxt, pvalue->t - 1, 3);// kha nang la numbits
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   switch (pvalue->t) {
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "ricRequest");
         stat = asn1PE_e2ap_CauseRICrequest (pctxt, pvalue->u.ricRequest); //not primitive
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         RTXCTXTPOPELEMNAME (pctxt);
         break;
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "ricService");
         stat = asn1PE_e2ap_CauseRICservice (pctxt, pvalue->u.ricService); //not primitive
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         RTXCTXTPOPELEMNAME (pctxt);
         break;
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "e2Node");
         stat = asn1PE_e2ap_CauseE2node (pctxt, pvalue->u.e2Node); //not primitive
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         RTXCTXTPOPELEMNAME (pctxt);
         break;
      case 4:
         RTXCTXTPUSHELEMNAME (pctxt, "transport");
         stat = asn1PE_e2ap_CauseTransport (pctxt, pvalue->u.transport); //not primitive
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         RTXCTXTPOPELEMNAME (pctxt);
         break;
      case 5:
         RTXCTXTPUSHELEMNAME (pctxt, "protocol");
         stat = asn1PE_e2ap_CauseProtocol (pctxt, pvalue->u.protocol); //not primitive
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         RTXCTXTPOPELEMNAME (pctxt);
         break;
      case 6:
         RTXCTXTPUSHELEMNAME (pctxt, "misc");
         stat = asn1PE_e2ap_CauseMisc (pctxt, pvalue->u.misc); //not primitive
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         RTXCTXTPOPELEMNAME (pctxt);
         break;
      case 7:
         RTXCTXTPUSHELEMNAME (pctxt, "serviceLayer");
         stat = asn1PE_e2ap_CauseServiceLayer (pctxt, pvalue->u.serviceLayer); //not primitive
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         RTXCTXTPOPELEMNAME (pctxt);
         break;
      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return (stat);
}

int asn1PD_e2ap_Cause (OSCTXT* pctxt, e2ap_Cause* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   RTXCTXTPUSHTYPENAME (pctxt, "Cause");

 
   stat = rtxDecBits (pctxt, &ui, 3);// kha nang la numbits
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;
   //RTXCTXTPOPELEMNAME (pctxt);

   switch (ui) {
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "ricRequest");
         pvalue->u.ricRequest = rtxMemAllocType (pctxt, e2ap_CauseRICrequest);
         if (pvalue->u.ricRequest == NULL) return LOG_RTERR (pctxt, RTERR_NOMEM);
         asn1Init_e2ap_CauseRICrequest(pvalue->u.ricRequest);
         stat = asn1PD_e2ap_CauseRICrequest (pctxt, pvalue->u.ricRequest);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         RTXCTXTPOPELEMNAME (pctxt);
         break;
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "ricService");
         pvalue->u.ricService = rtxMemAllocType (pctxt, e2ap_CauseRICservice);
         if (pvalue->u.ricService == NULL) return LOG_RTERR (pctxt, RTERR_NOMEM);
         asn1Init_e2ap_CauseRICservice(pvalue->u.ricService);
         stat = asn1PD_e2ap_CauseRICservice (pctxt, pvalue->u.ricService);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         RTXCTXTPOPELEMNAME (pctxt);
         break;
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "e2Node");
         pvalue->u.e2Node = rtxMemAllocType (pctxt, e2ap_CauseE2node);
         if (pvalue->u.e2Node == NULL) return LOG_RTERR (pctxt, RTERR_NOMEM);
         asn1Init_e2ap_CauseE2node(pvalue->u.e2Node);
         stat = asn1PD_e2ap_CauseE2node (pctxt, pvalue->u.e2Node);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         RTXCTXTPOPELEMNAME (pctxt);
         break;
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "transport");
         pvalue->u.transport = rtxMemAllocType (pctxt, e2ap_CauseTransport);
         if (pvalue->u.transport == NULL) return LOG_RTERR (pctxt, RTERR_NOMEM);
         asn1Init_e2ap_CauseTransport(pvalue->u.transport);
         stat = asn1PD_e2ap_CauseTransport (pctxt, pvalue->u.transport);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         RTXCTXTPOPELEMNAME (pctxt);
         break;
      case 4:
         RTXCTXTPUSHELEMNAME (pctxt, "protocol");
         pvalue->u.protocol = rtxMemAllocType (pctxt, e2ap_CauseProtocol);
         if (pvalue->u.protocol == NULL) return LOG_RTERR (pctxt, RTERR_NOMEM);
         asn1Init_e2ap_CauseProtocol(pvalue->u.protocol);
         stat = asn1PD_e2ap_CauseProtocol (pctxt, pvalue->u.protocol);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         RTXCTXTPOPELEMNAME (pctxt);
         break;
      case 5:
         RTXCTXTPUSHELEMNAME (pctxt, "misc");
         pvalue->u.misc = rtxMemAllocType (pctxt, e2ap_CauseMisc);
         if (pvalue->u.misc == NULL) return LOG_RTERR (pctxt, RTERR_NOMEM);
         asn1Init_e2ap_CauseMisc(pvalue->u.misc);
         stat = asn1PD_e2ap_CauseMisc (pctxt, pvalue->u.misc);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         RTXCTXTPOPELEMNAME (pctxt);
         break;
      case 6:
         RTXCTXTPUSHELEMNAME (pctxt, "serviceLayer");
         pvalue->u.serviceLayer = rtxMemAllocType (pctxt, e2ap_CauseServiceLayer);
         if (pvalue->u.serviceLayer == NULL) return LOG_RTERR (pctxt, RTERR_NOMEM);
         asn1Init_e2ap_CauseServiceLayer(pvalue->u.serviceLayer);
         stat = asn1PD_e2ap_CauseServiceLayer (pctxt, pvalue->u.serviceLayer);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         RTXCTXTPOPELEMNAME (pctxt);
         break;
      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return (stat);
}

int asn1PrtToStr_e2ap_Cause (const char* name, e2ap_Cause* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) return -1;
   

   switch (pvalue->t) {
      case T_e2ap_Cause_ricRequest:
         if (asn1PrtToStr_e2ap_CauseRICrequest ( "ricRequest", pvalue->u.ricRequest, buffer, bufSize) < 0) return -1;
         break;
      case T_e2ap_Cause_ricService:
         if (asn1PrtToStr_e2ap_CauseRICservice ( "ricService", pvalue->u.ricService, buffer, bufSize) < 0) return -1;
         break;
      case T_e2ap_Cause_e2Node:
         if (asn1PrtToStr_e2ap_CauseE2node ( "e2Node", pvalue->u.e2Node, buffer, bufSize) < 0) return -1;
         break;
      case T_e2ap_Cause_transport:
         if (asn1PrtToStr_e2ap_CauseTransport ( "transport", pvalue->u.transport, buffer, bufSize) < 0) return -1;
         break;
      case T_e2ap_Cause_protocol:
         if (asn1PrtToStr_e2ap_CauseProtocol ( "protocol", pvalue->u.protocol, buffer, bufSize) < 0) return -1;
         break;
      case T_e2ap_Cause_misc:
         if (asn1PrtToStr_e2ap_CauseMisc ( "misc", pvalue->u.misc, buffer, bufSize) < 0) return -1;
         break;
      case T_e2ap_Cause_serviceLayer:
         if (asn1PrtToStr_e2ap_CauseServiceLayer ( "serviceLayer", pvalue->u.serviceLayer, buffer, bufSize) < 0) return -1;
         break;
      default:
         return RTERR_INVOPT;
   }

   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}

int asn1Init_e2ap_Cause (e2ap_Cause* pvalue)
{
   if (pvalue == 0) return RTERR_NULLPTR;
   pvalue->t = 0;
   OSRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
   return 0;
}


void asn1Free_e2ap_Cause (OSCTXT* pctxt, e2ap_Cause* pvalue)
{
   if (pvalue == 0) return;
   switch (pvalue->t) {
      case 0: //no choice nothing to free
         break;
      case 1:
         if (pvalue->u.ricRequest) {
            //not primitive
            asn1Free_e2ap_CauseRICrequest (pctxt, pvalue->u.ricRequest);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.ricRequest);
            pvalue->u.ricRequest = 0;
         }
         break;
      case 2:
         if (pvalue->u.ricService) {
            //not primitive
            asn1Free_e2ap_CauseRICservice (pctxt, pvalue->u.ricService);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.ricService);
            pvalue->u.ricService = 0;
         }
         break;
      case 3:
         if (pvalue->u.e2Node) {
            //not primitive
            asn1Free_e2ap_CauseE2node (pctxt, pvalue->u.e2Node);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.e2Node);
            pvalue->u.e2Node = 0;
         }
         break;
      case 4:
         if (pvalue->u.transport) {
            //not primitive
            asn1Free_e2ap_CauseTransport (pctxt, pvalue->u.transport);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.transport);
            pvalue->u.transport = 0;
         }
         break;
      case 5:
         if (pvalue->u.protocol) {
            //not primitive
            asn1Free_e2ap_CauseProtocol (pctxt, pvalue->u.protocol);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.protocol);
            pvalue->u.protocol = 0;
         }
         break;
      case 6:
         if (pvalue->u.misc) {
            //not primitive
            asn1Free_e2ap_CauseMisc (pctxt, pvalue->u.misc);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.misc);
            pvalue->u.misc = 0;
         }
         break;
      case 7:
         if (pvalue->u.serviceLayer) {
            //not primitive
            asn1Free_e2ap_CauseServiceLayer (pctxt, pvalue->u.serviceLayer);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.serviceLayer);
            pvalue->u.serviceLayer = 0;
         }
         break;
   }
}


/*****************************************/
/*           E2connectionSetupFailed-Item                */
/*****************************************/
//sequence normal
// Các nội dung cần thiết cho template seq_normal.c.j2

// Các phần còn lại của template seq_normal.c.j2
//contain extensition bit -> theo mau cua GlobalgNB-ID
int asn1PE_e2ap_E2connectionSetupFailed_Item (OSCTXT* pctxt, e2ap_E2connectionSetupFailed_Item* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "E2connectionSetupFailed-Item");

   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field tnlInformation - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "tnlInformation");
   stat = asn1PE_e2ap_TNLinformation (pctxt, pvalue->tnlInformation);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /* encode field cause - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "cause");
   stat = asn1PE_e2ap_Cause (pctxt, pvalue->cause);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);



   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_E2connectionSetupFailed_Item (OSCTXT* pctxt, e2ap_E2connectionSetupFailed_Item* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME(pctxt, "E2connectionSetupFailed-Item");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field tnlInformation */
   RTXCTXTPUSHELEMNAME(pctxt, "tnlInformation");
      stat = asn1PD_e2ap_TNLinformation (pctxt, &pvalue->tnlInformation);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field cause */
   RTXCTXTPUSHELEMNAME(pctxt, "cause");
      stat = asn1PD_e2ap_Cause (pctxt, &pvalue->cause);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_E2connectionSetupFailed_Item (e2ap_E2connectionSetupFailed_Item* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_TNLinformation (&pvalue->tnlInformation);
   asn1Init_e2ap_Cause (&pvalue->cause);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_E2connectionSetupFailed_Item (OSCTXT* pctxt, e2ap_E2connectionSetupFailed_Item* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_TNLinformation (pctxt, &pvalue->tnlInformation);
   asn1Free_e2ap_Cause (pctxt, &pvalue->cause);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_E2connectionSetupFailed_Item (const char* name, e2ap_E2connectionSetupFailed_Item* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }
   if(asn1PrtToStr_e2ap_TNLinformation ("tnlInformation", &pvalue->tnlInformation, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_Cause ("cause", &pvalue->cause, buffer, bufSize) < 0)
   {
      return -1;
   }



   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           E2connectionSetupFailed_ItemIEs                */
/*****************************************/
/* ie.c.j2 */
/*ie thường*/
int asn1PE_e2ap_E2connectionSetupFailed_ItemIEs (OSCTXT* pctxt, e2ap_E2connectionSetupFailed_ItemIEs* pvalue)
{
   int stat = 0;
   //RTXCTXTPUSHTYPENAME (pctxt, "E2connectionSetupFailed-ItemIEs");

   /* encode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");
   stat = asn1PE_e2ap_ProtocolIE_ID (pctxt, pvalue->id);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");
   stat = asn1PE_e2ap_Criticality (pctxt, pvalue->criticality);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   {
      OSCTXT ictxt;
      OSOCTET* pDynamicEncodeBuffer;
      ASN1OpenType openType;
      OSBOOL  encoded = TRUE;

      openType.numocts = 0;
      openType.data = 0;

      rtxCopyContext (&ictxt, pctxt);
      pctxt->pStream = 0;

      stat = rtxInitContextBuffer (pctxt, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_E2connectionSetupFailed_ItemIEs_id_E2connectionSetupFailed_Item:
         
        // RTXCTXTPUSHELEMNAME (pctxt, "E2connectionSetupFailed_ItemIEs_id_E2connectionSetupFailed_Item");
         RTXCTXTPUSHELEMNAME (pctxt, "E2connectionSetupFailed-Item");
         stat = asn1PE_e2ap_E2connectionSetupFailed_Item (pctxt, pvalue->value.u._e2apE2connectionSetupFailed_ItemIEs_id_E2connectionSetupFailed_Item);
         RTXCTXTPOPELEMNAME (pctxt);
      
         break;

      case T_E2AP_PDU_Contents_e2ap_E2connectionSetupFailed_ItemIEs_UNDEF_:
      {
          if(0!=pvalue->value.u.extElem1){
              openType.numocts = pvalue->value.u.extElem1->numocts;
              openType.data = pvalue->value.u.extElem1->data;
          } else {
              /* No extension element to encode */
          }
          encoded = FALSE;
          break;
      }
      default:
         encoded = FALSE;
         stat = RTERR_INVOPT;
      }

      if (encoded) {
         openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
         openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
      }
      rtxCopyContext (pctxt, &ictxt);
      if(stat ==0) stat = pe_OpenType(pctxt, openType.numocts, openType.data);
      /*free dynamic encode buffer*/
      if(encoded){
          rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
      }
   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);
   //RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

int asn1PD_e2ap_E2connectionSetupFailed_ItemIEs (OSCTXT* pctxt, e2ap_E2connectionSetupFailed_ItemIEs* pvalue)
{
   int stat =0;
   /*deode root element id*/
   RTXCTXTPUSHELEMNAME(pctxt, "id");
   stat = asn1PD_e2ap_ProtocolIE_ID (pctxt, &pvalue->id);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*decode root element criticality*/
   RTXCTXTPUSHELEMNAME(pctxt, "criticality");
   stat = asn1PD_e2ap_Criticality (pctxt, &pvalue->criticality);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   /*decode root element value*/
   RTXCTXTPUSHELEMNAME(pctxt, "value");
   {
      OSUINT32 openTypeLen;
      size_t bitStartOffset, bitLength;
      stat = pd_UnconsLength(pctxt, &openTypeLen);
      if(stat <0) return LOG_RTERR(pctxt, stat);
      else if(stat == RT_OK_FRAG){
         rtxErrAddStrParm(pctxt, "open type with fragmented length use - perindef");
         return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
      }
      bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
      bitLength = openTypeLen * 8;
      switch (pvalue->id){
         case T_E2AP_PDU_Contents_e2ap_E2connectionSetupFailed_ItemIEs_id_E2connectionSetupFailed_Item:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_E2connectionSetupFailed_ItemIEs_id_E2connectionSetupFailed_Item;
            RTXCTXTPUSHELEMNAME(pctxt, "E2connectionSetupFailed-Item");
            //pvalue->value.u._e2ap_E2connectionSetupFailed_ItemIEs_id_id_E2connectionSetupFailed_Item 
             pvalue->value.u._e2apE2connectionSetupFailed_ItemIEs_id_E2connectionSetupFailed_Item 
                    = rtxMemAllocType(pctxt, e2ap_E2connectionSetupFailed_Item);
            //asn1Init_e2ap_E2connectionSetupFailed_Item(pvalue->value.u._e2ap_E2connectionSetupFailed_ItemIEs_id_id_E2connectionSetupFailed_Item);
            asn1Init_e2ap_E2connectionSetupFailed_Item(pvalue->value.u._e2apE2connectionSetupFailed_ItemIEs_id_E2connectionSetupFailed_Item);
            stat = asn1PD_e2ap_E2connectionSetupFailed_Item (pctxt,
                    (e2ap_E2connectionSetupFailed_Item*)pvalue->value.
                    u._e2apE2connectionSetupFailed_ItemIEs_id_E2connectionSetupFailed_Item);
            if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_E2connectionSetupFailed_ItemIEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*)rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
      }
      {
      size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
      size_t bitsConsumed = bitEndOffset - bitStartOffset;
      if(bitsConsumed < bitLength){
         stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
      } else {
         stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
      }
      }
   }
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   return stat;
}

void asn1Init_e2ap_E2connectionSetupFailed_ItemIEs (e2ap_E2connectionSetupFailed_ItemIEs* pvalue)
{
   if (!pvalue) return;
   OSCRTLMEMSET (pvalue, 0, sizeof(e2ap_E2connectionSetupFailed_ItemIEs));
}

#if 0
void asn1Free_e2ap_E2connectionSetupFailed_ItemIEs (OSCTXT* pctxt, e2ap_E2connectionSetupFailed_ItemIEs* pvalue)
{
   if (!pvalue) return;
   if (pvalue->extElem1) {
      rtxMemFreeArray (pctxt, pvalue->extElem1);
      pvalue->extElem1 = 0;
      pvalue->extElem1_n = 0;
   }
}
#endif
void asn1Free_e2ap_E2connectionSetupFailed_ItemIEs (OSCTXT* pctxt, e2ap_E2connectionSetupFailed_ItemIEs* pvalue)
{
   if(0==pvalue) return;
   switch(pvalue->value.t){
      case T_E2AP_PDU_Contents_e2ap_E2connectionSetupFailed_ItemIEs_id_E2connectionSetupFailed_Item:
         asn1Free_e2ap_E2connectionSetupFailed_Item (pctxt, pvalue->value.u._e2apE2connectionSetupFailed_ItemIEs_id_E2connectionSetupFailed_Item);
         rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2apE2connectionSetupFailed_ItemIEs_id_E2connectionSetupFailed_Item);
         pvalue->value.u._e2apE2connectionSetupFailed_ItemIEs_id_E2connectionSetupFailed_Item = 0;
         break;
      case T_E2AP_PDU_Contents_e2ap_E2connectionSetupFailed_ItemIEs_UNDEF_:
         if(0!=pvalue->value.u.extElem1){
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1->data);
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
             pvalue->value.u.extElem1 =0;
         }
         break;
         default:;
   }
}

int  asn1PrtToStr_e2ap_E2connectionSetupFailed_ItemIEs (const char * name, e2ap_E2connectionSetupFailed_ItemIEs* pvalue, char * buffer, OSSIZE bufSize){
   if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
       return -1;

      if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
         return -1;

      if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
         return -1;
      if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
         return -1;
      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_E2connectionSetupFailed_ItemIEs_id_E2connectionSetupFailed_Item:
         if(asn1PrtToStr_e2ap_E2connectionSetupFailed_Item("E2connectionSetupFailed-Item",
                pvalue->value.u._e2apE2connectionSetupFailed_ItemIEs_id_E2connectionSetupFailed_Item, buffer, bufSize)<0)// dungnm23 check lai nhe xem la
            return -1;
         break;
      default:
         if(0!=pvalue -> value.u.extElem1){
             rtPrintToStringIndent(buffer, bufSize);
             rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

         }
      }
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

      return 0;

}
 

/*****************************************/
/*           E2connectionSetupFailed_List                */
/*****************************************/
//seq_of_single_container


int asn1PE_e2ap_E2connectionSetupFailed_List (OSCTXT* pctxt, e2ap_E2connectionSetupFailed_List* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_E2connectionSetupFailed_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "E2connectionSetupFailed-List");

   /* encode length determinant */
   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;
   for (xx1 = 0; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next, xx1++) {
      pdata = (e2ap_E2connectionSetupFailed_ItemIEs*) pnode->data;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_e2ap_E2connectionSetupFailed_ItemIEs (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      //xx1++;
      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}

int asn1PD_e2ap_E2connectionSetupFailed_List (OSCTXT* pctxt, e2ap_E2connectionSetupFailed_List* ppvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_E2connectionSetupFailed_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "E2connectionSetupFailed-List");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (ppvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      pdata = rtxMemAllocType (pctxt, e2ap_E2connectionSetupFailed_ItemIEs);
      if (!pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);
      asn1Init_e2ap_E2connectionSetupFailed_ItemIEs (pdata);
      stat = asn1PD_e2ap_E2connectionSetupFailed_ItemIEs (pctxt, pdata);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         return LOG_RTERR (pctxt, stat);
      }

      rtxDListAppendNode (ppvalue, pdata);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

void asn1Init_e2ap_E2connectionSetupFailed_List (e2ap_E2connectionSetupFailed_List* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
}

void asn1Free_e2ap_E2connectionSetupFailed_List (OSCTXT* pctxt, e2ap_E2connectionSetupFailed_List* pvalue)
{
   if(pvalue==0) return;
   OSRTDListNode* pnode = pvalue->head;
   while (pnode) {
      e2ap_E2connectionSetupFailed_ItemIEs* pdata = (e2ap_E2connectionSetupFailed_ItemIEs*) pnode->data;
      if (pdata) {
         asn1Free_e2ap_E2connectionSetupFailed_ItemIEs (pctxt, pdata);
         rtxMemFreePtr (pctxt, pdata);
      }
      pnode = pnode->next;
   }
      rtxDListFreeAll(pctxt, pvalue);
}

#if 0
void asn1Free_e2ap_E2connectionSetupFailed_List (OSCTXT* pctxt, e2ap_E2connectionSetupFailed_List* pvalue){
   if(0==pvalue ) return;
   {
      e2ap_E2connectionSetupFailed_ItemIEs * pdata;
      OSRTDListNode *pnode = pvalue->head;
      while(0!=pnode){
         pdata = (e2ap_E2connectionSetupFailed_ItemIEs*)pnode->data;
         asn1Free_e2ap_E2connectionSetupFailed_ItemIEs(pctxt, pdata);
         pnode = pnode->next;
      }
      rtxDListFreeAll(pctxt, pvalue);
   }
}
#endif


int asn1PrtToStr_e2ap_E2connectionSetupFailed_List(const char* name, e2ap_E2connectionSetupFailed_List* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_E2connectionSetupFailed_ItemIEs* pdata;
    OSRTDListNode* pnode;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode = pvalue->head;  xx1 < pvalue->count && pnode != 0; pnode = pnode->next, xx1++){
        pdata = (e2ap_E2connectionSetupFailed_ItemIEs*)pnode->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 1
        if(asn1PrtToStr_e2ap_E2connectionSetupFailed_ItemIEs(nameBuf, pdata, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}/*****************************************/
/*           E2connectionUpdateAck_IEs                */
/*****************************************/
/* ie.c.j2 */
 /* d là con của msg */
EXTERN int asn1PE_e2ap_E2connectionUpdateAcknowledge_protocolIEs_element (OSCTXT* pctxt, e2ap_E2connectionUpdateAcknowledge_protocolIEs_element* pvalue)
{
    int stat =0;

    /*encode id*/

    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PE_e2ap_ProtocolIE_ID(pctxt, pvalue->id);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PE_e2ap_Criticality(pctxt, pvalue->criticality);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
    {
        OSCTXT lctxt;
        OSOCTET *pDynamicEncodeBuffer;
        ASN1OpenType openType;
        OSBOOL encoded = TRUE;

        openType.numocts = 0;
        openType.data =0;

        rtxCopyContext(&lctxt, pctxt);
        pctxt->pStream =0;

        stat = rtxInitContextBuffer(pctxt, 0, 0);
        if(stat!=0) return LOG_RTERR(pctxt, stat);

        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_E2connectionUpdateAck_IEs_id_TransactionID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-TransactionID");
                    stat = asn1PE_e2ap_TransactionID (pctxt, pvalue->value.u._e2ap_E2connectionUpdateAck_IEs_id_TransactionID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_E2connectionUpdateAck_IEs_id_E2connectionSetup:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-E2connectionSetup");
                    stat = asn1PE_e2ap_E2connectionUpdate_List (pctxt, pvalue->value.u._e2ap_E2connectionUpdateAck_IEs_id_E2connectionSetup);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_E2connectionUpdateAck_IEs_id_E2connectionSetupFailed:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-E2connectionSetupFailed");
                    stat = asn1PE_e2ap_E2connectionSetupFailed_List (pctxt, pvalue->value.u._e2ap_E2connectionUpdateAck_IEs_id_E2connectionSetupFailed);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_E2connectionUpdateAck_IEs_UNDEF_:
            {
                if(0!=pvalue->value.u.extElem1){
                    openType.numocts = pvalue->value.u.extElem1->numocts;
                    openType.data = pvalue->value.u.extElem1->data;
                } else {
                    /* No extension element to encode */
                }
                encoded = FALSE;
                break;
            }

            default:
                encoded = FALSE;
                stat = RTERR_INVOPT;
                break;
        } 

        if(encoded){
            openType.numocts = (OSUINT32)pe_GetMsgLen(pctxt);
            openType.data = pDynamicEncodeBuffer = pctxt -> buffer.data;
        }
        rtxCopyContext(pctxt, &lctxt);

        if(stat == 0) {
            stat = pe_OpenType (pctxt, openType.numocts, openType.data);
        }
    #if 1
        if(encoded){//dungnm23 check lai nhe
            rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
        }
    #endif

    }

    if(stat!=0) return LOG_RTERR(pctxt, stat);  
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}

EXTERN int  asn1PD_e2ap_E2connectionUpdateAcknowledge_protocolIEs_element (OSCTXT* pctxt, e2ap_E2connectionUpdateAcknowledge_protocolIEs_element* pvalue){
    int stat =0;

    /*decode id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PD_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PD_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");

    {
        OSUINT32 openTypeLen;
        size_t bitStartOffset, bitLength;

        stat = pd_UnconsLength(pctxt, &openTypeLen);
        if(stat<0) return LOG_RTERR(pctxt, stat);
        else if(stat == RT_OK_FRAG){
            rtxErrAddStrParm(pctxt, "open type with fragment length");
            return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
        }
        bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
        bitLength = openTypeLen * 8;

        switch(pvalue->id){//dungnm23 check case lai nhe
        
            case ASN1V_e2ap_id_TransactionID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_E2connectionUpdateAck_IEs_id_TransactionID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-TransactionID");
                pvalue->value.u._e2ap_E2connectionUpdateAck_IEs_id_TransactionID 
                    = rtxMemAllocType(pctxt, e2ap_TransactionID);

                asn1Init_e2ap_TransactionID(pvalue->value.u._e2ap_E2connectionUpdateAck_IEs_id_TransactionID);

                stat = asn1PD_e2ap_TransactionID (pctxt,
                        (e2ap_TransactionID*)pvalue->value.
                        u._e2ap_E2connectionUpdateAck_IEs_id_TransactionID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_E2connectionSetup:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_E2connectionUpdateAck_IEs_id_E2connectionSetup;
            RTXCTXTPUSHELEMNAME(pctxt, "id-E2connectionSetup");
                pvalue->value.u._e2ap_E2connectionUpdateAck_IEs_id_E2connectionSetup 
                    = rtxMemAllocType(pctxt, e2ap_E2connectionUpdate_List);

                asn1Init_e2ap_E2connectionUpdate_List(pvalue->value.u._e2ap_E2connectionUpdateAck_IEs_id_E2connectionSetup);

                stat = asn1PD_e2ap_E2connectionUpdate_List (pctxt,
                        (e2ap_E2connectionUpdate_List*)pvalue->value.
                        u._e2ap_E2connectionUpdateAck_IEs_id_E2connectionSetup);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_E2connectionSetupFailed:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_E2connectionUpdateAck_IEs_id_E2connectionSetupFailed;
            RTXCTXTPUSHELEMNAME(pctxt, "id-E2connectionSetupFailed");
                pvalue->value.u._e2ap_E2connectionUpdateAck_IEs_id_E2connectionSetupFailed 
                    = rtxMemAllocType(pctxt, e2ap_E2connectionSetupFailed_List);

                asn1Init_e2ap_E2connectionSetupFailed_List(pvalue->value.u._e2ap_E2connectionUpdateAck_IEs_id_E2connectionSetupFailed);

                stat = asn1PD_e2ap_E2connectionSetupFailed_List (pctxt,
                        (e2ap_E2connectionSetupFailed_List*)pvalue->value.
                        u._e2ap_E2connectionUpdateAck_IEs_id_E2connectionSetupFailed);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_E2connectionUpdateAck_IEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*) rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
    }
    {
    size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
    size_t bitsConsumed = bitEndOffset-bitStartOffset;
    if(bitsConsumed<bitLength){
        stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
    }
    else stat =(bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
    }}
    if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}


int asn1Init_e2ap_E2connectionUpdateAcknowledge_protocolIEs_element(e2ap_E2connectionUpdateAcknowledge_protocolIEs_element* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    OSCRTLMEMSET (&pvalue->value, 0, sizeof(pvalue->value));
    return 0;
}


//-----> chuaw có template rtxFreeASN1OpenType

#if 0
void asn1Free_e2ap_E2connectionUpdateAcknowledge_protocolIEs_element(OSCTXT* pctxt, e2ap_E2connectionUpdateAcknowledge_protocolIEs_element* pvalue)
{
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_E2connectionUpdateAck_IEs_id_id_TransactionID:
            // rtxFreeE2ap_TransactionID(pvalue->value.u._e2ap_E2connectionUpdateAck_IEs_id_id_TransactionID);

            if(pvalue->value.i._e2ap_E2connectionUpdateAcknowledge_id_TransactionID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_TransactionID(pctxt, pvalue->value.u._e2ap_E2connectionUpdateAck_IEs_id_id_TransactionID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2connectionUpdateAck_IEs_id_id_TransactionID);
           // pvalue->value.u._e2ap_E2connectionUpdateAck_IEs_id_id_TransactionID = NULL;
           pvalue->value.u._e2ap_E2connectionUpdateAck_IEs_id_TransactionID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_E2connectionUpdateAck_IEs_id_id_E2connectionSetup:
            // rtxFreeE2ap_E2connectionUpdate_List(pvalue->value.u._e2ap_E2connectionUpdateAck_IEs_id_id_E2connectionSetup);

            if(pvalue->value.i._e2ap_E2connectionUpdateAcknowledge_id_E2connectionUpdate_List!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_E2connectionUpdate_List(pctxt, pvalue->value.u._e2ap_E2connectionUpdateAck_IEs_id_id_E2connectionSetup);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2connectionUpdateAck_IEs_id_id_E2connectionSetup);
           // pvalue->value.u._e2ap_E2connectionUpdateAck_IEs_id_id_E2connectionSetup = NULL;
           pvalue->value.u._e2ap_E2connectionUpdateAck_IEs_id_E2connectionSetup = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_E2connectionUpdateAck_IEs_id_id_E2connectionSetupFailed:
            // rtxFreeE2ap_E2connectionSetupFailed_List(pvalue->value.u._e2ap_E2connectionUpdateAck_IEs_id_id_E2connectionSetupFailed);

            if(pvalue->value.i._e2ap_E2connectionUpdateAcknowledge_id_E2connectionSetupFailed_List!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_E2connectionSetupFailed_List(pctxt, pvalue->value.u._e2ap_E2connectionUpdateAck_IEs_id_id_E2connectionSetupFailed);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2connectionUpdateAck_IEs_id_id_E2connectionSetupFailed);
           // pvalue->value.u._e2ap_E2connectionUpdateAck_IEs_id_id_E2connectionSetupFailed = NULL;
           pvalue->value.u._e2ap_E2connectionUpdateAck_IEs_id_E2connectionSetupFailed = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_E2connectionUpdateAck_IEs_UNDEF_:
            rtxFreeASN1OpenType(pvalue->value.u.extElem1);
            break;
        default:
            break;
    }
}

int asn1PrtToStr_e2ap_E2connectionUpdateAcknowledge_protocolIEs_element(OSCTXT* pctxt, e2ap_E2connectionUpdateAcknowledge_protocolIEs_element* pvalue)
{
    int stat =0;
    RTXCTXTPUSHELEMNAME(pctxt, "e2ap_E2connectionUpdateAcknowledge_protocolIEs_element");

    /*print id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PrtToStr_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PrtToStr_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_E2connectionUpdateAck_IEs_id_id_TransactionID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "TransactionID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_TransactionID (pctxt, pvalue->value.u._e2ap_E2connectionUpdateAck_IEs_id_id_TransactionID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_E2connectionUpdateAck_IEs_id_id_E2connectionSetup:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "E2connectionUpdate-List");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_E2connectionUpdate_List (pctxt, pvalue->value.u._e2ap_E2connectionUpdateAck_IEs_id_id_E2connectionSetup);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_E2connectionUpdateAck_IEs_id_id_E2connectionSetupFailed:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "E2connectionSetupFailed-List");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_E2connectionSetupFailed_List (pctxt, pvalue->value.u._e2ap_E2connectionUpdateAck_IEs_id_id_E2connectionSetupFailed);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_E2connectionUpdateAck_IEs_UNDEF_:
            {
                rtxPLogMsg(pctxt, "Extension element present - raw data not printed.\n");
                break;
            }

            default:
                stat = RTERR_INVOPT;
                return LOG_RTERR(pctxt, stat);
        }
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);
}
#endif


int asn1PrtToStr_e2ap_E2connectionUpdateAcknowledge_protocolIEs_element (const char * name,
 e2ap_E2connectionUpdateAcknowledge_protocolIEs_element* pvalue, 
 char * buffer, OSSIZE bufSize){
    if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
        return -1;
    if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
        return -1;

    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_E2connectionUpdateAck_IEs_id_TransactionID:
            if(asn1PrtToStr_e2ap_TransactionID("TransactionID", 
                    pvalue->value.u._e2ap_E2connectionUpdateAck_IEs_id_TransactionID, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_E2connectionUpdateAck_IEs_id_E2connectionSetup:
            if(asn1PrtToStr_e2ap_E2connectionUpdate_List("E2connectionUpdate-List", 
                    pvalue->value.u._e2ap_E2connectionUpdateAck_IEs_id_E2connectionSetup, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_E2connectionUpdateAck_IEs_id_E2connectionSetupFailed:
            if(asn1PrtToStr_e2ap_E2connectionSetupFailed_List("E2connectionSetupFailed-List", 
                    pvalue->value.u._e2ap_E2connectionUpdateAck_IEs_id_E2connectionSetupFailed, buffer, bufSize)<0)
                return -1;
            break;    
        default:
        if(0!=pvalue -> value.u.extElem1){
            rtPrintToStringIndent(buffer, bufSize);
            rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

        }
        }
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

    return 0;

 }

 void asn1Free_e2ap_E2connectionUpdateAcknowledge_protocolIEs_element(OSCTXT* pctxt, e2ap_E2connectionUpdateAcknowledge_protocolIEs_element* pvalue){
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_E2connectionUpdateAck_IEs_id_TransactionID:
            if(pvalue->value.u._e2ap_E2connectionUpdateAck_IEs_id_TransactionID!=NULL){
            asn1Free_e2ap_TransactionID(pctxt, pvalue->value.u._e2ap_E2connectionUpdateAck_IEs_id_TransactionID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2connectionUpdateAck_IEs_id_TransactionID);
            pvalue->value.u._e2ap_E2connectionUpdateAck_IEs_id_TransactionID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_E2connectionUpdateAck_IEs_id_E2connectionSetup:
            if(pvalue->value.u._e2ap_E2connectionUpdateAck_IEs_id_E2connectionSetup!=NULL){
            asn1Free_e2ap_E2connectionUpdate_List(pctxt, pvalue->value.u._e2ap_E2connectionUpdateAck_IEs_id_E2connectionSetup);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2connectionUpdateAck_IEs_id_E2connectionSetup);
            pvalue->value.u._e2ap_E2connectionUpdateAck_IEs_id_E2connectionSetup = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_E2connectionUpdateAck_IEs_id_E2connectionSetupFailed:
            if(pvalue->value.u._e2ap_E2connectionUpdateAck_IEs_id_E2connectionSetupFailed!=NULL){
            asn1Free_e2ap_E2connectionSetupFailed_List(pctxt, pvalue->value.u._e2ap_E2connectionUpdateAck_IEs_id_E2connectionSetupFailed);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2connectionUpdateAck_IEs_id_E2connectionSetupFailed);
            pvalue->value.u._e2ap_E2connectionUpdateAck_IEs_id_E2connectionSetupFailed = NULL;
            }
            break;
        default:
            break;


    }
 }

 

/*****************************************/
/*           E2connectionUpdateAcknowledge                */
/*****************************************/
//2_container.c
/* 1. xxx_ProtocolIE -> mẫu cũ ở ie_big_msg */
EXTERN int asn1PE_e2ap_E2connectionUpdateAcknowledge_protocolIEs (OSCTXT* pctxt, e2ap_E2connectionUpdateAcknowledge_protocolIEs* pvalue)
{
    int stat =0;
    OSRTDListNode* pnode;
    OSUINT32 xx1;

    /*encode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pe_Length(pctxt, pvalue->count);
    if(stat<0) return LOG_RTERR(pctxt, stat);

    /*encode each element*/
    xx1 =0;
    for(pnode = pvalue->head; pnode != 0 && xx1<pvalue->count; pnode = pnode->next){
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE", xx1);
        stat = asn1PE_e2ap_E2connectionUpdateAcknowledge_protocolIEs_element (pctxt, ((e2ap_E2connectionUpdateAcknowledge_protocolIEs_element*)pnode->data));
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        xx1++;
        RTXCTXTPOPARRAYELEMNAME(pctxt);
    }

    return (stat);
}

EXTERN int  asn1PD_e2ap_E2connectionUpdateAcknowledge_protocolIEs(OSCTXT* pctxt, e2ap_E2connectionUpdateAcknowledge_protocolIEs* pvalue)
{
     int stat =0;
     OSRTDListNode* pnode;
     OSSIZE count =0;
     OSSIZE xx1=0;


     /*decode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pd_Length64(pctxt, &count); //tai sao lai 64
    if(stat!=0) return LOG_RTERR(pctxt, stat);

    /*decode each element*/
    rtxDListInit(pvalue);

    for(xx1=0; xx1 < count; xx1++){
        e2ap_E2connectionUpdateAcknowledge_protocolIEs_element* pdata;
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE",xx1);

        if(pnode == NULL) return LOG_RTERR(pctxt, RTERR_NOMEM);

        asn1Init_e2ap_E2connectionUpdateAcknowledge_protocolIEs_element(pdata);
        rtxDListAppendNode(pvalue, pnode);
        stat = asn1PD_e2ap_E2connectionUpdateAcknowledge_protocolIEs_element (pctxt, pdata);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        RTXCTXTPOPARRAYELEMNAME(pctxt);

    }
    return (stat);
}


int asn1Init_e2ap_E2connectionUpdateAcknowledge_protocolIEs(e2ap_E2connectionUpdateAcknowledge_protocolIEs* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    rtxDListFastInit (pvalue);
    return 0;
}
#if 1 //ao that day
void asn1Free_e2ap_E2connectionUpdateAcknowledge_protocolIEs(OSCTXT* pctxt, e2ap_E2connectionUpdateAcknowledge_protocolIEs* pvalue)
{
    if(0==pvalue) return;   
    e2ap_E2connectionUpdateAcknowledge_protocolIEs_element* pdata;
    OSRTDListNode* pnode=pvalue->head;
    while(0!=pnode){
        pdata = (e2ap_E2connectionUpdateAcknowledge_protocolIEs_element*)pnode->data;
       // asn1Free_e2ap_E2connectionUpdateAcknowledge_protocolIEs_element(pctxt, pdata);
        pnode = pnode->next;
    }
    rtxDListFreeAll(pctxt, pvalue);
}
#endif


EXTERN int asn1PrtToStr_e2ap_E2connectionUpdateAcknowledge_protocolIEs(const char* name, e2ap_E2connectionUpdateAcknowledge_protocolIEs* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_E2connectionUpdateAcknowledge_protocolIEs_element* pdata0;
    OSRTDListNode* pnode0;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode0 = pvalue->head;  xx1 < pvalue->count && pnode0 != 0; pnode0 = pnode0->next, xx1++){
        pdata0 = (e2ap_E2connectionUpdateAcknowledge_protocolIEs_element*)pnode0->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 0
        if(asn1PrtToStr_e2ap_E2connectionUpdateAcknowledge_protocolIEs_element(nameBuf, pdata0, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}


/*2 . E2connectionUpdateAcknowledge -> mẫu cũ ở seq_normal*/

int asn1PE_e2ap_E2connectionUpdateAcknowledge (OSCTXT* pctxt, e2ap_E2connectionUpdateAcknowledge* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "E2connectionUpdateAcknowledge");
   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field protocolIEs - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
   stat = asn1PE_e2ap_E2connectionUpdateAcknowledge_protocolIEs (pctxt, &pvalue->protocolIEs);
   if(stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_E2connectionUpdateAcknowledge (OSCTXT* pctxt, e2ap_E2connectionUpdateAcknowledge* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME(pctxt, "E2connectionUpdateAcknowledge");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field protocolIEs */
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
      stat = asn1PD_e2ap_E2connectionUpdateAcknowledge_protocolIEs (pctxt, &pvalue->protocolIEs);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_E2connectionUpdateAcknowledge (e2ap_E2connectionUpdateAcknowledge* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_E2connectionUpdateAcknowledge_protocolIEs(&pvalue->protocolIEs);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_E2connectionUpdateAcknowledge (OSCTXT* pctxt, e2ap_E2connectionUpdateAcknowledge* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_E2connectionUpdateAcknowledge_protocolIEs(pctxt, &pvalue->protocolIEs);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_E2connectionUpdateAcknowledge (const char* name, e2ap_E2connectionUpdateAcknowledge* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }

   if(asn1PrtToStr_e2ap_E2connectionUpdateAcknowledge_protocolIEs("protocolIEs", &pvalue->protocolIEs, buffer, bufSize) <0){
      return -1;
   }

   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/******************************************************/
/*                                                    */
/*    TimeToWait                          */
/*                                                    */
/******************************************************/
//enumerated


const OSEnumItem e2ap_TimeToWait_ENUMTAB[] = {
    { OSUTF8("v1s"), 0, 3, 0 },
    { OSUTF8("v2s"), 1, 3, 1 },
    { OSUTF8("v5s"), 2, 3, 2 },
    { OSUTF8("v10s"), 3, 4, 3 },
    { OSUTF8("v20s"), 4, 4, 4 },
    { OSUTF8("v60s"), 5, 4, 5 }
};


const OSUTF8CHAR* e2ap_TimeToWait_ToString (OSUINT32 value){
   OSINT32 idx = value;
   if(idx >=0 && idx < e2ap_TimeToWait_ENUMTABSIZE){
      return e2ap_TimeToWait_ENUMTAB[e2ap_TimeToWait_ENUMTAB[idx].transidx].name;
   }else{
      return OSUTF8("_UNKNOWN_");
   }
}


int e2ap_TimeToWait_ToEnum (OSCTXT* pctxt, const OSUTF8CHAR* value,e2ap_TimeToWait* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes(value);
   return e2ap_TimeToWait_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int e2ap_TimeToWait_ToEnum2 (OSCTXT* pctxt, const OSUTF8CHAR* value, OSSIZE valueLen,e2ap_TimeToWait* pvalue)
{
   OSINT32 idx = rtxLookupEnum(value, valueLen,
      e2ap_TimeToWait_ENUMTAB, e2ap_TimeToWait_ENUMTABSIZE);
   if (idx >= 0) {
      *pvalue = (e2ap_TimeToWait)e2ap_TimeToWait_ENUMTAB[idx].value;
      return 0;
   } else {
      rtxErrAddIntParm (pctxt, (const char*)value);//dungnm23 check xem là Str hay Int
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_e2ap_TimeToWait (OSCTXT* pctxt, e2ap_TimeToWait value)
{
   int stat = 0;
   RTXCTXTPUSHTYPENAME (pctxt, "TimeToWait");
   if (value >= 6) {
      rtxErrAddIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(5));
   if(stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}

EXTERN int asn1PD_e2ap_TimeToWait (OSCTXT* pctxt, e2ap_TimeToWait* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TimeToWait");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(5));
   if(stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return stat;
}

EXTERN int asn1PrtToStr_e2ap_TimeToWait (const char* name, e2ap_TimeToWait* pvalue, char* buffer, OSSIZE bufSize)
{
   int stat;

   if(rtPrintToStringIndent(buffer, bufSize) < 0) return -1;
   if(rtPrintToString(name, buffer, bufSize) < 0) return -1;

   switch(*pvalue) {
      case 0:
         stat = rtPrintToString(" = v1s \n", buffer, bufSize);
         break;
      case 1:
         stat = rtPrintToString(" = v2s \n", buffer, bufSize);
         break;
      case 2:
         stat = rtPrintToString(" = v5s \n", buffer, bufSize);
         break;
      case 3:
         stat = rtPrintToString(" = v10s \n", buffer, bufSize);
         break;
      case 4:
         stat = rtPrintToString(" = v20s \n", buffer, bufSize);
         break;
      case 5:
         stat = rtPrintToString(" = v60s \n", buffer, bufSize);
         break;
      default:
         stat = rtPrintToString(" = ???\n", buffer, bufSize);
   }

   if (stat < 0) return -1;
   return 0;

}

/*Init*/
EXTERN int asn1Init_e2ap_TimeToWait (e2ap_TimeToWait* pvalue){
      //if (pvalue == 0) return RTERR_NULLPTR;
      //*pvalue = 0;
      return 0;
}/*****************************************/
/*           ProcedureCode                */
/*****************************************/
//6 mau integer
// mau integer size(a...b) mau la procedurecode
EXTERN int asn1PE_e2ap_ProcedureCode (OSCTXT* pctxt, e2ap_ProcedureCode value){
    int stat = 0;
    RTXCTCXTPUSHTYPENAME (pctxt, "ProcedureCode");
    stat = pe_ConsUnsigned (pctxt, value, 0, 255);
    if (stat != 0) return LOG_RTERR (pctxt, stat);
    RTXCTXTPOPTYPENAME (pctxt);
    return stat;
}
EXTERN int asn1PD_e2ap_ProcedureCode (OSCTXT* pctxt, e2ap_ProcedureCode* pvalue){
    int stat = 0;
    RTXCTCXTPUSHTYPENAME (pctxt, "ProcedureCode");
    if(pctxt->buffer.aligned){
        int stat2 = PD_BYTE_ALIGN(pctxt);
        if(stat2 != 0) return LOG_RTERR (pctxt, stat2);
    }
    stat = rtxDecBitsToByte(pctxt, pvalue, 0);
    if (stat != 0) return LOG_RTERR (pctxt, stat);
    RTXCTXTPOPTYPENAME (pctxt);
    return stat;
}
//EXTERN int asn1Print_e2ap_ProcedureCode (const char* name, const e2ap_ProcedureCode* pvalue);
//EXTERN int asn1PrtToStr_e2ap_ProcedureCode (const char* name, e2ap_ProcedureCode* pvalue, char* buffer, OSSIZE bufSize);
//EXTERN int asn1PrtToStrm_e2ap_ProcedureCode (OSCTXT* pctxt, const char* name, const e2ap_ProcedureCode* pvalue);
EXTERN int asn1Init_e2ap_ProcedureCode (e2ap_ProcedureCode* pvalue){
    //if (pvalue == 0) return RTERR_NULLPTR;
    //*pvalue = 0;
    return 0;
}
EXTERN int asn1Free_e2ap_ProcedureCode (OSCTXT* pctxt, e2ap_ProcedureCode* pvalue){
    // No dynamic memory to free for integer
    return 0;
}
/******************************************************/
/*                                                    */
/*    TriggeringMessage                          */
/*                                                    */
/******************************************************/
//enumerated


const OSEnumItem e2ap_TriggeringMessage_ENUMTAB[] = {
    { OSUTF8("initiating_message"), 0, 18, 0 },
    { OSUTF8("successful_outcome"), 1, 18, 1 },
    { OSUTF8("unsuccessfull_outcome"), 2, 21, 2 }
};


const OSUTF8CHAR* e2ap_TriggeringMessage_ToString (OSUINT32 value){
   OSINT32 idx = value;
   if(idx >=0 && idx < e2ap_TriggeringMessage_ENUMTABSIZE){
      return e2ap_TriggeringMessage_ENUMTAB[e2ap_TriggeringMessage_ENUMTAB[idx].transidx].name;
   }else{
      return OSUTF8("_UNKNOWN_");
   }
}


int e2ap_TriggeringMessage_ToEnum (OSCTXT* pctxt, const OSUTF8CHAR* value,e2ap_TriggeringMessage* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes(value);
   return e2ap_TriggeringMessage_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int e2ap_TriggeringMessage_ToEnum2 (OSCTXT* pctxt, const OSUTF8CHAR* value, OSSIZE valueLen,e2ap_TriggeringMessage* pvalue)
{
   OSINT32 idx = rtxLookupEnum(value, valueLen,
      e2ap_TriggeringMessage_ENUMTAB, e2ap_TriggeringMessage_ENUMTABSIZE);
   if (idx >= 0) {
      *pvalue = (e2ap_TriggeringMessage)e2ap_TriggeringMessage_ENUMTAB[idx].value;
      return 0;
   } else {
      rtxErrAddIntParm (pctxt, (const char*)value);//dungnm23 check xem là Str hay Int
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_e2ap_TriggeringMessage (OSCTXT* pctxt, e2ap_TriggeringMessage value)
{
   int stat = 0;
   RTXCTXTPUSHTYPENAME (pctxt, "TriggeringMessage");
   if (value >= 3) {
      rtxErrAddIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(2));
   if(stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}

EXTERN int asn1PD_e2ap_TriggeringMessage (OSCTXT* pctxt, e2ap_TriggeringMessage* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TriggeringMessage");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(2));
   if(stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return stat;
}

EXTERN int asn1PrtToStr_e2ap_TriggeringMessage (const char* name, e2ap_TriggeringMessage* pvalue, char* buffer, OSSIZE bufSize)
{
   int stat;

   if(rtPrintToStringIndent(buffer, bufSize) < 0) return -1;
   if(rtPrintToString(name, buffer, bufSize) < 0) return -1;

   switch(*pvalue) {
      case 0:
         stat = rtPrintToString(" = initiating_message \n", buffer, bufSize);
         break;
      case 1:
         stat = rtPrintToString(" = successful_outcome \n", buffer, bufSize);
         break;
      case 2:
         stat = rtPrintToString(" = unsuccessfull_outcome \n", buffer, bufSize);
         break;
      default:
         stat = rtPrintToString(" = ???\n", buffer, bufSize);
   }

   if (stat < 0) return -1;
   return 0;

}

/*Init*/
EXTERN int asn1Init_e2ap_TriggeringMessage (e2ap_TriggeringMessage* pvalue){
      //if (pvalue == 0) return RTERR_NULLPTR;
      //*pvalue = 0;
      return 0;
}/******************************************************/
/*                                                    */
/*    Criticality                          */
/*                                                    */
/******************************************************/
//enumerated


const OSEnumItem e2ap_Criticality_ENUMTAB[] = {
    { OSUTF8("reject"), 0, 6, 0 },
    { OSUTF8("ignore"), 1, 6, 1 },
    { OSUTF8("notify"), 2, 6, 2 }
};


const OSUTF8CHAR* e2ap_Criticality_ToString (OSUINT32 value){
   OSINT32 idx = value;
   if(idx >=0 && idx < e2ap_Criticality_ENUMTABSIZE){
      return e2ap_Criticality_ENUMTAB[e2ap_Criticality_ENUMTAB[idx].transidx].name;
   }else{
      return OSUTF8("_UNKNOWN_");
   }
}


int e2ap_Criticality_ToEnum (OSCTXT* pctxt, const OSUTF8CHAR* value,e2ap_Criticality* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes(value);
   return e2ap_Criticality_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int e2ap_Criticality_ToEnum2 (OSCTXT* pctxt, const OSUTF8CHAR* value, OSSIZE valueLen,e2ap_Criticality* pvalue)
{
   OSINT32 idx = rtxLookupEnum(value, valueLen,
      e2ap_Criticality_ENUMTAB, e2ap_Criticality_ENUMTABSIZE);
   if (idx >= 0) {
      *pvalue = (e2ap_Criticality)e2ap_Criticality_ENUMTAB[idx].value;
      return 0;
   } else {
      rtxErrAddIntParm (pctxt, (const char*)value);//dungnm23 check xem là Str hay Int
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_e2ap_Criticality (OSCTXT* pctxt, e2ap_Criticality value)
{
   int stat = 0;
   RTXCTXTPUSHTYPENAME (pctxt, "Criticality");
   if (value >= 3) {
      rtxErrAddIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(2));
   if(stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}

EXTERN int asn1PD_e2ap_Criticality (OSCTXT* pctxt, e2ap_Criticality* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Criticality");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(2));
   if(stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return stat;
}

EXTERN int asn1PrtToStr_e2ap_Criticality (const char* name, e2ap_Criticality* pvalue, char* buffer, OSSIZE bufSize)
{
   int stat;

   if(rtPrintToStringIndent(buffer, bufSize) < 0) return -1;
   if(rtPrintToString(name, buffer, bufSize) < 0) return -1;

   switch(*pvalue) {
      case 0:
         stat = rtPrintToString(" = reject \n", buffer, bufSize);
         break;
      case 1:
         stat = rtPrintToString(" = ignore \n", buffer, bufSize);
         break;
      case 2:
         stat = rtPrintToString(" = notify \n", buffer, bufSize);
         break;
      default:
         stat = rtPrintToString(" = ???\n", buffer, bufSize);
   }

   if (stat < 0) return -1;
   return 0;

}

/*Init*/
EXTERN int asn1Init_e2ap_Criticality (e2ap_Criticality* pvalue){
      //if (pvalue == 0) return RTERR_NULLPTR;
      //*pvalue = 0;
      return 0;
}
/*****************************************/
/*           RICrequestID                */
/*****************************************/
//sequence normal
// Các nội dung cần thiết cho template seq_normal.c.j2
    // Nội dung của file .c cho primitive INTEGER (0..65535)
    /*****************************************/
/*           ricRequestorID                */
/*****************************************/
//interger intergrate
 //metadata.parsed.primitive_id == 6
// mau integer size(a...b) mau la timestayincell xn
//typedef OSUINT16 e2ap_RICrequestID_ricRequestorID;
EXTERN int asn1PE_e2ap_RICrequestID_ricRequestorID (OSCTXT* pctxt, e2ap_RICrequestID_ricRequestorID value){
    int stat =0;

    if(value<=65535 && value>= 0){
        stat = pe_ConsUnsigned (pctxt, value, 0, 65535);
        if(stat != 0) return LOG_RTERR (pctxt, stat);
    }else{
        rtxErrAddElemNameParm(pctxt);
        rtxErrAddUIntParm(pctxt, value);
        return LOG_RTERR(pctxt, RTERR_CONSVIO);
    }
    return stat;

}
EXTERN int asn1PD_e2ap_RICrequestID_ricRequestorID (OSCTXT* pctxt, e2ap_RICrequestID_ricRequestorID* pvalue){
    int stat =0;
    if(pctxt->buffer.aligned){
        int stat2 = PD_BYTE_ALIGN(pctxt);
        if(stat2 != 0) return LOG_RTERR (pctxt, stat2);
    }

    stat = rtxDecBitsToUInt16(pctxt, pvalue, pctxt->buffer.aligned ? 16:12);
    if(stat !=0) return LOG_RTERR (pctxt, stat);
    if(*pvalue > 65535 || *pvalue < 0){
        rtxErrAddElemNameParm(pctxt);
        rtxErrAddUIntParm(pctxt, 65535);
        return LOG_RTERR(pctxt, RTERR_CONSVIO);
    }
}
//EXTERN int asn1Print_e2ap_RICrequestID_ricRequestorID (const char* name, const e2ap_RICrequestID_ricRequestorID* pvalue);
EXTERN int asn1PrtToStr_e2ap_RICrequestID_ricRequestorID (const char* name, e2ap_RICrequestID_ricRequestorID* pvalue, char* buffer, OSSIZE bufSize){
    if(rtPrintToStringIndent(buffer, bufSize) < 0) return -1;
    if(rtPrintToStringUnsigned(name, *pvalue, buffer, bufSize) < 0) return -1;
    return 0;
}
//EXTERN int asn1PrtToStrm_e2ap_RICrequestID_ricRequestorID (OSCTXT* pctxt, const char* name, const e2ap_RICrequestID_ricRequestorID* pvalue);
EXTERN int asn1Init_e2ap_RICrequestID_ricRequestorID (e2ap_RICrequestID_ricRequestorID* pvalue){
    //if (pvalue == 0) return RTERR_NULLPTR;
    //*pvalue = 0;
    return 0;
}
EXTERN int asn1Free_e2ap_RICrequestID_ricRequestorID (OSCTXT* pctxt, e2ap_RICrequestID_ricRequestorID* pvalue){
    // No dynamic memory to free for integer
    return 0;
}



    // Nội dung của file .c cho primitive INTEGER (0..65535)
    /*****************************************/
/*           ricInstanceID                */
/*****************************************/
//interger intergrate
 //metadata.parsed.primitive_id == 6
// mau integer size(a...b) mau la timestayincell xn
//typedef OSUINT16 e2ap_RICrequestID_ricInstanceID;
EXTERN int asn1PE_e2ap_RICrequestID_ricInstanceID (OSCTXT* pctxt, e2ap_RICrequestID_ricInstanceID value){
    int stat =0;

    if(value<=65535 && value>= 0){
        stat = pe_ConsUnsigned (pctxt, value, 0, 65535);
        if(stat != 0) return LOG_RTERR (pctxt, stat);
    }else{
        rtxErrAddElemNameParm(pctxt);
        rtxErrAddUIntParm(pctxt, value);
        return LOG_RTERR(pctxt, RTERR_CONSVIO);
    }
    return stat;

}
EXTERN int asn1PD_e2ap_RICrequestID_ricInstanceID (OSCTXT* pctxt, e2ap_RICrequestID_ricInstanceID* pvalue){
    int stat =0;
    if(pctxt->buffer.aligned){
        int stat2 = PD_BYTE_ALIGN(pctxt);
        if(stat2 != 0) return LOG_RTERR (pctxt, stat2);
    }

    stat = rtxDecBitsToUInt16(pctxt, pvalue, pctxt->buffer.aligned ? 16:12);
    if(stat !=0) return LOG_RTERR (pctxt, stat);
    if(*pvalue > 65535 || *pvalue < 0){
        rtxErrAddElemNameParm(pctxt);
        rtxErrAddUIntParm(pctxt, 65535);
        return LOG_RTERR(pctxt, RTERR_CONSVIO);
    }
}
//EXTERN int asn1Print_e2ap_RICrequestID_ricInstanceID (const char* name, const e2ap_RICrequestID_ricInstanceID* pvalue);
EXTERN int asn1PrtToStr_e2ap_RICrequestID_ricInstanceID (const char* name, e2ap_RICrequestID_ricInstanceID* pvalue, char* buffer, OSSIZE bufSize){
    if(rtPrintToStringIndent(buffer, bufSize) < 0) return -1;
    if(rtPrintToStringUnsigned(name, *pvalue, buffer, bufSize) < 0) return -1;
    return 0;
}
//EXTERN int asn1PrtToStrm_e2ap_RICrequestID_ricInstanceID (OSCTXT* pctxt, const char* name, const e2ap_RICrequestID_ricInstanceID* pvalue);
EXTERN int asn1Init_e2ap_RICrequestID_ricInstanceID (e2ap_RICrequestID_ricInstanceID* pvalue){
    //if (pvalue == 0) return RTERR_NULLPTR;
    //*pvalue = 0;
    return 0;
}
EXTERN int asn1Free_e2ap_RICrequestID_ricInstanceID (OSCTXT* pctxt, e2ap_RICrequestID_ricInstanceID* pvalue){
    // No dynamic memory to free for integer
    return 0;
}




// Các phần còn lại của template seq_normal.c.j2
//contain extensition bit -> theo mau cua GlobalgNB-ID
int asn1PE_e2ap_RICrequestID (OSCTXT* pctxt, e2ap_RICrequestID* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RICrequestID");

   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field ricRequestorID - id = 6*/  
   RTXCTXTPUSHELEMNAME(pctxt, "ricRequestorID");
   stat = asn1PE_e2ap_RICrequestID_ricRequestorID(pctxt, pvalue->ricRequestorID); //intger mau 6 (a..b)
  
  
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /* encode field ricInstanceID - id = 6*/  
   RTXCTXTPUSHELEMNAME(pctxt, "ricInstanceID");
   stat = asn1PE_e2ap_RICrequestID_ricInstanceID(pctxt, pvalue->ricInstanceID); //intger mau 6 (a..b)
  
  
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);



   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RICrequestID (OSCTXT* pctxt, e2ap_RICrequestID* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME(pctxt, "RICrequestID");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field ricRequestorID */
   RTXCTXTPUSHELEMNAME(pctxt, "ricRequestorID");
      stat = asn1PD_e2ap_RICrequestID_ricRequestorID (pctxt, &pvalue->ricRequestorID); //primitive
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field ricInstanceID */
   RTXCTXTPUSHELEMNAME(pctxt, "ricInstanceID");
      stat = asn1PD_e2ap_RICrequestID_ricInstanceID (pctxt, &pvalue->ricInstanceID); //primitive
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RICrequestID (e2ap_RICrequestID* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RICrequestID_ricRequestorID (&pvalue->ricRequestorID); //primitive delete &
   asn1Init_e2ap_RICrequestID_ricInstanceID (&pvalue->ricInstanceID); //primitive delete &
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RICrequestID (OSCTXT* pctxt, e2ap_RICrequestID* pvalue)
{
   if(0==pvalue) return;
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RICrequestID (const char* name, e2ap_RICrequestID* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }

   if(asn1PrtToStr_e2ap_RICrequestID_ricRequestorID ("ricRequestorID", &pvalue->ricRequestorID, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_RICrequestID_ricInstanceID ("ricInstanceID", &pvalue->ricInstanceID, buffer, bufSize) < 0)
   {
      return -1;
   }


   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}
/*****************************************/
/*           CriticalityDiagnostics-IE-List                */
/*****************************************/
//sequence normal
// Các nội dung cần thiết cho template seq_normal.c.j2

// Các phần còn lại của template seq_normal.c.j2
//contain extensition bit -> theo mau cua GlobalgNB-ID
int asn1PE_e2ap_CriticalityDiagnostics_IE_List (OSCTXT* pctxt, e2ap_CriticalityDiagnostics_IE_List* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "CriticalityDiagnostics-IE-List");

   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field iECriticality - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "iECriticality");
   stat = asn1PE_e2ap_Criticality (pctxt, pvalue->iECriticality);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /* encode field iE_ID - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "iE-ID");
   stat = asn1PE_e2ap_ProtocolIE_ID (pctxt, pvalue->iE_ID);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /* encode field typeOfError - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "typeOfError");
   stat = asn1PE_e2ap_TypeOfError (pctxt, pvalue->typeOfError);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);



   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_CriticalityDiagnostics_IE_List (OSCTXT* pctxt, e2ap_CriticalityDiagnostics_IE_List* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[3];

   RTXCTXTPUSHTYPENAME(pctxt, "CriticalityDiagnostics-IE-List");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field iECriticality */
   RTXCTXTPUSHELEMNAME(pctxt, "iECriticality");
      stat = asn1PD_e2ap_Criticality (pctxt, &pvalue->iECriticality);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field iE_ID */
   RTXCTXTPUSHELEMNAME(pctxt, "iE-ID");
      stat = asn1PD_e2ap_ProtocolIE_ID (pctxt, &pvalue->iE_ID);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field typeOfError */
   RTXCTXTPUSHELEMNAME(pctxt, "typeOfError");
      stat = asn1PD_e2ap_TypeOfError (pctxt, &pvalue->typeOfError);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_CriticalityDiagnostics_IE_List (e2ap_CriticalityDiagnostics_IE_List* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_Criticality (&pvalue->iECriticality);
   asn1Init_e2ap_ProtocolIE_ID (&pvalue->iE_ID);
   asn1Init_e2ap_TypeOfError (&pvalue->typeOfError);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_CriticalityDiagnostics_IE_List (OSCTXT* pctxt, e2ap_CriticalityDiagnostics_IE_List* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_Criticality (pctxt, &pvalue->iECriticality);
   asn1Free_e2ap_ProtocolIE_ID (pctxt, &pvalue->iE_ID);
   asn1Free_e2ap_TypeOfError (pctxt, &pvalue->typeOfError);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_CriticalityDiagnostics_IE_List (const char* name, e2ap_CriticalityDiagnostics_IE_List* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }
   if(asn1PrtToStr_e2ap_Criticality ("iECriticality", &pvalue->iECriticality, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_ProtocolIE_ID ("iE_ID", &pvalue->iE_ID, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_TypeOfError ("typeOfError", &pvalue->typeOfError, buffer, bufSize) < 0)
   {
      return -1;
   }



   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}
/*****************************************/
/*           CriticalityDiagnostics                */
/*****************************************/
//sequence normal
// Các nội dung cần thiết cho template seq_normal.c.j2

// Các phần còn lại của template seq_normal.c.j2
//contain extensition bit -> theo mau cua GlobalgNB-ID
int asn1PE_e2ap_CriticalityDiagnostics (OSCTXT* pctxt, e2ap_CriticalityDiagnostics* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "CriticalityDiagnostics");

   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);

   /*optional bit for field procedureCode*/
   stat = rtxEncBit (pctxt, pvalue->m_procedureCodePresent);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   /*optional bit for field triggeringMessage*/
   stat = rtxEncBit (pctxt, pvalue->m_triggeringMessagePresent);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   /*optional bit for field procedureCriticality*/
   stat = rtxEncBit (pctxt, pvalue->m_procedureCriticalityPresent);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   /*optional bit for field ricRequestorID*/
   stat = rtxEncBit (pctxt, pvalue->m_ricRequestorIDPresent);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   /*optional bit for field iEsCriticalityDiagnostics*/
   stat = rtxEncBit (pctxt, pvalue->m_iEsCriticalityDiagnosticsPresent);
   if (stat != 0) return LOG_RTERR(pctxt, stat);

   /*encode root elements*/   
   /* encode field procedureCode - id = -1*/  
   if (pvalue->m_procedureCodePresent) {//OPTIONAL FIELD
   RTXCTXTPUSHELEMNAME(pctxt, "procedureCode");
   stat = asn1PE_e2ap_ProcedureCode (pctxt, pvalue->procedureCode);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   }

   /* encode field triggeringMessage - id = -1*/  
   if (pvalue->m_triggeringMessagePresent) {//OPTIONAL FIELD
   RTXCTXTPUSHELEMNAME(pctxt, "triggeringMessage");
   stat = asn1PE_e2ap_TriggeringMessage (pctxt, pvalue->triggeringMessage);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   }

   /* encode field procedureCriticality - id = -1*/  
   if (pvalue->m_procedureCriticalityPresent) {//OPTIONAL FIELD
   RTXCTXTPUSHELEMNAME(pctxt, "procedureCriticality");
   stat = asn1PE_e2ap_Criticality (pctxt, pvalue->procedureCriticality);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   }

   /* encode field ricRequestorID - id = -1*/  
   if (pvalue->m_ricRequestorIDPresent) {//OPTIONAL FIELD
   RTXCTXTPUSHELEMNAME(pctxt, "ricRequestorID");
   stat = asn1PE_e2ap_RICrequestID (pctxt, pvalue->ricRequestorID);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   }

   /* encode field iEsCriticalityDiagnostics - id = -1*/  
   if (pvalue->m_iEsCriticalityDiagnosticsPresent) {//OPTIONAL FIELD
   RTXCTXTPUSHELEMNAME(pctxt, "iEsCriticalityDiagnostics");
   stat = asn1PE_e2ap_CriticalityDiagnostics_IE_List (pctxt, pvalue->iEsCriticalityDiagnostics);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   }


   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_CriticalityDiagnostics (OSCTXT* pctxt, e2ap_CriticalityDiagnostics* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[5];

   RTXCTXTPUSHTYPENAME(pctxt, "CriticalityDiagnostics");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 5; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field procedureCode */
   RTXCTXTPUSHELEMNAME(pctxt, "procedureCode");
   if (optbits[0]) {
      pvalue->m_procedureCodePresent = TRUE;
      stat = asn1PD_e2ap_ProcedureCode (pctxt, &pvalue->procedureCode);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   } else {
      pvalue->m_procedureCodePresent = FALSE;
   }
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field triggeringMessage */
   RTXCTXTPUSHELEMNAME(pctxt, "triggeringMessage");
   if (optbits[0]) {
      pvalue->m_triggeringMessagePresent = TRUE;
      stat = asn1PD_e2ap_TriggeringMessage (pctxt, &pvalue->triggeringMessage);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   } else {
      pvalue->m_triggeringMessagePresent = FALSE;
   }
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field procedureCriticality */
   RTXCTXTPUSHELEMNAME(pctxt, "procedureCriticality");
   if (optbits[0]) {
      pvalue->m_procedureCriticalityPresent = TRUE;
      stat = asn1PD_e2ap_Criticality (pctxt, &pvalue->procedureCriticality);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   } else {
      pvalue->m_procedureCriticalityPresent = FALSE;
   }
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field ricRequestorID */
   RTXCTXTPUSHELEMNAME(pctxt, "ricRequestorID");
   if (optbits[0]) {
      pvalue->m_ricRequestorIDPresent = TRUE;
      stat = asn1PD_e2ap_RICrequestID (pctxt, &pvalue->ricRequestorID);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   } else {
      pvalue->m_ricRequestorIDPresent = FALSE;
   }
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field iEsCriticalityDiagnostics */
   RTXCTXTPUSHELEMNAME(pctxt, "iEsCriticalityDiagnostics");
   if (optbits[0]) {
      pvalue->m_iEsCriticalityDiagnosticsPresent = TRUE;
      stat = asn1PD_e2ap_CriticalityDiagnostics_IE_List (pctxt, &pvalue->iEsCriticalityDiagnostics);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   } else {
      pvalue->m_iEsCriticalityDiagnosticsPresent = FALSE;
   }
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_CriticalityDiagnostics (e2ap_CriticalityDiagnostics* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_ProcedureCode (&pvalue->procedureCode);
   asn1Init_e2ap_TriggeringMessage (&pvalue->triggeringMessage);
   asn1Init_e2ap_Criticality (&pvalue->procedureCriticality);
   asn1Init_e2ap_RICrequestID (&pvalue->ricRequestorID);
   asn1Init_e2ap_CriticalityDiagnostics_IE_List (&pvalue->iEsCriticalityDiagnostics);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_CriticalityDiagnostics (OSCTXT* pctxt, e2ap_CriticalityDiagnostics* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_ProcedureCode (pctxt, &pvalue->procedureCode);
   asn1Free_e2ap_TriggeringMessage (pctxt, &pvalue->triggeringMessage);
   asn1Free_e2ap_Criticality (pctxt, &pvalue->procedureCriticality);
   asn1Free_e2ap_RICrequestID (pctxt, &pvalue->ricRequestorID);
   asn1Free_e2ap_CriticalityDiagnostics_IE_List (pctxt, &pvalue->iEsCriticalityDiagnostics);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_CriticalityDiagnostics (const char* name, e2ap_CriticalityDiagnostics* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }
   if(asn1PrtToStr_e2ap_ProcedureCode ("procedureCode", &pvalue->procedureCode, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_TriggeringMessage ("triggeringMessage", &pvalue->triggeringMessage, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_Criticality ("procedureCriticality", &pvalue->procedureCriticality, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_RICrequestID ("ricRequestorID", &pvalue->ricRequestorID, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_CriticalityDiagnostics_IE_List ("iEsCriticalityDiagnostics", &pvalue->iEsCriticalityDiagnostics, buffer, bufSize) < 0)
   {
      return -1;
   }



   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           E2connectionUpdateFailure_IEs                */
/*****************************************/
/* ie.c.j2 */
 /* d là con của msg */
EXTERN int asn1PE_e2ap_E2connectionUpdateFailure_protocolIEs_element (OSCTXT* pctxt, e2ap_E2connectionUpdateFailure_protocolIEs_element* pvalue)
{
    int stat =0;

    /*encode id*/

    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PE_e2ap_ProtocolIE_ID(pctxt, pvalue->id);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PE_e2ap_Criticality(pctxt, pvalue->criticality);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
    {
        OSCTXT lctxt;
        OSOCTET *pDynamicEncodeBuffer;
        ASN1OpenType openType;
        OSBOOL encoded = TRUE;

        openType.numocts = 0;
        openType.data =0;

        rtxCopyContext(&lctxt, pctxt);
        pctxt->pStream =0;

        stat = rtxInitContextBuffer(pctxt, 0, 0);
        if(stat!=0) return LOG_RTERR(pctxt, stat);

        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_E2connectionUpdateFailure_IEs_id_TransactionID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-TransactionID");
                    stat = asn1PE_e2ap_TransactionID (pctxt, pvalue->value.u._e2ap_E2connectionUpdateFailure_IEs_id_TransactionID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_E2connectionUpdateFailure_IEs_id_Cause:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-Cause");
                    stat = asn1PE_e2ap_Cause (pctxt, pvalue->value.u._e2ap_E2connectionUpdateFailure_IEs_id_Cause);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_E2connectionUpdateFailure_IEs_id_TimeToWait:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-TimeToWait");
                    stat = asn1PE_e2ap_TimeToWait (pctxt, pvalue->value.u._e2ap_E2connectionUpdateFailure_IEs_id_TimeToWait);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_E2connectionUpdateFailure_IEs_id_CriticalityDiagnostics:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-CriticalityDiagnostics");
                    stat = asn1PE_e2ap_CriticalityDiagnostics (pctxt, pvalue->value.u._e2ap_E2connectionUpdateFailure_IEs_id_CriticalityDiagnostics);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_E2connectionUpdateFailure_IEs_UNDEF_:
            {
                if(0!=pvalue->value.u.extElem1){
                    openType.numocts = pvalue->value.u.extElem1->numocts;
                    openType.data = pvalue->value.u.extElem1->data;
                } else {
                    /* No extension element to encode */
                }
                encoded = FALSE;
                break;
            }

            default:
                encoded = FALSE;
                stat = RTERR_INVOPT;
                break;
        } 

        if(encoded){
            openType.numocts = (OSUINT32)pe_GetMsgLen(pctxt);
            openType.data = pDynamicEncodeBuffer = pctxt -> buffer.data;
        }
        rtxCopyContext(pctxt, &lctxt);

        if(stat == 0) {
            stat = pe_OpenType (pctxt, openType.numocts, openType.data);
        }
    #if 1
        if(encoded){//dungnm23 check lai nhe
            rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
        }
    #endif

    }

    if(stat!=0) return LOG_RTERR(pctxt, stat);  
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}

EXTERN int  asn1PD_e2ap_E2connectionUpdateFailure_protocolIEs_element (OSCTXT* pctxt, e2ap_E2connectionUpdateFailure_protocolIEs_element* pvalue){
    int stat =0;

    /*decode id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PD_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PD_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");

    {
        OSUINT32 openTypeLen;
        size_t bitStartOffset, bitLength;

        stat = pd_UnconsLength(pctxt, &openTypeLen);
        if(stat<0) return LOG_RTERR(pctxt, stat);
        else if(stat == RT_OK_FRAG){
            rtxErrAddStrParm(pctxt, "open type with fragment length");
            return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
        }
        bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
        bitLength = openTypeLen * 8;

        switch(pvalue->id){//dungnm23 check case lai nhe
        
            case ASN1V_e2ap_id_TransactionID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_E2connectionUpdateFailure_IEs_id_TransactionID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-TransactionID");
                pvalue->value.u._e2ap_E2connectionUpdateFailure_IEs_id_TransactionID 
                    = rtxMemAllocType(pctxt, e2ap_TransactionID);

                asn1Init_e2ap_TransactionID(pvalue->value.u._e2ap_E2connectionUpdateFailure_IEs_id_TransactionID);

                stat = asn1PD_e2ap_TransactionID (pctxt,
                        (e2ap_TransactionID*)pvalue->value.
                        u._e2ap_E2connectionUpdateFailure_IEs_id_TransactionID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_Cause:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_E2connectionUpdateFailure_IEs_id_Cause;
            RTXCTXTPUSHELEMNAME(pctxt, "id-Cause");
                pvalue->value.u._e2ap_E2connectionUpdateFailure_IEs_id_Cause 
                    = rtxMemAllocType(pctxt, e2ap_Cause);

                asn1Init_e2ap_Cause(pvalue->value.u._e2ap_E2connectionUpdateFailure_IEs_id_Cause);

                stat = asn1PD_e2ap_Cause (pctxt,
                        (e2ap_Cause*)pvalue->value.
                        u._e2ap_E2connectionUpdateFailure_IEs_id_Cause);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_TimeToWait:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_E2connectionUpdateFailure_IEs_id_TimeToWait;
            RTXCTXTPUSHELEMNAME(pctxt, "id-TimeToWait");
                pvalue->value.u._e2ap_E2connectionUpdateFailure_IEs_id_TimeToWait 
                    = rtxMemAllocType(pctxt, e2ap_TimeToWait);

                asn1Init_e2ap_TimeToWait(pvalue->value.u._e2ap_E2connectionUpdateFailure_IEs_id_TimeToWait);

                stat = asn1PD_e2ap_TimeToWait (pctxt,
                        (e2ap_TimeToWait*)pvalue->value.
                        u._e2ap_E2connectionUpdateFailure_IEs_id_TimeToWait);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_CriticalityDiagnostics:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_E2connectionUpdateFailure_IEs_id_CriticalityDiagnostics;
            RTXCTXTPUSHELEMNAME(pctxt, "id-CriticalityDiagnostics");
                pvalue->value.u._e2ap_E2connectionUpdateFailure_IEs_id_CriticalityDiagnostics 
                    = rtxMemAllocType(pctxt, e2ap_CriticalityDiagnostics);

                asn1Init_e2ap_CriticalityDiagnostics(pvalue->value.u._e2ap_E2connectionUpdateFailure_IEs_id_CriticalityDiagnostics);

                stat = asn1PD_e2ap_CriticalityDiagnostics (pctxt,
                        (e2ap_CriticalityDiagnostics*)pvalue->value.
                        u._e2ap_E2connectionUpdateFailure_IEs_id_CriticalityDiagnostics);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_E2connectionUpdateFailure_IEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*) rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
    }
    {
    size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
    size_t bitsConsumed = bitEndOffset-bitStartOffset;
    if(bitsConsumed<bitLength){
        stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
    }
    else stat =(bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
    }}
    if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}


int asn1Init_e2ap_E2connectionUpdateFailure_protocolIEs_element(e2ap_E2connectionUpdateFailure_protocolIEs_element* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    OSCRTLMEMSET (&pvalue->value, 0, sizeof(pvalue->value));
    return 0;
}


//-----> chuaw có template rtxFreeASN1OpenType

#if 0
void asn1Free_e2ap_E2connectionUpdateFailure_protocolIEs_element(OSCTXT* pctxt, e2ap_E2connectionUpdateFailure_protocolIEs_element* pvalue)
{
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_E2connectionUpdateFailure_IEs_id_id_TransactionID:
            // rtxFreeE2ap_TransactionID(pvalue->value.u._e2ap_E2connectionUpdateFailure_IEs_id_id_TransactionID);

            if(pvalue->value.i._e2ap_E2connectionUpdateFailure_id_TransactionID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_TransactionID(pctxt, pvalue->value.u._e2ap_E2connectionUpdateFailure_IEs_id_id_TransactionID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2connectionUpdateFailure_IEs_id_id_TransactionID);
           // pvalue->value.u._e2ap_E2connectionUpdateFailure_IEs_id_id_TransactionID = NULL;
           pvalue->value.u._e2ap_E2connectionUpdateFailure_IEs_id_TransactionID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_E2connectionUpdateFailure_IEs_id_id_Cause:
            // rtxFreeE2ap_Cause(pvalue->value.u._e2ap_E2connectionUpdateFailure_IEs_id_id_Cause);

            if(pvalue->value.i._e2ap_E2connectionUpdateFailure_id_Cause!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_Cause(pctxt, pvalue->value.u._e2ap_E2connectionUpdateFailure_IEs_id_id_Cause);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2connectionUpdateFailure_IEs_id_id_Cause);
           // pvalue->value.u._e2ap_E2connectionUpdateFailure_IEs_id_id_Cause = NULL;
           pvalue->value.u._e2ap_E2connectionUpdateFailure_IEs_id_Cause = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_E2connectionUpdateFailure_IEs_id_id_TimeToWait:
            // rtxFreeE2ap_TimeToWait(pvalue->value.u._e2ap_E2connectionUpdateFailure_IEs_id_id_TimeToWait);

            if(pvalue->value.i._e2ap_E2connectionUpdateFailure_id_TimeToWait!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_TimeToWait(pctxt, pvalue->value.u._e2ap_E2connectionUpdateFailure_IEs_id_id_TimeToWait);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2connectionUpdateFailure_IEs_id_id_TimeToWait);
           // pvalue->value.u._e2ap_E2connectionUpdateFailure_IEs_id_id_TimeToWait = NULL;
           pvalue->value.u._e2ap_E2connectionUpdateFailure_IEs_id_TimeToWait = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_E2connectionUpdateFailure_IEs_id_id_CriticalityDiagnostics:
            // rtxFreeE2ap_CriticalityDiagnostics(pvalue->value.u._e2ap_E2connectionUpdateFailure_IEs_id_id_CriticalityDiagnostics);

            if(pvalue->value.i._e2ap_E2connectionUpdateFailure_id_CriticalityDiagnostics!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_CriticalityDiagnostics(pctxt, pvalue->value.u._e2ap_E2connectionUpdateFailure_IEs_id_id_CriticalityDiagnostics);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2connectionUpdateFailure_IEs_id_id_CriticalityDiagnostics);
           // pvalue->value.u._e2ap_E2connectionUpdateFailure_IEs_id_id_CriticalityDiagnostics = NULL;
           pvalue->value.u._e2ap_E2connectionUpdateFailure_IEs_id_CriticalityDiagnostics = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_E2connectionUpdateFailure_IEs_UNDEF_:
            rtxFreeASN1OpenType(pvalue->value.u.extElem1);
            break;
        default:
            break;
    }
}

int asn1PrtToStr_e2ap_E2connectionUpdateFailure_protocolIEs_element(OSCTXT* pctxt, e2ap_E2connectionUpdateFailure_protocolIEs_element* pvalue)
{
    int stat =0;
    RTXCTXTPUSHELEMNAME(pctxt, "e2ap_E2connectionUpdateFailure_protocolIEs_element");

    /*print id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PrtToStr_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PrtToStr_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_E2connectionUpdateFailure_IEs_id_id_TransactionID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "TransactionID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_TransactionID (pctxt, pvalue->value.u._e2ap_E2connectionUpdateFailure_IEs_id_id_TransactionID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_E2connectionUpdateFailure_IEs_id_id_Cause:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "Cause");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_Cause (pctxt, pvalue->value.u._e2ap_E2connectionUpdateFailure_IEs_id_id_Cause);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_E2connectionUpdateFailure_IEs_id_id_TimeToWait:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "TimeToWait");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_TimeToWait (pctxt, pvalue->value.u._e2ap_E2connectionUpdateFailure_IEs_id_id_TimeToWait);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_E2connectionUpdateFailure_IEs_id_id_CriticalityDiagnostics:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "CriticalityDiagnostics");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_CriticalityDiagnostics (pctxt, pvalue->value.u._e2ap_E2connectionUpdateFailure_IEs_id_id_CriticalityDiagnostics);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_E2connectionUpdateFailure_IEs_UNDEF_:
            {
                rtxPLogMsg(pctxt, "Extension element present - raw data not printed.\n");
                break;
            }

            default:
                stat = RTERR_INVOPT;
                return LOG_RTERR(pctxt, stat);
        }
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);
}
#endif


int asn1PrtToStr_e2ap_E2connectionUpdateFailure_protocolIEs_element (const char * name,
 e2ap_E2connectionUpdateFailure_protocolIEs_element* pvalue, 
 char * buffer, OSSIZE bufSize){
    if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
        return -1;
    if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
        return -1;

    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_E2connectionUpdateFailure_IEs_id_TransactionID:
            if(asn1PrtToStr_e2ap_TransactionID("TransactionID", 
                    pvalue->value.u._e2ap_E2connectionUpdateFailure_IEs_id_TransactionID, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_E2connectionUpdateFailure_IEs_id_Cause:
            if(asn1PrtToStr_e2ap_Cause("Cause", 
                    pvalue->value.u._e2ap_E2connectionUpdateFailure_IEs_id_Cause, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_E2connectionUpdateFailure_IEs_id_TimeToWait:
            if(asn1PrtToStr_e2ap_TimeToWait("TimeToWait", 
                    pvalue->value.u._e2ap_E2connectionUpdateFailure_IEs_id_TimeToWait, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_E2connectionUpdateFailure_IEs_id_CriticalityDiagnostics:
            if(asn1PrtToStr_e2ap_CriticalityDiagnostics("CriticalityDiagnostics", 
                    pvalue->value.u._e2ap_E2connectionUpdateFailure_IEs_id_CriticalityDiagnostics, buffer, bufSize)<0)
                return -1;
            break;    
        default:
        if(0!=pvalue -> value.u.extElem1){
            rtPrintToStringIndent(buffer, bufSize);
            rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

        }
        }
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

    return 0;

 }

 void asn1Free_e2ap_E2connectionUpdateFailure_protocolIEs_element(OSCTXT* pctxt, e2ap_E2connectionUpdateFailure_protocolIEs_element* pvalue){
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_E2connectionUpdateFailure_IEs_id_TransactionID:
            if(pvalue->value.u._e2ap_E2connectionUpdateFailure_IEs_id_TransactionID!=NULL){
            asn1Free_e2ap_TransactionID(pctxt, pvalue->value.u._e2ap_E2connectionUpdateFailure_IEs_id_TransactionID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2connectionUpdateFailure_IEs_id_TransactionID);
            pvalue->value.u._e2ap_E2connectionUpdateFailure_IEs_id_TransactionID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_E2connectionUpdateFailure_IEs_id_Cause:
            if(pvalue->value.u._e2ap_E2connectionUpdateFailure_IEs_id_Cause!=NULL){
            asn1Free_e2ap_Cause(pctxt, pvalue->value.u._e2ap_E2connectionUpdateFailure_IEs_id_Cause);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2connectionUpdateFailure_IEs_id_Cause);
            pvalue->value.u._e2ap_E2connectionUpdateFailure_IEs_id_Cause = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_E2connectionUpdateFailure_IEs_id_TimeToWait:
            if(pvalue->value.u._e2ap_E2connectionUpdateFailure_IEs_id_TimeToWait!=NULL){
            asn1Free_e2ap_TimeToWait(pctxt, pvalue->value.u._e2ap_E2connectionUpdateFailure_IEs_id_TimeToWait);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2connectionUpdateFailure_IEs_id_TimeToWait);
            pvalue->value.u._e2ap_E2connectionUpdateFailure_IEs_id_TimeToWait = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_E2connectionUpdateFailure_IEs_id_CriticalityDiagnostics:
            if(pvalue->value.u._e2ap_E2connectionUpdateFailure_IEs_id_CriticalityDiagnostics!=NULL){
            asn1Free_e2ap_CriticalityDiagnostics(pctxt, pvalue->value.u._e2ap_E2connectionUpdateFailure_IEs_id_CriticalityDiagnostics);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2connectionUpdateFailure_IEs_id_CriticalityDiagnostics);
            pvalue->value.u._e2ap_E2connectionUpdateFailure_IEs_id_CriticalityDiagnostics = NULL;
            }
            break;
        default:
            break;


    }
 }

 

/*****************************************/
/*           E2connectionUpdateFailure                */
/*****************************************/
//2_container.c
/* 1. xxx_ProtocolIE -> mẫu cũ ở ie_big_msg */
EXTERN int asn1PE_e2ap_E2connectionUpdateFailure_protocolIEs (OSCTXT* pctxt, e2ap_E2connectionUpdateFailure_protocolIEs* pvalue)
{
    int stat =0;
    OSRTDListNode* pnode;
    OSUINT32 xx1;

    /*encode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pe_Length(pctxt, pvalue->count);
    if(stat<0) return LOG_RTERR(pctxt, stat);

    /*encode each element*/
    xx1 =0;
    for(pnode = pvalue->head; pnode != 0 && xx1<pvalue->count; pnode = pnode->next){
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE", xx1);
        stat = asn1PE_e2ap_E2connectionUpdateFailure_protocolIEs_element (pctxt, ((e2ap_E2connectionUpdateFailure_protocolIEs_element*)pnode->data));
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        xx1++;
        RTXCTXTPOPARRAYELEMNAME(pctxt);
    }

    return (stat);
}

EXTERN int  asn1PD_e2ap_E2connectionUpdateFailure_protocolIEs(OSCTXT* pctxt, e2ap_E2connectionUpdateFailure_protocolIEs* pvalue)
{
     int stat =0;
     OSRTDListNode* pnode;
     OSSIZE count =0;
     OSSIZE xx1=0;


     /*decode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pd_Length64(pctxt, &count); //tai sao lai 64
    if(stat!=0) return LOG_RTERR(pctxt, stat);

    /*decode each element*/
    rtxDListInit(pvalue);

    for(xx1=0; xx1 < count; xx1++){
        e2ap_E2connectionUpdateFailure_protocolIEs_element* pdata;
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE",xx1);

        if(pnode == NULL) return LOG_RTERR(pctxt, RTERR_NOMEM);

        asn1Init_e2ap_E2connectionUpdateFailure_protocolIEs_element(pdata);
        rtxDListAppendNode(pvalue, pnode);
        stat = asn1PD_e2ap_E2connectionUpdateFailure_protocolIEs_element (pctxt, pdata);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        RTXCTXTPOPARRAYELEMNAME(pctxt);

    }
    return (stat);
}


int asn1Init_e2ap_E2connectionUpdateFailure_protocolIEs(e2ap_E2connectionUpdateFailure_protocolIEs* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    rtxDListFastInit (pvalue);
    return 0;
}
#if 1 //ao that day
void asn1Free_e2ap_E2connectionUpdateFailure_protocolIEs(OSCTXT* pctxt, e2ap_E2connectionUpdateFailure_protocolIEs* pvalue)
{
    if(0==pvalue) return;   
    e2ap_E2connectionUpdateFailure_protocolIEs_element* pdata;
    OSRTDListNode* pnode=pvalue->head;
    while(0!=pnode){
        pdata = (e2ap_E2connectionUpdateFailure_protocolIEs_element*)pnode->data;
       // asn1Free_e2ap_E2connectionUpdateFailure_protocolIEs_element(pctxt, pdata);
        pnode = pnode->next;
    }
    rtxDListFreeAll(pctxt, pvalue);
}
#endif


EXTERN int asn1PrtToStr_e2ap_E2connectionUpdateFailure_protocolIEs(const char* name, e2ap_E2connectionUpdateFailure_protocolIEs* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_E2connectionUpdateFailure_protocolIEs_element* pdata0;
    OSRTDListNode* pnode0;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode0 = pvalue->head;  xx1 < pvalue->count && pnode0 != 0; pnode0 = pnode0->next, xx1++){
        pdata0 = (e2ap_E2connectionUpdateFailure_protocolIEs_element*)pnode0->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 0
        if(asn1PrtToStr_e2ap_E2connectionUpdateFailure_protocolIEs_element(nameBuf, pdata0, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}


/*2 . E2connectionUpdateFailure -> mẫu cũ ở seq_normal*/

int asn1PE_e2ap_E2connectionUpdateFailure (OSCTXT* pctxt, e2ap_E2connectionUpdateFailure* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "E2connectionUpdateFailure");
   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field protocolIEs - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
   stat = asn1PE_e2ap_E2connectionUpdateFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
   if(stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_E2connectionUpdateFailure (OSCTXT* pctxt, e2ap_E2connectionUpdateFailure* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME(pctxt, "E2connectionUpdateFailure");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field protocolIEs */
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
      stat = asn1PD_e2ap_E2connectionUpdateFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_E2connectionUpdateFailure (e2ap_E2connectionUpdateFailure* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_E2connectionUpdateFailure_protocolIEs(&pvalue->protocolIEs);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_E2connectionUpdateFailure (OSCTXT* pctxt, e2ap_E2connectionUpdateFailure* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_E2connectionUpdateFailure_protocolIEs(pctxt, &pvalue->protocolIEs);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_E2connectionUpdateFailure (const char* name, e2ap_E2connectionUpdateFailure* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }

   if(asn1PrtToStr_e2ap_E2connectionUpdateFailure_protocolIEs("protocolIEs", &pvalue->protocolIEs, buffer, bufSize) <0){
      return -1;
   }

   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           PLMN_Identity                */
/*****************************************/
//8 mau octet string
//type 8  mau la octet string size(n) mau la plmn_identity
EXTERN int asn1PE_e2ap_PLMN_Identity (OSCTXT* pctxt, e2ap_PLMN_Identity* pvalue){
   int stat = 0;
   RTXCTCXTPUSHTYPENAME (pctxt, "PLMN-Identity");
   PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(3), OSUINTCONST(3), 0, 0);

   stat = pe_OctetString(pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}
EXTERN int asn1PD_e2ap_PLMN_Identity (OSCTXT* pctxt, e2ap_PLMN_Identity* pvalue){
   int stat = 0;
   RTXCTCXTPUSHTYPENAME (pctxt, "PLMN-Identity");
   PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(3), OSUINTCONST(3), 0, 0);

   stat = pd_OctetString(pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}
//EXTERN int asn1PrtToStr_e2ap_PLMN_Identity (const char* name, e2ap_PLMN_Identity* pvalue, char* buffer, OSSIZE bufSize);
//EXTERN int asn1PrtToStrm_e2ap_PLMN_Identity (OSCTXT* pctxt, const char* name, const e2ap_PLMN_Identity* pvalue);
//EXTERN int asn1Copy_e2ap_PLMN_Identity (OSCTXT* pctxt, const e2ap_PLMN_Identity* pSrcValue, e2ap_PLMN_Identity* pDstValue);

int asn1Init_e2ap_PLMN_Identity (e2ap_PLMN_Identity* pvalue){
   if (pvalue == 0) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   return 0;
}
void asn1Free_e2ap_PLMN_Identity (OSCTXT* pctxt, e2ap_PLMN_Identity* pvalue){
   // No dynamic memory to free for fixed-size OCTET STRING
   return;
}
/* e2ap_GNB_ID_Choice.c */

/*****************************************/
/*           GNB_ID_Choice                */
/*****************************************/
// choice
// Các nội dung cần thiết cho template choice.c.j2
    // Nội dung của file .c cho primitive BIT STRING (SIZE(22..32))
    /* bitstring intergrate header file */
//metadata.parsed.primitive_id == 4



//type 4  mau la ul_coordination_info bitstring (a..b)

EXTERN int asn1PE_e2ap_GNB_ID_Choice_gnb_ID(OSCTXT* pctxt, e2ap_GNB_ID_Choice_gnb_ID* pvalue){
    int stat =0;
    //RTXCTXTPUSHTYPENAME(pctxt, "gnb-ID");
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(22), OSUINTCONST(32), 0, 0);
    stat = pe_BitString (pctxt, OS_MIN(pvalue->numbits, 32), pvalue->data);
    if(stat != 0) return LOG_RTERR (pctxt, stat);
    //RTXCTXTPOPTYPENAME(pctxt);
    return stat;
}
EXTERN int asn1PD_e2ap_GNB_ID_Choice_gnb_ID(OSCTXT* pctxt, e2ap_GNB_ID_Choice_gnb_ID* pvalue){
    int stat =0;
    //RTXCTXTPUSHTYPENAME(pctxt, "gnb-ID");
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(22), OSUINTCONST(32), 0, 0);
    stat = pd_BitString (pctxt, &pvalue->numbits, pvalue->data, sizeof(pvalue->data));
    if(stat != 0) return LOG_RTERR (pctxt, stat);
    //RTXCTXTPOPTYPENAME(pctxt);
    return stat;
}
//EXTERN int asn1PrtToStr_e2ap_GNB_ID_Choice_gnb_ID (const char* name, e2ap_GNB_ID_Choice_gnb_ID* pvalue, char* buffer, OSSIZE bufSize);
//EXTERN int asn1PrtToStrm_e2ap_GNB_ID_Choice_gnb_ID (OSCTXT* pctxt, const char* name, const e2ap_GNB_ID_Choice_gnb_ID* pvalue);
//EXTERN int asn1Copy_e2ap_GNB_ID_Choice_gnb_ID(OSCTXT* pctxt,const e2ap_GNB_ID_Choice_gnb_ID* pSrcValue,  e2ap_GNB_ID_Choice_gnb_ID* pDstValue);
EXTERN int asn1Init_e2ap_GNB_ID_Choice_gnb_ID(e2ap_GNB_ID_Choice_gnb_ID* pvalue){
    if(0==pvalue) return RTERR_NULLPTR;
    pvalue->numbits=0;
    return 0;
}
EXTERN void asn1Free_e2ap_GNB_ID_Choice_gnb_ID(OSCTXT* pctxt, e2ap_GNB_ID_Choice_gnb_ID* pvalue){
    // No dynamic memory to free for fixed-size BIT STRING
    return;
}


// Các phần còn lại của template choice.c.j2
// choice without extension

EXTERN int asn1PE_e2ap_GNB_ID_Choice (OSCTXT* pctxt, e2ap_GNB_ID_Choice* pvalue)
{
   int stat = 0;
   RTXCTXTPUSHTYPENAME (pctxt, "GNB-ID-Choice");
   RTXCTXTPUSHELEMNAME (pctxt, "t");
 
   stat = rtxEncBits (pctxt, pvalue->t - 1, 0);// kha nang la numbits
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   switch (pvalue->t) {
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "gnb-ID");
         //primitive BIT STRING - id = 4
         stat = asn1PE_e2ap_GNB_ID_Choice_gnb_ID (pctxt, &pvalue->u.gnb_ID); //bit string in choice type 4
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         RTXCTXTPOPELEMNAME (pctxt);
         break;
      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return (stat);
}

int asn1PD_e2ap_GNB_ID_Choice (OSCTXT* pctxt, e2ap_GNB_ID_Choice* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   RTXCTXTPUSHTYPENAME (pctxt, "GNB-ID-Choice");

 
   stat = rtxDecBits (pctxt, &ui, 0);// kha nang la numbits
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;
   //RTXCTXTPOPELEMNAME (pctxt);

   switch (ui) {
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "gnb-ID");
         pvalue->u.gnb_ID = rtxMemAllocType (pctxt, e2ap_GNB_ID_Choice_gnb_ID);
         if (pvalue->u.gnb_ID == NULL) return LOG_RTERR (pctxt, RTERR_NOMEM);
         //primitive BIT STRING
         asn1Init_e2ap_GNB_ID_Choice_gnb_ID(pvalue->u.gnb_ID);
         stat = asn1PD_e2ap_GNB_ID_Choice_gnb_ID (pctxt, pvalue->u.gnb_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         RTXCTXTPOPELEMNAME (pctxt);
         break;
      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return (stat);
}

int asn1PrtToStr_e2ap_GNB_ID_Choice (const char* name, e2ap_GNB_ID_Choice* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) return -1;
   

   switch (pvalue->t) {
      case T_e2ap_GNB_ID_Choice_gnb_ID:
         //primitive BIT STRING
         asn1PrtToStr_e2ap_GNB_ID_Choice_gnb_ID (pctxt, pvalue->u.gnb_ID);
         break;
      default:
         return RTERR_INVOPT;
   }

   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}

int asn1Init_e2ap_GNB_ID_Choice (e2ap_GNB_ID_Choice* pvalue)
{
   if (pvalue == 0) return RTERR_NULLPTR;
   pvalue->t = 0;
   OSRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
   return 0;
}


void asn1Free_e2ap_GNB_ID_Choice (OSCTXT* pctxt, e2ap_GNB_ID_Choice* pvalue)
{
   if (pvalue == 0) return;
   switch (pvalue->t) {
      case 0: //no choice nothing to free
         break;
      case 1:
         if (pvalue->u.gnb_ID) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.gnb_ID);
            pvalue->u.gnb_ID = 0;
         }
         break;
   }
}


/*****************************************/
/*           GlobalgNB-ID                */
/*****************************************/
//sequence normal
// Các nội dung cần thiết cho template seq_normal.c.j2

// Các phần còn lại của template seq_normal.c.j2
//contain extensition bit -> theo mau cua GlobalgNB-ID
int asn1PE_e2ap_GlobalgNB_ID (OSCTXT* pctxt, e2ap_GlobalgNB_ID* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "GlobalgNB-ID");

   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field plmn_id - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "plmn-id");
   stat = asn1PE_e2ap_PLMN_Identity (pctxt, pvalue->plmn_id);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /* encode field gnb_id - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "gnb-id");
   stat = asn1PE_e2ap_GNB_ID_Choice (pctxt, pvalue->gnb_id);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);



   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_GlobalgNB_ID (OSCTXT* pctxt, e2ap_GlobalgNB_ID* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME(pctxt, "GlobalgNB-ID");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field plmn_id */
   RTXCTXTPUSHELEMNAME(pctxt, "plmn-id");
      stat = asn1PD_e2ap_PLMN_Identity (pctxt, &pvalue->plmn_id);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field gnb_id */
   RTXCTXTPUSHELEMNAME(pctxt, "gnb-id");
      stat = asn1PD_e2ap_GNB_ID_Choice (pctxt, &pvalue->gnb_id);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_GlobalgNB_ID (e2ap_GlobalgNB_ID* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_PLMN_Identity (&pvalue->plmn_id);
   asn1Init_e2ap_GNB_ID_Choice (&pvalue->gnb_id);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_GlobalgNB_ID (OSCTXT* pctxt, e2ap_GlobalgNB_ID* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_PLMN_Identity (pctxt, &pvalue->plmn_id);
   asn1Free_e2ap_GNB_ID_Choice (pctxt, &pvalue->gnb_id);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_GlobalgNB_ID (const char* name, e2ap_GlobalgNB_ID* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }
   if(asn1PrtToStr_e2ap_PLMN_Identity ("plmn_id", &pvalue->plmn_id, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_GNB_ID_Choice ("gnb_id", &pvalue->gnb_id, buffer, bufSize) < 0)
   {
      return -1;
   }



   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/* e2ap_ENGNB_ID.c */

/*****************************************/
/*           ENGNB_ID                */
/*****************************************/
// choice
// Các nội dung cần thiết cho template choice.c.j2
    // Nội dung của file .c cho primitive BIT STRING (SIZE (22..32))
    /* bitstring intergrate header file */
//metadata.parsed.primitive_id == 4



//type 4  mau la ul_coordination_info bitstring (a..b)

EXTERN int asn1PE_e2ap_ENGNB_ID_gNB_ID(OSCTXT* pctxt, e2ap_ENGNB_ID_gNB_ID* pvalue){
    int stat =0;
    //RTXCTXTPUSHTYPENAME(pctxt, "gNB-ID");
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(22), OSUINTCONST(32), 0, 0);
    stat = pe_BitString (pctxt, OS_MIN(pvalue->numbits, 32), pvalue->data);
    if(stat != 0) return LOG_RTERR (pctxt, stat);
    //RTXCTXTPOPTYPENAME(pctxt);
    return stat;
}
EXTERN int asn1PD_e2ap_ENGNB_ID_gNB_ID(OSCTXT* pctxt, e2ap_ENGNB_ID_gNB_ID* pvalue){
    int stat =0;
    //RTXCTXTPUSHTYPENAME(pctxt, "gNB-ID");
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(22), OSUINTCONST(32), 0, 0);
    stat = pd_BitString (pctxt, &pvalue->numbits, pvalue->data, sizeof(pvalue->data));
    if(stat != 0) return LOG_RTERR (pctxt, stat);
    //RTXCTXTPOPTYPENAME(pctxt);
    return stat;
}
//EXTERN int asn1PrtToStr_e2ap_ENGNB_ID_gNB_ID (const char* name, e2ap_ENGNB_ID_gNB_ID* pvalue, char* buffer, OSSIZE bufSize);
//EXTERN int asn1PrtToStrm_e2ap_ENGNB_ID_gNB_ID (OSCTXT* pctxt, const char* name, const e2ap_ENGNB_ID_gNB_ID* pvalue);
//EXTERN int asn1Copy_e2ap_ENGNB_ID_gNB_ID(OSCTXT* pctxt,const e2ap_ENGNB_ID_gNB_ID* pSrcValue,  e2ap_ENGNB_ID_gNB_ID* pDstValue);
EXTERN int asn1Init_e2ap_ENGNB_ID_gNB_ID(e2ap_ENGNB_ID_gNB_ID* pvalue){
    if(0==pvalue) return RTERR_NULLPTR;
    pvalue->numbits=0;
    return 0;
}
EXTERN void asn1Free_e2ap_ENGNB_ID_gNB_ID(OSCTXT* pctxt, e2ap_ENGNB_ID_gNB_ID* pvalue){
    // No dynamic memory to free for fixed-size BIT STRING
    return;
}


// Các phần còn lại của template choice.c.j2
// choice without extension

EXTERN int asn1PE_e2ap_ENGNB_ID (OSCTXT* pctxt, e2ap_ENGNB_ID* pvalue)
{
   int stat = 0;
   RTXCTXTPUSHTYPENAME (pctxt, "ENGNB-ID");
   RTXCTXTPUSHELEMNAME (pctxt, "t");
 
   stat = rtxEncBits (pctxt, pvalue->t - 1, 0);// kha nang la numbits
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   switch (pvalue->t) {
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "gNB-ID");
         //primitive BIT STRING - id = 4
         stat = asn1PE_e2ap_ENGNB_ID_gNB_ID (pctxt, &pvalue->u.gNB_ID); //bit string in choice type 4
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         RTXCTXTPOPELEMNAME (pctxt);
         break;
      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return (stat);
}

int asn1PD_e2ap_ENGNB_ID (OSCTXT* pctxt, e2ap_ENGNB_ID* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   RTXCTXTPUSHTYPENAME (pctxt, "ENGNB-ID");

 
   stat = rtxDecBits (pctxt, &ui, 0);// kha nang la numbits
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;
   //RTXCTXTPOPELEMNAME (pctxt);

   switch (ui) {
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "gNB-ID");
         pvalue->u.gNB_ID = rtxMemAllocType (pctxt, e2ap_ENGNB_ID_gNB_ID);
         if (pvalue->u.gNB_ID == NULL) return LOG_RTERR (pctxt, RTERR_NOMEM);
         //primitive BIT STRING
         asn1Init_e2ap_ENGNB_ID_gNB_ID(pvalue->u.gNB_ID);
         stat = asn1PD_e2ap_ENGNB_ID_gNB_ID (pctxt, pvalue->u.gNB_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         RTXCTXTPOPELEMNAME (pctxt);
         break;
      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return (stat);
}

int asn1PrtToStr_e2ap_ENGNB_ID (const char* name, e2ap_ENGNB_ID* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) return -1;
   

   switch (pvalue->t) {
      case T_e2ap_ENGNB_ID_gNB_ID:
         //primitive BIT STRING
         asn1PrtToStr_e2ap_ENGNB_ID_gNB_ID (pctxt, pvalue->u.gNB_ID);
         break;
      default:
         return RTERR_INVOPT;
   }

   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}

int asn1Init_e2ap_ENGNB_ID (e2ap_ENGNB_ID* pvalue)
{
   if (pvalue == 0) return RTERR_NULLPTR;
   pvalue->t = 0;
   OSRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
   return 0;
}


void asn1Free_e2ap_ENGNB_ID (OSCTXT* pctxt, e2ap_ENGNB_ID* pvalue)
{
   if (pvalue == 0) return;
   switch (pvalue->t) {
      case 0: //no choice nothing to free
         break;
      case 1:
         if (pvalue->u.gNB_ID) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.gNB_ID);
            pvalue->u.gNB_ID = 0;
         }
         break;
   }
}


/*****************************************/
/*           GlobalenGNB-ID                */
/*****************************************/
//sequence normal
// Các nội dung cần thiết cho template seq_normal.c.j2

// Các phần còn lại của template seq_normal.c.j2
//contain extensition bit -> theo mau cua GlobalgNB-ID
int asn1PE_e2ap_GlobalenGNB_ID (OSCTXT* pctxt, e2ap_GlobalenGNB_ID* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "GlobalenGNB-ID");

   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field pLMN_Identity - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "pLMN-Identity");
   stat = asn1PE_e2ap_PLMN_Identity (pctxt, pvalue->pLMN_Identity);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /* encode field gNB_ID - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "gNB-ID");
   stat = asn1PE_e2ap_ENGNB_ID (pctxt, pvalue->gNB_ID);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);



   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_GlobalenGNB_ID (OSCTXT* pctxt, e2ap_GlobalenGNB_ID* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME(pctxt, "GlobalenGNB-ID");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field pLMN_Identity */
   RTXCTXTPUSHELEMNAME(pctxt, "pLMN-Identity");
      stat = asn1PD_e2ap_PLMN_Identity (pctxt, &pvalue->pLMN_Identity);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field gNB_ID */
   RTXCTXTPUSHELEMNAME(pctxt, "gNB-ID");
      stat = asn1PD_e2ap_ENGNB_ID (pctxt, &pvalue->gNB_ID);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_GlobalenGNB_ID (e2ap_GlobalenGNB_ID* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_PLMN_Identity (&pvalue->pLMN_Identity);
   asn1Init_e2ap_ENGNB_ID (&pvalue->gNB_ID);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_GlobalenGNB_ID (OSCTXT* pctxt, e2ap_GlobalenGNB_ID* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_PLMN_Identity (pctxt, &pvalue->pLMN_Identity);
   asn1Free_e2ap_ENGNB_ID (pctxt, &pvalue->gNB_ID);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_GlobalenGNB_ID (const char* name, e2ap_GlobalenGNB_ID* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }
   if(asn1PrtToStr_e2ap_PLMN_Identity ("pLMN_Identity", &pvalue->pLMN_Identity, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_ENGNB_ID ("gNB_ID", &pvalue->gNB_ID, buffer, bufSize) < 0)
   {
      return -1;
   }



   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           GNB_CU_UP_ID                */
/*****************************************/
//6 mau integer
// mau integer size(a...b) mau la procedurecode
EXTERN int asn1PE_e2ap_GNB_CU_UP_ID (OSCTXT* pctxt, e2ap_GNB_CU_UP_ID value){
    int stat = 0;
    RTXCTCXTPUSHTYPENAME (pctxt, "GNB-CU-UP-ID");
    stat = pe_ConsUnsigned (pctxt, value, 0, 68719476735);
    if (stat != 0) return LOG_RTERR (pctxt, stat);
    RTXCTXTPOPTYPENAME (pctxt);
    return stat;
}
EXTERN int asn1PD_e2ap_GNB_CU_UP_ID (OSCTXT* pctxt, e2ap_GNB_CU_UP_ID* pvalue){
    int stat = 0;
    RTXCTCXTPUSHTYPENAME (pctxt, "GNB-CU-UP-ID");
    if(pctxt->buffer.aligned){
        int stat2 = PD_BYTE_ALIGN(pctxt);
        if(stat2 != 0) return LOG_RTERR (pctxt, stat2);
    }
    stat = rtxDecBitsToByte(pctxt, pvalue, 0);
    if (stat != 0) return LOG_RTERR (pctxt, stat);
    RTXCTXTPOPTYPENAME (pctxt);
    return stat;
}
//EXTERN int asn1Print_e2ap_GNB_CU_UP_ID (const char* name, const e2ap_GNB_CU_UP_ID* pvalue);
//EXTERN int asn1PrtToStr_e2ap_GNB_CU_UP_ID (const char* name, e2ap_GNB_CU_UP_ID* pvalue, char* buffer, OSSIZE bufSize);
//EXTERN int asn1PrtToStrm_e2ap_GNB_CU_UP_ID (OSCTXT* pctxt, const char* name, const e2ap_GNB_CU_UP_ID* pvalue);
EXTERN int asn1Init_e2ap_GNB_CU_UP_ID (e2ap_GNB_CU_UP_ID* pvalue){
    //if (pvalue == 0) return RTERR_NULLPTR;
    //*pvalue = 0;
    return 0;
}
EXTERN int asn1Free_e2ap_GNB_CU_UP_ID (OSCTXT* pctxt, e2ap_GNB_CU_UP_ID* pvalue){
    // No dynamic memory to free for integer
    return 0;
}
/*****************************************/
/*           GNB_DU_ID                */
/*****************************************/
//6 mau integer
// mau integer size(a...b) mau la procedurecode
EXTERN int asn1PE_e2ap_GNB_DU_ID (OSCTXT* pctxt, e2ap_GNB_DU_ID value){
    int stat = 0;
    RTXCTCXTPUSHTYPENAME (pctxt, "GNB-DU-ID");
    stat = pe_ConsUnsigned (pctxt, value, 0, 68719476735);
    if (stat != 0) return LOG_RTERR (pctxt, stat);
    RTXCTXTPOPTYPENAME (pctxt);
    return stat;
}
EXTERN int asn1PD_e2ap_GNB_DU_ID (OSCTXT* pctxt, e2ap_GNB_DU_ID* pvalue){
    int stat = 0;
    RTXCTCXTPUSHTYPENAME (pctxt, "GNB-DU-ID");
    if(pctxt->buffer.aligned){
        int stat2 = PD_BYTE_ALIGN(pctxt);
        if(stat2 != 0) return LOG_RTERR (pctxt, stat2);
    }
    stat = rtxDecBitsToByte(pctxt, pvalue, 0);
    if (stat != 0) return LOG_RTERR (pctxt, stat);
    RTXCTXTPOPTYPENAME (pctxt);
    return stat;
}
//EXTERN int asn1Print_e2ap_GNB_DU_ID (const char* name, const e2ap_GNB_DU_ID* pvalue);
//EXTERN int asn1PrtToStr_e2ap_GNB_DU_ID (const char* name, e2ap_GNB_DU_ID* pvalue, char* buffer, OSSIZE bufSize);
//EXTERN int asn1PrtToStrm_e2ap_GNB_DU_ID (OSCTXT* pctxt, const char* name, const e2ap_GNB_DU_ID* pvalue);
EXTERN int asn1Init_e2ap_GNB_DU_ID (e2ap_GNB_DU_ID* pvalue){
    //if (pvalue == 0) return RTERR_NULLPTR;
    //*pvalue = 0;
    return 0;
}
EXTERN int asn1Free_e2ap_GNB_DU_ID (OSCTXT* pctxt, e2ap_GNB_DU_ID* pvalue){
    // No dynamic memory to free for integer
    return 0;
}

/*****************************************/
/*           GlobalE2node-gNB-ID                */
/*****************************************/
//sequence normal
// Các nội dung cần thiết cho template seq_normal.c.j2

// Các phần còn lại của template seq_normal.c.j2
//contain extensition bit -> theo mau cua GlobalgNB-ID
int asn1PE_e2ap_GlobalE2node_gNB_ID (OSCTXT* pctxt, e2ap_GlobalE2node_gNB_ID* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "GlobalE2node-gNB-ID");

   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);

   /*optional bit for field global_en_gNB_ID*/
   stat = rtxEncBit (pctxt, pvalue->m_global_en_gNB_IDPresent);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   /*optional bit for field gNB_CU_UP_ID*/
   stat = rtxEncBit (pctxt, pvalue->m_gNB_CU_UP_IDPresent);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   /*optional bit for field gNB_DU_ID*/
   stat = rtxEncBit (pctxt, pvalue->m_gNB_DU_IDPresent);
   if (stat != 0) return LOG_RTERR(pctxt, stat);

   /*encode root elements*/   
   /* encode field global_gNB_ID - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "global-gNB-ID");
   stat = asn1PE_e2ap_GlobalgNB_ID (pctxt, pvalue->global_gNB_ID);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /* encode field global_en_gNB_ID - id = -1*/  
   if (pvalue->m_global_en_gNB_IDPresent) {//OPTIONAL FIELD
   RTXCTXTPUSHELEMNAME(pctxt, "global-en-gNB-ID");
   stat = asn1PE_e2ap_GlobalenGNB_ID (pctxt, pvalue->global_en_gNB_ID);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   }

   /* encode field gNB_CU_UP_ID - id = -1*/  
   if (pvalue->m_gNB_CU_UP_IDPresent) {//OPTIONAL FIELD
   RTXCTXTPUSHELEMNAME(pctxt, "gNB-CU-UP-ID");
   stat = asn1PE_e2ap_GNB_CU_UP_ID (pctxt, pvalue->gNB_CU_UP_ID);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   }

   /* encode field gNB_DU_ID - id = -1*/  
   if (pvalue->m_gNB_DU_IDPresent) {//OPTIONAL FIELD
   RTXCTXTPUSHELEMNAME(pctxt, "gNB-DU-ID");
   stat = asn1PE_e2ap_GNB_DU_ID (pctxt, pvalue->gNB_DU_ID);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   }


   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_GlobalE2node_gNB_ID (OSCTXT* pctxt, e2ap_GlobalE2node_gNB_ID* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[4];

   RTXCTXTPUSHTYPENAME(pctxt, "GlobalE2node-gNB-ID");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 4; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field global_gNB_ID */
   RTXCTXTPUSHELEMNAME(pctxt, "global-gNB-ID");
      stat = asn1PD_e2ap_GlobalgNB_ID (pctxt, &pvalue->global_gNB_ID);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field global_en_gNB_ID */
   RTXCTXTPUSHELEMNAME(pctxt, "global-en-gNB-ID");
   if (optbits[0]) {
      pvalue->m_global_en_gNB_IDPresent = TRUE;
      stat = asn1PD_e2ap_GlobalenGNB_ID (pctxt, &pvalue->global_en_gNB_ID);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   } else {
      pvalue->m_global_en_gNB_IDPresent = FALSE;
   }
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field gNB_CU_UP_ID */
   RTXCTXTPUSHELEMNAME(pctxt, "gNB-CU-UP-ID");
   if (optbits[0]) {
      pvalue->m_gNB_CU_UP_IDPresent = TRUE;
      stat = asn1PD_e2ap_GNB_CU_UP_ID (pctxt, &pvalue->gNB_CU_UP_ID);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   } else {
      pvalue->m_gNB_CU_UP_IDPresent = FALSE;
   }
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field gNB_DU_ID */
   RTXCTXTPUSHELEMNAME(pctxt, "gNB-DU-ID");
   if (optbits[0]) {
      pvalue->m_gNB_DU_IDPresent = TRUE;
      stat = asn1PD_e2ap_GNB_DU_ID (pctxt, &pvalue->gNB_DU_ID);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   } else {
      pvalue->m_gNB_DU_IDPresent = FALSE;
   }
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_GlobalE2node_gNB_ID (e2ap_GlobalE2node_gNB_ID* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_GlobalgNB_ID (&pvalue->global_gNB_ID);
   asn1Init_e2ap_GlobalenGNB_ID (&pvalue->global_en_gNB_ID);
   asn1Init_e2ap_GNB_CU_UP_ID (&pvalue->gNB_CU_UP_ID);
   asn1Init_e2ap_GNB_DU_ID (&pvalue->gNB_DU_ID);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_GlobalE2node_gNB_ID (OSCTXT* pctxt, e2ap_GlobalE2node_gNB_ID* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_GlobalgNB_ID (pctxt, &pvalue->global_gNB_ID);
   asn1Free_e2ap_GlobalenGNB_ID (pctxt, &pvalue->global_en_gNB_ID);
   asn1Free_e2ap_GNB_CU_UP_ID (pctxt, &pvalue->gNB_CU_UP_ID);
   asn1Free_e2ap_GNB_DU_ID (pctxt, &pvalue->gNB_DU_ID);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_GlobalE2node_gNB_ID (const char* name, e2ap_GlobalE2node_gNB_ID* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }
   if(asn1PrtToStr_e2ap_GlobalgNB_ID ("global_gNB_ID", &pvalue->global_gNB_ID, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_GlobalenGNB_ID ("global_en_gNB_ID", &pvalue->global_en_gNB_ID, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_GNB_CU_UP_ID ("gNB_CU_UP_ID", &pvalue->gNB_CU_UP_ID, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_GNB_DU_ID ("gNB_DU_ID", &pvalue->gNB_DU_ID, buffer, bufSize) < 0)
   {
      return -1;
   }



   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}
/*****************************************/
/*           GlobalE2node-en-gNB-ID                */
/*****************************************/
//sequence normal
// Các nội dung cần thiết cho template seq_normal.c.j2

// Các phần còn lại của template seq_normal.c.j2
//contain extensition bit -> theo mau cua GlobalgNB-ID
int asn1PE_e2ap_GlobalE2node_en_gNB_ID (OSCTXT* pctxt, e2ap_GlobalE2node_en_gNB_ID* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "GlobalE2node-en-gNB-ID");

   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);

   /*optional bit for field en_gNB_CU_UP_ID*/
   stat = rtxEncBit (pctxt, pvalue->m_en_gNB_CU_UP_IDPresent);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   /*optional bit for field en_gNB_DU_ID*/
   stat = rtxEncBit (pctxt, pvalue->m_en_gNB_DU_IDPresent);
   if (stat != 0) return LOG_RTERR(pctxt, stat);

   /*encode root elements*/   
   /* encode field global_en_gNB_ID - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "global-en-gNB-ID");
   stat = asn1PE_e2ap_GlobalenGNB_ID (pctxt, pvalue->global_en_gNB_ID);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /* encode field en_gNB_CU_UP_ID - id = -1*/  
   if (pvalue->m_en_gNB_CU_UP_IDPresent) {//OPTIONAL FIELD
   RTXCTXTPUSHELEMNAME(pctxt, "en-gNB-CU-UP-ID");
   stat = asn1PE_e2ap_GNB_CU_UP_ID (pctxt, pvalue->en_gNB_CU_UP_ID);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   }

   /* encode field en_gNB_DU_ID - id = -1*/  
   if (pvalue->m_en_gNB_DU_IDPresent) {//OPTIONAL FIELD
   RTXCTXTPUSHELEMNAME(pctxt, "en-gNB-DU-ID");
   stat = asn1PE_e2ap_GNB_DU_ID (pctxt, pvalue->en_gNB_DU_ID);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   }


   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_GlobalE2node_en_gNB_ID (OSCTXT* pctxt, e2ap_GlobalE2node_en_gNB_ID* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[3];

   RTXCTXTPUSHTYPENAME(pctxt, "GlobalE2node-en-gNB-ID");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field global_en_gNB_ID */
   RTXCTXTPUSHELEMNAME(pctxt, "global-en-gNB-ID");
      stat = asn1PD_e2ap_GlobalenGNB_ID (pctxt, &pvalue->global_en_gNB_ID);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field en_gNB_CU_UP_ID */
   RTXCTXTPUSHELEMNAME(pctxt, "en-gNB-CU-UP-ID");
   if (optbits[0]) {
      pvalue->m_en_gNB_CU_UP_IDPresent = TRUE;
      stat = asn1PD_e2ap_GNB_CU_UP_ID (pctxt, &pvalue->en_gNB_CU_UP_ID);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   } else {
      pvalue->m_en_gNB_CU_UP_IDPresent = FALSE;
   }
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field en_gNB_DU_ID */
   RTXCTXTPUSHELEMNAME(pctxt, "en-gNB-DU-ID");
   if (optbits[0]) {
      pvalue->m_en_gNB_DU_IDPresent = TRUE;
      stat = asn1PD_e2ap_GNB_DU_ID (pctxt, &pvalue->en_gNB_DU_ID);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   } else {
      pvalue->m_en_gNB_DU_IDPresent = FALSE;
   }
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_GlobalE2node_en_gNB_ID (e2ap_GlobalE2node_en_gNB_ID* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_GlobalenGNB_ID (&pvalue->global_en_gNB_ID);
   asn1Init_e2ap_GNB_CU_UP_ID (&pvalue->en_gNB_CU_UP_ID);
   asn1Init_e2ap_GNB_DU_ID (&pvalue->en_gNB_DU_ID);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_GlobalE2node_en_gNB_ID (OSCTXT* pctxt, e2ap_GlobalE2node_en_gNB_ID* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_GlobalenGNB_ID (pctxt, &pvalue->global_en_gNB_ID);
   asn1Free_e2ap_GNB_CU_UP_ID (pctxt, &pvalue->en_gNB_CU_UP_ID);
   asn1Free_e2ap_GNB_DU_ID (pctxt, &pvalue->en_gNB_DU_ID);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_GlobalE2node_en_gNB_ID (const char* name, e2ap_GlobalE2node_en_gNB_ID* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }
   if(asn1PrtToStr_e2ap_GlobalenGNB_ID ("global_en_gNB_ID", &pvalue->global_en_gNB_ID, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_GNB_CU_UP_ID ("en_gNB_CU_UP_ID", &pvalue->en_gNB_CU_UP_ID, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_GNB_DU_ID ("en_gNB_DU_ID", &pvalue->en_gNB_DU_ID, buffer, bufSize) < 0)
   {
      return -1;
   }



   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/* e2ap_ENB_ID_Choice.c */

/*****************************************/
/*           ENB_ID_Choice                */
/*****************************************/
// choice
// Các nội dung cần thiết cho template choice.c.j2
    // Nội dung của file .c cho primitive BIT STRING (SIZE(20))
    /* bitstring intergrate header file */
//metadata.parsed.primitive_id == 3

//mau rnti_full ben xn  bitstring (n)

EXTERN int asn1PE_e2ap_ENB_ID_Choice_enb_ID_macro(OSCTXT* pctxt, e2ap_ENB_ID_Choice_enb_ID_macro* pvalue){
    int stat =0;
    //RTXCTXTPUSHTYPENAME(pctxt, "enb-ID-macro");
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(20), OSUINTCONST(20), 0, 0);
    stat = pe_BitString (pctxt, OS_MIN(pvalue->numbits, 20), pvalue->data);
    if(stat != 0) return LOG_RTERR (pctxt, stat);
    //RTXCTXTPOPTYPENAME(pctxt);
    return stat;
}
EXTERN int asn1PD_e2ap_ENB_ID_Choice_enb_ID_macro(OSCTXT* pctxt, e2ap_ENB_ID_Choice_enb_ID_macro* pvalue){
    int stat =0;
    //RTXCTXTPUSHTYPENAME(pctxt, "enb-ID-macro");
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(20), OSUINTCONST(20), 0, 0);
    stat = pd_BitString (pctxt, &pvalue->numbits, pvalue->data, sizeof(pvalue->data));
    if(stat != 0) return LOG_RTERR (pctxt, stat);
    //RTXCTXTPOPTYPENAME(pctxt);
    return stat;
}
EXTERN int asn1PrtToStr_e2ap_ENB_ID_Choice_enb_ID_macro (const char* name, e2ap_ENB_ID_Choice_enb_ID_macro* pvalue, char* buffer, OSSIZE bufSize){
    if(rtPrintToStringIndent(buffer, bufSize) < 0) return -1;
    if(rtPrintToStringBitStrBraceText (name, OS_MIN(pvalue->numbits, 20), pvalue->data, buffer, bufSize) < 0) return -1;
    return 0;
}
//EXTERN int asn1PrtToStrm_e2ap_ENB_ID_Choice_enb_ID_macro (OSCTXT* pctxt, const char* name, const e2ap_ENB_ID_Choice_enb_ID_macro* pvalue);
//EXTERN int asn1Copy_e2ap_ENB_ID_Choice_enb_ID_macro(OSCTXT* pctxt,const e2ap_ENB_ID_Choice_enb_ID_macro* pSrcValue,  e2ap_ENB_ID_Choice_enb_ID_macro* pDstValue);
EXTERN int asn1Init_e2ap_ENB_ID_Choice_enb_ID_macro(e2ap_ENB_ID_Choice_enb_ID_macro* pvalue){
    if(0==pvalue) return RTERR_NULLPTR;
    pvalue->numbits=0;
    return 0;
}
EXTERN void asn1Free_e2ap_ENB_ID_Choice_enb_ID_macro(OSCTXT* pctxt, e2ap_ENB_ID_Choice_enb_ID_macro* pvalue){
    // No dynamic memory to free for fixed-size BIT STRING
    return;
}



    // Nội dung của file .c cho primitive BIT STRING (SIZE(18))
    /* bitstring intergrate header file */
//metadata.parsed.primitive_id == 3

//mau rnti_full ben xn  bitstring (n)

EXTERN int asn1PE_e2ap_ENB_ID_Choice_enb_ID_shortmacro(OSCTXT* pctxt, e2ap_ENB_ID_Choice_enb_ID_shortmacro* pvalue){
    int stat =0;
    //RTXCTXTPUSHTYPENAME(pctxt, "enb-ID-shortmacro");
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(18), OSUINTCONST(18), 0, 0);
    stat = pe_BitString (pctxt, OS_MIN(pvalue->numbits, 18), pvalue->data);
    if(stat != 0) return LOG_RTERR (pctxt, stat);
    //RTXCTXTPOPTYPENAME(pctxt);
    return stat;
}
EXTERN int asn1PD_e2ap_ENB_ID_Choice_enb_ID_shortmacro(OSCTXT* pctxt, e2ap_ENB_ID_Choice_enb_ID_shortmacro* pvalue){
    int stat =0;
    //RTXCTXTPUSHTYPENAME(pctxt, "enb-ID-shortmacro");
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(18), OSUINTCONST(18), 0, 0);
    stat = pd_BitString (pctxt, &pvalue->numbits, pvalue->data, sizeof(pvalue->data));
    if(stat != 0) return LOG_RTERR (pctxt, stat);
    //RTXCTXTPOPTYPENAME(pctxt);
    return stat;
}
EXTERN int asn1PrtToStr_e2ap_ENB_ID_Choice_enb_ID_shortmacro (const char* name, e2ap_ENB_ID_Choice_enb_ID_shortmacro* pvalue, char* buffer, OSSIZE bufSize){
    if(rtPrintToStringIndent(buffer, bufSize) < 0) return -1;
    if(rtPrintToStringBitStrBraceText (name, OS_MIN(pvalue->numbits, 18), pvalue->data, buffer, bufSize) < 0) return -1;
    return 0;
}
//EXTERN int asn1PrtToStrm_e2ap_ENB_ID_Choice_enb_ID_shortmacro (OSCTXT* pctxt, const char* name, const e2ap_ENB_ID_Choice_enb_ID_shortmacro* pvalue);
//EXTERN int asn1Copy_e2ap_ENB_ID_Choice_enb_ID_shortmacro(OSCTXT* pctxt,const e2ap_ENB_ID_Choice_enb_ID_shortmacro* pSrcValue,  e2ap_ENB_ID_Choice_enb_ID_shortmacro* pDstValue);
EXTERN int asn1Init_e2ap_ENB_ID_Choice_enb_ID_shortmacro(e2ap_ENB_ID_Choice_enb_ID_shortmacro* pvalue){
    if(0==pvalue) return RTERR_NULLPTR;
    pvalue->numbits=0;
    return 0;
}
EXTERN void asn1Free_e2ap_ENB_ID_Choice_enb_ID_shortmacro(OSCTXT* pctxt, e2ap_ENB_ID_Choice_enb_ID_shortmacro* pvalue){
    // No dynamic memory to free for fixed-size BIT STRING
    return;
}



    // Nội dung của file .c cho primitive BIT STRING (SIZE(21))
    /* bitstring intergrate header file */
//metadata.parsed.primitive_id == 3

//mau rnti_full ben xn  bitstring (n)

EXTERN int asn1PE_e2ap_ENB_ID_Choice_enb_ID_longmacro(OSCTXT* pctxt, e2ap_ENB_ID_Choice_enb_ID_longmacro* pvalue){
    int stat =0;
    //RTXCTXTPUSHTYPENAME(pctxt, "enb-ID-longmacro");
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(21), OSUINTCONST(21), 0, 0);
    stat = pe_BitString (pctxt, OS_MIN(pvalue->numbits, 21), pvalue->data);
    if(stat != 0) return LOG_RTERR (pctxt, stat);
    //RTXCTXTPOPTYPENAME(pctxt);
    return stat;
}
EXTERN int asn1PD_e2ap_ENB_ID_Choice_enb_ID_longmacro(OSCTXT* pctxt, e2ap_ENB_ID_Choice_enb_ID_longmacro* pvalue){
    int stat =0;
    //RTXCTXTPUSHTYPENAME(pctxt, "enb-ID-longmacro");
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(21), OSUINTCONST(21), 0, 0);
    stat = pd_BitString (pctxt, &pvalue->numbits, pvalue->data, sizeof(pvalue->data));
    if(stat != 0) return LOG_RTERR (pctxt, stat);
    //RTXCTXTPOPTYPENAME(pctxt);
    return stat;
}
EXTERN int asn1PrtToStr_e2ap_ENB_ID_Choice_enb_ID_longmacro (const char* name, e2ap_ENB_ID_Choice_enb_ID_longmacro* pvalue, char* buffer, OSSIZE bufSize){
    if(rtPrintToStringIndent(buffer, bufSize) < 0) return -1;
    if(rtPrintToStringBitStrBraceText (name, OS_MIN(pvalue->numbits, 21), pvalue->data, buffer, bufSize) < 0) return -1;
    return 0;
}
//EXTERN int asn1PrtToStrm_e2ap_ENB_ID_Choice_enb_ID_longmacro (OSCTXT* pctxt, const char* name, const e2ap_ENB_ID_Choice_enb_ID_longmacro* pvalue);
//EXTERN int asn1Copy_e2ap_ENB_ID_Choice_enb_ID_longmacro(OSCTXT* pctxt,const e2ap_ENB_ID_Choice_enb_ID_longmacro* pSrcValue,  e2ap_ENB_ID_Choice_enb_ID_longmacro* pDstValue);
EXTERN int asn1Init_e2ap_ENB_ID_Choice_enb_ID_longmacro(e2ap_ENB_ID_Choice_enb_ID_longmacro* pvalue){
    if(0==pvalue) return RTERR_NULLPTR;
    pvalue->numbits=0;
    return 0;
}
EXTERN void asn1Free_e2ap_ENB_ID_Choice_enb_ID_longmacro(OSCTXT* pctxt, e2ap_ENB_ID_Choice_enb_ID_longmacro* pvalue){
    // No dynamic memory to free for fixed-size BIT STRING
    return;
}




// Các phần còn lại của template choice.c.j2
// choice without extension

EXTERN int asn1PE_e2ap_ENB_ID_Choice (OSCTXT* pctxt, e2ap_ENB_ID_Choice* pvalue)
{
   int stat = 0;
   RTXCTXTPUSHTYPENAME (pctxt, "ENB-ID-Choice");
   RTXCTXTPUSHELEMNAME (pctxt, "t");
 
   stat = rtxEncBits (pctxt, pvalue->t - 1, 2);// kha nang la numbits
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   switch (pvalue->t) {
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "enb-ID-macro");
         //primitive BIT STRING - id = 3
         stat = asn1PE_e2ap_ENB_ID_Choice_enb_ID_macro (pctxt, &pvalue->u.enb_ID_macro); //bit string in choice type 3
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         RTXCTXTPOPELEMNAME (pctxt);
         break;
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "enb-ID-shortmacro");
         //primitive BIT STRING - id = 3
         stat = asn1PE_e2ap_ENB_ID_Choice_enb_ID_shortmacro (pctxt, &pvalue->u.enb_ID_shortmacro); //bit string in choice type 3
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         RTXCTXTPOPELEMNAME (pctxt);
         break;
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "enb-ID-longmacro");
         //primitive BIT STRING - id = 3
         stat = asn1PE_e2ap_ENB_ID_Choice_enb_ID_longmacro (pctxt, &pvalue->u.enb_ID_longmacro); //bit string in choice type 3
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         RTXCTXTPOPELEMNAME (pctxt);
         break;
      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return (stat);
}

int asn1PD_e2ap_ENB_ID_Choice (OSCTXT* pctxt, e2ap_ENB_ID_Choice* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   RTXCTXTPUSHTYPENAME (pctxt, "ENB-ID-Choice");

 
   stat = rtxDecBits (pctxt, &ui, 2);// kha nang la numbits
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;
   //RTXCTXTPOPELEMNAME (pctxt);

   switch (ui) {
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "enb-ID-macro");
         pvalue->u.enb_ID_macro = rtxMemAllocType (pctxt, e2ap_ENB_ID_Choice_enb_ID_macro);
         if (pvalue->u.enb_ID_macro == NULL) return LOG_RTERR (pctxt, RTERR_NOMEM);
         //primitive BIT STRING
         asn1Init_e2ap_ENB_ID_Choice_enb_ID_macro(pvalue->u.enb_ID_macro);
         stat = asn1PD_e2ap_ENB_ID_Choice_enb_ID_macro (pctxt, pvalue->u.enb_ID_macro);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         RTXCTXTPOPELEMNAME (pctxt);
         break;
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "enb-ID-shortmacro");
         pvalue->u.enb_ID_shortmacro = rtxMemAllocType (pctxt, e2ap_ENB_ID_Choice_enb_ID_shortmacro);
         if (pvalue->u.enb_ID_shortmacro == NULL) return LOG_RTERR (pctxt, RTERR_NOMEM);
         //primitive BIT STRING
         asn1Init_e2ap_ENB_ID_Choice_enb_ID_shortmacro(pvalue->u.enb_ID_shortmacro);
         stat = asn1PD_e2ap_ENB_ID_Choice_enb_ID_shortmacro (pctxt, pvalue->u.enb_ID_shortmacro);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         RTXCTXTPOPELEMNAME (pctxt);
         break;
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "enb-ID-longmacro");
         pvalue->u.enb_ID_longmacro = rtxMemAllocType (pctxt, e2ap_ENB_ID_Choice_enb_ID_longmacro);
         if (pvalue->u.enb_ID_longmacro == NULL) return LOG_RTERR (pctxt, RTERR_NOMEM);
         //primitive BIT STRING
         asn1Init_e2ap_ENB_ID_Choice_enb_ID_longmacro(pvalue->u.enb_ID_longmacro);
         stat = asn1PD_e2ap_ENB_ID_Choice_enb_ID_longmacro (pctxt, pvalue->u.enb_ID_longmacro);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         RTXCTXTPOPELEMNAME (pctxt);
         break;
      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return (stat);
}

int asn1PrtToStr_e2ap_ENB_ID_Choice (const char* name, e2ap_ENB_ID_Choice* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) return -1;
   

   switch (pvalue->t) {
      case T_e2ap_ENB_ID_Choice_enb_ID_macro:
         //primitive BIT STRING
         asn1PrtToStr_e2ap_ENB_ID_Choice_enb_ID_macro (pctxt, pvalue->u.enb_ID_macro);
         break;
      case T_e2ap_ENB_ID_Choice_enb_ID_shortmacro:
         //primitive BIT STRING
         asn1PrtToStr_e2ap_ENB_ID_Choice_enb_ID_shortmacro (pctxt, pvalue->u.enb_ID_shortmacro);
         break;
      case T_e2ap_ENB_ID_Choice_enb_ID_longmacro:
         //primitive BIT STRING
         asn1PrtToStr_e2ap_ENB_ID_Choice_enb_ID_longmacro (pctxt, pvalue->u.enb_ID_longmacro);
         break;
      default:
         return RTERR_INVOPT;
   }

   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}

int asn1Init_e2ap_ENB_ID_Choice (e2ap_ENB_ID_Choice* pvalue)
{
   if (pvalue == 0) return RTERR_NULLPTR;
   pvalue->t = 0;
   OSRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
   return 0;
}


void asn1Free_e2ap_ENB_ID_Choice (OSCTXT* pctxt, e2ap_ENB_ID_Choice* pvalue)
{
   if (pvalue == 0) return;
   switch (pvalue->t) {
      case 0: //no choice nothing to free
         break;
      case 1:
         if (pvalue->u.enb_ID_macro) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.enb_ID_macro);
            pvalue->u.enb_ID_macro = 0;
         }
         break;
      case 2:
         if (pvalue->u.enb_ID_shortmacro) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.enb_ID_shortmacro);
            pvalue->u.enb_ID_shortmacro = 0;
         }
         break;
      case 3:
         if (pvalue->u.enb_ID_longmacro) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.enb_ID_longmacro);
            pvalue->u.enb_ID_longmacro = 0;
         }
         break;
   }
}


/*****************************************/
/*           GlobalngeNB-ID                */
/*****************************************/
//sequence normal
// Các nội dung cần thiết cho template seq_normal.c.j2

// Các phần còn lại của template seq_normal.c.j2
//contain extensition bit -> theo mau cua GlobalgNB-ID
int asn1PE_e2ap_GlobalngeNB_ID (OSCTXT* pctxt, e2ap_GlobalngeNB_ID* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "GlobalngeNB-ID");

   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field plmn_id - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "plmn-id");
   stat = asn1PE_e2ap_PLMN_Identity (pctxt, pvalue->plmn_id);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /* encode field enb_id - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "enb-id");
   stat = asn1PE_e2ap_ENB_ID_Choice (pctxt, pvalue->enb_id);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);



   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_GlobalngeNB_ID (OSCTXT* pctxt, e2ap_GlobalngeNB_ID* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME(pctxt, "GlobalngeNB-ID");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field plmn_id */
   RTXCTXTPUSHELEMNAME(pctxt, "plmn-id");
      stat = asn1PD_e2ap_PLMN_Identity (pctxt, &pvalue->plmn_id);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field enb_id */
   RTXCTXTPUSHELEMNAME(pctxt, "enb-id");
      stat = asn1PD_e2ap_ENB_ID_Choice (pctxt, &pvalue->enb_id);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_GlobalngeNB_ID (e2ap_GlobalngeNB_ID* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_PLMN_Identity (&pvalue->plmn_id);
   asn1Init_e2ap_ENB_ID_Choice (&pvalue->enb_id);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_GlobalngeNB_ID (OSCTXT* pctxt, e2ap_GlobalngeNB_ID* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_PLMN_Identity (pctxt, &pvalue->plmn_id);
   asn1Free_e2ap_ENB_ID_Choice (pctxt, &pvalue->enb_id);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_GlobalngeNB_ID (const char* name, e2ap_GlobalngeNB_ID* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }
   if(asn1PrtToStr_e2ap_PLMN_Identity ("plmn_id", &pvalue->plmn_id, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_ENB_ID_Choice ("enb_id", &pvalue->enb_id, buffer, bufSize) < 0)
   {
      return -1;
   }



   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/* e2ap_ENB_ID.c */

/*****************************************/
/*           ENB_ID                */
/*****************************************/
// choice
// Các nội dung cần thiết cho template choice.c.j2
    // Nội dung của file .c cho primitive BIT STRING (SIZE (20))
    /* bitstring intergrate header file */
//metadata.parsed.primitive_id == 3

//mau rnti_full ben xn  bitstring (n)

EXTERN int asn1PE_e2ap_ENB_ID_macro_eNB_ID(OSCTXT* pctxt, e2ap_ENB_ID_macro_eNB_ID* pvalue){
    int stat =0;
    //RTXCTXTPUSHTYPENAME(pctxt, "macro-eNB-ID");
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(20), OSUINTCONST(20), 0, 0);
    stat = pe_BitString (pctxt, OS_MIN(pvalue->numbits, 20), pvalue->data);
    if(stat != 0) return LOG_RTERR (pctxt, stat);
    //RTXCTXTPOPTYPENAME(pctxt);
    return stat;
}
EXTERN int asn1PD_e2ap_ENB_ID_macro_eNB_ID(OSCTXT* pctxt, e2ap_ENB_ID_macro_eNB_ID* pvalue){
    int stat =0;
    //RTXCTXTPUSHTYPENAME(pctxt, "macro-eNB-ID");
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(20), OSUINTCONST(20), 0, 0);
    stat = pd_BitString (pctxt, &pvalue->numbits, pvalue->data, sizeof(pvalue->data));
    if(stat != 0) return LOG_RTERR (pctxt, stat);
    //RTXCTXTPOPTYPENAME(pctxt);
    return stat;
}
EXTERN int asn1PrtToStr_e2ap_ENB_ID_macro_eNB_ID (const char* name, e2ap_ENB_ID_macro_eNB_ID* pvalue, char* buffer, OSSIZE bufSize){
    if(rtPrintToStringIndent(buffer, bufSize) < 0) return -1;
    if(rtPrintToStringBitStrBraceText (name, OS_MIN(pvalue->numbits, 20), pvalue->data, buffer, bufSize) < 0) return -1;
    return 0;
}
//EXTERN int asn1PrtToStrm_e2ap_ENB_ID_macro_eNB_ID (OSCTXT* pctxt, const char* name, const e2ap_ENB_ID_macro_eNB_ID* pvalue);
//EXTERN int asn1Copy_e2ap_ENB_ID_macro_eNB_ID(OSCTXT* pctxt,const e2ap_ENB_ID_macro_eNB_ID* pSrcValue,  e2ap_ENB_ID_macro_eNB_ID* pDstValue);
EXTERN int asn1Init_e2ap_ENB_ID_macro_eNB_ID(e2ap_ENB_ID_macro_eNB_ID* pvalue){
    if(0==pvalue) return RTERR_NULLPTR;
    pvalue->numbits=0;
    return 0;
}
EXTERN void asn1Free_e2ap_ENB_ID_macro_eNB_ID(OSCTXT* pctxt, e2ap_ENB_ID_macro_eNB_ID* pvalue){
    // No dynamic memory to free for fixed-size BIT STRING
    return;
}



    // Nội dung của file .c cho primitive BIT STRING (SIZE (28))
    /* bitstring intergrate header file */
//metadata.parsed.primitive_id == 3

//mau rnti_full ben xn  bitstring (n)

EXTERN int asn1PE_e2ap_ENB_ID_home_eNB_ID(OSCTXT* pctxt, e2ap_ENB_ID_home_eNB_ID* pvalue){
    int stat =0;
    //RTXCTXTPUSHTYPENAME(pctxt, "home-eNB-ID");
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(28), OSUINTCONST(28), 0, 0);
    stat = pe_BitString (pctxt, OS_MIN(pvalue->numbits, 28), pvalue->data);
    if(stat != 0) return LOG_RTERR (pctxt, stat);
    //RTXCTXTPOPTYPENAME(pctxt);
    return stat;
}
EXTERN int asn1PD_e2ap_ENB_ID_home_eNB_ID(OSCTXT* pctxt, e2ap_ENB_ID_home_eNB_ID* pvalue){
    int stat =0;
    //RTXCTXTPUSHTYPENAME(pctxt, "home-eNB-ID");
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(28), OSUINTCONST(28), 0, 0);
    stat = pd_BitString (pctxt, &pvalue->numbits, pvalue->data, sizeof(pvalue->data));
    if(stat != 0) return LOG_RTERR (pctxt, stat);
    //RTXCTXTPOPTYPENAME(pctxt);
    return stat;
}
EXTERN int asn1PrtToStr_e2ap_ENB_ID_home_eNB_ID (const char* name, e2ap_ENB_ID_home_eNB_ID* pvalue, char* buffer, OSSIZE bufSize){
    if(rtPrintToStringIndent(buffer, bufSize) < 0) return -1;
    if(rtPrintToStringBitStrBraceText (name, OS_MIN(pvalue->numbits, 28), pvalue->data, buffer, bufSize) < 0) return -1;
    return 0;
}
//EXTERN int asn1PrtToStrm_e2ap_ENB_ID_home_eNB_ID (OSCTXT* pctxt, const char* name, const e2ap_ENB_ID_home_eNB_ID* pvalue);
//EXTERN int asn1Copy_e2ap_ENB_ID_home_eNB_ID(OSCTXT* pctxt,const e2ap_ENB_ID_home_eNB_ID* pSrcValue,  e2ap_ENB_ID_home_eNB_ID* pDstValue);
EXTERN int asn1Init_e2ap_ENB_ID_home_eNB_ID(e2ap_ENB_ID_home_eNB_ID* pvalue){
    if(0==pvalue) return RTERR_NULLPTR;
    pvalue->numbits=0;
    return 0;
}
EXTERN void asn1Free_e2ap_ENB_ID_home_eNB_ID(OSCTXT* pctxt, e2ap_ENB_ID_home_eNB_ID* pvalue){
    // No dynamic memory to free for fixed-size BIT STRING
    return;
}



    // Nội dung của file .c cho primitive BIT STRING (SIZE(18))
    /* bitstring intergrate header file */
//metadata.parsed.primitive_id == 3

//mau rnti_full ben xn  bitstring (n)

EXTERN int asn1PE_e2ap_ENB_ID_short_Macro_eNB_ID(OSCTXT* pctxt, e2ap_ENB_ID_short_Macro_eNB_ID* pvalue){
    int stat =0;
    //RTXCTXTPUSHTYPENAME(pctxt, "short-Macro-eNB-ID");
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(18), OSUINTCONST(18), 0, 0);
    stat = pe_BitString (pctxt, OS_MIN(pvalue->numbits, 18), pvalue->data);
    if(stat != 0) return LOG_RTERR (pctxt, stat);
    //RTXCTXTPOPTYPENAME(pctxt);
    return stat;
}
EXTERN int asn1PD_e2ap_ENB_ID_short_Macro_eNB_ID(OSCTXT* pctxt, e2ap_ENB_ID_short_Macro_eNB_ID* pvalue){
    int stat =0;
    //RTXCTXTPUSHTYPENAME(pctxt, "short-Macro-eNB-ID");
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(18), OSUINTCONST(18), 0, 0);
    stat = pd_BitString (pctxt, &pvalue->numbits, pvalue->data, sizeof(pvalue->data));
    if(stat != 0) return LOG_RTERR (pctxt, stat);
    //RTXCTXTPOPTYPENAME(pctxt);
    return stat;
}
EXTERN int asn1PrtToStr_e2ap_ENB_ID_short_Macro_eNB_ID (const char* name, e2ap_ENB_ID_short_Macro_eNB_ID* pvalue, char* buffer, OSSIZE bufSize){
    if(rtPrintToStringIndent(buffer, bufSize) < 0) return -1;
    if(rtPrintToStringBitStrBraceText (name, OS_MIN(pvalue->numbits, 18), pvalue->data, buffer, bufSize) < 0) return -1;
    return 0;
}
//EXTERN int asn1PrtToStrm_e2ap_ENB_ID_short_Macro_eNB_ID (OSCTXT* pctxt, const char* name, const e2ap_ENB_ID_short_Macro_eNB_ID* pvalue);
//EXTERN int asn1Copy_e2ap_ENB_ID_short_Macro_eNB_ID(OSCTXT* pctxt,const e2ap_ENB_ID_short_Macro_eNB_ID* pSrcValue,  e2ap_ENB_ID_short_Macro_eNB_ID* pDstValue);
EXTERN int asn1Init_e2ap_ENB_ID_short_Macro_eNB_ID(e2ap_ENB_ID_short_Macro_eNB_ID* pvalue){
    if(0==pvalue) return RTERR_NULLPTR;
    pvalue->numbits=0;
    return 0;
}
EXTERN void asn1Free_e2ap_ENB_ID_short_Macro_eNB_ID(OSCTXT* pctxt, e2ap_ENB_ID_short_Macro_eNB_ID* pvalue){
    // No dynamic memory to free for fixed-size BIT STRING
    return;
}



    // Nội dung của file .c cho primitive BIT STRING (SIZE(21))
    /* bitstring intergrate header file */
//metadata.parsed.primitive_id == 3

//mau rnti_full ben xn  bitstring (n)

EXTERN int asn1PE_e2ap_ENB_ID_long_Macro_eNB_ID(OSCTXT* pctxt, e2ap_ENB_ID_long_Macro_eNB_ID* pvalue){
    int stat =0;
    //RTXCTXTPUSHTYPENAME(pctxt, "long-Macro-eNB-ID");
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(21), OSUINTCONST(21), 0, 0);
    stat = pe_BitString (pctxt, OS_MIN(pvalue->numbits, 21), pvalue->data);
    if(stat != 0) return LOG_RTERR (pctxt, stat);
    //RTXCTXTPOPTYPENAME(pctxt);
    return stat;
}
EXTERN int asn1PD_e2ap_ENB_ID_long_Macro_eNB_ID(OSCTXT* pctxt, e2ap_ENB_ID_long_Macro_eNB_ID* pvalue){
    int stat =0;
    //RTXCTXTPUSHTYPENAME(pctxt, "long-Macro-eNB-ID");
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(21), OSUINTCONST(21), 0, 0);
    stat = pd_BitString (pctxt, &pvalue->numbits, pvalue->data, sizeof(pvalue->data));
    if(stat != 0) return LOG_RTERR (pctxt, stat);
    //RTXCTXTPOPTYPENAME(pctxt);
    return stat;
}
EXTERN int asn1PrtToStr_e2ap_ENB_ID_long_Macro_eNB_ID (const char* name, e2ap_ENB_ID_long_Macro_eNB_ID* pvalue, char* buffer, OSSIZE bufSize){
    if(rtPrintToStringIndent(buffer, bufSize) < 0) return -1;
    if(rtPrintToStringBitStrBraceText (name, OS_MIN(pvalue->numbits, 21), pvalue->data, buffer, bufSize) < 0) return -1;
    return 0;
}
//EXTERN int asn1PrtToStrm_e2ap_ENB_ID_long_Macro_eNB_ID (OSCTXT* pctxt, const char* name, const e2ap_ENB_ID_long_Macro_eNB_ID* pvalue);
//EXTERN int asn1Copy_e2ap_ENB_ID_long_Macro_eNB_ID(OSCTXT* pctxt,const e2ap_ENB_ID_long_Macro_eNB_ID* pSrcValue,  e2ap_ENB_ID_long_Macro_eNB_ID* pDstValue);
EXTERN int asn1Init_e2ap_ENB_ID_long_Macro_eNB_ID(e2ap_ENB_ID_long_Macro_eNB_ID* pvalue){
    if(0==pvalue) return RTERR_NULLPTR;
    pvalue->numbits=0;
    return 0;
}
EXTERN void asn1Free_e2ap_ENB_ID_long_Macro_eNB_ID(OSCTXT* pctxt, e2ap_ENB_ID_long_Macro_eNB_ID* pvalue){
    // No dynamic memory to free for fixed-size BIT STRING
    return;
}




// Các phần còn lại của template choice.c.j2
// choice without extension

EXTERN int asn1PE_e2ap_ENB_ID (OSCTXT* pctxt, e2ap_ENB_ID* pvalue)
{
   int stat = 0;
   RTXCTXTPUSHTYPENAME (pctxt, "ENB-ID");
   RTXCTXTPUSHELEMNAME (pctxt, "t");
 
   stat = rtxEncBits (pctxt, pvalue->t - 1, 2);// kha nang la numbits
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   switch (pvalue->t) {
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "macro-eNB-ID");
         //primitive BIT STRING - id = 3
         stat = asn1PE_e2ap_ENB_ID_macro_eNB_ID (pctxt, &pvalue->u.macro_eNB_ID); //bit string in choice type 3
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         RTXCTXTPOPELEMNAME (pctxt);
         break;
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "home-eNB-ID");
         //primitive BIT STRING - id = 3
         stat = asn1PE_e2ap_ENB_ID_home_eNB_ID (pctxt, &pvalue->u.home_eNB_ID); //bit string in choice type 3
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         RTXCTXTPOPELEMNAME (pctxt);
         break;
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "short-Macro-eNB-ID");
         //primitive BIT STRING - id = 3
         stat = asn1PE_e2ap_ENB_ID_short_Macro_eNB_ID (pctxt, &pvalue->u.short_Macro_eNB_ID); //bit string in choice type 3
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         RTXCTXTPOPELEMNAME (pctxt);
         break;
      case 4:
         RTXCTXTPUSHELEMNAME (pctxt, "long-Macro-eNB-ID");
         //primitive BIT STRING - id = 3
         stat = asn1PE_e2ap_ENB_ID_long_Macro_eNB_ID (pctxt, &pvalue->u.long_Macro_eNB_ID); //bit string in choice type 3
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         RTXCTXTPOPELEMNAME (pctxt);
         break;
      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return (stat);
}

int asn1PD_e2ap_ENB_ID (OSCTXT* pctxt, e2ap_ENB_ID* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   RTXCTXTPUSHTYPENAME (pctxt, "ENB-ID");

 
   stat = rtxDecBits (pctxt, &ui, 2);// kha nang la numbits
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;
   //RTXCTXTPOPELEMNAME (pctxt);

   switch (ui) {
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "macro-eNB-ID");
         pvalue->u.macro_eNB_ID = rtxMemAllocType (pctxt, e2ap_ENB_ID_macro_eNB_ID);
         if (pvalue->u.macro_eNB_ID == NULL) return LOG_RTERR (pctxt, RTERR_NOMEM);
         //primitive BIT STRING
         asn1Init_e2ap_ENB_ID_macro_eNB_ID(pvalue->u.macro_eNB_ID);
         stat = asn1PD_e2ap_ENB_ID_macro_eNB_ID (pctxt, pvalue->u.macro_eNB_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         RTXCTXTPOPELEMNAME (pctxt);
         break;
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "home-eNB-ID");
         pvalue->u.home_eNB_ID = rtxMemAllocType (pctxt, e2ap_ENB_ID_home_eNB_ID);
         if (pvalue->u.home_eNB_ID == NULL) return LOG_RTERR (pctxt, RTERR_NOMEM);
         //primitive BIT STRING
         asn1Init_e2ap_ENB_ID_home_eNB_ID(pvalue->u.home_eNB_ID);
         stat = asn1PD_e2ap_ENB_ID_home_eNB_ID (pctxt, pvalue->u.home_eNB_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         RTXCTXTPOPELEMNAME (pctxt);
         break;
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "short-Macro-eNB-ID");
         pvalue->u.short_Macro_eNB_ID = rtxMemAllocType (pctxt, e2ap_ENB_ID_short_Macro_eNB_ID);
         if (pvalue->u.short_Macro_eNB_ID == NULL) return LOG_RTERR (pctxt, RTERR_NOMEM);
         //primitive BIT STRING
         asn1Init_e2ap_ENB_ID_short_Macro_eNB_ID(pvalue->u.short_Macro_eNB_ID);
         stat = asn1PD_e2ap_ENB_ID_short_Macro_eNB_ID (pctxt, pvalue->u.short_Macro_eNB_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         RTXCTXTPOPELEMNAME (pctxt);
         break;
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "long-Macro-eNB-ID");
         pvalue->u.long_Macro_eNB_ID = rtxMemAllocType (pctxt, e2ap_ENB_ID_long_Macro_eNB_ID);
         if (pvalue->u.long_Macro_eNB_ID == NULL) return LOG_RTERR (pctxt, RTERR_NOMEM);
         //primitive BIT STRING
         asn1Init_e2ap_ENB_ID_long_Macro_eNB_ID(pvalue->u.long_Macro_eNB_ID);
         stat = asn1PD_e2ap_ENB_ID_long_Macro_eNB_ID (pctxt, pvalue->u.long_Macro_eNB_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         RTXCTXTPOPELEMNAME (pctxt);
         break;
      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return (stat);
}

int asn1PrtToStr_e2ap_ENB_ID (const char* name, e2ap_ENB_ID* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) return -1;
   

   switch (pvalue->t) {
      case T_e2ap_ENB_ID_macro_eNB_ID:
         //primitive BIT STRING
         asn1PrtToStr_e2ap_ENB_ID_macro_eNB_ID (pctxt, pvalue->u.macro_eNB_ID);
         break;
      case T_e2ap_ENB_ID_home_eNB_ID:
         //primitive BIT STRING
         asn1PrtToStr_e2ap_ENB_ID_home_eNB_ID (pctxt, pvalue->u.home_eNB_ID);
         break;
      case T_e2ap_ENB_ID_short_Macro_eNB_ID:
         //primitive BIT STRING
         asn1PrtToStr_e2ap_ENB_ID_short_Macro_eNB_ID (pctxt, pvalue->u.short_Macro_eNB_ID);
         break;
      case T_e2ap_ENB_ID_long_Macro_eNB_ID:
         //primitive BIT STRING
         asn1PrtToStr_e2ap_ENB_ID_long_Macro_eNB_ID (pctxt, pvalue->u.long_Macro_eNB_ID);
         break;
      default:
         return RTERR_INVOPT;
   }

   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}

int asn1Init_e2ap_ENB_ID (e2ap_ENB_ID* pvalue)
{
   if (pvalue == 0) return RTERR_NULLPTR;
   pvalue->t = 0;
   OSRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
   return 0;
}


void asn1Free_e2ap_ENB_ID (OSCTXT* pctxt, e2ap_ENB_ID* pvalue)
{
   if (pvalue == 0) return;
   switch (pvalue->t) {
      case 0: //no choice nothing to free
         break;
      case 1:
         if (pvalue->u.macro_eNB_ID) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.macro_eNB_ID);
            pvalue->u.macro_eNB_ID = 0;
         }
         break;
      case 2:
         if (pvalue->u.home_eNB_ID) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.home_eNB_ID);
            pvalue->u.home_eNB_ID = 0;
         }
         break;
      case 3:
         if (pvalue->u.short_Macro_eNB_ID) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.short_Macro_eNB_ID);
            pvalue->u.short_Macro_eNB_ID = 0;
         }
         break;
      case 4:
         if (pvalue->u.long_Macro_eNB_ID) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.long_Macro_eNB_ID);
            pvalue->u.long_Macro_eNB_ID = 0;
         }
         break;
   }
}


/*****************************************/
/*           GlobalENB-ID                */
/*****************************************/
//sequence normal
// Các nội dung cần thiết cho template seq_normal.c.j2

// Các phần còn lại của template seq_normal.c.j2
//contain extensition bit -> theo mau cua GlobalgNB-ID
int asn1PE_e2ap_GlobalENB_ID (OSCTXT* pctxt, e2ap_GlobalENB_ID* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "GlobalENB-ID");

   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field pLMN_Identity - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "pLMN-Identity");
   stat = asn1PE_e2ap_PLMN_Identity (pctxt, pvalue->pLMN_Identity);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /* encode field eNB_ID - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "eNB-ID");
   stat = asn1PE_e2ap_ENB_ID (pctxt, pvalue->eNB_ID);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);



   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_GlobalENB_ID (OSCTXT* pctxt, e2ap_GlobalENB_ID* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME(pctxt, "GlobalENB-ID");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field pLMN_Identity */
   RTXCTXTPUSHELEMNAME(pctxt, "pLMN-Identity");
      stat = asn1PD_e2ap_PLMN_Identity (pctxt, &pvalue->pLMN_Identity);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field eNB_ID */
   RTXCTXTPUSHELEMNAME(pctxt, "eNB-ID");
      stat = asn1PD_e2ap_ENB_ID (pctxt, &pvalue->eNB_ID);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_GlobalENB_ID (e2ap_GlobalENB_ID* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_PLMN_Identity (&pvalue->pLMN_Identity);
   asn1Init_e2ap_ENB_ID (&pvalue->eNB_ID);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_GlobalENB_ID (OSCTXT* pctxt, e2ap_GlobalENB_ID* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_PLMN_Identity (pctxt, &pvalue->pLMN_Identity);
   asn1Free_e2ap_ENB_ID (pctxt, &pvalue->eNB_ID);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_GlobalENB_ID (const char* name, e2ap_GlobalENB_ID* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }
   if(asn1PrtToStr_e2ap_PLMN_Identity ("pLMN_Identity", &pvalue->pLMN_Identity, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_ENB_ID ("eNB_ID", &pvalue->eNB_ID, buffer, bufSize) < 0)
   {
      return -1;
   }



   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           NGENB_DU_ID                */
/*****************************************/
//6 mau integer
// mau integer size(a...b) mau la procedurecode
EXTERN int asn1PE_e2ap_NGENB_DU_ID (OSCTXT* pctxt, e2ap_NGENB_DU_ID value){
    int stat = 0;
    RTXCTCXTPUSHTYPENAME (pctxt, "NGENB-DU-ID");
    stat = pe_ConsUnsigned (pctxt, value, 0, 68719476735);
    if (stat != 0) return LOG_RTERR (pctxt, stat);
    RTXCTXTPOPTYPENAME (pctxt);
    return stat;
}
EXTERN int asn1PD_e2ap_NGENB_DU_ID (OSCTXT* pctxt, e2ap_NGENB_DU_ID* pvalue){
    int stat = 0;
    RTXCTCXTPUSHTYPENAME (pctxt, "NGENB-DU-ID");
    if(pctxt->buffer.aligned){
        int stat2 = PD_BYTE_ALIGN(pctxt);
        if(stat2 != 0) return LOG_RTERR (pctxt, stat2);
    }
    stat = rtxDecBitsToByte(pctxt, pvalue, 0);
    if (stat != 0) return LOG_RTERR (pctxt, stat);
    RTXCTXTPOPTYPENAME (pctxt);
    return stat;
}
//EXTERN int asn1Print_e2ap_NGENB_DU_ID (const char* name, const e2ap_NGENB_DU_ID* pvalue);
//EXTERN int asn1PrtToStr_e2ap_NGENB_DU_ID (const char* name, e2ap_NGENB_DU_ID* pvalue, char* buffer, OSSIZE bufSize);
//EXTERN int asn1PrtToStrm_e2ap_NGENB_DU_ID (OSCTXT* pctxt, const char* name, const e2ap_NGENB_DU_ID* pvalue);
EXTERN int asn1Init_e2ap_NGENB_DU_ID (e2ap_NGENB_DU_ID* pvalue){
    //if (pvalue == 0) return RTERR_NULLPTR;
    //*pvalue = 0;
    return 0;
}
EXTERN int asn1Free_e2ap_NGENB_DU_ID (OSCTXT* pctxt, e2ap_NGENB_DU_ID* pvalue){
    // No dynamic memory to free for integer
    return 0;
}

/*****************************************/
/*           GlobalE2node-ng-eNB-ID                */
/*****************************************/
//sequence normal
// Các nội dung cần thiết cho template seq_normal.c.j2

// Các phần còn lại của template seq_normal.c.j2
//contain extensition bit -> theo mau cua GlobalgNB-ID
int asn1PE_e2ap_GlobalE2node_ng_eNB_ID (OSCTXT* pctxt, e2ap_GlobalE2node_ng_eNB_ID* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "GlobalE2node-ng-eNB-ID");

   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);

   /*optional bit for field global_eNB_ID*/
   stat = rtxEncBit (pctxt, pvalue->m_global_eNB_IDPresent);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   /*optional bit for field ngENB_DU_ID*/
   stat = rtxEncBit (pctxt, pvalue->m_ngENB_DU_IDPresent);
   if (stat != 0) return LOG_RTERR(pctxt, stat);

   /*encode root elements*/   
   /* encode field global_ng_eNB_ID - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "global-ng-eNB-ID");
   stat = asn1PE_e2ap_GlobalngeNB_ID (pctxt, pvalue->global_ng_eNB_ID);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /* encode field global_eNB_ID - id = -1*/  
   if (pvalue->m_global_eNB_IDPresent) {//OPTIONAL FIELD
   RTXCTXTPUSHELEMNAME(pctxt, "global-eNB-ID");
   stat = asn1PE_e2ap_GlobalENB_ID (pctxt, pvalue->global_eNB_ID);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   }

   /* encode field ngENB_DU_ID - id = -1*/  
   if (pvalue->m_ngENB_DU_IDPresent) {//OPTIONAL FIELD
   RTXCTXTPUSHELEMNAME(pctxt, "ngENB-DU-ID");
   stat = asn1PE_e2ap_NGENB_DU_ID (pctxt, pvalue->ngENB_DU_ID);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   }


   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_GlobalE2node_ng_eNB_ID (OSCTXT* pctxt, e2ap_GlobalE2node_ng_eNB_ID* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[3];

   RTXCTXTPUSHTYPENAME(pctxt, "GlobalE2node-ng-eNB-ID");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field global_ng_eNB_ID */
   RTXCTXTPUSHELEMNAME(pctxt, "global-ng-eNB-ID");
      stat = asn1PD_e2ap_GlobalngeNB_ID (pctxt, &pvalue->global_ng_eNB_ID);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field global_eNB_ID */
   RTXCTXTPUSHELEMNAME(pctxt, "global-eNB-ID");
   if (optbits[0]) {
      pvalue->m_global_eNB_IDPresent = TRUE;
      stat = asn1PD_e2ap_GlobalENB_ID (pctxt, &pvalue->global_eNB_ID);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   } else {
      pvalue->m_global_eNB_IDPresent = FALSE;
   }
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field ngENB_DU_ID */
   RTXCTXTPUSHELEMNAME(pctxt, "ngENB-DU-ID");
   if (optbits[0]) {
      pvalue->m_ngENB_DU_IDPresent = TRUE;
      stat = asn1PD_e2ap_NGENB_DU_ID (pctxt, &pvalue->ngENB_DU_ID);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   } else {
      pvalue->m_ngENB_DU_IDPresent = FALSE;
   }
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_GlobalE2node_ng_eNB_ID (e2ap_GlobalE2node_ng_eNB_ID* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_GlobalngeNB_ID (&pvalue->global_ng_eNB_ID);
   asn1Init_e2ap_GlobalENB_ID (&pvalue->global_eNB_ID);
   asn1Init_e2ap_NGENB_DU_ID (&pvalue->ngENB_DU_ID);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_GlobalE2node_ng_eNB_ID (OSCTXT* pctxt, e2ap_GlobalE2node_ng_eNB_ID* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_GlobalngeNB_ID (pctxt, &pvalue->global_ng_eNB_ID);
   asn1Free_e2ap_GlobalENB_ID (pctxt, &pvalue->global_eNB_ID);
   asn1Free_e2ap_NGENB_DU_ID (pctxt, &pvalue->ngENB_DU_ID);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_GlobalE2node_ng_eNB_ID (const char* name, e2ap_GlobalE2node_ng_eNB_ID* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }
   if(asn1PrtToStr_e2ap_GlobalngeNB_ID ("global_ng_eNB_ID", &pvalue->global_ng_eNB_ID, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_GlobalENB_ID ("global_eNB_ID", &pvalue->global_eNB_ID, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_NGENB_DU_ID ("ngENB_DU_ID", &pvalue->ngENB_DU_ID, buffer, bufSize) < 0)
   {
      return -1;
   }



   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}
/*****************************************/
/*           GlobalE2node-eNB-ID                */
/*****************************************/
//sequence normal
// Các nội dung cần thiết cho template seq_normal.c.j2

// Các phần còn lại của template seq_normal.c.j2
//contain extensition bit -> theo mau cua GlobalgNB-ID
int asn1PE_e2ap_GlobalE2node_eNB_ID (OSCTXT* pctxt, e2ap_GlobalE2node_eNB_ID* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "GlobalE2node-eNB-ID");

   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field global_eNB_ID - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "global-eNB-ID");
   stat = asn1PE_e2ap_GlobalENB_ID (pctxt, pvalue->global_eNB_ID);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);



   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_GlobalE2node_eNB_ID (OSCTXT* pctxt, e2ap_GlobalE2node_eNB_ID* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME(pctxt, "GlobalE2node-eNB-ID");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field global_eNB_ID */
   RTXCTXTPUSHELEMNAME(pctxt, "global-eNB-ID");
      stat = asn1PD_e2ap_GlobalENB_ID (pctxt, &pvalue->global_eNB_ID);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_GlobalE2node_eNB_ID (e2ap_GlobalE2node_eNB_ID* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_GlobalENB_ID (&pvalue->global_eNB_ID);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_GlobalE2node_eNB_ID (OSCTXT* pctxt, e2ap_GlobalE2node_eNB_ID* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_GlobalENB_ID (pctxt, &pvalue->global_eNB_ID);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_GlobalE2node_eNB_ID (const char* name, e2ap_GlobalE2node_eNB_ID* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }
   if(asn1PrtToStr_e2ap_GlobalENB_ID ("global_eNB_ID", &pvalue->global_eNB_ID, buffer, bufSize) < 0)
   {
      return -1;
   }



   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/* e2ap_GlobalE2node_ID.c */

/*****************************************/
/*           GlobalE2node_ID                */
/*****************************************/
// choice
// Các nội dung cần thiết cho template choice.c.j2

// Các phần còn lại của template choice.c.j2
// choice without extension

EXTERN int asn1PE_e2ap_GlobalE2node_ID (OSCTXT* pctxt, e2ap_GlobalE2node_ID* pvalue)
{
   int stat = 0;
   RTXCTXTPUSHTYPENAME (pctxt, "GlobalE2node-ID");
   RTXCTXTPUSHELEMNAME (pctxt, "t");
 
   stat = rtxEncBits (pctxt, pvalue->t - 1, 2);// kha nang la numbits
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   switch (pvalue->t) {
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "gNB");
         stat = asn1PE_e2ap_GlobalE2node_gNB_ID (pctxt, pvalue->u.gNB); //not primitive
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         RTXCTXTPOPELEMNAME (pctxt);
         break;
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "en-gNB");
         stat = asn1PE_e2ap_GlobalE2node_en_gNB_ID (pctxt, pvalue->u.en_gNB); //not primitive
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         RTXCTXTPOPELEMNAME (pctxt);
         break;
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "ng-eNB");
         stat = asn1PE_e2ap_GlobalE2node_ng_eNB_ID (pctxt, pvalue->u.ng_eNB); //not primitive
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         RTXCTXTPOPELEMNAME (pctxt);
         break;
      case 4:
         RTXCTXTPUSHELEMNAME (pctxt, "eNB");
         stat = asn1PE_e2ap_GlobalE2node_eNB_ID (pctxt, pvalue->u.eNB); //not primitive
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         RTXCTXTPOPELEMNAME (pctxt);
         break;
      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return (stat);
}

int asn1PD_e2ap_GlobalE2node_ID (OSCTXT* pctxt, e2ap_GlobalE2node_ID* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   RTXCTXTPUSHTYPENAME (pctxt, "GlobalE2node-ID");

 
   stat = rtxDecBits (pctxt, &ui, 2);// kha nang la numbits
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;
   //RTXCTXTPOPELEMNAME (pctxt);

   switch (ui) {
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "gNB");
         pvalue->u.gNB = rtxMemAllocType (pctxt, e2ap_GlobalE2node_gNB_ID);
         if (pvalue->u.gNB == NULL) return LOG_RTERR (pctxt, RTERR_NOMEM);
         asn1Init_e2ap_GlobalE2node_gNB_ID(pvalue->u.gNB);
         stat = asn1PD_e2ap_GlobalE2node_gNB_ID (pctxt, pvalue->u.gNB);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         RTXCTXTPOPELEMNAME (pctxt);
         break;
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "en-gNB");
         pvalue->u.en_gNB = rtxMemAllocType (pctxt, e2ap_GlobalE2node_en_gNB_ID);
         if (pvalue->u.en_gNB == NULL) return LOG_RTERR (pctxt, RTERR_NOMEM);
         asn1Init_e2ap_GlobalE2node_en_gNB_ID(pvalue->u.en_gNB);
         stat = asn1PD_e2ap_GlobalE2node_en_gNB_ID (pctxt, pvalue->u.en_gNB);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         RTXCTXTPOPELEMNAME (pctxt);
         break;
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "ng-eNB");
         pvalue->u.ng_eNB = rtxMemAllocType (pctxt, e2ap_GlobalE2node_ng_eNB_ID);
         if (pvalue->u.ng_eNB == NULL) return LOG_RTERR (pctxt, RTERR_NOMEM);
         asn1Init_e2ap_GlobalE2node_ng_eNB_ID(pvalue->u.ng_eNB);
         stat = asn1PD_e2ap_GlobalE2node_ng_eNB_ID (pctxt, pvalue->u.ng_eNB);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         RTXCTXTPOPELEMNAME (pctxt);
         break;
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "eNB");
         pvalue->u.eNB = rtxMemAllocType (pctxt, e2ap_GlobalE2node_eNB_ID);
         if (pvalue->u.eNB == NULL) return LOG_RTERR (pctxt, RTERR_NOMEM);
         asn1Init_e2ap_GlobalE2node_eNB_ID(pvalue->u.eNB);
         stat = asn1PD_e2ap_GlobalE2node_eNB_ID (pctxt, pvalue->u.eNB);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         RTXCTXTPOPELEMNAME (pctxt);
         break;
      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return (stat);
}

int asn1PrtToStr_e2ap_GlobalE2node_ID (const char* name, e2ap_GlobalE2node_ID* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) return -1;
   

   switch (pvalue->t) {
      case T_e2ap_GlobalE2node_ID_gNB:
         if (asn1PrtToStr_e2ap_GlobalE2node_gNB_ID ( "gNB", pvalue->u.gNB, buffer, bufSize) < 0) return -1;
         break;
      case T_e2ap_GlobalE2node_ID_en_gNB:
         if (asn1PrtToStr_e2ap_GlobalE2node_en_gNB_ID ( "en_gNB", pvalue->u.en_gNB, buffer, bufSize) < 0) return -1;
         break;
      case T_e2ap_GlobalE2node_ID_ng_eNB:
         if (asn1PrtToStr_e2ap_GlobalE2node_ng_eNB_ID ( "ng_eNB", pvalue->u.ng_eNB, buffer, bufSize) < 0) return -1;
         break;
      case T_e2ap_GlobalE2node_ID_eNB:
         if (asn1PrtToStr_e2ap_GlobalE2node_eNB_ID ( "eNB", pvalue->u.eNB, buffer, bufSize) < 0) return -1;
         break;
      default:
         return RTERR_INVOPT;
   }

   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}

int asn1Init_e2ap_GlobalE2node_ID (e2ap_GlobalE2node_ID* pvalue)
{
   if (pvalue == 0) return RTERR_NULLPTR;
   pvalue->t = 0;
   OSRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
   return 0;
}


void asn1Free_e2ap_GlobalE2node_ID (OSCTXT* pctxt, e2ap_GlobalE2node_ID* pvalue)
{
   if (pvalue == 0) return;
   switch (pvalue->t) {
      case 0: //no choice nothing to free
         break;
      case 1:
         if (pvalue->u.gNB) {
            //not primitive
            asn1Free_e2ap_GlobalE2node_gNB_ID (pctxt, pvalue->u.gNB);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.gNB);
            pvalue->u.gNB = 0;
         }
         break;
      case 2:
         if (pvalue->u.en_gNB) {
            //not primitive
            asn1Free_e2ap_GlobalE2node_en_gNB_ID (pctxt, pvalue->u.en_gNB);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.en_gNB);
            pvalue->u.en_gNB = 0;
         }
         break;
      case 3:
         if (pvalue->u.ng_eNB) {
            //not primitive
            asn1Free_e2ap_GlobalE2node_ng_eNB_ID (pctxt, pvalue->u.ng_eNB);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.ng_eNB);
            pvalue->u.ng_eNB = 0;
         }
         break;
      case 4:
         if (pvalue->u.eNB) {
            //not primitive
            asn1Free_e2ap_GlobalE2node_eNB_ID (pctxt, pvalue->u.eNB);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.eNB);
            pvalue->u.eNB = 0;
         }
         break;
   }
}

/******************************************************/
/*                                                    */
/*    E2nodeComponentInterfaceType                          */
/*                                                    */
/******************************************************/
//enumerated


const OSEnumItem e2ap_E2nodeComponentInterfaceType_ENUMTAB[] = {
    { OSUTF8("ng"), 0, 2, 0 },
    { OSUTF8("xn"), 1, 2, 1 },
    { OSUTF8("e1"), 2, 2, 2 },
    { OSUTF8("f1"), 3, 2, 3 },
    { OSUTF8("w1"), 4, 2, 4 },
    { OSUTF8("s1"), 5, 2, 5 },
    { OSUTF8("x2"), 6, 2, 6 }
};


const OSUTF8CHAR* e2ap_E2nodeComponentInterfaceType_ToString (OSUINT32 value){
   OSINT32 idx = value;
   if(idx >=0 && idx < e2ap_E2nodeComponentInterfaceType_ENUMTABSIZE){
      return e2ap_E2nodeComponentInterfaceType_ENUMTAB[e2ap_E2nodeComponentInterfaceType_ENUMTAB[idx].transidx].name;
   }else{
      return OSUTF8("_UNKNOWN_");
   }
}


int e2ap_E2nodeComponentInterfaceType_ToEnum (OSCTXT* pctxt, const OSUTF8CHAR* value,e2ap_E2nodeComponentInterfaceType* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes(value);
   return e2ap_E2nodeComponentInterfaceType_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int e2ap_E2nodeComponentInterfaceType_ToEnum2 (OSCTXT* pctxt, const OSUTF8CHAR* value, OSSIZE valueLen,e2ap_E2nodeComponentInterfaceType* pvalue)
{
   OSINT32 idx = rtxLookupEnum(value, valueLen,
      e2ap_E2nodeComponentInterfaceType_ENUMTAB, e2ap_E2nodeComponentInterfaceType_ENUMTABSIZE);
   if (idx >= 0) {
      *pvalue = (e2ap_E2nodeComponentInterfaceType)e2ap_E2nodeComponentInterfaceType_ENUMTAB[idx].value;
      return 0;
   } else {
      rtxErrAddIntParm (pctxt, (const char*)value);//dungnm23 check xem là Str hay Int
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_e2ap_E2nodeComponentInterfaceType (OSCTXT* pctxt, e2ap_E2nodeComponentInterfaceType value)
{
   int stat = 0;
   RTXCTXTPUSHTYPENAME (pctxt, "E2nodeComponentInterfaceType");
   if (value >= 7) {
      rtxErrAddIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(6));
   if(stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}

EXTERN int asn1PD_e2ap_E2nodeComponentInterfaceType (OSCTXT* pctxt, e2ap_E2nodeComponentInterfaceType* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "E2nodeComponentInterfaceType");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(6));
   if(stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return stat;
}

EXTERN int asn1PrtToStr_e2ap_E2nodeComponentInterfaceType (const char* name, e2ap_E2nodeComponentInterfaceType* pvalue, char* buffer, OSSIZE bufSize)
{
   int stat;

   if(rtPrintToStringIndent(buffer, bufSize) < 0) return -1;
   if(rtPrintToString(name, buffer, bufSize) < 0) return -1;

   switch(*pvalue) {
      case 0:
         stat = rtPrintToString(" = ng \n", buffer, bufSize);
         break;
      case 1:
         stat = rtPrintToString(" = xn \n", buffer, bufSize);
         break;
      case 2:
         stat = rtPrintToString(" = e1 \n", buffer, bufSize);
         break;
      case 3:
         stat = rtPrintToString(" = f1 \n", buffer, bufSize);
         break;
      case 4:
         stat = rtPrintToString(" = w1 \n", buffer, bufSize);
         break;
      case 5:
         stat = rtPrintToString(" = s1 \n", buffer, bufSize);
         break;
      case 6:
         stat = rtPrintToString(" = x2 \n", buffer, bufSize);
         break;
      default:
         stat = rtPrintToString(" = ???\n", buffer, bufSize);
   }

   if (stat < 0) return -1;
   return 0;

}

/*Init*/
EXTERN int asn1Init_e2ap_E2nodeComponentInterfaceType (e2ap_E2nodeComponentInterfaceType* pvalue){
      //if (pvalue == 0) return RTERR_NULLPTR;
      //*pvalue = 0;
      return 0;
}/* e2ap_AMFName.c */

//printable string
/*****************************************/
/*           AMFName                */
/*****************************************/

/* Constrained PrintableString */
EXTERN int asn1PE_e2ap_AMFName (OSCTXT* pctxt, e2ap_AMFName value)
{
   int stat = 0;
   RTXCTXTPUSHTYPENAME (pctxt, "AMFName");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(150), OSUINTCONST(0), OSUINT32_MAX);

   char c = (char) rtValidateStr (19, value);  /* 19 = PrintableString */
   if (c != 0) {
      char lbuf[2];
      lbuf[0] = c;
      lbuf[1] = 0;

      rtxErrAddEleNameParm(pctxt);
      rtxErrAddStrParm (pctxt, lbuf);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   stat = pe_ConstrainedStringEx (pctxt, value, 0, 8, 7, 7);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}

EXTERN int asn1PD_e2ap_AMFName (OSCTXT* pctxt, e2ap_AMFName* ppvalue)
{
   int stat = 0;
   RTXCTXTPUSHTYPENAME (pctxt, "AMFName");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(150), OSUINTCONST(0), OSUINT32_MAX);

   stat = pd_ConstrainedStringEx (pctxt, ppvalue, 0, 8, 7, 7);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}


void asn1Free_e2ap_AMFName (OSCTXT* pctxt, e2ap_AMFName pvalue)
{
   if(0==pvalue) return;
   rtxMemFreePtr (pctxt, (void*)pvalue);
   pvalue = 0;
}

/* Print to string */
int asn1PrtToStr_e2ap_AMFName (const char* name, e2ap_AMFName pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringIndent (buffer, bufSize) < 0) return -1;
   if (rtPrintToStringCharStr (name, pvalue, buffer, bufSize) < 0) return -1;
   return 0;
}

EXTERN int asn1Init_e2ap_AMFName (e2ap_AMFName* pvalue){
   //if(0==pvalue) return RTERR_NULLPTR;
   //pvalue = 0;
   return 0;
}
/*****************************************/
/*           E2nodeComponentInterfaceNG                */
/*****************************************/
//sequence normal
// Các nội dung cần thiết cho template seq_normal.c.j2

// Các phần còn lại của template seq_normal.c.j2
//contain extensition bit -> theo mau cua GlobalgNB-ID
int asn1PE_e2ap_E2nodeComponentInterfaceNG (OSCTXT* pctxt, e2ap_E2nodeComponentInterfaceNG* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "E2nodeComponentInterfaceNG");

   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field amf_name - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "amf-name");
   stat = asn1PE_e2ap_AMFName (pctxt, pvalue->amf_name);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);



   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_E2nodeComponentInterfaceNG (OSCTXT* pctxt, e2ap_E2nodeComponentInterfaceNG* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME(pctxt, "E2nodeComponentInterfaceNG");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field amf_name */
   RTXCTXTPUSHELEMNAME(pctxt, "amf-name");
      stat = asn1PD_e2ap_AMFName (pctxt, &pvalue->amf_name);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_E2nodeComponentInterfaceNG (e2ap_E2nodeComponentInterfaceNG* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_AMFName (&pvalue->amf_name);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_E2nodeComponentInterfaceNG (OSCTXT* pctxt, e2ap_E2nodeComponentInterfaceNG* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_AMFName (pctxt, &pvalue->amf_name);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_E2nodeComponentInterfaceNG (const char* name, e2ap_E2nodeComponentInterfaceNG* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }
   if(asn1PrtToStr_e2ap_AMFName ("amf_name", &pvalue->amf_name, buffer, bufSize) < 0)
   {
      return -1;
   }



   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/* e2ap_GlobalNG_RANNode_ID.c */

/*****************************************/
/*           GlobalNG_RANNode_ID                */
/*****************************************/
// choice
// Các nội dung cần thiết cho template choice.c.j2

// Các phần còn lại của template choice.c.j2
// choice without extension

EXTERN int asn1PE_e2ap_GlobalNG_RANNode_ID (OSCTXT* pctxt, e2ap_GlobalNG_RANNode_ID* pvalue)
{
   int stat = 0;
   RTXCTXTPUSHTYPENAME (pctxt, "GlobalNG-RANNode-ID");
   RTXCTXTPUSHELEMNAME (pctxt, "t");
 
   stat = rtxEncBits (pctxt, pvalue->t - 1, 1);// kha nang la numbits
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   switch (pvalue->t) {
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "gNB");
         stat = asn1PE_e2ap_GlobalgNB_ID (pctxt, pvalue->u.gNB); //not primitive
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         RTXCTXTPOPELEMNAME (pctxt);
         break;
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "ng-eNB");
         stat = asn1PE_e2ap_GlobalngeNB_ID (pctxt, pvalue->u.ng_eNB); //not primitive
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         RTXCTXTPOPELEMNAME (pctxt);
         break;
      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return (stat);
}

int asn1PD_e2ap_GlobalNG_RANNode_ID (OSCTXT* pctxt, e2ap_GlobalNG_RANNode_ID* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   RTXCTXTPUSHTYPENAME (pctxt, "GlobalNG-RANNode-ID");

 
   stat = rtxDecBits (pctxt, &ui, 1);// kha nang la numbits
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;
   //RTXCTXTPOPELEMNAME (pctxt);

   switch (ui) {
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "gNB");
         pvalue->u.gNB = rtxMemAllocType (pctxt, e2ap_GlobalgNB_ID);
         if (pvalue->u.gNB == NULL) return LOG_RTERR (pctxt, RTERR_NOMEM);
         asn1Init_e2ap_GlobalgNB_ID(pvalue->u.gNB);
         stat = asn1PD_e2ap_GlobalgNB_ID (pctxt, pvalue->u.gNB);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         RTXCTXTPOPELEMNAME (pctxt);
         break;
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "ng-eNB");
         pvalue->u.ng_eNB = rtxMemAllocType (pctxt, e2ap_GlobalngeNB_ID);
         if (pvalue->u.ng_eNB == NULL) return LOG_RTERR (pctxt, RTERR_NOMEM);
         asn1Init_e2ap_GlobalngeNB_ID(pvalue->u.ng_eNB);
         stat = asn1PD_e2ap_GlobalngeNB_ID (pctxt, pvalue->u.ng_eNB);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         RTXCTXTPOPELEMNAME (pctxt);
         break;
      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return (stat);
}

int asn1PrtToStr_e2ap_GlobalNG_RANNode_ID (const char* name, e2ap_GlobalNG_RANNode_ID* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) return -1;
   

   switch (pvalue->t) {
      case T_e2ap_GlobalNG_RANNode_ID_gNB:
         if (asn1PrtToStr_e2ap_GlobalgNB_ID ( "gNB", pvalue->u.gNB, buffer, bufSize) < 0) return -1;
         break;
      case T_e2ap_GlobalNG_RANNode_ID_ng_eNB:
         if (asn1PrtToStr_e2ap_GlobalngeNB_ID ( "ng_eNB", pvalue->u.ng_eNB, buffer, bufSize) < 0) return -1;
         break;
      default:
         return RTERR_INVOPT;
   }

   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}

int asn1Init_e2ap_GlobalNG_RANNode_ID (e2ap_GlobalNG_RANNode_ID* pvalue)
{
   if (pvalue == 0) return RTERR_NULLPTR;
   pvalue->t = 0;
   OSRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
   return 0;
}


void asn1Free_e2ap_GlobalNG_RANNode_ID (OSCTXT* pctxt, e2ap_GlobalNG_RANNode_ID* pvalue)
{
   if (pvalue == 0) return;
   switch (pvalue->t) {
      case 0: //no choice nothing to free
         break;
      case 1:
         if (pvalue->u.gNB) {
            //not primitive
            asn1Free_e2ap_GlobalgNB_ID (pctxt, pvalue->u.gNB);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.gNB);
            pvalue->u.gNB = 0;
         }
         break;
      case 2:
         if (pvalue->u.ng_eNB) {
            //not primitive
            asn1Free_e2ap_GlobalngeNB_ID (pctxt, pvalue->u.ng_eNB);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.ng_eNB);
            pvalue->u.ng_eNB = 0;
         }
         break;
   }
}


/*****************************************/
/*           E2nodeComponentInterfaceXn                */
/*****************************************/
//sequence normal
// Các nội dung cần thiết cho template seq_normal.c.j2

// Các phần còn lại của template seq_normal.c.j2
//contain extensition bit -> theo mau cua GlobalgNB-ID
int asn1PE_e2ap_E2nodeComponentInterfaceXn (OSCTXT* pctxt, e2ap_E2nodeComponentInterfaceXn* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "E2nodeComponentInterfaceXn");

   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field global_NG_RAN_Node_ID - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "global-NG-RAN-Node-ID");
   stat = asn1PE_e2ap_GlobalNG_RANNode_ID (pctxt, pvalue->global_NG_RAN_Node_ID);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);



   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_E2nodeComponentInterfaceXn (OSCTXT* pctxt, e2ap_E2nodeComponentInterfaceXn* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME(pctxt, "E2nodeComponentInterfaceXn");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field global_NG_RAN_Node_ID */
   RTXCTXTPUSHELEMNAME(pctxt, "global-NG-RAN-Node-ID");
      stat = asn1PD_e2ap_GlobalNG_RANNode_ID (pctxt, &pvalue->global_NG_RAN_Node_ID);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_E2nodeComponentInterfaceXn (e2ap_E2nodeComponentInterfaceXn* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_GlobalNG_RANNode_ID (&pvalue->global_NG_RAN_Node_ID);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_E2nodeComponentInterfaceXn (OSCTXT* pctxt, e2ap_E2nodeComponentInterfaceXn* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_GlobalNG_RANNode_ID (pctxt, &pvalue->global_NG_RAN_Node_ID);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_E2nodeComponentInterfaceXn (const char* name, e2ap_E2nodeComponentInterfaceXn* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }
   if(asn1PrtToStr_e2ap_GlobalNG_RANNode_ID ("global_NG_RAN_Node_ID", &pvalue->global_NG_RAN_Node_ID, buffer, bufSize) < 0)
   {
      return -1;
   }



   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}
/*****************************************/
/*           E2nodeComponentInterfaceE1                */
/*****************************************/
//sequence normal
// Các nội dung cần thiết cho template seq_normal.c.j2

// Các phần còn lại của template seq_normal.c.j2
//contain extensition bit -> theo mau cua GlobalgNB-ID
int asn1PE_e2ap_E2nodeComponentInterfaceE1 (OSCTXT* pctxt, e2ap_E2nodeComponentInterfaceE1* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "E2nodeComponentInterfaceE1");

   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field gNB_CU_UP_ID - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "gNB-CU-UP-ID");
   stat = asn1PE_e2ap_GNB_CU_UP_ID (pctxt, pvalue->gNB_CU_UP_ID);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);



   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_E2nodeComponentInterfaceE1 (OSCTXT* pctxt, e2ap_E2nodeComponentInterfaceE1* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME(pctxt, "E2nodeComponentInterfaceE1");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field gNB_CU_UP_ID */
   RTXCTXTPUSHELEMNAME(pctxt, "gNB-CU-UP-ID");
      stat = asn1PD_e2ap_GNB_CU_UP_ID (pctxt, &pvalue->gNB_CU_UP_ID);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_E2nodeComponentInterfaceE1 (e2ap_E2nodeComponentInterfaceE1* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_GNB_CU_UP_ID (&pvalue->gNB_CU_UP_ID);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_E2nodeComponentInterfaceE1 (OSCTXT* pctxt, e2ap_E2nodeComponentInterfaceE1* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_GNB_CU_UP_ID (pctxt, &pvalue->gNB_CU_UP_ID);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_E2nodeComponentInterfaceE1 (const char* name, e2ap_E2nodeComponentInterfaceE1* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }
   if(asn1PrtToStr_e2ap_GNB_CU_UP_ID ("gNB_CU_UP_ID", &pvalue->gNB_CU_UP_ID, buffer, bufSize) < 0)
   {
      return -1;
   }



   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}
/*****************************************/
/*           E2nodeComponentInterfaceF1                */
/*****************************************/
//sequence normal
// Các nội dung cần thiết cho template seq_normal.c.j2

// Các phần còn lại của template seq_normal.c.j2
//contain extensition bit -> theo mau cua GlobalgNB-ID
int asn1PE_e2ap_E2nodeComponentInterfaceF1 (OSCTXT* pctxt, e2ap_E2nodeComponentInterfaceF1* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "E2nodeComponentInterfaceF1");

   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field gNB_DU_ID - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "gNB-DU-ID");
   stat = asn1PE_e2ap_GNB_DU_ID (pctxt, pvalue->gNB_DU_ID);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);



   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_E2nodeComponentInterfaceF1 (OSCTXT* pctxt, e2ap_E2nodeComponentInterfaceF1* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME(pctxt, "E2nodeComponentInterfaceF1");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field gNB_DU_ID */
   RTXCTXTPUSHELEMNAME(pctxt, "gNB-DU-ID");
      stat = asn1PD_e2ap_GNB_DU_ID (pctxt, &pvalue->gNB_DU_ID);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_E2nodeComponentInterfaceF1 (e2ap_E2nodeComponentInterfaceF1* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_GNB_DU_ID (&pvalue->gNB_DU_ID);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_E2nodeComponentInterfaceF1 (OSCTXT* pctxt, e2ap_E2nodeComponentInterfaceF1* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_GNB_DU_ID (pctxt, &pvalue->gNB_DU_ID);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_E2nodeComponentInterfaceF1 (const char* name, e2ap_E2nodeComponentInterfaceF1* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }
   if(asn1PrtToStr_e2ap_GNB_DU_ID ("gNB_DU_ID", &pvalue->gNB_DU_ID, buffer, bufSize) < 0)
   {
      return -1;
   }



   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}
/*****************************************/
/*           E2nodeComponentInterfaceW1                */
/*****************************************/
//sequence normal
// Các nội dung cần thiết cho template seq_normal.c.j2

// Các phần còn lại của template seq_normal.c.j2
//contain extensition bit -> theo mau cua GlobalgNB-ID
int asn1PE_e2ap_E2nodeComponentInterfaceW1 (OSCTXT* pctxt, e2ap_E2nodeComponentInterfaceW1* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "E2nodeComponentInterfaceW1");

   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field ng_eNB_DU_ID - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "ng-eNB-DU-ID");
   stat = asn1PE_e2ap_NGENB_DU_ID (pctxt, pvalue->ng_eNB_DU_ID);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);



   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_E2nodeComponentInterfaceW1 (OSCTXT* pctxt, e2ap_E2nodeComponentInterfaceW1* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME(pctxt, "E2nodeComponentInterfaceW1");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field ng_eNB_DU_ID */
   RTXCTXTPUSHELEMNAME(pctxt, "ng-eNB-DU-ID");
      stat = asn1PD_e2ap_NGENB_DU_ID (pctxt, &pvalue->ng_eNB_DU_ID);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_E2nodeComponentInterfaceW1 (e2ap_E2nodeComponentInterfaceW1* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_NGENB_DU_ID (&pvalue->ng_eNB_DU_ID);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_E2nodeComponentInterfaceW1 (OSCTXT* pctxt, e2ap_E2nodeComponentInterfaceW1* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_NGENB_DU_ID (pctxt, &pvalue->ng_eNB_DU_ID);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_E2nodeComponentInterfaceW1 (const char* name, e2ap_E2nodeComponentInterfaceW1* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }
   if(asn1PrtToStr_e2ap_NGENB_DU_ID ("ng_eNB_DU_ID", &pvalue->ng_eNB_DU_ID, buffer, bufSize) < 0)
   {
      return -1;
   }



   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/* e2ap_MMEname.c */

//printable string
/*****************************************/
/*           MMEname                */
/*****************************************/

/* Constrained PrintableString */
EXTERN int asn1PE_e2ap_MMEname (OSCTXT* pctxt, e2ap_MMEname value)
{
   int stat = 0;
   RTXCTXTPUSHTYPENAME (pctxt, "MMEname");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(150), OSUINTCONST(0), OSUINT32_MAX);

   char c = (char) rtValidateStr (19, value);  /* 19 = PrintableString */
   if (c != 0) {
      char lbuf[2];
      lbuf[0] = c;
      lbuf[1] = 0;

      rtxErrAddEleNameParm(pctxt);
      rtxErrAddStrParm (pctxt, lbuf);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   stat = pe_ConstrainedStringEx (pctxt, value, 0, 8, 7, 7);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}

EXTERN int asn1PD_e2ap_MMEname (OSCTXT* pctxt, e2ap_MMEname* ppvalue)
{
   int stat = 0;
   RTXCTXTPUSHTYPENAME (pctxt, "MMEname");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(150), OSUINTCONST(0), OSUINT32_MAX);

   stat = pd_ConstrainedStringEx (pctxt, ppvalue, 0, 8, 7, 7);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}


void asn1Free_e2ap_MMEname (OSCTXT* pctxt, e2ap_MMEname pvalue)
{
   if(0==pvalue) return;
   rtxMemFreePtr (pctxt, (void*)pvalue);
   pvalue = 0;
}

/* Print to string */
int asn1PrtToStr_e2ap_MMEname (const char* name, e2ap_MMEname pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringIndent (buffer, bufSize) < 0) return -1;
   if (rtPrintToStringCharStr (name, pvalue, buffer, bufSize) < 0) return -1;
   return 0;
}

EXTERN int asn1Init_e2ap_MMEname (e2ap_MMEname* pvalue){
   //if(0==pvalue) return RTERR_NULLPTR;
   //pvalue = 0;
   return 0;
}
/*****************************************/
/*           E2nodeComponentInterfaceS1                */
/*****************************************/
//sequence normal
// Các nội dung cần thiết cho template seq_normal.c.j2

// Các phần còn lại của template seq_normal.c.j2
//contain extensition bit -> theo mau cua GlobalgNB-ID
int asn1PE_e2ap_E2nodeComponentInterfaceS1 (OSCTXT* pctxt, e2ap_E2nodeComponentInterfaceS1* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "E2nodeComponentInterfaceS1");

   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field mme_name - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "mme-name");
   stat = asn1PE_e2ap_MMEname (pctxt, pvalue->mme_name);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);



   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_E2nodeComponentInterfaceS1 (OSCTXT* pctxt, e2ap_E2nodeComponentInterfaceS1* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME(pctxt, "E2nodeComponentInterfaceS1");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field mme_name */
   RTXCTXTPUSHELEMNAME(pctxt, "mme-name");
      stat = asn1PD_e2ap_MMEname (pctxt, &pvalue->mme_name);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_E2nodeComponentInterfaceS1 (e2ap_E2nodeComponentInterfaceS1* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_MMEname (&pvalue->mme_name);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_E2nodeComponentInterfaceS1 (OSCTXT* pctxt, e2ap_E2nodeComponentInterfaceS1* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_MMEname (pctxt, &pvalue->mme_name);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_E2nodeComponentInterfaceS1 (const char* name, e2ap_E2nodeComponentInterfaceS1* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }
   if(asn1PrtToStr_e2ap_MMEname ("mme_name", &pvalue->mme_name, buffer, bufSize) < 0)
   {
      return -1;
   }



   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}
/*****************************************/
/*           E2nodeComponentInterfaceX2                */
/*****************************************/
//sequence normal
// Các nội dung cần thiết cho template seq_normal.c.j2

// Các phần còn lại của template seq_normal.c.j2
//contain extensition bit -> theo mau cua GlobalgNB-ID
int asn1PE_e2ap_E2nodeComponentInterfaceX2 (OSCTXT* pctxt, e2ap_E2nodeComponentInterfaceX2* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "E2nodeComponentInterfaceX2");

   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);

   /*optional bit for field global_eNB_ID*/
   stat = rtxEncBit (pctxt, pvalue->m_global_eNB_IDPresent);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   /*optional bit for field global_en_gNB_ID*/
   stat = rtxEncBit (pctxt, pvalue->m_global_en_gNB_IDPresent);
   if (stat != 0) return LOG_RTERR(pctxt, stat);

   /*encode root elements*/   
   /* encode field global_eNB_ID - id = -1*/  
   if (pvalue->m_global_eNB_IDPresent) {//OPTIONAL FIELD
   RTXCTXTPUSHELEMNAME(pctxt, "global-eNB-ID");
   stat = asn1PE_e2ap_GlobalENB_ID (pctxt, pvalue->global_eNB_ID);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   }

   /* encode field global_en_gNB_ID - id = -1*/  
   if (pvalue->m_global_en_gNB_IDPresent) {//OPTIONAL FIELD
   RTXCTXTPUSHELEMNAME(pctxt, "global-en-gNB-ID");
   stat = asn1PE_e2ap_GlobalenGNB_ID (pctxt, pvalue->global_en_gNB_ID);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   }


   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_E2nodeComponentInterfaceX2 (OSCTXT* pctxt, e2ap_E2nodeComponentInterfaceX2* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME(pctxt, "E2nodeComponentInterfaceX2");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field global_eNB_ID */
   RTXCTXTPUSHELEMNAME(pctxt, "global-eNB-ID");
   if (optbits[0]) {
      pvalue->m_global_eNB_IDPresent = TRUE;
      stat = asn1PD_e2ap_GlobalENB_ID (pctxt, &pvalue->global_eNB_ID);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   } else {
      pvalue->m_global_eNB_IDPresent = FALSE;
   }
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field global_en_gNB_ID */
   RTXCTXTPUSHELEMNAME(pctxt, "global-en-gNB-ID");
   if (optbits[0]) {
      pvalue->m_global_en_gNB_IDPresent = TRUE;
      stat = asn1PD_e2ap_GlobalenGNB_ID (pctxt, &pvalue->global_en_gNB_ID);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   } else {
      pvalue->m_global_en_gNB_IDPresent = FALSE;
   }
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_E2nodeComponentInterfaceX2 (e2ap_E2nodeComponentInterfaceX2* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_GlobalENB_ID (&pvalue->global_eNB_ID);
   asn1Init_e2ap_GlobalenGNB_ID (&pvalue->global_en_gNB_ID);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_E2nodeComponentInterfaceX2 (OSCTXT* pctxt, e2ap_E2nodeComponentInterfaceX2* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_GlobalENB_ID (pctxt, &pvalue->global_eNB_ID);
   asn1Free_e2ap_GlobalenGNB_ID (pctxt, &pvalue->global_en_gNB_ID);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_E2nodeComponentInterfaceX2 (const char* name, e2ap_E2nodeComponentInterfaceX2* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }
   if(asn1PrtToStr_e2ap_GlobalENB_ID ("global_eNB_ID", &pvalue->global_eNB_ID, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_GlobalenGNB_ID ("global_en_gNB_ID", &pvalue->global_en_gNB_ID, buffer, bufSize) < 0)
   {
      return -1;
   }



   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/* e2ap_E2nodeComponentID.c */

/*****************************************/
/*           E2nodeComponentID                */
/*****************************************/
// choice
// Các nội dung cần thiết cho template choice.c.j2

// Các phần còn lại của template choice.c.j2
// choice without extension

EXTERN int asn1PE_e2ap_E2nodeComponentID (OSCTXT* pctxt, e2ap_E2nodeComponentID* pvalue)
{
   int stat = 0;
   RTXCTXTPUSHTYPENAME (pctxt, "E2nodeComponentID");
   RTXCTXTPUSHELEMNAME (pctxt, "t");
 
   stat = rtxEncBits (pctxt, pvalue->t - 1, 3);// kha nang la numbits
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   switch (pvalue->t) {
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "e2nodeComponentInterfaceTypeNG");
         stat = asn1PE_e2ap_E2nodeComponentInterfaceNG (pctxt, pvalue->u.e2nodeComponentInterfaceTypeNG); //not primitive
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         RTXCTXTPOPELEMNAME (pctxt);
         break;
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "e2nodeComponentInterfaceTypeXn");
         stat = asn1PE_e2ap_E2nodeComponentInterfaceXn (pctxt, pvalue->u.e2nodeComponentInterfaceTypeXn); //not primitive
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         RTXCTXTPOPELEMNAME (pctxt);
         break;
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "e2nodeComponentInterfaceTypeE1");
         stat = asn1PE_e2ap_E2nodeComponentInterfaceE1 (pctxt, pvalue->u.e2nodeComponentInterfaceTypeE1); //not primitive
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         RTXCTXTPOPELEMNAME (pctxt);
         break;
      case 4:
         RTXCTXTPUSHELEMNAME (pctxt, "e2nodeComponentInterfaceTypeF1");
         stat = asn1PE_e2ap_E2nodeComponentInterfaceF1 (pctxt, pvalue->u.e2nodeComponentInterfaceTypeF1); //not primitive
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         RTXCTXTPOPELEMNAME (pctxt);
         break;
      case 5:
         RTXCTXTPUSHELEMNAME (pctxt, "e2nodeComponentInterfaceTypeW1");
         stat = asn1PE_e2ap_E2nodeComponentInterfaceW1 (pctxt, pvalue->u.e2nodeComponentInterfaceTypeW1); //not primitive
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         RTXCTXTPOPELEMNAME (pctxt);
         break;
      case 6:
         RTXCTXTPUSHELEMNAME (pctxt, "e2nodeComponentInterfaceTypeS1");
         stat = asn1PE_e2ap_E2nodeComponentInterfaceS1 (pctxt, pvalue->u.e2nodeComponentInterfaceTypeS1); //not primitive
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         RTXCTXTPOPELEMNAME (pctxt);
         break;
      case 7:
         RTXCTXTPUSHELEMNAME (pctxt, "e2nodeComponentInterfaceTypeX2");
         stat = asn1PE_e2ap_E2nodeComponentInterfaceX2 (pctxt, pvalue->u.e2nodeComponentInterfaceTypeX2); //not primitive
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         RTXCTXTPOPELEMNAME (pctxt);
         break;
      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return (stat);
}

int asn1PD_e2ap_E2nodeComponentID (OSCTXT* pctxt, e2ap_E2nodeComponentID* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   RTXCTXTPUSHTYPENAME (pctxt, "E2nodeComponentID");

 
   stat = rtxDecBits (pctxt, &ui, 3);// kha nang la numbits
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;
   //RTXCTXTPOPELEMNAME (pctxt);

   switch (ui) {
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "e2nodeComponentInterfaceTypeNG");
         pvalue->u.e2nodeComponentInterfaceTypeNG = rtxMemAllocType (pctxt, e2ap_E2nodeComponentInterfaceNG);
         if (pvalue->u.e2nodeComponentInterfaceTypeNG == NULL) return LOG_RTERR (pctxt, RTERR_NOMEM);
         asn1Init_e2ap_E2nodeComponentInterfaceNG(pvalue->u.e2nodeComponentInterfaceTypeNG);
         stat = asn1PD_e2ap_E2nodeComponentInterfaceNG (pctxt, pvalue->u.e2nodeComponentInterfaceTypeNG);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         RTXCTXTPOPELEMNAME (pctxt);
         break;
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "e2nodeComponentInterfaceTypeXn");
         pvalue->u.e2nodeComponentInterfaceTypeXn = rtxMemAllocType (pctxt, e2ap_E2nodeComponentInterfaceXn);
         if (pvalue->u.e2nodeComponentInterfaceTypeXn == NULL) return LOG_RTERR (pctxt, RTERR_NOMEM);
         asn1Init_e2ap_E2nodeComponentInterfaceXn(pvalue->u.e2nodeComponentInterfaceTypeXn);
         stat = asn1PD_e2ap_E2nodeComponentInterfaceXn (pctxt, pvalue->u.e2nodeComponentInterfaceTypeXn);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         RTXCTXTPOPELEMNAME (pctxt);
         break;
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "e2nodeComponentInterfaceTypeE1");
         pvalue->u.e2nodeComponentInterfaceTypeE1 = rtxMemAllocType (pctxt, e2ap_E2nodeComponentInterfaceE1);
         if (pvalue->u.e2nodeComponentInterfaceTypeE1 == NULL) return LOG_RTERR (pctxt, RTERR_NOMEM);
         asn1Init_e2ap_E2nodeComponentInterfaceE1(pvalue->u.e2nodeComponentInterfaceTypeE1);
         stat = asn1PD_e2ap_E2nodeComponentInterfaceE1 (pctxt, pvalue->u.e2nodeComponentInterfaceTypeE1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         RTXCTXTPOPELEMNAME (pctxt);
         break;
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "e2nodeComponentInterfaceTypeF1");
         pvalue->u.e2nodeComponentInterfaceTypeF1 = rtxMemAllocType (pctxt, e2ap_E2nodeComponentInterfaceF1);
         if (pvalue->u.e2nodeComponentInterfaceTypeF1 == NULL) return LOG_RTERR (pctxt, RTERR_NOMEM);
         asn1Init_e2ap_E2nodeComponentInterfaceF1(pvalue->u.e2nodeComponentInterfaceTypeF1);
         stat = asn1PD_e2ap_E2nodeComponentInterfaceF1 (pctxt, pvalue->u.e2nodeComponentInterfaceTypeF1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         RTXCTXTPOPELEMNAME (pctxt);
         break;
      case 4:
         RTXCTXTPUSHELEMNAME (pctxt, "e2nodeComponentInterfaceTypeW1");
         pvalue->u.e2nodeComponentInterfaceTypeW1 = rtxMemAllocType (pctxt, e2ap_E2nodeComponentInterfaceW1);
         if (pvalue->u.e2nodeComponentInterfaceTypeW1 == NULL) return LOG_RTERR (pctxt, RTERR_NOMEM);
         asn1Init_e2ap_E2nodeComponentInterfaceW1(pvalue->u.e2nodeComponentInterfaceTypeW1);
         stat = asn1PD_e2ap_E2nodeComponentInterfaceW1 (pctxt, pvalue->u.e2nodeComponentInterfaceTypeW1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         RTXCTXTPOPELEMNAME (pctxt);
         break;
      case 5:
         RTXCTXTPUSHELEMNAME (pctxt, "e2nodeComponentInterfaceTypeS1");
         pvalue->u.e2nodeComponentInterfaceTypeS1 = rtxMemAllocType (pctxt, e2ap_E2nodeComponentInterfaceS1);
         if (pvalue->u.e2nodeComponentInterfaceTypeS1 == NULL) return LOG_RTERR (pctxt, RTERR_NOMEM);
         asn1Init_e2ap_E2nodeComponentInterfaceS1(pvalue->u.e2nodeComponentInterfaceTypeS1);
         stat = asn1PD_e2ap_E2nodeComponentInterfaceS1 (pctxt, pvalue->u.e2nodeComponentInterfaceTypeS1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         RTXCTXTPOPELEMNAME (pctxt);
         break;
      case 6:
         RTXCTXTPUSHELEMNAME (pctxt, "e2nodeComponentInterfaceTypeX2");
         pvalue->u.e2nodeComponentInterfaceTypeX2 = rtxMemAllocType (pctxt, e2ap_E2nodeComponentInterfaceX2);
         if (pvalue->u.e2nodeComponentInterfaceTypeX2 == NULL) return LOG_RTERR (pctxt, RTERR_NOMEM);
         asn1Init_e2ap_E2nodeComponentInterfaceX2(pvalue->u.e2nodeComponentInterfaceTypeX2);
         stat = asn1PD_e2ap_E2nodeComponentInterfaceX2 (pctxt, pvalue->u.e2nodeComponentInterfaceTypeX2);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         RTXCTXTPOPELEMNAME (pctxt);
         break;
      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return (stat);
}

int asn1PrtToStr_e2ap_E2nodeComponentID (const char* name, e2ap_E2nodeComponentID* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) return -1;
   

   switch (pvalue->t) {
      case T_e2ap_E2nodeComponentID_e2nodeComponentInterfaceTypeNG:
         if (asn1PrtToStr_e2ap_E2nodeComponentInterfaceNG ( "e2nodeComponentInterfaceTypeNG", pvalue->u.e2nodeComponentInterfaceTypeNG, buffer, bufSize) < 0) return -1;
         break;
      case T_e2ap_E2nodeComponentID_e2nodeComponentInterfaceTypeXn:
         if (asn1PrtToStr_e2ap_E2nodeComponentInterfaceXn ( "e2nodeComponentInterfaceTypeXn", pvalue->u.e2nodeComponentInterfaceTypeXn, buffer, bufSize) < 0) return -1;
         break;
      case T_e2ap_E2nodeComponentID_e2nodeComponentInterfaceTypeE1:
         if (asn1PrtToStr_e2ap_E2nodeComponentInterfaceE1 ( "e2nodeComponentInterfaceTypeE1", pvalue->u.e2nodeComponentInterfaceTypeE1, buffer, bufSize) < 0) return -1;
         break;
      case T_e2ap_E2nodeComponentID_e2nodeComponentInterfaceTypeF1:
         if (asn1PrtToStr_e2ap_E2nodeComponentInterfaceF1 ( "e2nodeComponentInterfaceTypeF1", pvalue->u.e2nodeComponentInterfaceTypeF1, buffer, bufSize) < 0) return -1;
         break;
      case T_e2ap_E2nodeComponentID_e2nodeComponentInterfaceTypeW1:
         if (asn1PrtToStr_e2ap_E2nodeComponentInterfaceW1 ( "e2nodeComponentInterfaceTypeW1", pvalue->u.e2nodeComponentInterfaceTypeW1, buffer, bufSize) < 0) return -1;
         break;
      case T_e2ap_E2nodeComponentID_e2nodeComponentInterfaceTypeS1:
         if (asn1PrtToStr_e2ap_E2nodeComponentInterfaceS1 ( "e2nodeComponentInterfaceTypeS1", pvalue->u.e2nodeComponentInterfaceTypeS1, buffer, bufSize) < 0) return -1;
         break;
      case T_e2ap_E2nodeComponentID_e2nodeComponentInterfaceTypeX2:
         if (asn1PrtToStr_e2ap_E2nodeComponentInterfaceX2 ( "e2nodeComponentInterfaceTypeX2", pvalue->u.e2nodeComponentInterfaceTypeX2, buffer, bufSize) < 0) return -1;
         break;
      default:
         return RTERR_INVOPT;
   }

   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}

int asn1Init_e2ap_E2nodeComponentID (e2ap_E2nodeComponentID* pvalue)
{
   if (pvalue == 0) return RTERR_NULLPTR;
   pvalue->t = 0;
   OSRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
   return 0;
}


void asn1Free_e2ap_E2nodeComponentID (OSCTXT* pctxt, e2ap_E2nodeComponentID* pvalue)
{
   if (pvalue == 0) return;
   switch (pvalue->t) {
      case 0: //no choice nothing to free
         break;
      case 1:
         if (pvalue->u.e2nodeComponentInterfaceTypeNG) {
            //not primitive
            asn1Free_e2ap_E2nodeComponentInterfaceNG (pctxt, pvalue->u.e2nodeComponentInterfaceTypeNG);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.e2nodeComponentInterfaceTypeNG);
            pvalue->u.e2nodeComponentInterfaceTypeNG = 0;
         }
         break;
      case 2:
         if (pvalue->u.e2nodeComponentInterfaceTypeXn) {
            //not primitive
            asn1Free_e2ap_E2nodeComponentInterfaceXn (pctxt, pvalue->u.e2nodeComponentInterfaceTypeXn);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.e2nodeComponentInterfaceTypeXn);
            pvalue->u.e2nodeComponentInterfaceTypeXn = 0;
         }
         break;
      case 3:
         if (pvalue->u.e2nodeComponentInterfaceTypeE1) {
            //not primitive
            asn1Free_e2ap_E2nodeComponentInterfaceE1 (pctxt, pvalue->u.e2nodeComponentInterfaceTypeE1);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.e2nodeComponentInterfaceTypeE1);
            pvalue->u.e2nodeComponentInterfaceTypeE1 = 0;
         }
         break;
      case 4:
         if (pvalue->u.e2nodeComponentInterfaceTypeF1) {
            //not primitive
            asn1Free_e2ap_E2nodeComponentInterfaceF1 (pctxt, pvalue->u.e2nodeComponentInterfaceTypeF1);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.e2nodeComponentInterfaceTypeF1);
            pvalue->u.e2nodeComponentInterfaceTypeF1 = 0;
         }
         break;
      case 5:
         if (pvalue->u.e2nodeComponentInterfaceTypeW1) {
            //not primitive
            asn1Free_e2ap_E2nodeComponentInterfaceW1 (pctxt, pvalue->u.e2nodeComponentInterfaceTypeW1);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.e2nodeComponentInterfaceTypeW1);
            pvalue->u.e2nodeComponentInterfaceTypeW1 = 0;
         }
         break;
      case 6:
         if (pvalue->u.e2nodeComponentInterfaceTypeS1) {
            //not primitive
            asn1Free_e2ap_E2nodeComponentInterfaceS1 (pctxt, pvalue->u.e2nodeComponentInterfaceTypeS1);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.e2nodeComponentInterfaceTypeS1);
            pvalue->u.e2nodeComponentInterfaceTypeS1 = 0;
         }
         break;
      case 7:
         if (pvalue->u.e2nodeComponentInterfaceTypeX2) {
            //not primitive
            asn1Free_e2ap_E2nodeComponentInterfaceX2 (pctxt, pvalue->u.e2nodeComponentInterfaceTypeX2);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.e2nodeComponentInterfaceTypeX2);
            pvalue->u.e2nodeComponentInterfaceTypeX2 = 0;
         }
         break;
   }
}


/*****************************************/
/*           E2nodeComponentConfiguration                */
/*****************************************/
//sequence normal
// Các nội dung cần thiết cho template seq_normal.c.j2
    // Nội dung của file .c cho primitive OCTET STRING
     /*****************************************/
/*           e2nodeComponentRequestPart                */
/*****************************************/
//octet string intergrate 
//metadata.parsed.primitive_id == 9

//-> mau la measurementtimingconfiguration
EXTERN int asn1PE_e2ap_E2nodeComponentConfiguration_e2nodeComponentRequestPart (OSCTXT* pctxt, e2ap_E2nodeComponentConfiguration_e2nodeComponentRequestPart value){
    int stat =0;
    stat = pe_OctetString(pctxt, value.numocts, value.data);
    if(stat !=0) return LOG_RTERR(pctxt, stat);
    return stat;
}
EXTERN int asn1PD_e2ap_E2nodeComponentConfiguration_e2nodeComponentRequestPart (OSCTXT* pctxt, e2ap_E2nodeComponentConfiguration_e2nodeComponentRequestPart* pvalue){
    int stat =0;
    stat = pd_DynOctetString(pctxt, pvalue);
    if(stat !=0) return LOG_RTERR(pctxt, stat);
    return stat;
}
EXTERN int asn1PrtToStr_e2ap_E2nodeComponentConfiguration_e2nodeComponentRequestPart (const char* name, e2ap_E2nodeComponentConfiguration_e2nodeComponentRequestPart *pvalue, char* buffer, OSSIZE bufSize){
    if(rtPrintToStringIndent(buffer, bufSize) < 0) return -1;
    if(rtPrintToStringHexStr(name, pvalue->numocts, pvalue->data, buffer, bufSize) < 0) return -1;
    return 0;
}
EXTERN int asn1PrtToStrm_e2ap_E2nodeComponentConfiguration_e2nodeComponentRequestPart (OSCTXT* pctxt, const char* name, const e2ap_E2nodeComponentConfiguration_e2nodeComponentRequestPart* pvalue){
    int stat =0;
    stat = rtPrintToStreamIndent(pctxt);
    if(stat !=0) return LOG_RTERR(pctxt, stat);
    stat = rtPrintToStreamHexStr(pctxt, name, pvalue->numocts, pvalue->data);
    if(stat !=0) return LOG_RTERR(pctxt, stat);
    return stat;
}
EXTERN int asn1Copy_e2ap_E2nodeComponentConfiguration_e2nodeComponentRequestPart (OSCTXT* pctxt, const e2ap_E2nodeComponentConfiguration_e2nodeComponentRequestPart* pSrcValue, e2ap_E2nodeComponentConfiguration_e2nodeComponentRequestPart* pDstValue);
EXTERN int asn1Init_e2ap_E2nodeComponentConfiguration_e2nodeComponentRequestPart (e2ap_E2nodeComponentConfiguration_e2nodeComponentRequestPart* pvalue){
    pvalue->numocts = 0;
    pvalue->data = 0;
    return 0;
}
EXTERN void asn1Free_e2ap_E2nodeComponentConfiguration_e2nodeComponentRequestPart (OSCTXT* pctxt, e2ap_E2nodeComponentConfiguration_e2nodeComponentRequestPart* pvalue){
    if(pvalue->numocts >0){
        rtFreeMemPtr(pctxt, (void*)pvalue->data);
        pvalue->numocts =0;
        pvalue->data =0;
    }
}

    // Nội dung của file .c cho primitive OCTET STRING
     /*****************************************/
/*           e2nodeComponentResponsePart                */
/*****************************************/
//octet string intergrate 
//metadata.parsed.primitive_id == 9

//-> mau la measurementtimingconfiguration
EXTERN int asn1PE_e2ap_E2nodeComponentConfiguration_e2nodeComponentResponsePart (OSCTXT* pctxt, e2ap_E2nodeComponentConfiguration_e2nodeComponentResponsePart value){
    int stat =0;
    stat = pe_OctetString(pctxt, value.numocts, value.data);
    if(stat !=0) return LOG_RTERR(pctxt, stat);
    return stat;
}
EXTERN int asn1PD_e2ap_E2nodeComponentConfiguration_e2nodeComponentResponsePart (OSCTXT* pctxt, e2ap_E2nodeComponentConfiguration_e2nodeComponentResponsePart* pvalue){
    int stat =0;
    stat = pd_DynOctetString(pctxt, pvalue);
    if(stat !=0) return LOG_RTERR(pctxt, stat);
    return stat;
}
EXTERN int asn1PrtToStr_e2ap_E2nodeComponentConfiguration_e2nodeComponentResponsePart (const char* name, e2ap_E2nodeComponentConfiguration_e2nodeComponentResponsePart *pvalue, char* buffer, OSSIZE bufSize){
    if(rtPrintToStringIndent(buffer, bufSize) < 0) return -1;
    if(rtPrintToStringHexStr(name, pvalue->numocts, pvalue->data, buffer, bufSize) < 0) return -1;
    return 0;
}
EXTERN int asn1PrtToStrm_e2ap_E2nodeComponentConfiguration_e2nodeComponentResponsePart (OSCTXT* pctxt, const char* name, const e2ap_E2nodeComponentConfiguration_e2nodeComponentResponsePart* pvalue){
    int stat =0;
    stat = rtPrintToStreamIndent(pctxt);
    if(stat !=0) return LOG_RTERR(pctxt, stat);
    stat = rtPrintToStreamHexStr(pctxt, name, pvalue->numocts, pvalue->data);
    if(stat !=0) return LOG_RTERR(pctxt, stat);
    return stat;
}
EXTERN int asn1Copy_e2ap_E2nodeComponentConfiguration_e2nodeComponentResponsePart (OSCTXT* pctxt, const e2ap_E2nodeComponentConfiguration_e2nodeComponentResponsePart* pSrcValue, e2ap_E2nodeComponentConfiguration_e2nodeComponentResponsePart* pDstValue);
EXTERN int asn1Init_e2ap_E2nodeComponentConfiguration_e2nodeComponentResponsePart (e2ap_E2nodeComponentConfiguration_e2nodeComponentResponsePart* pvalue){
    pvalue->numocts = 0;
    pvalue->data = 0;
    return 0;
}
EXTERN void asn1Free_e2ap_E2nodeComponentConfiguration_e2nodeComponentResponsePart (OSCTXT* pctxt, e2ap_E2nodeComponentConfiguration_e2nodeComponentResponsePart* pvalue){
    if(pvalue->numocts >0){
        rtFreeMemPtr(pctxt, (void*)pvalue->data);
        pvalue->numocts =0;
        pvalue->data =0;
    }
}


// Các phần còn lại của template seq_normal.c.j2
//contain extensition bit -> theo mau cua GlobalgNB-ID
int asn1PE_e2ap_E2nodeComponentConfiguration (OSCTXT* pctxt, e2ap_E2nodeComponentConfiguration* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "E2nodeComponentConfiguration");

   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field e2nodeComponentRequestPart - id = 9*/  
   RTXCTXTPUSHELEMNAME(pctxt, "e2nodeComponentRequestPart");
  
   stat = asn1PE_e2ap_E2nodeComponentConfiguration_e2nodeComponentRequestPart(pctxt, pvalue->e2nodeComponentRequestPart); //octet string no size - mau 9
  
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /* encode field e2nodeComponentResponsePart - id = 9*/  
   RTXCTXTPUSHELEMNAME(pctxt, "e2nodeComponentResponsePart");
  
   stat = asn1PE_e2ap_E2nodeComponentConfiguration_e2nodeComponentResponsePart(pctxt, pvalue->e2nodeComponentResponsePart); //octet string no size - mau 9
  
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);



   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_E2nodeComponentConfiguration (OSCTXT* pctxt, e2ap_E2nodeComponentConfiguration* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME(pctxt, "E2nodeComponentConfiguration");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field e2nodeComponentRequestPart */
   RTXCTXTPUSHELEMNAME(pctxt, "e2nodeComponentRequestPart");
      stat = asn1PD_e2ap_E2nodeComponentConfiguration_e2nodeComponentRequestPart (pctxt, &pvalue->e2nodeComponentRequestPart); //primitive
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field e2nodeComponentResponsePart */
   RTXCTXTPUSHELEMNAME(pctxt, "e2nodeComponentResponsePart");
      stat = asn1PD_e2ap_E2nodeComponentConfiguration_e2nodeComponentResponsePart (pctxt, &pvalue->e2nodeComponentResponsePart); //primitive
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_E2nodeComponentConfiguration (e2ap_E2nodeComponentConfiguration* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_E2nodeComponentConfiguration_e2nodeComponentRequestPart (&pvalue->e2nodeComponentRequestPart); //primitive delete &
   asn1Init_e2ap_E2nodeComponentConfiguration_e2nodeComponentResponsePart (&pvalue->e2nodeComponentResponsePart); //primitive delete &
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_E2nodeComponentConfiguration (OSCTXT* pctxt, e2ap_E2nodeComponentConfiguration* pvalue)
{
   if(0==pvalue) return;
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_E2nodeComponentConfiguration (const char* name, e2ap_E2nodeComponentConfiguration* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }

   if(asn1PrtToStr_e2ap_E2nodeComponentConfiguration_e2nodeComponentRequestPart ("e2nodeComponentRequestPart", &pvalue->e2nodeComponentRequestPart, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_E2nodeComponentConfiguration_e2nodeComponentResponsePart ("e2nodeComponentResponsePart", &pvalue->e2nodeComponentResponsePart, buffer, bufSize) < 0)
   {
      return -1;
   }


   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}
/*****************************************/
/*           E2nodeComponentConfigAddition-Item                */
/*****************************************/
//sequence normal
// Các nội dung cần thiết cho template seq_normal.c.j2

// Các phần còn lại của template seq_normal.c.j2
//contain extensition bit -> theo mau cua GlobalgNB-ID
int asn1PE_e2ap_E2nodeComponentConfigAddition_Item (OSCTXT* pctxt, e2ap_E2nodeComponentConfigAddition_Item* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "E2nodeComponentConfigAddition-Item");

   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field e2nodeComponentInterfaceType - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "e2nodeComponentInterfaceType");
   stat = asn1PE_e2ap_E2nodeComponentInterfaceType (pctxt, pvalue->e2nodeComponentInterfaceType);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /* encode field e2nodeComponentID - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "e2nodeComponentID");
   stat = asn1PE_e2ap_E2nodeComponentID (pctxt, pvalue->e2nodeComponentID);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /* encode field e2nodeComponentConfiguration - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "e2nodeComponentConfiguration");
   stat = asn1PE_e2ap_E2nodeComponentConfiguration (pctxt, pvalue->e2nodeComponentConfiguration);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);



   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_E2nodeComponentConfigAddition_Item (OSCTXT* pctxt, e2ap_E2nodeComponentConfigAddition_Item* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[3];

   RTXCTXTPUSHTYPENAME(pctxt, "E2nodeComponentConfigAddition-Item");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field e2nodeComponentInterfaceType */
   RTXCTXTPUSHELEMNAME(pctxt, "e2nodeComponentInterfaceType");
      stat = asn1PD_e2ap_E2nodeComponentInterfaceType (pctxt, &pvalue->e2nodeComponentInterfaceType);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field e2nodeComponentID */
   RTXCTXTPUSHELEMNAME(pctxt, "e2nodeComponentID");
      stat = asn1PD_e2ap_E2nodeComponentID (pctxt, &pvalue->e2nodeComponentID);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field e2nodeComponentConfiguration */
   RTXCTXTPUSHELEMNAME(pctxt, "e2nodeComponentConfiguration");
      stat = asn1PD_e2ap_E2nodeComponentConfiguration (pctxt, &pvalue->e2nodeComponentConfiguration);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_E2nodeComponentConfigAddition_Item (e2ap_E2nodeComponentConfigAddition_Item* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_E2nodeComponentInterfaceType (&pvalue->e2nodeComponentInterfaceType);
   asn1Init_e2ap_E2nodeComponentID (&pvalue->e2nodeComponentID);
   asn1Init_e2ap_E2nodeComponentConfiguration (&pvalue->e2nodeComponentConfiguration);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_E2nodeComponentConfigAddition_Item (OSCTXT* pctxt, e2ap_E2nodeComponentConfigAddition_Item* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_E2nodeComponentInterfaceType (pctxt, &pvalue->e2nodeComponentInterfaceType);
   asn1Free_e2ap_E2nodeComponentID (pctxt, &pvalue->e2nodeComponentID);
   asn1Free_e2ap_E2nodeComponentConfiguration (pctxt, &pvalue->e2nodeComponentConfiguration);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_E2nodeComponentConfigAddition_Item (const char* name, e2ap_E2nodeComponentConfigAddition_Item* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }
   if(asn1PrtToStr_e2ap_E2nodeComponentInterfaceType ("e2nodeComponentInterfaceType", &pvalue->e2nodeComponentInterfaceType, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_E2nodeComponentID ("e2nodeComponentID", &pvalue->e2nodeComponentID, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_E2nodeComponentConfiguration ("e2nodeComponentConfiguration", &pvalue->e2nodeComponentConfiguration, buffer, bufSize) < 0)
   {
      return -1;
   }



   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           E2nodeComponentConfigAddition_ItemIEs                */
/*****************************************/
/* ie.c.j2 */
/*ie thường*/
int asn1PE_e2ap_E2nodeComponentConfigAddition_ItemIEs (OSCTXT* pctxt, e2ap_E2nodeComponentConfigAddition_ItemIEs* pvalue)
{
   int stat = 0;
   //RTXCTXTPUSHTYPENAME (pctxt, "E2nodeComponentConfigAddition-ItemIEs");

   /* encode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");
   stat = asn1PE_e2ap_ProtocolIE_ID (pctxt, pvalue->id);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");
   stat = asn1PE_e2ap_Criticality (pctxt, pvalue->criticality);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   {
      OSCTXT ictxt;
      OSOCTET* pDynamicEncodeBuffer;
      ASN1OpenType openType;
      OSBOOL  encoded = TRUE;

      openType.numocts = 0;
      openType.data = 0;

      rtxCopyContext (&ictxt, pctxt);
      pctxt->pStream = 0;

      stat = rtxInitContextBuffer (pctxt, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_E2nodeComponentConfigAddition_ItemIEs_id_E2nodeComponentConfigAddition_Item:
         
        // RTXCTXTPUSHELEMNAME (pctxt, "E2nodeComponentConfigAddition_ItemIEs_id_E2nodeComponentConfigAddition_Item");
         RTXCTXTPUSHELEMNAME (pctxt, "E2nodeComponentConfigAddition-Item");
         stat = asn1PE_e2ap_E2nodeComponentConfigAddition_Item (pctxt, pvalue->value.u._e2apE2nodeComponentConfigAddition_ItemIEs_id_E2nodeComponentConfigAddition_Item);
         RTXCTXTPOPELEMNAME (pctxt);
      
         break;

      case T_E2AP_PDU_Contents_e2ap_E2nodeComponentConfigAddition_ItemIEs_UNDEF_:
      {
          if(0!=pvalue->value.u.extElem1){
              openType.numocts = pvalue->value.u.extElem1->numocts;
              openType.data = pvalue->value.u.extElem1->data;
          } else {
              /* No extension element to encode */
          }
          encoded = FALSE;
          break;
      }
      default:
         encoded = FALSE;
         stat = RTERR_INVOPT;
      }

      if (encoded) {
         openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
         openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
      }
      rtxCopyContext (pctxt, &ictxt);
      if(stat ==0) stat = pe_OpenType(pctxt, openType.numocts, openType.data);
      /*free dynamic encode buffer*/
      if(encoded){
          rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
      }
   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);
   //RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

int asn1PD_e2ap_E2nodeComponentConfigAddition_ItemIEs (OSCTXT* pctxt, e2ap_E2nodeComponentConfigAddition_ItemIEs* pvalue)
{
   int stat =0;
   /*deode root element id*/
   RTXCTXTPUSHELEMNAME(pctxt, "id");
   stat = asn1PD_e2ap_ProtocolIE_ID (pctxt, &pvalue->id);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*decode root element criticality*/
   RTXCTXTPUSHELEMNAME(pctxt, "criticality");
   stat = asn1PD_e2ap_Criticality (pctxt, &pvalue->criticality);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   /*decode root element value*/
   RTXCTXTPUSHELEMNAME(pctxt, "value");
   {
      OSUINT32 openTypeLen;
      size_t bitStartOffset, bitLength;
      stat = pd_UnconsLength(pctxt, &openTypeLen);
      if(stat <0) return LOG_RTERR(pctxt, stat);
      else if(stat == RT_OK_FRAG){
         rtxErrAddStrParm(pctxt, "open type with fragmented length use - perindef");
         return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
      }
      bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
      bitLength = openTypeLen * 8;
      switch (pvalue->id){
         case T_E2AP_PDU_Contents_e2ap_E2nodeComponentConfigAddition_ItemIEs_id_E2nodeComponentConfigAddition_Item:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_E2nodeComponentConfigAddition_ItemIEs_id_E2nodeComponentConfigAddition_Item;
            RTXCTXTPUSHELEMNAME(pctxt, "E2nodeComponentConfigAddition-Item");
            //pvalue->value.u._e2ap_E2nodeComponentConfigAddition_ItemIEs_id_id_E2nodeComponentConfigAddition_Item 
             pvalue->value.u._e2apE2nodeComponentConfigAddition_ItemIEs_id_E2nodeComponentConfigAddition_Item 
                    = rtxMemAllocType(pctxt, e2ap_E2nodeComponentConfigAddition_Item);
            //asn1Init_e2ap_E2nodeComponentConfigAddition_Item(pvalue->value.u._e2ap_E2nodeComponentConfigAddition_ItemIEs_id_id_E2nodeComponentConfigAddition_Item);
            asn1Init_e2ap_E2nodeComponentConfigAddition_Item(pvalue->value.u._e2apE2nodeComponentConfigAddition_ItemIEs_id_E2nodeComponentConfigAddition_Item);
            stat = asn1PD_e2ap_E2nodeComponentConfigAddition_Item (pctxt,
                    (e2ap_E2nodeComponentConfigAddition_Item*)pvalue->value.
                    u._e2apE2nodeComponentConfigAddition_ItemIEs_id_E2nodeComponentConfigAddition_Item);
            if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_E2nodeComponentConfigAddition_ItemIEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*)rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
      }
      {
      size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
      size_t bitsConsumed = bitEndOffset - bitStartOffset;
      if(bitsConsumed < bitLength){
         stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
      } else {
         stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
      }
      }
   }
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   return stat;
}

void asn1Init_e2ap_E2nodeComponentConfigAddition_ItemIEs (e2ap_E2nodeComponentConfigAddition_ItemIEs* pvalue)
{
   if (!pvalue) return;
   OSCRTLMEMSET (pvalue, 0, sizeof(e2ap_E2nodeComponentConfigAddition_ItemIEs));
}

#if 0
void asn1Free_e2ap_E2nodeComponentConfigAddition_ItemIEs (OSCTXT* pctxt, e2ap_E2nodeComponentConfigAddition_ItemIEs* pvalue)
{
   if (!pvalue) return;
   if (pvalue->extElem1) {
      rtxMemFreeArray (pctxt, pvalue->extElem1);
      pvalue->extElem1 = 0;
      pvalue->extElem1_n = 0;
   }
}
#endif
void asn1Free_e2ap_E2nodeComponentConfigAddition_ItemIEs (OSCTXT* pctxt, e2ap_E2nodeComponentConfigAddition_ItemIEs* pvalue)
{
   if(0==pvalue) return;
   switch(pvalue->value.t){
      case T_E2AP_PDU_Contents_e2ap_E2nodeComponentConfigAddition_ItemIEs_id_E2nodeComponentConfigAddition_Item:
         asn1Free_e2ap_E2nodeComponentConfigAddition_Item (pctxt, pvalue->value.u._e2apE2nodeComponentConfigAddition_ItemIEs_id_E2nodeComponentConfigAddition_Item);
         rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2apE2nodeComponentConfigAddition_ItemIEs_id_E2nodeComponentConfigAddition_Item);
         pvalue->value.u._e2apE2nodeComponentConfigAddition_ItemIEs_id_E2nodeComponentConfigAddition_Item = 0;
         break;
      case T_E2AP_PDU_Contents_e2ap_E2nodeComponentConfigAddition_ItemIEs_UNDEF_:
         if(0!=pvalue->value.u.extElem1){
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1->data);
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
             pvalue->value.u.extElem1 =0;
         }
         break;
         default:;
   }
}

int  asn1PrtToStr_e2ap_E2nodeComponentConfigAddition_ItemIEs (const char * name, e2ap_E2nodeComponentConfigAddition_ItemIEs* pvalue, char * buffer, OSSIZE bufSize){
   if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
       return -1;

      if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
         return -1;

      if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
         return -1;
      if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
         return -1;
      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_E2nodeComponentConfigAddition_ItemIEs_id_E2nodeComponentConfigAddition_Item:
         if(asn1PrtToStr_e2ap_E2nodeComponentConfigAddition_Item("E2nodeComponentConfigAddition-Item",
                pvalue->value.u._e2apE2nodeComponentConfigAddition_ItemIEs_id_E2nodeComponentConfigAddition_Item, buffer, bufSize)<0)// dungnm23 check lai nhe xem la
            return -1;
         break;
      default:
         if(0!=pvalue -> value.u.extElem1){
             rtPrintToStringIndent(buffer, bufSize);
             rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

         }
      }
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

      return 0;

}
 

/*****************************************/
/*           E2nodeComponentConfigAddition_List                */
/*****************************************/
//seq_of_single_container


int asn1PE_e2ap_E2nodeComponentConfigAddition_List (OSCTXT* pctxt, e2ap_E2nodeComponentConfigAddition_List* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_E2nodeComponentConfigAddition_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "E2nodeComponentConfigAddition-List");

   /* encode length determinant */
   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1024), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;
   for (xx1 = 0; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next, xx1++) {
      pdata = (e2ap_E2nodeComponentConfigAddition_ItemIEs*) pnode->data;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_e2ap_E2nodeComponentConfigAddition_ItemIEs (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      //xx1++;
      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}

int asn1PD_e2ap_E2nodeComponentConfigAddition_List (OSCTXT* pctxt, e2ap_E2nodeComponentConfigAddition_List* ppvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_E2nodeComponentConfigAddition_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "E2nodeComponentConfigAddition-List");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1024), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (ppvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      pdata = rtxMemAllocType (pctxt, e2ap_E2nodeComponentConfigAddition_ItemIEs);
      if (!pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);
      asn1Init_e2ap_E2nodeComponentConfigAddition_ItemIEs (pdata);
      stat = asn1PD_e2ap_E2nodeComponentConfigAddition_ItemIEs (pctxt, pdata);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         return LOG_RTERR (pctxt, stat);
      }

      rtxDListAppendNode (ppvalue, pdata);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

void asn1Init_e2ap_E2nodeComponentConfigAddition_List (e2ap_E2nodeComponentConfigAddition_List* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
}

void asn1Free_e2ap_E2nodeComponentConfigAddition_List (OSCTXT* pctxt, e2ap_E2nodeComponentConfigAddition_List* pvalue)
{
   if(pvalue==0) return;
   OSRTDListNode* pnode = pvalue->head;
   while (pnode) {
      e2ap_E2nodeComponentConfigAddition_ItemIEs* pdata = (e2ap_E2nodeComponentConfigAddition_ItemIEs*) pnode->data;
      if (pdata) {
         asn1Free_e2ap_E2nodeComponentConfigAddition_ItemIEs (pctxt, pdata);
         rtxMemFreePtr (pctxt, pdata);
      }
      pnode = pnode->next;
   }
      rtxDListFreeAll(pctxt, pvalue);
}

#if 0
void asn1Free_e2ap_E2nodeComponentConfigAddition_List (OSCTXT* pctxt, e2ap_E2nodeComponentConfigAddition_List* pvalue){
   if(0==pvalue ) return;
   {
      e2ap_E2nodeComponentConfigAddition_ItemIEs * pdata;
      OSRTDListNode *pnode = pvalue->head;
      while(0!=pnode){
         pdata = (e2ap_E2nodeComponentConfigAddition_ItemIEs*)pnode->data;
         asn1Free_e2ap_E2nodeComponentConfigAddition_ItemIEs(pctxt, pdata);
         pnode = pnode->next;
      }
      rtxDListFreeAll(pctxt, pvalue);
   }
}
#endif


int asn1PrtToStr_e2ap_E2nodeComponentConfigAddition_List(const char* name, e2ap_E2nodeComponentConfigAddition_List* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_E2nodeComponentConfigAddition_ItemIEs* pdata;
    OSRTDListNode* pnode;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode = pvalue->head;  xx1 < pvalue->count && pnode != 0; pnode = pnode->next, xx1++){
        pdata = (e2ap_E2nodeComponentConfigAddition_ItemIEs*)pnode->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 1
        if(asn1PrtToStr_e2ap_E2nodeComponentConfigAddition_ItemIEs(nameBuf, pdata, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}
/*****************************************/
/*           E2nodeComponentConfigUpdate-Item                */
/*****************************************/
//sequence normal
// Các nội dung cần thiết cho template seq_normal.c.j2

// Các phần còn lại của template seq_normal.c.j2
//contain extensition bit -> theo mau cua GlobalgNB-ID
int asn1PE_e2ap_E2nodeComponentConfigUpdate_Item (OSCTXT* pctxt, e2ap_E2nodeComponentConfigUpdate_Item* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "E2nodeComponentConfigUpdate-Item");

   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field e2nodeComponentInterfaceType - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "e2nodeComponentInterfaceType");
   stat = asn1PE_e2ap_E2nodeComponentInterfaceType (pctxt, pvalue->e2nodeComponentInterfaceType);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /* encode field e2nodeComponentID - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "e2nodeComponentID");
   stat = asn1PE_e2ap_E2nodeComponentID (pctxt, pvalue->e2nodeComponentID);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /* encode field e2nodeComponentConfiguration - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "e2nodeComponentConfiguration");
   stat = asn1PE_e2ap_E2nodeComponentConfiguration (pctxt, pvalue->e2nodeComponentConfiguration);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);



   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_E2nodeComponentConfigUpdate_Item (OSCTXT* pctxt, e2ap_E2nodeComponentConfigUpdate_Item* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[3];

   RTXCTXTPUSHTYPENAME(pctxt, "E2nodeComponentConfigUpdate-Item");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field e2nodeComponentInterfaceType */
   RTXCTXTPUSHELEMNAME(pctxt, "e2nodeComponentInterfaceType");
      stat = asn1PD_e2ap_E2nodeComponentInterfaceType (pctxt, &pvalue->e2nodeComponentInterfaceType);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field e2nodeComponentID */
   RTXCTXTPUSHELEMNAME(pctxt, "e2nodeComponentID");
      stat = asn1PD_e2ap_E2nodeComponentID (pctxt, &pvalue->e2nodeComponentID);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field e2nodeComponentConfiguration */
   RTXCTXTPUSHELEMNAME(pctxt, "e2nodeComponentConfiguration");
      stat = asn1PD_e2ap_E2nodeComponentConfiguration (pctxt, &pvalue->e2nodeComponentConfiguration);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_E2nodeComponentConfigUpdate_Item (e2ap_E2nodeComponentConfigUpdate_Item* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_E2nodeComponentInterfaceType (&pvalue->e2nodeComponentInterfaceType);
   asn1Init_e2ap_E2nodeComponentID (&pvalue->e2nodeComponentID);
   asn1Init_e2ap_E2nodeComponentConfiguration (&pvalue->e2nodeComponentConfiguration);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_E2nodeComponentConfigUpdate_Item (OSCTXT* pctxt, e2ap_E2nodeComponentConfigUpdate_Item* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_E2nodeComponentInterfaceType (pctxt, &pvalue->e2nodeComponentInterfaceType);
   asn1Free_e2ap_E2nodeComponentID (pctxt, &pvalue->e2nodeComponentID);
   asn1Free_e2ap_E2nodeComponentConfiguration (pctxt, &pvalue->e2nodeComponentConfiguration);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_E2nodeComponentConfigUpdate_Item (const char* name, e2ap_E2nodeComponentConfigUpdate_Item* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }
   if(asn1PrtToStr_e2ap_E2nodeComponentInterfaceType ("e2nodeComponentInterfaceType", &pvalue->e2nodeComponentInterfaceType, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_E2nodeComponentID ("e2nodeComponentID", &pvalue->e2nodeComponentID, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_E2nodeComponentConfiguration ("e2nodeComponentConfiguration", &pvalue->e2nodeComponentConfiguration, buffer, bufSize) < 0)
   {
      return -1;
   }



   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           E2nodeComponentConfigUpdate_ItemIEs                */
/*****************************************/
/* ie.c.j2 */
/*ie thường*/
int asn1PE_e2ap_E2nodeComponentConfigUpdate_ItemIEs (OSCTXT* pctxt, e2ap_E2nodeComponentConfigUpdate_ItemIEs* pvalue)
{
   int stat = 0;
   //RTXCTXTPUSHTYPENAME (pctxt, "E2nodeComponentConfigUpdate-ItemIEs");

   /* encode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");
   stat = asn1PE_e2ap_ProtocolIE_ID (pctxt, pvalue->id);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");
   stat = asn1PE_e2ap_Criticality (pctxt, pvalue->criticality);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   {
      OSCTXT ictxt;
      OSOCTET* pDynamicEncodeBuffer;
      ASN1OpenType openType;
      OSBOOL  encoded = TRUE;

      openType.numocts = 0;
      openType.data = 0;

      rtxCopyContext (&ictxt, pctxt);
      pctxt->pStream = 0;

      stat = rtxInitContextBuffer (pctxt, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_E2nodeComponentConfigUpdate_ItemIEs_id_E2nodeComponentConfigUpdate_Item:
         
        // RTXCTXTPUSHELEMNAME (pctxt, "E2nodeComponentConfigUpdate_ItemIEs_id_E2nodeComponentConfigUpdate_Item");
         RTXCTXTPUSHELEMNAME (pctxt, "E2nodeComponentConfigUpdate-Item");
         stat = asn1PE_e2ap_E2nodeComponentConfigUpdate_Item (pctxt, pvalue->value.u._e2apE2nodeComponentConfigUpdate_ItemIEs_id_E2nodeComponentConfigUpdate_Item);
         RTXCTXTPOPELEMNAME (pctxt);
      
         break;

      case T_E2AP_PDU_Contents_e2ap_E2nodeComponentConfigUpdate_ItemIEs_UNDEF_:
      {
          if(0!=pvalue->value.u.extElem1){
              openType.numocts = pvalue->value.u.extElem1->numocts;
              openType.data = pvalue->value.u.extElem1->data;
          } else {
              /* No extension element to encode */
          }
          encoded = FALSE;
          break;
      }
      default:
         encoded = FALSE;
         stat = RTERR_INVOPT;
      }

      if (encoded) {
         openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
         openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
      }
      rtxCopyContext (pctxt, &ictxt);
      if(stat ==0) stat = pe_OpenType(pctxt, openType.numocts, openType.data);
      /*free dynamic encode buffer*/
      if(encoded){
          rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
      }
   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);
   //RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

int asn1PD_e2ap_E2nodeComponentConfigUpdate_ItemIEs (OSCTXT* pctxt, e2ap_E2nodeComponentConfigUpdate_ItemIEs* pvalue)
{
   int stat =0;
   /*deode root element id*/
   RTXCTXTPUSHELEMNAME(pctxt, "id");
   stat = asn1PD_e2ap_ProtocolIE_ID (pctxt, &pvalue->id);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*decode root element criticality*/
   RTXCTXTPUSHELEMNAME(pctxt, "criticality");
   stat = asn1PD_e2ap_Criticality (pctxt, &pvalue->criticality);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   /*decode root element value*/
   RTXCTXTPUSHELEMNAME(pctxt, "value");
   {
      OSUINT32 openTypeLen;
      size_t bitStartOffset, bitLength;
      stat = pd_UnconsLength(pctxt, &openTypeLen);
      if(stat <0) return LOG_RTERR(pctxt, stat);
      else if(stat == RT_OK_FRAG){
         rtxErrAddStrParm(pctxt, "open type with fragmented length use - perindef");
         return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
      }
      bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
      bitLength = openTypeLen * 8;
      switch (pvalue->id){
         case T_E2AP_PDU_Contents_e2ap_E2nodeComponentConfigUpdate_ItemIEs_id_E2nodeComponentConfigUpdate_Item:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_E2nodeComponentConfigUpdate_ItemIEs_id_E2nodeComponentConfigUpdate_Item;
            RTXCTXTPUSHELEMNAME(pctxt, "E2nodeComponentConfigUpdate-Item");
            //pvalue->value.u._e2ap_E2nodeComponentConfigUpdate_ItemIEs_id_id_E2nodeComponentConfigUpdate_Item 
             pvalue->value.u._e2apE2nodeComponentConfigUpdate_ItemIEs_id_E2nodeComponentConfigUpdate_Item 
                    = rtxMemAllocType(pctxt, e2ap_E2nodeComponentConfigUpdate_Item);
            //asn1Init_e2ap_E2nodeComponentConfigUpdate_Item(pvalue->value.u._e2ap_E2nodeComponentConfigUpdate_ItemIEs_id_id_E2nodeComponentConfigUpdate_Item);
            asn1Init_e2ap_E2nodeComponentConfigUpdate_Item(pvalue->value.u._e2apE2nodeComponentConfigUpdate_ItemIEs_id_E2nodeComponentConfigUpdate_Item);
            stat = asn1PD_e2ap_E2nodeComponentConfigUpdate_Item (pctxt,
                    (e2ap_E2nodeComponentConfigUpdate_Item*)pvalue->value.
                    u._e2apE2nodeComponentConfigUpdate_ItemIEs_id_E2nodeComponentConfigUpdate_Item);
            if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_E2nodeComponentConfigUpdate_ItemIEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*)rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
      }
      {
      size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
      size_t bitsConsumed = bitEndOffset - bitStartOffset;
      if(bitsConsumed < bitLength){
         stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
      } else {
         stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
      }
      }
   }
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   return stat;
}

void asn1Init_e2ap_E2nodeComponentConfigUpdate_ItemIEs (e2ap_E2nodeComponentConfigUpdate_ItemIEs* pvalue)
{
   if (!pvalue) return;
   OSCRTLMEMSET (pvalue, 0, sizeof(e2ap_E2nodeComponentConfigUpdate_ItemIEs));
}

#if 0
void asn1Free_e2ap_E2nodeComponentConfigUpdate_ItemIEs (OSCTXT* pctxt, e2ap_E2nodeComponentConfigUpdate_ItemIEs* pvalue)
{
   if (!pvalue) return;
   if (pvalue->extElem1) {
      rtxMemFreeArray (pctxt, pvalue->extElem1);
      pvalue->extElem1 = 0;
      pvalue->extElem1_n = 0;
   }
}
#endif
void asn1Free_e2ap_E2nodeComponentConfigUpdate_ItemIEs (OSCTXT* pctxt, e2ap_E2nodeComponentConfigUpdate_ItemIEs* pvalue)
{
   if(0==pvalue) return;
   switch(pvalue->value.t){
      case T_E2AP_PDU_Contents_e2ap_E2nodeComponentConfigUpdate_ItemIEs_id_E2nodeComponentConfigUpdate_Item:
         asn1Free_e2ap_E2nodeComponentConfigUpdate_Item (pctxt, pvalue->value.u._e2apE2nodeComponentConfigUpdate_ItemIEs_id_E2nodeComponentConfigUpdate_Item);
         rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2apE2nodeComponentConfigUpdate_ItemIEs_id_E2nodeComponentConfigUpdate_Item);
         pvalue->value.u._e2apE2nodeComponentConfigUpdate_ItemIEs_id_E2nodeComponentConfigUpdate_Item = 0;
         break;
      case T_E2AP_PDU_Contents_e2ap_E2nodeComponentConfigUpdate_ItemIEs_UNDEF_:
         if(0!=pvalue->value.u.extElem1){
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1->data);
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
             pvalue->value.u.extElem1 =0;
         }
         break;
         default:;
   }
}

int  asn1PrtToStr_e2ap_E2nodeComponentConfigUpdate_ItemIEs (const char * name, e2ap_E2nodeComponentConfigUpdate_ItemIEs* pvalue, char * buffer, OSSIZE bufSize){
   if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
       return -1;

      if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
         return -1;

      if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
         return -1;
      if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
         return -1;
      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_E2nodeComponentConfigUpdate_ItemIEs_id_E2nodeComponentConfigUpdate_Item:
         if(asn1PrtToStr_e2ap_E2nodeComponentConfigUpdate_Item("E2nodeComponentConfigUpdate-Item",
                pvalue->value.u._e2apE2nodeComponentConfigUpdate_ItemIEs_id_E2nodeComponentConfigUpdate_Item, buffer, bufSize)<0)// dungnm23 check lai nhe xem la
            return -1;
         break;
      default:
         if(0!=pvalue -> value.u.extElem1){
             rtPrintToStringIndent(buffer, bufSize);
             rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

         }
      }
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

      return 0;

}
 

/*****************************************/
/*           E2nodeComponentConfigUpdate_List                */
/*****************************************/
//seq_of_single_container


int asn1PE_e2ap_E2nodeComponentConfigUpdate_List (OSCTXT* pctxt, e2ap_E2nodeComponentConfigUpdate_List* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_E2nodeComponentConfigUpdate_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "E2nodeComponentConfigUpdate-List");

   /* encode length determinant */
   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1024), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;
   for (xx1 = 0; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next, xx1++) {
      pdata = (e2ap_E2nodeComponentConfigUpdate_ItemIEs*) pnode->data;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_e2ap_E2nodeComponentConfigUpdate_ItemIEs (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      //xx1++;
      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}

int asn1PD_e2ap_E2nodeComponentConfigUpdate_List (OSCTXT* pctxt, e2ap_E2nodeComponentConfigUpdate_List* ppvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_E2nodeComponentConfigUpdate_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "E2nodeComponentConfigUpdate-List");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1024), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (ppvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      pdata = rtxMemAllocType (pctxt, e2ap_E2nodeComponentConfigUpdate_ItemIEs);
      if (!pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);
      asn1Init_e2ap_E2nodeComponentConfigUpdate_ItemIEs (pdata);
      stat = asn1PD_e2ap_E2nodeComponentConfigUpdate_ItemIEs (pctxt, pdata);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         return LOG_RTERR (pctxt, stat);
      }

      rtxDListAppendNode (ppvalue, pdata);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

void asn1Init_e2ap_E2nodeComponentConfigUpdate_List (e2ap_E2nodeComponentConfigUpdate_List* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
}

void asn1Free_e2ap_E2nodeComponentConfigUpdate_List (OSCTXT* pctxt, e2ap_E2nodeComponentConfigUpdate_List* pvalue)
{
   if(pvalue==0) return;
   OSRTDListNode* pnode = pvalue->head;
   while (pnode) {
      e2ap_E2nodeComponentConfigUpdate_ItemIEs* pdata = (e2ap_E2nodeComponentConfigUpdate_ItemIEs*) pnode->data;
      if (pdata) {
         asn1Free_e2ap_E2nodeComponentConfigUpdate_ItemIEs (pctxt, pdata);
         rtxMemFreePtr (pctxt, pdata);
      }
      pnode = pnode->next;
   }
      rtxDListFreeAll(pctxt, pvalue);
}

#if 0
void asn1Free_e2ap_E2nodeComponentConfigUpdate_List (OSCTXT* pctxt, e2ap_E2nodeComponentConfigUpdate_List* pvalue){
   if(0==pvalue ) return;
   {
      e2ap_E2nodeComponentConfigUpdate_ItemIEs * pdata;
      OSRTDListNode *pnode = pvalue->head;
      while(0!=pnode){
         pdata = (e2ap_E2nodeComponentConfigUpdate_ItemIEs*)pnode->data;
         asn1Free_e2ap_E2nodeComponentConfigUpdate_ItemIEs(pctxt, pdata);
         pnode = pnode->next;
      }
      rtxDListFreeAll(pctxt, pvalue);
   }
}
#endif


int asn1PrtToStr_e2ap_E2nodeComponentConfigUpdate_List(const char* name, e2ap_E2nodeComponentConfigUpdate_List* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_E2nodeComponentConfigUpdate_ItemIEs* pdata;
    OSRTDListNode* pnode;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode = pvalue->head;  xx1 < pvalue->count && pnode != 0; pnode = pnode->next, xx1++){
        pdata = (e2ap_E2nodeComponentConfigUpdate_ItemIEs*)pnode->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 1
        if(asn1PrtToStr_e2ap_E2nodeComponentConfigUpdate_ItemIEs(nameBuf, pdata, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}
/*****************************************/
/*           E2nodeComponentConfigRemoval-Item                */
/*****************************************/
//sequence normal
// Các nội dung cần thiết cho template seq_normal.c.j2

// Các phần còn lại của template seq_normal.c.j2
//contain extensition bit -> theo mau cua GlobalgNB-ID
int asn1PE_e2ap_E2nodeComponentConfigRemoval_Item (OSCTXT* pctxt, e2ap_E2nodeComponentConfigRemoval_Item* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "E2nodeComponentConfigRemoval-Item");

   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field e2nodeComponentInterfaceType - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "e2nodeComponentInterfaceType");
   stat = asn1PE_e2ap_E2nodeComponentInterfaceType (pctxt, pvalue->e2nodeComponentInterfaceType);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /* encode field e2nodeComponentID - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "e2nodeComponentID");
   stat = asn1PE_e2ap_E2nodeComponentID (pctxt, pvalue->e2nodeComponentID);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);



   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_E2nodeComponentConfigRemoval_Item (OSCTXT* pctxt, e2ap_E2nodeComponentConfigRemoval_Item* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME(pctxt, "E2nodeComponentConfigRemoval-Item");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field e2nodeComponentInterfaceType */
   RTXCTXTPUSHELEMNAME(pctxt, "e2nodeComponentInterfaceType");
      stat = asn1PD_e2ap_E2nodeComponentInterfaceType (pctxt, &pvalue->e2nodeComponentInterfaceType);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field e2nodeComponentID */
   RTXCTXTPUSHELEMNAME(pctxt, "e2nodeComponentID");
      stat = asn1PD_e2ap_E2nodeComponentID (pctxt, &pvalue->e2nodeComponentID);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_E2nodeComponentConfigRemoval_Item (e2ap_E2nodeComponentConfigRemoval_Item* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_E2nodeComponentInterfaceType (&pvalue->e2nodeComponentInterfaceType);
   asn1Init_e2ap_E2nodeComponentID (&pvalue->e2nodeComponentID);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_E2nodeComponentConfigRemoval_Item (OSCTXT* pctxt, e2ap_E2nodeComponentConfigRemoval_Item* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_E2nodeComponentInterfaceType (pctxt, &pvalue->e2nodeComponentInterfaceType);
   asn1Free_e2ap_E2nodeComponentID (pctxt, &pvalue->e2nodeComponentID);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_E2nodeComponentConfigRemoval_Item (const char* name, e2ap_E2nodeComponentConfigRemoval_Item* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }
   if(asn1PrtToStr_e2ap_E2nodeComponentInterfaceType ("e2nodeComponentInterfaceType", &pvalue->e2nodeComponentInterfaceType, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_E2nodeComponentID ("e2nodeComponentID", &pvalue->e2nodeComponentID, buffer, bufSize) < 0)
   {
      return -1;
   }



   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           E2nodeComponentConfigRemoval_ItemIEs                */
/*****************************************/
/* ie.c.j2 */
/*ie thường*/
int asn1PE_e2ap_E2nodeComponentConfigRemoval_ItemIEs (OSCTXT* pctxt, e2ap_E2nodeComponentConfigRemoval_ItemIEs* pvalue)
{
   int stat = 0;
   //RTXCTXTPUSHTYPENAME (pctxt, "E2nodeComponentConfigRemoval-ItemIEs");

   /* encode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");
   stat = asn1PE_e2ap_ProtocolIE_ID (pctxt, pvalue->id);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");
   stat = asn1PE_e2ap_Criticality (pctxt, pvalue->criticality);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   {
      OSCTXT ictxt;
      OSOCTET* pDynamicEncodeBuffer;
      ASN1OpenType openType;
      OSBOOL  encoded = TRUE;

      openType.numocts = 0;
      openType.data = 0;

      rtxCopyContext (&ictxt, pctxt);
      pctxt->pStream = 0;

      stat = rtxInitContextBuffer (pctxt, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_E2nodeComponentConfigRemoval_ItemIEs_id_E2nodeComponentConfigRemoval_Item:
         
        // RTXCTXTPUSHELEMNAME (pctxt, "E2nodeComponentConfigRemoval_ItemIEs_id_E2nodeComponentConfigRemoval_Item");
         RTXCTXTPUSHELEMNAME (pctxt, "E2nodeComponentConfigRemoval-Item");
         stat = asn1PE_e2ap_E2nodeComponentConfigRemoval_Item (pctxt, pvalue->value.u._e2apE2nodeComponentConfigRemoval_ItemIEs_id_E2nodeComponentConfigRemoval_Item);
         RTXCTXTPOPELEMNAME (pctxt);
      
         break;

      case T_E2AP_PDU_Contents_e2ap_E2nodeComponentConfigRemoval_ItemIEs_UNDEF_:
      {
          if(0!=pvalue->value.u.extElem1){
              openType.numocts = pvalue->value.u.extElem1->numocts;
              openType.data = pvalue->value.u.extElem1->data;
          } else {
              /* No extension element to encode */
          }
          encoded = FALSE;
          break;
      }
      default:
         encoded = FALSE;
         stat = RTERR_INVOPT;
      }

      if (encoded) {
         openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
         openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
      }
      rtxCopyContext (pctxt, &ictxt);
      if(stat ==0) stat = pe_OpenType(pctxt, openType.numocts, openType.data);
      /*free dynamic encode buffer*/
      if(encoded){
          rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
      }
   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);
   //RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

int asn1PD_e2ap_E2nodeComponentConfigRemoval_ItemIEs (OSCTXT* pctxt, e2ap_E2nodeComponentConfigRemoval_ItemIEs* pvalue)
{
   int stat =0;
   /*deode root element id*/
   RTXCTXTPUSHELEMNAME(pctxt, "id");
   stat = asn1PD_e2ap_ProtocolIE_ID (pctxt, &pvalue->id);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*decode root element criticality*/
   RTXCTXTPUSHELEMNAME(pctxt, "criticality");
   stat = asn1PD_e2ap_Criticality (pctxt, &pvalue->criticality);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   /*decode root element value*/
   RTXCTXTPUSHELEMNAME(pctxt, "value");
   {
      OSUINT32 openTypeLen;
      size_t bitStartOffset, bitLength;
      stat = pd_UnconsLength(pctxt, &openTypeLen);
      if(stat <0) return LOG_RTERR(pctxt, stat);
      else if(stat == RT_OK_FRAG){
         rtxErrAddStrParm(pctxt, "open type with fragmented length use - perindef");
         return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
      }
      bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
      bitLength = openTypeLen * 8;
      switch (pvalue->id){
         case T_E2AP_PDU_Contents_e2ap_E2nodeComponentConfigRemoval_ItemIEs_id_E2nodeComponentConfigRemoval_Item:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_E2nodeComponentConfigRemoval_ItemIEs_id_E2nodeComponentConfigRemoval_Item;
            RTXCTXTPUSHELEMNAME(pctxt, "E2nodeComponentConfigRemoval-Item");
            //pvalue->value.u._e2ap_E2nodeComponentConfigRemoval_ItemIEs_id_id_E2nodeComponentConfigRemoval_Item 
             pvalue->value.u._e2apE2nodeComponentConfigRemoval_ItemIEs_id_E2nodeComponentConfigRemoval_Item 
                    = rtxMemAllocType(pctxt, e2ap_E2nodeComponentConfigRemoval_Item);
            //asn1Init_e2ap_E2nodeComponentConfigRemoval_Item(pvalue->value.u._e2ap_E2nodeComponentConfigRemoval_ItemIEs_id_id_E2nodeComponentConfigRemoval_Item);
            asn1Init_e2ap_E2nodeComponentConfigRemoval_Item(pvalue->value.u._e2apE2nodeComponentConfigRemoval_ItemIEs_id_E2nodeComponentConfigRemoval_Item);
            stat = asn1PD_e2ap_E2nodeComponentConfigRemoval_Item (pctxt,
                    (e2ap_E2nodeComponentConfigRemoval_Item*)pvalue->value.
                    u._e2apE2nodeComponentConfigRemoval_ItemIEs_id_E2nodeComponentConfigRemoval_Item);
            if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_E2nodeComponentConfigRemoval_ItemIEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*)rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
      }
      {
      size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
      size_t bitsConsumed = bitEndOffset - bitStartOffset;
      if(bitsConsumed < bitLength){
         stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
      } else {
         stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
      }
      }
   }
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   return stat;
}

void asn1Init_e2ap_E2nodeComponentConfigRemoval_ItemIEs (e2ap_E2nodeComponentConfigRemoval_ItemIEs* pvalue)
{
   if (!pvalue) return;
   OSCRTLMEMSET (pvalue, 0, sizeof(e2ap_E2nodeComponentConfigRemoval_ItemIEs));
}

#if 0
void asn1Free_e2ap_E2nodeComponentConfigRemoval_ItemIEs (OSCTXT* pctxt, e2ap_E2nodeComponentConfigRemoval_ItemIEs* pvalue)
{
   if (!pvalue) return;
   if (pvalue->extElem1) {
      rtxMemFreeArray (pctxt, pvalue->extElem1);
      pvalue->extElem1 = 0;
      pvalue->extElem1_n = 0;
   }
}
#endif
void asn1Free_e2ap_E2nodeComponentConfigRemoval_ItemIEs (OSCTXT* pctxt, e2ap_E2nodeComponentConfigRemoval_ItemIEs* pvalue)
{
   if(0==pvalue) return;
   switch(pvalue->value.t){
      case T_E2AP_PDU_Contents_e2ap_E2nodeComponentConfigRemoval_ItemIEs_id_E2nodeComponentConfigRemoval_Item:
         asn1Free_e2ap_E2nodeComponentConfigRemoval_Item (pctxt, pvalue->value.u._e2apE2nodeComponentConfigRemoval_ItemIEs_id_E2nodeComponentConfigRemoval_Item);
         rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2apE2nodeComponentConfigRemoval_ItemIEs_id_E2nodeComponentConfigRemoval_Item);
         pvalue->value.u._e2apE2nodeComponentConfigRemoval_ItemIEs_id_E2nodeComponentConfigRemoval_Item = 0;
         break;
      case T_E2AP_PDU_Contents_e2ap_E2nodeComponentConfigRemoval_ItemIEs_UNDEF_:
         if(0!=pvalue->value.u.extElem1){
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1->data);
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
             pvalue->value.u.extElem1 =0;
         }
         break;
         default:;
   }
}

int  asn1PrtToStr_e2ap_E2nodeComponentConfigRemoval_ItemIEs (const char * name, e2ap_E2nodeComponentConfigRemoval_ItemIEs* pvalue, char * buffer, OSSIZE bufSize){
   if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
       return -1;

      if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
         return -1;

      if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
         return -1;
      if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
         return -1;
      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_E2nodeComponentConfigRemoval_ItemIEs_id_E2nodeComponentConfigRemoval_Item:
         if(asn1PrtToStr_e2ap_E2nodeComponentConfigRemoval_Item("E2nodeComponentConfigRemoval-Item",
                pvalue->value.u._e2apE2nodeComponentConfigRemoval_ItemIEs_id_E2nodeComponentConfigRemoval_Item, buffer, bufSize)<0)// dungnm23 check lai nhe xem la
            return -1;
         break;
      default:
         if(0!=pvalue -> value.u.extElem1){
             rtPrintToStringIndent(buffer, bufSize);
             rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

         }
      }
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

      return 0;

}
 

/*****************************************/
/*           E2nodeComponentConfigRemoval_List                */
/*****************************************/
//seq_of_single_container


int asn1PE_e2ap_E2nodeComponentConfigRemoval_List (OSCTXT* pctxt, e2ap_E2nodeComponentConfigRemoval_List* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_E2nodeComponentConfigRemoval_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "E2nodeComponentConfigRemoval-List");

   /* encode length determinant */
   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1024), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;
   for (xx1 = 0; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next, xx1++) {
      pdata = (e2ap_E2nodeComponentConfigRemoval_ItemIEs*) pnode->data;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_e2ap_E2nodeComponentConfigRemoval_ItemIEs (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      //xx1++;
      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}

int asn1PD_e2ap_E2nodeComponentConfigRemoval_List (OSCTXT* pctxt, e2ap_E2nodeComponentConfigRemoval_List* ppvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_E2nodeComponentConfigRemoval_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "E2nodeComponentConfigRemoval-List");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1024), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (ppvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      pdata = rtxMemAllocType (pctxt, e2ap_E2nodeComponentConfigRemoval_ItemIEs);
      if (!pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);
      asn1Init_e2ap_E2nodeComponentConfigRemoval_ItemIEs (pdata);
      stat = asn1PD_e2ap_E2nodeComponentConfigRemoval_ItemIEs (pctxt, pdata);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         return LOG_RTERR (pctxt, stat);
      }

      rtxDListAppendNode (ppvalue, pdata);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

void asn1Init_e2ap_E2nodeComponentConfigRemoval_List (e2ap_E2nodeComponentConfigRemoval_List* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
}

void asn1Free_e2ap_E2nodeComponentConfigRemoval_List (OSCTXT* pctxt, e2ap_E2nodeComponentConfigRemoval_List* pvalue)
{
   if(pvalue==0) return;
   OSRTDListNode* pnode = pvalue->head;
   while (pnode) {
      e2ap_E2nodeComponentConfigRemoval_ItemIEs* pdata = (e2ap_E2nodeComponentConfigRemoval_ItemIEs*) pnode->data;
      if (pdata) {
         asn1Free_e2ap_E2nodeComponentConfigRemoval_ItemIEs (pctxt, pdata);
         rtxMemFreePtr (pctxt, pdata);
      }
      pnode = pnode->next;
   }
      rtxDListFreeAll(pctxt, pvalue);
}

#if 0
void asn1Free_e2ap_E2nodeComponentConfigRemoval_List (OSCTXT* pctxt, e2ap_E2nodeComponentConfigRemoval_List* pvalue){
   if(0==pvalue ) return;
   {
      e2ap_E2nodeComponentConfigRemoval_ItemIEs * pdata;
      OSRTDListNode *pnode = pvalue->head;
      while(0!=pnode){
         pdata = (e2ap_E2nodeComponentConfigRemoval_ItemIEs*)pnode->data;
         asn1Free_e2ap_E2nodeComponentConfigRemoval_ItemIEs(pctxt, pdata);
         pnode = pnode->next;
      }
      rtxDListFreeAll(pctxt, pvalue);
   }
}
#endif


int asn1PrtToStr_e2ap_E2nodeComponentConfigRemoval_List(const char* name, e2ap_E2nodeComponentConfigRemoval_List* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_E2nodeComponentConfigRemoval_ItemIEs* pdata;
    OSRTDListNode* pnode;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode = pvalue->head;  xx1 < pvalue->count && pnode != 0; pnode = pnode->next, xx1++){
        pdata = (e2ap_E2nodeComponentConfigRemoval_ItemIEs*)pnode->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 1
        if(asn1PrtToStr_e2ap_E2nodeComponentConfigRemoval_ItemIEs(nameBuf, pdata, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}
/*****************************************/
/*           E2nodeTNLassociationRemoval-Item                */
/*****************************************/
//sequence normal
// Các nội dung cần thiết cho template seq_normal.c.j2

// Các phần còn lại của template seq_normal.c.j2
//contain extensition bit -> theo mau cua GlobalgNB-ID
int asn1PE_e2ap_E2nodeTNLassociationRemoval_Item (OSCTXT* pctxt, e2ap_E2nodeTNLassociationRemoval_Item* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "E2nodeTNLassociationRemoval-Item");

   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field tnlInformation - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "tnlInformation");
   stat = asn1PE_e2ap_TNLinformation (pctxt, pvalue->tnlInformation);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /* encode field tnlInformationRIC - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "tnlInformationRIC");
   stat = asn1PE_e2ap_TNLinformation (pctxt, pvalue->tnlInformationRIC);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);



   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_E2nodeTNLassociationRemoval_Item (OSCTXT* pctxt, e2ap_E2nodeTNLassociationRemoval_Item* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME(pctxt, "E2nodeTNLassociationRemoval-Item");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field tnlInformation */
   RTXCTXTPUSHELEMNAME(pctxt, "tnlInformation");
      stat = asn1PD_e2ap_TNLinformation (pctxt, &pvalue->tnlInformation);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field tnlInformationRIC */
   RTXCTXTPUSHELEMNAME(pctxt, "tnlInformationRIC");
      stat = asn1PD_e2ap_TNLinformation (pctxt, &pvalue->tnlInformationRIC);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_E2nodeTNLassociationRemoval_Item (e2ap_E2nodeTNLassociationRemoval_Item* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_TNLinformation (&pvalue->tnlInformation);
   asn1Init_e2ap_TNLinformation (&pvalue->tnlInformationRIC);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_E2nodeTNLassociationRemoval_Item (OSCTXT* pctxt, e2ap_E2nodeTNLassociationRemoval_Item* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_TNLinformation (pctxt, &pvalue->tnlInformation);
   asn1Free_e2ap_TNLinformation (pctxt, &pvalue->tnlInformationRIC);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_E2nodeTNLassociationRemoval_Item (const char* name, e2ap_E2nodeTNLassociationRemoval_Item* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }
   if(asn1PrtToStr_e2ap_TNLinformation ("tnlInformation", &pvalue->tnlInformation, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_TNLinformation ("tnlInformationRIC", &pvalue->tnlInformationRIC, buffer, bufSize) < 0)
   {
      return -1;
   }



   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           E2nodeTNLassociationRemoval_ItemIEs                */
/*****************************************/
/* ie.c.j2 */
/*ie thường*/
int asn1PE_e2ap_E2nodeTNLassociationRemoval_ItemIEs (OSCTXT* pctxt, e2ap_E2nodeTNLassociationRemoval_ItemIEs* pvalue)
{
   int stat = 0;
   //RTXCTXTPUSHTYPENAME (pctxt, "E2nodeTNLassociationRemoval-ItemIEs");

   /* encode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");
   stat = asn1PE_e2ap_ProtocolIE_ID (pctxt, pvalue->id);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");
   stat = asn1PE_e2ap_Criticality (pctxt, pvalue->criticality);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   {
      OSCTXT ictxt;
      OSOCTET* pDynamicEncodeBuffer;
      ASN1OpenType openType;
      OSBOOL  encoded = TRUE;

      openType.numocts = 0;
      openType.data = 0;

      rtxCopyContext (&ictxt, pctxt);
      pctxt->pStream = 0;

      stat = rtxInitContextBuffer (pctxt, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_E2nodeTNLassociationRemoval_ItemIEs_id_E2nodeTNLassociationRemoval_Item:
         
        // RTXCTXTPUSHELEMNAME (pctxt, "E2nodeTNLassociationRemoval_ItemIEs_id_E2nodeTNLassociationRemoval_Item");
         RTXCTXTPUSHELEMNAME (pctxt, "E2nodeTNLassociationRemoval-Item");
         stat = asn1PE_e2ap_E2nodeTNLassociationRemoval_Item (pctxt, pvalue->value.u._e2apE2nodeTNLassociationRemoval_ItemIEs_id_E2nodeTNLassociationRemoval_Item);
         RTXCTXTPOPELEMNAME (pctxt);
      
         break;

      case T_E2AP_PDU_Contents_e2ap_E2nodeTNLassociationRemoval_ItemIEs_UNDEF_:
      {
          if(0!=pvalue->value.u.extElem1){
              openType.numocts = pvalue->value.u.extElem1->numocts;
              openType.data = pvalue->value.u.extElem1->data;
          } else {
              /* No extension element to encode */
          }
          encoded = FALSE;
          break;
      }
      default:
         encoded = FALSE;
         stat = RTERR_INVOPT;
      }

      if (encoded) {
         openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
         openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
      }
      rtxCopyContext (pctxt, &ictxt);
      if(stat ==0) stat = pe_OpenType(pctxt, openType.numocts, openType.data);
      /*free dynamic encode buffer*/
      if(encoded){
          rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
      }
   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);
   //RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

int asn1PD_e2ap_E2nodeTNLassociationRemoval_ItemIEs (OSCTXT* pctxt, e2ap_E2nodeTNLassociationRemoval_ItemIEs* pvalue)
{
   int stat =0;
   /*deode root element id*/
   RTXCTXTPUSHELEMNAME(pctxt, "id");
   stat = asn1PD_e2ap_ProtocolIE_ID (pctxt, &pvalue->id);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*decode root element criticality*/
   RTXCTXTPUSHELEMNAME(pctxt, "criticality");
   stat = asn1PD_e2ap_Criticality (pctxt, &pvalue->criticality);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   /*decode root element value*/
   RTXCTXTPUSHELEMNAME(pctxt, "value");
   {
      OSUINT32 openTypeLen;
      size_t bitStartOffset, bitLength;
      stat = pd_UnconsLength(pctxt, &openTypeLen);
      if(stat <0) return LOG_RTERR(pctxt, stat);
      else if(stat == RT_OK_FRAG){
         rtxErrAddStrParm(pctxt, "open type with fragmented length use - perindef");
         return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
      }
      bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
      bitLength = openTypeLen * 8;
      switch (pvalue->id){
         case T_E2AP_PDU_Contents_e2ap_E2nodeTNLassociationRemoval_ItemIEs_id_E2nodeTNLassociationRemoval_Item:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_E2nodeTNLassociationRemoval_ItemIEs_id_E2nodeTNLassociationRemoval_Item;
            RTXCTXTPUSHELEMNAME(pctxt, "E2nodeTNLassociationRemoval-Item");
            //pvalue->value.u._e2ap_E2nodeTNLassociationRemoval_ItemIEs_id_id_E2nodeTNLassociationRemoval_Item 
             pvalue->value.u._e2apE2nodeTNLassociationRemoval_ItemIEs_id_E2nodeTNLassociationRemoval_Item 
                    = rtxMemAllocType(pctxt, e2ap_E2nodeTNLassociationRemoval_Item);
            //asn1Init_e2ap_E2nodeTNLassociationRemoval_Item(pvalue->value.u._e2ap_E2nodeTNLassociationRemoval_ItemIEs_id_id_E2nodeTNLassociationRemoval_Item);
            asn1Init_e2ap_E2nodeTNLassociationRemoval_Item(pvalue->value.u._e2apE2nodeTNLassociationRemoval_ItemIEs_id_E2nodeTNLassociationRemoval_Item);
            stat = asn1PD_e2ap_E2nodeTNLassociationRemoval_Item (pctxt,
                    (e2ap_E2nodeTNLassociationRemoval_Item*)pvalue->value.
                    u._e2apE2nodeTNLassociationRemoval_ItemIEs_id_E2nodeTNLassociationRemoval_Item);
            if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_E2nodeTNLassociationRemoval_ItemIEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*)rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
      }
      {
      size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
      size_t bitsConsumed = bitEndOffset - bitStartOffset;
      if(bitsConsumed < bitLength){
         stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
      } else {
         stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
      }
      }
   }
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   return stat;
}

void asn1Init_e2ap_E2nodeTNLassociationRemoval_ItemIEs (e2ap_E2nodeTNLassociationRemoval_ItemIEs* pvalue)
{
   if (!pvalue) return;
   OSCRTLMEMSET (pvalue, 0, sizeof(e2ap_E2nodeTNLassociationRemoval_ItemIEs));
}

#if 0
void asn1Free_e2ap_E2nodeTNLassociationRemoval_ItemIEs (OSCTXT* pctxt, e2ap_E2nodeTNLassociationRemoval_ItemIEs* pvalue)
{
   if (!pvalue) return;
   if (pvalue->extElem1) {
      rtxMemFreeArray (pctxt, pvalue->extElem1);
      pvalue->extElem1 = 0;
      pvalue->extElem1_n = 0;
   }
}
#endif
void asn1Free_e2ap_E2nodeTNLassociationRemoval_ItemIEs (OSCTXT* pctxt, e2ap_E2nodeTNLassociationRemoval_ItemIEs* pvalue)
{
   if(0==pvalue) return;
   switch(pvalue->value.t){
      case T_E2AP_PDU_Contents_e2ap_E2nodeTNLassociationRemoval_ItemIEs_id_E2nodeTNLassociationRemoval_Item:
         asn1Free_e2ap_E2nodeTNLassociationRemoval_Item (pctxt, pvalue->value.u._e2apE2nodeTNLassociationRemoval_ItemIEs_id_E2nodeTNLassociationRemoval_Item);
         rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2apE2nodeTNLassociationRemoval_ItemIEs_id_E2nodeTNLassociationRemoval_Item);
         pvalue->value.u._e2apE2nodeTNLassociationRemoval_ItemIEs_id_E2nodeTNLassociationRemoval_Item = 0;
         break;
      case T_E2AP_PDU_Contents_e2ap_E2nodeTNLassociationRemoval_ItemIEs_UNDEF_:
         if(0!=pvalue->value.u.extElem1){
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1->data);
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
             pvalue->value.u.extElem1 =0;
         }
         break;
         default:;
   }
}

int  asn1PrtToStr_e2ap_E2nodeTNLassociationRemoval_ItemIEs (const char * name, e2ap_E2nodeTNLassociationRemoval_ItemIEs* pvalue, char * buffer, OSSIZE bufSize){
   if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
       return -1;

      if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
         return -1;

      if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
         return -1;
      if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
         return -1;
      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_E2nodeTNLassociationRemoval_ItemIEs_id_E2nodeTNLassociationRemoval_Item:
         if(asn1PrtToStr_e2ap_E2nodeTNLassociationRemoval_Item("E2nodeTNLassociationRemoval-Item",
                pvalue->value.u._e2apE2nodeTNLassociationRemoval_ItemIEs_id_E2nodeTNLassociationRemoval_Item, buffer, bufSize)<0)// dungnm23 check lai nhe xem la
            return -1;
         break;
      default:
         if(0!=pvalue -> value.u.extElem1){
             rtPrintToStringIndent(buffer, bufSize);
             rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

         }
      }
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

      return 0;

}
 

/*****************************************/
/*           E2nodeTNLassociationRemoval_List                */
/*****************************************/
//seq_of_single_container


int asn1PE_e2ap_E2nodeTNLassociationRemoval_List (OSCTXT* pctxt, e2ap_E2nodeTNLassociationRemoval_List* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_E2nodeTNLassociationRemoval_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "E2nodeTNLassociationRemoval-List");

   /* encode length determinant */
   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;
   for (xx1 = 0; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next, xx1++) {
      pdata = (e2ap_E2nodeTNLassociationRemoval_ItemIEs*) pnode->data;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_e2ap_E2nodeTNLassociationRemoval_ItemIEs (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      //xx1++;
      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}

int asn1PD_e2ap_E2nodeTNLassociationRemoval_List (OSCTXT* pctxt, e2ap_E2nodeTNLassociationRemoval_List* ppvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_E2nodeTNLassociationRemoval_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "E2nodeTNLassociationRemoval-List");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (ppvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      pdata = rtxMemAllocType (pctxt, e2ap_E2nodeTNLassociationRemoval_ItemIEs);
      if (!pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);
      asn1Init_e2ap_E2nodeTNLassociationRemoval_ItemIEs (pdata);
      stat = asn1PD_e2ap_E2nodeTNLassociationRemoval_ItemIEs (pctxt, pdata);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         return LOG_RTERR (pctxt, stat);
      }

      rtxDListAppendNode (ppvalue, pdata);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

void asn1Init_e2ap_E2nodeTNLassociationRemoval_List (e2ap_E2nodeTNLassociationRemoval_List* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
}

void asn1Free_e2ap_E2nodeTNLassociationRemoval_List (OSCTXT* pctxt, e2ap_E2nodeTNLassociationRemoval_List* pvalue)
{
   if(pvalue==0) return;
   OSRTDListNode* pnode = pvalue->head;
   while (pnode) {
      e2ap_E2nodeTNLassociationRemoval_ItemIEs* pdata = (e2ap_E2nodeTNLassociationRemoval_ItemIEs*) pnode->data;
      if (pdata) {
         asn1Free_e2ap_E2nodeTNLassociationRemoval_ItemIEs (pctxt, pdata);
         rtxMemFreePtr (pctxt, pdata);
      }
      pnode = pnode->next;
   }
      rtxDListFreeAll(pctxt, pvalue);
}

#if 0
void asn1Free_e2ap_E2nodeTNLassociationRemoval_List (OSCTXT* pctxt, e2ap_E2nodeTNLassociationRemoval_List* pvalue){
   if(0==pvalue ) return;
   {
      e2ap_E2nodeTNLassociationRemoval_ItemIEs * pdata;
      OSRTDListNode *pnode = pvalue->head;
      while(0!=pnode){
         pdata = (e2ap_E2nodeTNLassociationRemoval_ItemIEs*)pnode->data;
         asn1Free_e2ap_E2nodeTNLassociationRemoval_ItemIEs(pctxt, pdata);
         pnode = pnode->next;
      }
      rtxDListFreeAll(pctxt, pvalue);
   }
}
#endif


int asn1PrtToStr_e2ap_E2nodeTNLassociationRemoval_List(const char* name, e2ap_E2nodeTNLassociationRemoval_List* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_E2nodeTNLassociationRemoval_ItemIEs* pdata;
    OSRTDListNode* pnode;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode = pvalue->head;  xx1 < pvalue->count && pnode != 0; pnode = pnode->next, xx1++){
        pdata = (e2ap_E2nodeTNLassociationRemoval_ItemIEs*)pnode->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 1
        if(asn1PrtToStr_e2ap_E2nodeTNLassociationRemoval_ItemIEs(nameBuf, pdata, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}/*****************************************/
/*           E2nodeConfigurationUpdate_IEs                */
/*****************************************/
/* ie.c.j2 */
 /* d là con của msg */
EXTERN int asn1PE_e2ap_E2nodeConfigurationUpdate_protocolIEs_element (OSCTXT* pctxt, e2ap_E2nodeConfigurationUpdate_protocolIEs_element* pvalue)
{
    int stat =0;

    /*encode id*/

    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PE_e2ap_ProtocolIE_ID(pctxt, pvalue->id);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PE_e2ap_Criticality(pctxt, pvalue->criticality);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
    {
        OSCTXT lctxt;
        OSOCTET *pDynamicEncodeBuffer;
        ASN1OpenType openType;
        OSBOOL encoded = TRUE;

        openType.numocts = 0;
        openType.data =0;

        rtxCopyContext(&lctxt, pctxt);
        pctxt->pStream =0;

        stat = rtxInitContextBuffer(pctxt, 0, 0);
        if(stat!=0) return LOG_RTERR(pctxt, stat);

        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdate_IEs_id_TransactionID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-TransactionID");
                    stat = asn1PE_e2ap_TransactionID (pctxt, pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_TransactionID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdate_IEs_id_GlobalE2node_ID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-GlobalE2node-ID");
                    stat = asn1PE_e2ap_GlobalE2node_ID (pctxt, pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_GlobalE2node_ID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdate_IEs_id_E2nodeComponentConfigAddition:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-E2nodeComponentConfigAddition");
                    stat = asn1PE_e2ap_E2nodeComponentConfigAddition_List (pctxt, pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_E2nodeComponentConfigAddition);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdate_IEs_id_E2nodeComponentConfigUpdate:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-E2nodeComponentConfigUpdate");
                    stat = asn1PE_e2ap_E2nodeComponentConfigUpdate_List (pctxt, pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_E2nodeComponentConfigUpdate);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdate_IEs_id_E2nodeComponentConfigRemoval:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-E2nodeComponentConfigRemoval");
                    stat = asn1PE_e2ap_E2nodeComponentConfigRemoval_List (pctxt, pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_E2nodeComponentConfigRemoval);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdate_IEs_id_E2nodeTNLassociationRemoval:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-E2nodeTNLassociationRemoval");
                    stat = asn1PE_e2ap_E2nodeTNLassociationRemoval_List (pctxt, pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_E2nodeTNLassociationRemoval);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdate_IEs_UNDEF_:
            {
                if(0!=pvalue->value.u.extElem1){
                    openType.numocts = pvalue->value.u.extElem1->numocts;
                    openType.data = pvalue->value.u.extElem1->data;
                } else {
                    /* No extension element to encode */
                }
                encoded = FALSE;
                break;
            }

            default:
                encoded = FALSE;
                stat = RTERR_INVOPT;
                break;
        } 

        if(encoded){
            openType.numocts = (OSUINT32)pe_GetMsgLen(pctxt);
            openType.data = pDynamicEncodeBuffer = pctxt -> buffer.data;
        }
        rtxCopyContext(pctxt, &lctxt);

        if(stat == 0) {
            stat = pe_OpenType (pctxt, openType.numocts, openType.data);
        }
    #if 1
        if(encoded){//dungnm23 check lai nhe
            rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
        }
    #endif

    }

    if(stat!=0) return LOG_RTERR(pctxt, stat);  
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}

EXTERN int  asn1PD_e2ap_E2nodeConfigurationUpdate_protocolIEs_element (OSCTXT* pctxt, e2ap_E2nodeConfigurationUpdate_protocolIEs_element* pvalue){
    int stat =0;

    /*decode id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PD_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PD_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");

    {
        OSUINT32 openTypeLen;
        size_t bitStartOffset, bitLength;

        stat = pd_UnconsLength(pctxt, &openTypeLen);
        if(stat<0) return LOG_RTERR(pctxt, stat);
        else if(stat == RT_OK_FRAG){
            rtxErrAddStrParm(pctxt, "open type with fragment length");
            return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
        }
        bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
        bitLength = openTypeLen * 8;

        switch(pvalue->id){//dungnm23 check case lai nhe
        
            case ASN1V_e2ap_id_TransactionID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdate_IEs_id_TransactionID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-TransactionID");
                pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_TransactionID 
                    = rtxMemAllocType(pctxt, e2ap_TransactionID);

                asn1Init_e2ap_TransactionID(pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_TransactionID);

                stat = asn1PD_e2ap_TransactionID (pctxt,
                        (e2ap_TransactionID*)pvalue->value.
                        u._e2ap_E2nodeConfigurationUpdate_IEs_id_TransactionID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_GlobalE2node_ID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdate_IEs_id_GlobalE2node_ID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-GlobalE2node-ID");
                pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_GlobalE2node_ID 
                    = rtxMemAllocType(pctxt, e2ap_GlobalE2node_ID);

                asn1Init_e2ap_GlobalE2node_ID(pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_GlobalE2node_ID);

                stat = asn1PD_e2ap_GlobalE2node_ID (pctxt,
                        (e2ap_GlobalE2node_ID*)pvalue->value.
                        u._e2ap_E2nodeConfigurationUpdate_IEs_id_GlobalE2node_ID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_E2nodeComponentConfigAddition:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdate_IEs_id_E2nodeComponentConfigAddition;
            RTXCTXTPUSHELEMNAME(pctxt, "id-E2nodeComponentConfigAddition");
                pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_E2nodeComponentConfigAddition 
                    = rtxMemAllocType(pctxt, e2ap_E2nodeComponentConfigAddition_List);

                asn1Init_e2ap_E2nodeComponentConfigAddition_List(pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_E2nodeComponentConfigAddition);

                stat = asn1PD_e2ap_E2nodeComponentConfigAddition_List (pctxt,
                        (e2ap_E2nodeComponentConfigAddition_List*)pvalue->value.
                        u._e2ap_E2nodeConfigurationUpdate_IEs_id_E2nodeComponentConfigAddition);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_E2nodeComponentConfigUpdate:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdate_IEs_id_E2nodeComponentConfigUpdate;
            RTXCTXTPUSHELEMNAME(pctxt, "id-E2nodeComponentConfigUpdate");
                pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_E2nodeComponentConfigUpdate 
                    = rtxMemAllocType(pctxt, e2ap_E2nodeComponentConfigUpdate_List);

                asn1Init_e2ap_E2nodeComponentConfigUpdate_List(pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_E2nodeComponentConfigUpdate);

                stat = asn1PD_e2ap_E2nodeComponentConfigUpdate_List (pctxt,
                        (e2ap_E2nodeComponentConfigUpdate_List*)pvalue->value.
                        u._e2ap_E2nodeConfigurationUpdate_IEs_id_E2nodeComponentConfigUpdate);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_E2nodeComponentConfigRemoval:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdate_IEs_id_E2nodeComponentConfigRemoval;
            RTXCTXTPUSHELEMNAME(pctxt, "id-E2nodeComponentConfigRemoval");
                pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_E2nodeComponentConfigRemoval 
                    = rtxMemAllocType(pctxt, e2ap_E2nodeComponentConfigRemoval_List);

                asn1Init_e2ap_E2nodeComponentConfigRemoval_List(pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_E2nodeComponentConfigRemoval);

                stat = asn1PD_e2ap_E2nodeComponentConfigRemoval_List (pctxt,
                        (e2ap_E2nodeComponentConfigRemoval_List*)pvalue->value.
                        u._e2ap_E2nodeConfigurationUpdate_IEs_id_E2nodeComponentConfigRemoval);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_E2nodeTNLassociationRemoval:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdate_IEs_id_E2nodeTNLassociationRemoval;
            RTXCTXTPUSHELEMNAME(pctxt, "id-E2nodeTNLassociationRemoval");
                pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_E2nodeTNLassociationRemoval 
                    = rtxMemAllocType(pctxt, e2ap_E2nodeTNLassociationRemoval_List);

                asn1Init_e2ap_E2nodeTNLassociationRemoval_List(pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_E2nodeTNLassociationRemoval);

                stat = asn1PD_e2ap_E2nodeTNLassociationRemoval_List (pctxt,
                        (e2ap_E2nodeTNLassociationRemoval_List*)pvalue->value.
                        u._e2ap_E2nodeConfigurationUpdate_IEs_id_E2nodeTNLassociationRemoval);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdate_IEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*) rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
    }
    {
    size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
    size_t bitsConsumed = bitEndOffset-bitStartOffset;
    if(bitsConsumed<bitLength){
        stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
    }
    else stat =(bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
    }}
    if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}


int asn1Init_e2ap_E2nodeConfigurationUpdate_protocolIEs_element(e2ap_E2nodeConfigurationUpdate_protocolIEs_element* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    OSCRTLMEMSET (&pvalue->value, 0, sizeof(pvalue->value));
    return 0;
}


//-----> chuaw có template rtxFreeASN1OpenType

#if 0
void asn1Free_e2ap_E2nodeConfigurationUpdate_protocolIEs_element(OSCTXT* pctxt, e2ap_E2nodeConfigurationUpdate_protocolIEs_element* pvalue)
{
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdate_IEs_id_id_TransactionID:
            // rtxFreeE2ap_TransactionID(pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_id_TransactionID);

            if(pvalue->value.i._e2ap_E2nodeConfigurationUpdate_id_TransactionID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_TransactionID(pctxt, pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_id_TransactionID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_id_TransactionID);
           // pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_id_TransactionID = NULL;
           pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_TransactionID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdate_IEs_id_id_GlobalE2node_ID:
            // rtxFreeE2ap_GlobalE2node_ID(pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_id_GlobalE2node_ID);

            if(pvalue->value.i._e2ap_E2nodeConfigurationUpdate_id_GlobalE2node_ID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_GlobalE2node_ID(pctxt, pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_id_GlobalE2node_ID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_id_GlobalE2node_ID);
           // pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_id_GlobalE2node_ID = NULL;
           pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_GlobalE2node_ID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdate_IEs_id_id_E2nodeComponentConfigAddition:
            // rtxFreeE2ap_E2nodeComponentConfigAddition_List(pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_id_E2nodeComponentConfigAddition);

            if(pvalue->value.i._e2ap_E2nodeConfigurationUpdate_id_E2nodeComponentConfigAddition_List!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_E2nodeComponentConfigAddition_List(pctxt, pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_id_E2nodeComponentConfigAddition);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_id_E2nodeComponentConfigAddition);
           // pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_id_E2nodeComponentConfigAddition = NULL;
           pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_E2nodeComponentConfigAddition = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdate_IEs_id_id_E2nodeComponentConfigUpdate:
            // rtxFreeE2ap_E2nodeComponentConfigUpdate_List(pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_id_E2nodeComponentConfigUpdate);

            if(pvalue->value.i._e2ap_E2nodeConfigurationUpdate_id_E2nodeComponentConfigUpdate_List!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_E2nodeComponentConfigUpdate_List(pctxt, pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_id_E2nodeComponentConfigUpdate);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_id_E2nodeComponentConfigUpdate);
           // pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_id_E2nodeComponentConfigUpdate = NULL;
           pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_E2nodeComponentConfigUpdate = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdate_IEs_id_id_E2nodeComponentConfigRemoval:
            // rtxFreeE2ap_E2nodeComponentConfigRemoval_List(pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_id_E2nodeComponentConfigRemoval);

            if(pvalue->value.i._e2ap_E2nodeConfigurationUpdate_id_E2nodeComponentConfigRemoval_List!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_E2nodeComponentConfigRemoval_List(pctxt, pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_id_E2nodeComponentConfigRemoval);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_id_E2nodeComponentConfigRemoval);
           // pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_id_E2nodeComponentConfigRemoval = NULL;
           pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_E2nodeComponentConfigRemoval = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdate_IEs_id_id_E2nodeTNLassociationRemoval:
            // rtxFreeE2ap_E2nodeTNLassociationRemoval_List(pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_id_E2nodeTNLassociationRemoval);

            if(pvalue->value.i._e2ap_E2nodeConfigurationUpdate_id_E2nodeTNLassociationRemoval_List!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_E2nodeTNLassociationRemoval_List(pctxt, pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_id_E2nodeTNLassociationRemoval);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_id_E2nodeTNLassociationRemoval);
           // pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_id_E2nodeTNLassociationRemoval = NULL;
           pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_E2nodeTNLassociationRemoval = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdate_IEs_UNDEF_:
            rtxFreeASN1OpenType(pvalue->value.u.extElem1);
            break;
        default:
            break;
    }
}

int asn1PrtToStr_e2ap_E2nodeConfigurationUpdate_protocolIEs_element(OSCTXT* pctxt, e2ap_E2nodeConfigurationUpdate_protocolIEs_element* pvalue)
{
    int stat =0;
    RTXCTXTPUSHELEMNAME(pctxt, "e2ap_E2nodeConfigurationUpdate_protocolIEs_element");

    /*print id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PrtToStr_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PrtToStr_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdate_IEs_id_id_TransactionID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "TransactionID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_TransactionID (pctxt, pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_id_TransactionID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdate_IEs_id_id_GlobalE2node_ID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "GlobalE2node-ID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_GlobalE2node_ID (pctxt, pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_id_GlobalE2node_ID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdate_IEs_id_id_E2nodeComponentConfigAddition:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "E2nodeComponentConfigAddition-List");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_E2nodeComponentConfigAddition_List (pctxt, pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_id_E2nodeComponentConfigAddition);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdate_IEs_id_id_E2nodeComponentConfigUpdate:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "E2nodeComponentConfigUpdate-List");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_E2nodeComponentConfigUpdate_List (pctxt, pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_id_E2nodeComponentConfigUpdate);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdate_IEs_id_id_E2nodeComponentConfigRemoval:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "E2nodeComponentConfigRemoval-List");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_E2nodeComponentConfigRemoval_List (pctxt, pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_id_E2nodeComponentConfigRemoval);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdate_IEs_id_id_E2nodeTNLassociationRemoval:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "E2nodeTNLassociationRemoval-List");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_E2nodeTNLassociationRemoval_List (pctxt, pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_id_E2nodeTNLassociationRemoval);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdate_IEs_UNDEF_:
            {
                rtxPLogMsg(pctxt, "Extension element present - raw data not printed.\n");
                break;
            }

            default:
                stat = RTERR_INVOPT;
                return LOG_RTERR(pctxt, stat);
        }
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);
}
#endif


int asn1PrtToStr_e2ap_E2nodeConfigurationUpdate_protocolIEs_element (const char * name,
 e2ap_E2nodeConfigurationUpdate_protocolIEs_element* pvalue, 
 char * buffer, OSSIZE bufSize){
    if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
        return -1;
    if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
        return -1;

    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdate_IEs_id_TransactionID:
            if(asn1PrtToStr_e2ap_TransactionID("TransactionID", 
                    pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_TransactionID, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdate_IEs_id_GlobalE2node_ID:
            if(asn1PrtToStr_e2ap_GlobalE2node_ID("GlobalE2node-ID", 
                    pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_GlobalE2node_ID, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdate_IEs_id_E2nodeComponentConfigAddition:
            if(asn1PrtToStr_e2ap_E2nodeComponentConfigAddition_List("E2nodeComponentConfigAddition-List", 
                    pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_E2nodeComponentConfigAddition, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdate_IEs_id_E2nodeComponentConfigUpdate:
            if(asn1PrtToStr_e2ap_E2nodeComponentConfigUpdate_List("E2nodeComponentConfigUpdate-List", 
                    pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_E2nodeComponentConfigUpdate, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdate_IEs_id_E2nodeComponentConfigRemoval:
            if(asn1PrtToStr_e2ap_E2nodeComponentConfigRemoval_List("E2nodeComponentConfigRemoval-List", 
                    pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_E2nodeComponentConfigRemoval, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdate_IEs_id_E2nodeTNLassociationRemoval:
            if(asn1PrtToStr_e2ap_E2nodeTNLassociationRemoval_List("E2nodeTNLassociationRemoval-List", 
                    pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_E2nodeTNLassociationRemoval, buffer, bufSize)<0)
                return -1;
            break;    
        default:
        if(0!=pvalue -> value.u.extElem1){
            rtPrintToStringIndent(buffer, bufSize);
            rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

        }
        }
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

    return 0;

 }

 void asn1Free_e2ap_E2nodeConfigurationUpdate_protocolIEs_element(OSCTXT* pctxt, e2ap_E2nodeConfigurationUpdate_protocolIEs_element* pvalue){
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdate_IEs_id_TransactionID:
            if(pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_TransactionID!=NULL){
            asn1Free_e2ap_TransactionID(pctxt, pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_TransactionID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_TransactionID);
            pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_TransactionID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdate_IEs_id_GlobalE2node_ID:
            if(pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_GlobalE2node_ID!=NULL){
            asn1Free_e2ap_GlobalE2node_ID(pctxt, pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_GlobalE2node_ID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_GlobalE2node_ID);
            pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_GlobalE2node_ID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdate_IEs_id_E2nodeComponentConfigAddition:
            if(pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_E2nodeComponentConfigAddition!=NULL){
            asn1Free_e2ap_E2nodeComponentConfigAddition_List(pctxt, pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_E2nodeComponentConfigAddition);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_E2nodeComponentConfigAddition);
            pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_E2nodeComponentConfigAddition = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdate_IEs_id_E2nodeComponentConfigUpdate:
            if(pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_E2nodeComponentConfigUpdate!=NULL){
            asn1Free_e2ap_E2nodeComponentConfigUpdate_List(pctxt, pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_E2nodeComponentConfigUpdate);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_E2nodeComponentConfigUpdate);
            pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_E2nodeComponentConfigUpdate = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdate_IEs_id_E2nodeComponentConfigRemoval:
            if(pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_E2nodeComponentConfigRemoval!=NULL){
            asn1Free_e2ap_E2nodeComponentConfigRemoval_List(pctxt, pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_E2nodeComponentConfigRemoval);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_E2nodeComponentConfigRemoval);
            pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_E2nodeComponentConfigRemoval = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdate_IEs_id_E2nodeTNLassociationRemoval:
            if(pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_E2nodeTNLassociationRemoval!=NULL){
            asn1Free_e2ap_E2nodeTNLassociationRemoval_List(pctxt, pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_E2nodeTNLassociationRemoval);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_E2nodeTNLassociationRemoval);
            pvalue->value.u._e2ap_E2nodeConfigurationUpdate_IEs_id_E2nodeTNLassociationRemoval = NULL;
            }
            break;
        default:
            break;


    }
 }

 

/*****************************************/
/*           E2nodeConfigurationUpdate                */
/*****************************************/
//2_container.c
/* 1. xxx_ProtocolIE -> mẫu cũ ở ie_big_msg */
EXTERN int asn1PE_e2ap_E2nodeConfigurationUpdate_protocolIEs (OSCTXT* pctxt, e2ap_E2nodeConfigurationUpdate_protocolIEs* pvalue)
{
    int stat =0;
    OSRTDListNode* pnode;
    OSUINT32 xx1;

    /*encode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pe_Length(pctxt, pvalue->count);
    if(stat<0) return LOG_RTERR(pctxt, stat);

    /*encode each element*/
    xx1 =0;
    for(pnode = pvalue->head; pnode != 0 && xx1<pvalue->count; pnode = pnode->next){
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE", xx1);
        stat = asn1PE_e2ap_E2nodeConfigurationUpdate_protocolIEs_element (pctxt, ((e2ap_E2nodeConfigurationUpdate_protocolIEs_element*)pnode->data));
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        xx1++;
        RTXCTXTPOPARRAYELEMNAME(pctxt);
    }

    return (stat);
}

EXTERN int  asn1PD_e2ap_E2nodeConfigurationUpdate_protocolIEs(OSCTXT* pctxt, e2ap_E2nodeConfigurationUpdate_protocolIEs* pvalue)
{
     int stat =0;
     OSRTDListNode* pnode;
     OSSIZE count =0;
     OSSIZE xx1=0;


     /*decode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pd_Length64(pctxt, &count); //tai sao lai 64
    if(stat!=0) return LOG_RTERR(pctxt, stat);

    /*decode each element*/
    rtxDListInit(pvalue);

    for(xx1=0; xx1 < count; xx1++){
        e2ap_E2nodeConfigurationUpdate_protocolIEs_element* pdata;
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE",xx1);

        if(pnode == NULL) return LOG_RTERR(pctxt, RTERR_NOMEM);

        asn1Init_e2ap_E2nodeConfigurationUpdate_protocolIEs_element(pdata);
        rtxDListAppendNode(pvalue, pnode);
        stat = asn1PD_e2ap_E2nodeConfigurationUpdate_protocolIEs_element (pctxt, pdata);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        RTXCTXTPOPARRAYELEMNAME(pctxt);

    }
    return (stat);
}


int asn1Init_e2ap_E2nodeConfigurationUpdate_protocolIEs(e2ap_E2nodeConfigurationUpdate_protocolIEs* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    rtxDListFastInit (pvalue);
    return 0;
}
#if 1 //ao that day
void asn1Free_e2ap_E2nodeConfigurationUpdate_protocolIEs(OSCTXT* pctxt, e2ap_E2nodeConfigurationUpdate_protocolIEs* pvalue)
{
    if(0==pvalue) return;   
    e2ap_E2nodeConfigurationUpdate_protocolIEs_element* pdata;
    OSRTDListNode* pnode=pvalue->head;
    while(0!=pnode){
        pdata = (e2ap_E2nodeConfigurationUpdate_protocolIEs_element*)pnode->data;
       // asn1Free_e2ap_E2nodeConfigurationUpdate_protocolIEs_element(pctxt, pdata);
        pnode = pnode->next;
    }
    rtxDListFreeAll(pctxt, pvalue);
}
#endif


EXTERN int asn1PrtToStr_e2ap_E2nodeConfigurationUpdate_protocolIEs(const char* name, e2ap_E2nodeConfigurationUpdate_protocolIEs* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_E2nodeConfigurationUpdate_protocolIEs_element* pdata0;
    OSRTDListNode* pnode0;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode0 = pvalue->head;  xx1 < pvalue->count && pnode0 != 0; pnode0 = pnode0->next, xx1++){
        pdata0 = (e2ap_E2nodeConfigurationUpdate_protocolIEs_element*)pnode0->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 0
        if(asn1PrtToStr_e2ap_E2nodeConfigurationUpdate_protocolIEs_element(nameBuf, pdata0, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}


/*2 . E2nodeConfigurationUpdate -> mẫu cũ ở seq_normal*/

int asn1PE_e2ap_E2nodeConfigurationUpdate (OSCTXT* pctxt, e2ap_E2nodeConfigurationUpdate* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "E2nodeConfigurationUpdate");
   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field protocolIEs - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
   stat = asn1PE_e2ap_E2nodeConfigurationUpdate_protocolIEs (pctxt, &pvalue->protocolIEs);
   if(stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_E2nodeConfigurationUpdate (OSCTXT* pctxt, e2ap_E2nodeConfigurationUpdate* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME(pctxt, "E2nodeConfigurationUpdate");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field protocolIEs */
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
      stat = asn1PD_e2ap_E2nodeConfigurationUpdate_protocolIEs (pctxt, &pvalue->protocolIEs);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_E2nodeConfigurationUpdate (e2ap_E2nodeConfigurationUpdate* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_E2nodeConfigurationUpdate_protocolIEs(&pvalue->protocolIEs);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_E2nodeConfigurationUpdate (OSCTXT* pctxt, e2ap_E2nodeConfigurationUpdate* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_E2nodeConfigurationUpdate_protocolIEs(pctxt, &pvalue->protocolIEs);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_E2nodeConfigurationUpdate (const char* name, e2ap_E2nodeConfigurationUpdate* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }

   if(asn1PrtToStr_e2ap_E2nodeConfigurationUpdate_protocolIEs("protocolIEs", &pvalue->protocolIEs, buffer, bufSize) <0){
      return -1;
   }

   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}
/*****************************************/
/*           E2nodeComponentConfigurationAck                */
/*****************************************/
//sequence normal
// Các nội dung cần thiết cho template seq_normal.c.j2
    // Nội dung của file .c cho primitive ENUMERATED
    //enumerated intergrate
//metadata.parsed.primitive_id == 13

//mau tu dapsresponseinfo-item -> dapsressponseindicator
const OSEnumItem e2ap_E2nodeComponentConfigurationAck_updateOutcome_ENUMTAB[] = {
    {OSUTF8("success"), 0,7,0},
    {OSUTF8("failure"), 1,7,1}
};

/* Encode / Decode */
EXTERN int asn1PE_e2ap_E2nodeComponentConfigurationAck_updateOutcome (OSCTXT* pctxt, e2ap_E2nodeComponentConfigurationAck_updateOutcome value){
    int stat =0;
    if(value >= 2) {
       rtxErrAddIntParm (pctxt, value);
       return LOG_RTERR (pctxt, RTERR_INVENUM);
    }

    /*extention bit*/
    stat = rtxEncBit (pctxt, 0);
    if(stat != 0) return LOG_RTERR (pctxt, stat);
    stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
    if(stat != 0) return LOG_RTERR (pctxt, stat);
    return stat;
}
EXTERN int asn1PD_e2ap_E2nodeComponentConfigurationAck_updateOutcome (OSCTXT* pctxt, e2ap_E2nodeComponentConfigurationAck_updateOutcome* pvalue){
    int stat = 0;
    OSUINT32 ui;
    OSBOOL extbit = FALSE;
    stat = DEC_BIT(pctxt, &extbit);
    if (stat != 0) return LOG_RTERR (pctxt, stat);

    if(extbit){
        stat = pd_SmallNonNegWholeNumber(pctxt, &ui);
        if(stat != 0) return LOG_RTERR (pctxt, stat);
        *pvalue = ASN_K_EXTENUM;
    }else{
        stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
        if(stat != 0) return LOG_RTERR (pctxt, stat);
    }
    
    return stat;

}

/* Print helpers */
EXTERN void asn1Print_e2ap_E2nodeComponentConfigurationAck_updateOutcome (const char* name, const e2ap_E2nodeComponentConfigurationAck_updateOutcome* pvalue){
    rtxPrintIndent();
    printf("%s: ", name);
    switch(*pvalue) {
        case 0:
            printf("success\n");
            break;
        case 1:
            printf("failure\n");
            break;
        default:
            printf("??? (%u)\n", *pvalue);
    }
}

/* Convert to stream (pretty print to stream) */
EXTERN int asn1PrtToStrm_e2ap_E2nodeComponentConfigurationAck_updateOutcome (OSCTXT* pctxt, const char* name, const e2ap_E2nodeComponentConfigurationAck_updateOutcome* pvalue){
    rtPrintToStringIndent(pctxt);
    rtPrintToStream(pctxt, name);
    switch(*pvalue) {
        case 0:
            rtPrintToStream(pctxt, " = success \n");
            break;
        case 1:
            rtPrintToStream(pctxt, " = failure \n");
            break;
        default:
            rtPrintToStreamUnsigned(pctxt, " = ???\n", *pvalue);
    }
}

/* Convert to string (write into user buffer) */
EXTERN int asn1PrtToStr_e2ap_E2nodeComponentConfigurationAck_updateOutcome (const char* name,e2ap_E2nodeComponentConfigurationAck_updateOutcome* pvalue,  char* buffer,OSSIZE bufSize){
    int stat;
    
    if(rtPrintToStringIndent(buffer, bufSize) < 0) return -1;
    if(rtPrintToString(name, buffer, bufSize) < 0) return -1;
    
    switch(*pvalue) {
        case 0:
            stat = rtPrintToString(" = success \n", buffer, bufSize);
            break;
        case 1:
            stat = rtPrintToString(" = failure \n", buffer, bufSize);
            break;
        default:
            stat = rtPrintToStringUnsigned(" = ???\n",*pvalue, buffer, bufSize);
    }
    
    if (stat < 0) return -1;
    return 0;   
}

/* Enum <-> String conversion */
EXTERN const OSUTF8CHAR* e2ap_E2nodeComponentConfigurationAck_updateOutcome_ToString (OSUINT32 value){
    OSINT32 idx = value;
    if (idx >= 0 && idx < e2ap_E2nodeComponentConfigurationAck_updateOutcome_ENUMTABSIZE) {
        return e2ap_E2nodeComponentConfigurationAck_updateOutcome_ENUMTAB
        [e2ap_E2nodeComponentConfigurationAck_updateOutcome_ENUMTAB[idx].transidx].name;
    } else {
        return OSUTF8("_UNKNOWN_");
    }
}
EXTERN int e2ap_E2nodeComponentConfigurationAck_updateOutcome_ToEnum (OSCTXT* pctxt, const OSUTF8CHAR* value,e2ap_E2nodeComponentConfigurationAck_updateOutcome* pvalue){
    OSSIZE valueLen = rtxUTF8LenBytes(value);
    return e2ap_E2nodeComponentConfigurationAck_updateOutcome_ToEnum2 (pctxt, value, valueLen, pvalue);
}

EXTERN int e2ap_E2nodeComponentConfigurationAck_updateOutcome_ToEnum2 (OSCTXT* pctxt, const OSUTF8CHAR* value, OSSIZE valueLen,e2ap_E2nodeComponentConfigurationAck_updateOutcome* pvalue){
    OSINT32 idx = rtxLookupEnum(value, valueLen,
       e2ap_E2nodeComponentConfigurationAck_updateOutcome_ENUMTAB, 
       e2ap_E2nodeComponentConfigurationAck_updateOutcome_ENUMTABSIZE);
    if (idx >= 0) {
       *pvalue = (e2ap_E2nodeComponentConfigurationAck_updateOutcome)e2ap_E2nodeComponentConfigurationAck_updateOutcome_ENUMTAB[idx].value;
       return 0;
    } else {
       rtxErrAddStrParm (pctxt, (const char*)value);
       return LOG_RTERR (pctxt, RTERR_INVENUM);
    }
}

EXTERN int asn1Init_e2ap_E2nodeComponentConfigurationAck_updateOutcome (e2ap_E2nodeComponentConfigurationAck_updateOutcome* pvalue){
    //if (pvalue == 0) return RTERR_NULLPTR;
    //*pvalue = 0;
    return 0;
}

// Các phần còn lại của template seq_normal.c.j2
//contain extensition bit -> theo mau cua GlobalgNB-ID
int asn1PE_e2ap_E2nodeComponentConfigurationAck (OSCTXT* pctxt, e2ap_E2nodeComponentConfigurationAck* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "E2nodeComponentConfigurationAck");

   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);

   /*optional bit for field failureCause*/
   stat = rtxEncBit (pctxt, pvalue->m_failureCausePresent);
   if (stat != 0) return LOG_RTERR(pctxt, stat);

   /*encode root elements*/   
   /* encode field updateOutcome - id = 13*/  
   RTXCTXTPUSHELEMNAME(pctxt, "updateOutcome");
   stat = asn1PE_e2ap_E2nodeComponentConfigurationAck_updateOutcome(pctxt, &pvalue->updateOutcome); //enum inter prim
  
  
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /* encode field failureCause - id = -1*/  
   if (pvalue->m_failureCausePresent) {//OPTIONAL FIELD
   RTXCTXTPUSHELEMNAME(pctxt, "failureCause");
   stat = asn1PE_e2ap_Cause (pctxt, pvalue->failureCause);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   }


   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_E2nodeComponentConfigurationAck (OSCTXT* pctxt, e2ap_E2nodeComponentConfigurationAck* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME(pctxt, "E2nodeComponentConfigurationAck");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field updateOutcome */
   RTXCTXTPUSHELEMNAME(pctxt, "updateOutcome");
      stat = asn1PD_e2ap_E2nodeComponentConfigurationAck_updateOutcome (pctxt, &pvalue->updateOutcome); //primitive
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field failureCause */
   RTXCTXTPUSHELEMNAME(pctxt, "failureCause");
   if (optbits[0]) {
      pvalue->m_failureCausePresent = TRUE;
      stat = asn1PD_e2ap_Cause (pctxt, &pvalue->failureCause);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   } else {
      pvalue->m_failureCausePresent = FALSE;
   }
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_E2nodeComponentConfigurationAck (e2ap_E2nodeComponentConfigurationAck* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_E2nodeComponentConfigurationAck_updateOutcome (&pvalue->updateOutcome); //primitive delete &
   asn1Init_e2ap_Cause (&pvalue->failureCause);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_E2nodeComponentConfigurationAck (OSCTXT* pctxt, e2ap_E2nodeComponentConfigurationAck* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_Cause (pctxt, &pvalue->failureCause);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_E2nodeComponentConfigurationAck (const char* name, e2ap_E2nodeComponentConfigurationAck* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }

   if(asn1PrtToStr_e2ap_E2nodeComponentConfigurationAck_updateOutcome ("updateOutcome", &pvalue->updateOutcome, buffer, bufSize) < 0)
   {
      return -1;
   }

   if(asn1PrtToStr_e2ap_Cause ("failureCause", &pvalue->failureCause, buffer, bufSize) < 0)
   {
      return -1;
   }



   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}
/*****************************************/
/*           E2nodeComponentConfigAdditionAck-Item                */
/*****************************************/
//sequence normal
// Các nội dung cần thiết cho template seq_normal.c.j2

// Các phần còn lại của template seq_normal.c.j2
//contain extensition bit -> theo mau cua GlobalgNB-ID
int asn1PE_e2ap_E2nodeComponentConfigAdditionAck_Item (OSCTXT* pctxt, e2ap_E2nodeComponentConfigAdditionAck_Item* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "E2nodeComponentConfigAdditionAck-Item");

   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field e2nodeComponentInterfaceType - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "e2nodeComponentInterfaceType");
   stat = asn1PE_e2ap_E2nodeComponentInterfaceType (pctxt, pvalue->e2nodeComponentInterfaceType);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /* encode field e2nodeComponentID - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "e2nodeComponentID");
   stat = asn1PE_e2ap_E2nodeComponentID (pctxt, pvalue->e2nodeComponentID);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /* encode field e2nodeComponentConfigurationAck - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "e2nodeComponentConfigurationAck");
   stat = asn1PE_e2ap_E2nodeComponentConfigurationAck (pctxt, pvalue->e2nodeComponentConfigurationAck);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);



   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_E2nodeComponentConfigAdditionAck_Item (OSCTXT* pctxt, e2ap_E2nodeComponentConfigAdditionAck_Item* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[3];

   RTXCTXTPUSHTYPENAME(pctxt, "E2nodeComponentConfigAdditionAck-Item");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field e2nodeComponentInterfaceType */
   RTXCTXTPUSHELEMNAME(pctxt, "e2nodeComponentInterfaceType");
      stat = asn1PD_e2ap_E2nodeComponentInterfaceType (pctxt, &pvalue->e2nodeComponentInterfaceType);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field e2nodeComponentID */
   RTXCTXTPUSHELEMNAME(pctxt, "e2nodeComponentID");
      stat = asn1PD_e2ap_E2nodeComponentID (pctxt, &pvalue->e2nodeComponentID);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field e2nodeComponentConfigurationAck */
   RTXCTXTPUSHELEMNAME(pctxt, "e2nodeComponentConfigurationAck");
      stat = asn1PD_e2ap_E2nodeComponentConfigurationAck (pctxt, &pvalue->e2nodeComponentConfigurationAck);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_E2nodeComponentConfigAdditionAck_Item (e2ap_E2nodeComponentConfigAdditionAck_Item* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_E2nodeComponentInterfaceType (&pvalue->e2nodeComponentInterfaceType);
   asn1Init_e2ap_E2nodeComponentID (&pvalue->e2nodeComponentID);
   asn1Init_e2ap_E2nodeComponentConfigurationAck (&pvalue->e2nodeComponentConfigurationAck);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_E2nodeComponentConfigAdditionAck_Item (OSCTXT* pctxt, e2ap_E2nodeComponentConfigAdditionAck_Item* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_E2nodeComponentInterfaceType (pctxt, &pvalue->e2nodeComponentInterfaceType);
   asn1Free_e2ap_E2nodeComponentID (pctxt, &pvalue->e2nodeComponentID);
   asn1Free_e2ap_E2nodeComponentConfigurationAck (pctxt, &pvalue->e2nodeComponentConfigurationAck);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_E2nodeComponentConfigAdditionAck_Item (const char* name, e2ap_E2nodeComponentConfigAdditionAck_Item* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }
   if(asn1PrtToStr_e2ap_E2nodeComponentInterfaceType ("e2nodeComponentInterfaceType", &pvalue->e2nodeComponentInterfaceType, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_E2nodeComponentID ("e2nodeComponentID", &pvalue->e2nodeComponentID, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_E2nodeComponentConfigurationAck ("e2nodeComponentConfigurationAck", &pvalue->e2nodeComponentConfigurationAck, buffer, bufSize) < 0)
   {
      return -1;
   }



   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           E2nodeComponentConfigAdditionAck_ItemIEs                */
/*****************************************/
/* ie.c.j2 */
/*ie thường*/
int asn1PE_e2ap_E2nodeComponentConfigAdditionAck_ItemIEs (OSCTXT* pctxt, e2ap_E2nodeComponentConfigAdditionAck_ItemIEs* pvalue)
{
   int stat = 0;
   //RTXCTXTPUSHTYPENAME (pctxt, "E2nodeComponentConfigAdditionAck-ItemIEs");

   /* encode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");
   stat = asn1PE_e2ap_ProtocolIE_ID (pctxt, pvalue->id);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");
   stat = asn1PE_e2ap_Criticality (pctxt, pvalue->criticality);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   {
      OSCTXT ictxt;
      OSOCTET* pDynamicEncodeBuffer;
      ASN1OpenType openType;
      OSBOOL  encoded = TRUE;

      openType.numocts = 0;
      openType.data = 0;

      rtxCopyContext (&ictxt, pctxt);
      pctxt->pStream = 0;

      stat = rtxInitContextBuffer (pctxt, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_E2nodeComponentConfigAdditionAck_ItemIEs_id_E2nodeComponentConfigAdditionAck_Item:
         
        // RTXCTXTPUSHELEMNAME (pctxt, "E2nodeComponentConfigAdditionAck_ItemIEs_id_E2nodeComponentConfigAdditionAck_Item");
         RTXCTXTPUSHELEMNAME (pctxt, "E2nodeComponentConfigAdditionAck-Item");
         stat = asn1PE_e2ap_E2nodeComponentConfigAdditionAck_Item (pctxt, pvalue->value.u._e2apE2nodeComponentConfigAdditionAck_ItemIEs_id_E2nodeComponentConfigAdditionAck_Item);
         RTXCTXTPOPELEMNAME (pctxt);
      
         break;

      case T_E2AP_PDU_Contents_e2ap_E2nodeComponentConfigAdditionAck_ItemIEs_UNDEF_:
      {
          if(0!=pvalue->value.u.extElem1){
              openType.numocts = pvalue->value.u.extElem1->numocts;
              openType.data = pvalue->value.u.extElem1->data;
          } else {
              /* No extension element to encode */
          }
          encoded = FALSE;
          break;
      }
      default:
         encoded = FALSE;
         stat = RTERR_INVOPT;
      }

      if (encoded) {
         openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
         openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
      }
      rtxCopyContext (pctxt, &ictxt);
      if(stat ==0) stat = pe_OpenType(pctxt, openType.numocts, openType.data);
      /*free dynamic encode buffer*/
      if(encoded){
          rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
      }
   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);
   //RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

int asn1PD_e2ap_E2nodeComponentConfigAdditionAck_ItemIEs (OSCTXT* pctxt, e2ap_E2nodeComponentConfigAdditionAck_ItemIEs* pvalue)
{
   int stat =0;
   /*deode root element id*/
   RTXCTXTPUSHELEMNAME(pctxt, "id");
   stat = asn1PD_e2ap_ProtocolIE_ID (pctxt, &pvalue->id);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*decode root element criticality*/
   RTXCTXTPUSHELEMNAME(pctxt, "criticality");
   stat = asn1PD_e2ap_Criticality (pctxt, &pvalue->criticality);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   /*decode root element value*/
   RTXCTXTPUSHELEMNAME(pctxt, "value");
   {
      OSUINT32 openTypeLen;
      size_t bitStartOffset, bitLength;
      stat = pd_UnconsLength(pctxt, &openTypeLen);
      if(stat <0) return LOG_RTERR(pctxt, stat);
      else if(stat == RT_OK_FRAG){
         rtxErrAddStrParm(pctxt, "open type with fragmented length use - perindef");
         return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
      }
      bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
      bitLength = openTypeLen * 8;
      switch (pvalue->id){
         case T_E2AP_PDU_Contents_e2ap_E2nodeComponentConfigAdditionAck_ItemIEs_id_E2nodeComponentConfigAdditionAck_Item:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_E2nodeComponentConfigAdditionAck_ItemIEs_id_E2nodeComponentConfigAdditionAck_Item;
            RTXCTXTPUSHELEMNAME(pctxt, "E2nodeComponentConfigAdditionAck-Item");
            //pvalue->value.u._e2ap_E2nodeComponentConfigAdditionAck_ItemIEs_id_id_E2nodeComponentConfigAdditionAck_Item 
             pvalue->value.u._e2apE2nodeComponentConfigAdditionAck_ItemIEs_id_E2nodeComponentConfigAdditionAck_Item 
                    = rtxMemAllocType(pctxt, e2ap_E2nodeComponentConfigAdditionAck_Item);
            //asn1Init_e2ap_E2nodeComponentConfigAdditionAck_Item(pvalue->value.u._e2ap_E2nodeComponentConfigAdditionAck_ItemIEs_id_id_E2nodeComponentConfigAdditionAck_Item);
            asn1Init_e2ap_E2nodeComponentConfigAdditionAck_Item(pvalue->value.u._e2apE2nodeComponentConfigAdditionAck_ItemIEs_id_E2nodeComponentConfigAdditionAck_Item);
            stat = asn1PD_e2ap_E2nodeComponentConfigAdditionAck_Item (pctxt,
                    (e2ap_E2nodeComponentConfigAdditionAck_Item*)pvalue->value.
                    u._e2apE2nodeComponentConfigAdditionAck_ItemIEs_id_E2nodeComponentConfigAdditionAck_Item);
            if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_E2nodeComponentConfigAdditionAck_ItemIEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*)rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
      }
      {
      size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
      size_t bitsConsumed = bitEndOffset - bitStartOffset;
      if(bitsConsumed < bitLength){
         stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
      } else {
         stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
      }
      }
   }
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   return stat;
}

void asn1Init_e2ap_E2nodeComponentConfigAdditionAck_ItemIEs (e2ap_E2nodeComponentConfigAdditionAck_ItemIEs* pvalue)
{
   if (!pvalue) return;
   OSCRTLMEMSET (pvalue, 0, sizeof(e2ap_E2nodeComponentConfigAdditionAck_ItemIEs));
}

#if 0
void asn1Free_e2ap_E2nodeComponentConfigAdditionAck_ItemIEs (OSCTXT* pctxt, e2ap_E2nodeComponentConfigAdditionAck_ItemIEs* pvalue)
{
   if (!pvalue) return;
   if (pvalue->extElem1) {
      rtxMemFreeArray (pctxt, pvalue->extElem1);
      pvalue->extElem1 = 0;
      pvalue->extElem1_n = 0;
   }
}
#endif
void asn1Free_e2ap_E2nodeComponentConfigAdditionAck_ItemIEs (OSCTXT* pctxt, e2ap_E2nodeComponentConfigAdditionAck_ItemIEs* pvalue)
{
   if(0==pvalue) return;
   switch(pvalue->value.t){
      case T_E2AP_PDU_Contents_e2ap_E2nodeComponentConfigAdditionAck_ItemIEs_id_E2nodeComponentConfigAdditionAck_Item:
         asn1Free_e2ap_E2nodeComponentConfigAdditionAck_Item (pctxt, pvalue->value.u._e2apE2nodeComponentConfigAdditionAck_ItemIEs_id_E2nodeComponentConfigAdditionAck_Item);
         rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2apE2nodeComponentConfigAdditionAck_ItemIEs_id_E2nodeComponentConfigAdditionAck_Item);
         pvalue->value.u._e2apE2nodeComponentConfigAdditionAck_ItemIEs_id_E2nodeComponentConfigAdditionAck_Item = 0;
         break;
      case T_E2AP_PDU_Contents_e2ap_E2nodeComponentConfigAdditionAck_ItemIEs_UNDEF_:
         if(0!=pvalue->value.u.extElem1){
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1->data);
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
             pvalue->value.u.extElem1 =0;
         }
         break;
         default:;
   }
}

int  asn1PrtToStr_e2ap_E2nodeComponentConfigAdditionAck_ItemIEs (const char * name, e2ap_E2nodeComponentConfigAdditionAck_ItemIEs* pvalue, char * buffer, OSSIZE bufSize){
   if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
       return -1;

      if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
         return -1;

      if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
         return -1;
      if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
         return -1;
      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_E2nodeComponentConfigAdditionAck_ItemIEs_id_E2nodeComponentConfigAdditionAck_Item:
         if(asn1PrtToStr_e2ap_E2nodeComponentConfigAdditionAck_Item("E2nodeComponentConfigAdditionAck-Item",
                pvalue->value.u._e2apE2nodeComponentConfigAdditionAck_ItemIEs_id_E2nodeComponentConfigAdditionAck_Item, buffer, bufSize)<0)// dungnm23 check lai nhe xem la
            return -1;
         break;
      default:
         if(0!=pvalue -> value.u.extElem1){
             rtPrintToStringIndent(buffer, bufSize);
             rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

         }
      }
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

      return 0;

}
 

/*****************************************/
/*           E2nodeComponentConfigAdditionAck_List                */
/*****************************************/
//seq_of_single_container


int asn1PE_e2ap_E2nodeComponentConfigAdditionAck_List (OSCTXT* pctxt, e2ap_E2nodeComponentConfigAdditionAck_List* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_E2nodeComponentConfigAdditionAck_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "E2nodeComponentConfigAdditionAck-List");

   /* encode length determinant */
   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1024), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;
   for (xx1 = 0; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next, xx1++) {
      pdata = (e2ap_E2nodeComponentConfigAdditionAck_ItemIEs*) pnode->data;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_e2ap_E2nodeComponentConfigAdditionAck_ItemIEs (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      //xx1++;
      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}

int asn1PD_e2ap_E2nodeComponentConfigAdditionAck_List (OSCTXT* pctxt, e2ap_E2nodeComponentConfigAdditionAck_List* ppvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_E2nodeComponentConfigAdditionAck_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "E2nodeComponentConfigAdditionAck-List");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1024), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (ppvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      pdata = rtxMemAllocType (pctxt, e2ap_E2nodeComponentConfigAdditionAck_ItemIEs);
      if (!pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);
      asn1Init_e2ap_E2nodeComponentConfigAdditionAck_ItemIEs (pdata);
      stat = asn1PD_e2ap_E2nodeComponentConfigAdditionAck_ItemIEs (pctxt, pdata);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         return LOG_RTERR (pctxt, stat);
      }

      rtxDListAppendNode (ppvalue, pdata);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

void asn1Init_e2ap_E2nodeComponentConfigAdditionAck_List (e2ap_E2nodeComponentConfigAdditionAck_List* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
}

void asn1Free_e2ap_E2nodeComponentConfigAdditionAck_List (OSCTXT* pctxt, e2ap_E2nodeComponentConfigAdditionAck_List* pvalue)
{
   if(pvalue==0) return;
   OSRTDListNode* pnode = pvalue->head;
   while (pnode) {
      e2ap_E2nodeComponentConfigAdditionAck_ItemIEs* pdata = (e2ap_E2nodeComponentConfigAdditionAck_ItemIEs*) pnode->data;
      if (pdata) {
         asn1Free_e2ap_E2nodeComponentConfigAdditionAck_ItemIEs (pctxt, pdata);
         rtxMemFreePtr (pctxt, pdata);
      }
      pnode = pnode->next;
   }
      rtxDListFreeAll(pctxt, pvalue);
}

#if 0
void asn1Free_e2ap_E2nodeComponentConfigAdditionAck_List (OSCTXT* pctxt, e2ap_E2nodeComponentConfigAdditionAck_List* pvalue){
   if(0==pvalue ) return;
   {
      e2ap_E2nodeComponentConfigAdditionAck_ItemIEs * pdata;
      OSRTDListNode *pnode = pvalue->head;
      while(0!=pnode){
         pdata = (e2ap_E2nodeComponentConfigAdditionAck_ItemIEs*)pnode->data;
         asn1Free_e2ap_E2nodeComponentConfigAdditionAck_ItemIEs(pctxt, pdata);
         pnode = pnode->next;
      }
      rtxDListFreeAll(pctxt, pvalue);
   }
}
#endif


int asn1PrtToStr_e2ap_E2nodeComponentConfigAdditionAck_List(const char* name, e2ap_E2nodeComponentConfigAdditionAck_List* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_E2nodeComponentConfigAdditionAck_ItemIEs* pdata;
    OSRTDListNode* pnode;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode = pvalue->head;  xx1 < pvalue->count && pnode != 0; pnode = pnode->next, xx1++){
        pdata = (e2ap_E2nodeComponentConfigAdditionAck_ItemIEs*)pnode->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 1
        if(asn1PrtToStr_e2ap_E2nodeComponentConfigAdditionAck_ItemIEs(nameBuf, pdata, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}
/*****************************************/
/*           E2nodeComponentConfigUpdateAck-Item                */
/*****************************************/
//sequence normal
// Các nội dung cần thiết cho template seq_normal.c.j2

// Các phần còn lại của template seq_normal.c.j2
//contain extensition bit -> theo mau cua GlobalgNB-ID
int asn1PE_e2ap_E2nodeComponentConfigUpdateAck_Item (OSCTXT* pctxt, e2ap_E2nodeComponentConfigUpdateAck_Item* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "E2nodeComponentConfigUpdateAck-Item");

   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field e2nodeComponentInterfaceType - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "e2nodeComponentInterfaceType");
   stat = asn1PE_e2ap_E2nodeComponentInterfaceType (pctxt, pvalue->e2nodeComponentInterfaceType);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /* encode field e2nodeComponentID - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "e2nodeComponentID");
   stat = asn1PE_e2ap_E2nodeComponentID (pctxt, pvalue->e2nodeComponentID);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /* encode field e2nodeComponentConfigurationAck - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "e2nodeComponentConfigurationAck");
   stat = asn1PE_e2ap_E2nodeComponentConfigurationAck (pctxt, pvalue->e2nodeComponentConfigurationAck);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);



   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_E2nodeComponentConfigUpdateAck_Item (OSCTXT* pctxt, e2ap_E2nodeComponentConfigUpdateAck_Item* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[3];

   RTXCTXTPUSHTYPENAME(pctxt, "E2nodeComponentConfigUpdateAck-Item");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field e2nodeComponentInterfaceType */
   RTXCTXTPUSHELEMNAME(pctxt, "e2nodeComponentInterfaceType");
      stat = asn1PD_e2ap_E2nodeComponentInterfaceType (pctxt, &pvalue->e2nodeComponentInterfaceType);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field e2nodeComponentID */
   RTXCTXTPUSHELEMNAME(pctxt, "e2nodeComponentID");
      stat = asn1PD_e2ap_E2nodeComponentID (pctxt, &pvalue->e2nodeComponentID);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field e2nodeComponentConfigurationAck */
   RTXCTXTPUSHELEMNAME(pctxt, "e2nodeComponentConfigurationAck");
      stat = asn1PD_e2ap_E2nodeComponentConfigurationAck (pctxt, &pvalue->e2nodeComponentConfigurationAck);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_E2nodeComponentConfigUpdateAck_Item (e2ap_E2nodeComponentConfigUpdateAck_Item* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_E2nodeComponentInterfaceType (&pvalue->e2nodeComponentInterfaceType);
   asn1Init_e2ap_E2nodeComponentID (&pvalue->e2nodeComponentID);
   asn1Init_e2ap_E2nodeComponentConfigurationAck (&pvalue->e2nodeComponentConfigurationAck);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_E2nodeComponentConfigUpdateAck_Item (OSCTXT* pctxt, e2ap_E2nodeComponentConfigUpdateAck_Item* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_E2nodeComponentInterfaceType (pctxt, &pvalue->e2nodeComponentInterfaceType);
   asn1Free_e2ap_E2nodeComponentID (pctxt, &pvalue->e2nodeComponentID);
   asn1Free_e2ap_E2nodeComponentConfigurationAck (pctxt, &pvalue->e2nodeComponentConfigurationAck);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_E2nodeComponentConfigUpdateAck_Item (const char* name, e2ap_E2nodeComponentConfigUpdateAck_Item* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }
   if(asn1PrtToStr_e2ap_E2nodeComponentInterfaceType ("e2nodeComponentInterfaceType", &pvalue->e2nodeComponentInterfaceType, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_E2nodeComponentID ("e2nodeComponentID", &pvalue->e2nodeComponentID, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_E2nodeComponentConfigurationAck ("e2nodeComponentConfigurationAck", &pvalue->e2nodeComponentConfigurationAck, buffer, bufSize) < 0)
   {
      return -1;
   }



   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           E2nodeComponentConfigUpdateAck_ItemIEs                */
/*****************************************/
/* ie.c.j2 */
/*ie thường*/
int asn1PE_e2ap_E2nodeComponentConfigUpdateAck_ItemIEs (OSCTXT* pctxt, e2ap_E2nodeComponentConfigUpdateAck_ItemIEs* pvalue)
{
   int stat = 0;
   //RTXCTXTPUSHTYPENAME (pctxt, "E2nodeComponentConfigUpdateAck-ItemIEs");

   /* encode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");
   stat = asn1PE_e2ap_ProtocolIE_ID (pctxt, pvalue->id);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");
   stat = asn1PE_e2ap_Criticality (pctxt, pvalue->criticality);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   {
      OSCTXT ictxt;
      OSOCTET* pDynamicEncodeBuffer;
      ASN1OpenType openType;
      OSBOOL  encoded = TRUE;

      openType.numocts = 0;
      openType.data = 0;

      rtxCopyContext (&ictxt, pctxt);
      pctxt->pStream = 0;

      stat = rtxInitContextBuffer (pctxt, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_E2nodeComponentConfigUpdateAck_ItemIEs_id_E2nodeComponentConfigUpdateAck_Item:
         
        // RTXCTXTPUSHELEMNAME (pctxt, "E2nodeComponentConfigUpdateAck_ItemIEs_id_E2nodeComponentConfigUpdateAck_Item");
         RTXCTXTPUSHELEMNAME (pctxt, "E2nodeComponentConfigUpdateAck-Item");
         stat = asn1PE_e2ap_E2nodeComponentConfigUpdateAck_Item (pctxt, pvalue->value.u._e2apE2nodeComponentConfigUpdateAck_ItemIEs_id_E2nodeComponentConfigUpdateAck_Item);
         RTXCTXTPOPELEMNAME (pctxt);
      
         break;

      case T_E2AP_PDU_Contents_e2ap_E2nodeComponentConfigUpdateAck_ItemIEs_UNDEF_:
      {
          if(0!=pvalue->value.u.extElem1){
              openType.numocts = pvalue->value.u.extElem1->numocts;
              openType.data = pvalue->value.u.extElem1->data;
          } else {
              /* No extension element to encode */
          }
          encoded = FALSE;
          break;
      }
      default:
         encoded = FALSE;
         stat = RTERR_INVOPT;
      }

      if (encoded) {
         openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
         openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
      }
      rtxCopyContext (pctxt, &ictxt);
      if(stat ==0) stat = pe_OpenType(pctxt, openType.numocts, openType.data);
      /*free dynamic encode buffer*/
      if(encoded){
          rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
      }
   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);
   //RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

int asn1PD_e2ap_E2nodeComponentConfigUpdateAck_ItemIEs (OSCTXT* pctxt, e2ap_E2nodeComponentConfigUpdateAck_ItemIEs* pvalue)
{
   int stat =0;
   /*deode root element id*/
   RTXCTXTPUSHELEMNAME(pctxt, "id");
   stat = asn1PD_e2ap_ProtocolIE_ID (pctxt, &pvalue->id);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*decode root element criticality*/
   RTXCTXTPUSHELEMNAME(pctxt, "criticality");
   stat = asn1PD_e2ap_Criticality (pctxt, &pvalue->criticality);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   /*decode root element value*/
   RTXCTXTPUSHELEMNAME(pctxt, "value");
   {
      OSUINT32 openTypeLen;
      size_t bitStartOffset, bitLength;
      stat = pd_UnconsLength(pctxt, &openTypeLen);
      if(stat <0) return LOG_RTERR(pctxt, stat);
      else if(stat == RT_OK_FRAG){
         rtxErrAddStrParm(pctxt, "open type with fragmented length use - perindef");
         return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
      }
      bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
      bitLength = openTypeLen * 8;
      switch (pvalue->id){
         case T_E2AP_PDU_Contents_e2ap_E2nodeComponentConfigUpdateAck_ItemIEs_id_E2nodeComponentConfigUpdateAck_Item:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_E2nodeComponentConfigUpdateAck_ItemIEs_id_E2nodeComponentConfigUpdateAck_Item;
            RTXCTXTPUSHELEMNAME(pctxt, "E2nodeComponentConfigUpdateAck-Item");
            //pvalue->value.u._e2ap_E2nodeComponentConfigUpdateAck_ItemIEs_id_id_E2nodeComponentConfigUpdateAck_Item 
             pvalue->value.u._e2apE2nodeComponentConfigUpdateAck_ItemIEs_id_E2nodeComponentConfigUpdateAck_Item 
                    = rtxMemAllocType(pctxt, e2ap_E2nodeComponentConfigUpdateAck_Item);
            //asn1Init_e2ap_E2nodeComponentConfigUpdateAck_Item(pvalue->value.u._e2ap_E2nodeComponentConfigUpdateAck_ItemIEs_id_id_E2nodeComponentConfigUpdateAck_Item);
            asn1Init_e2ap_E2nodeComponentConfigUpdateAck_Item(pvalue->value.u._e2apE2nodeComponentConfigUpdateAck_ItemIEs_id_E2nodeComponentConfigUpdateAck_Item);
            stat = asn1PD_e2ap_E2nodeComponentConfigUpdateAck_Item (pctxt,
                    (e2ap_E2nodeComponentConfigUpdateAck_Item*)pvalue->value.
                    u._e2apE2nodeComponentConfigUpdateAck_ItemIEs_id_E2nodeComponentConfigUpdateAck_Item);
            if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_E2nodeComponentConfigUpdateAck_ItemIEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*)rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
      }
      {
      size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
      size_t bitsConsumed = bitEndOffset - bitStartOffset;
      if(bitsConsumed < bitLength){
         stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
      } else {
         stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
      }
      }
   }
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   return stat;
}

void asn1Init_e2ap_E2nodeComponentConfigUpdateAck_ItemIEs (e2ap_E2nodeComponentConfigUpdateAck_ItemIEs* pvalue)
{
   if (!pvalue) return;
   OSCRTLMEMSET (pvalue, 0, sizeof(e2ap_E2nodeComponentConfigUpdateAck_ItemIEs));
}

#if 0
void asn1Free_e2ap_E2nodeComponentConfigUpdateAck_ItemIEs (OSCTXT* pctxt, e2ap_E2nodeComponentConfigUpdateAck_ItemIEs* pvalue)
{
   if (!pvalue) return;
   if (pvalue->extElem1) {
      rtxMemFreeArray (pctxt, pvalue->extElem1);
      pvalue->extElem1 = 0;
      pvalue->extElem1_n = 0;
   }
}
#endif
void asn1Free_e2ap_E2nodeComponentConfigUpdateAck_ItemIEs (OSCTXT* pctxt, e2ap_E2nodeComponentConfigUpdateAck_ItemIEs* pvalue)
{
   if(0==pvalue) return;
   switch(pvalue->value.t){
      case T_E2AP_PDU_Contents_e2ap_E2nodeComponentConfigUpdateAck_ItemIEs_id_E2nodeComponentConfigUpdateAck_Item:
         asn1Free_e2ap_E2nodeComponentConfigUpdateAck_Item (pctxt, pvalue->value.u._e2apE2nodeComponentConfigUpdateAck_ItemIEs_id_E2nodeComponentConfigUpdateAck_Item);
         rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2apE2nodeComponentConfigUpdateAck_ItemIEs_id_E2nodeComponentConfigUpdateAck_Item);
         pvalue->value.u._e2apE2nodeComponentConfigUpdateAck_ItemIEs_id_E2nodeComponentConfigUpdateAck_Item = 0;
         break;
      case T_E2AP_PDU_Contents_e2ap_E2nodeComponentConfigUpdateAck_ItemIEs_UNDEF_:
         if(0!=pvalue->value.u.extElem1){
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1->data);
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
             pvalue->value.u.extElem1 =0;
         }
         break;
         default:;
   }
}

int  asn1PrtToStr_e2ap_E2nodeComponentConfigUpdateAck_ItemIEs (const char * name, e2ap_E2nodeComponentConfigUpdateAck_ItemIEs* pvalue, char * buffer, OSSIZE bufSize){
   if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
       return -1;

      if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
         return -1;

      if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
         return -1;
      if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
         return -1;
      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_E2nodeComponentConfigUpdateAck_ItemIEs_id_E2nodeComponentConfigUpdateAck_Item:
         if(asn1PrtToStr_e2ap_E2nodeComponentConfigUpdateAck_Item("E2nodeComponentConfigUpdateAck-Item",
                pvalue->value.u._e2apE2nodeComponentConfigUpdateAck_ItemIEs_id_E2nodeComponentConfigUpdateAck_Item, buffer, bufSize)<0)// dungnm23 check lai nhe xem la
            return -1;
         break;
      default:
         if(0!=pvalue -> value.u.extElem1){
             rtPrintToStringIndent(buffer, bufSize);
             rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

         }
      }
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

      return 0;

}
 

/*****************************************/
/*           E2nodeComponentConfigUpdateAck_List                */
/*****************************************/
//seq_of_single_container


int asn1PE_e2ap_E2nodeComponentConfigUpdateAck_List (OSCTXT* pctxt, e2ap_E2nodeComponentConfigUpdateAck_List* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_E2nodeComponentConfigUpdateAck_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "E2nodeComponentConfigUpdateAck-List");

   /* encode length determinant */
   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1024), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;
   for (xx1 = 0; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next, xx1++) {
      pdata = (e2ap_E2nodeComponentConfigUpdateAck_ItemIEs*) pnode->data;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_e2ap_E2nodeComponentConfigUpdateAck_ItemIEs (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      //xx1++;
      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}

int asn1PD_e2ap_E2nodeComponentConfigUpdateAck_List (OSCTXT* pctxt, e2ap_E2nodeComponentConfigUpdateAck_List* ppvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_E2nodeComponentConfigUpdateAck_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "E2nodeComponentConfigUpdateAck-List");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1024), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (ppvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      pdata = rtxMemAllocType (pctxt, e2ap_E2nodeComponentConfigUpdateAck_ItemIEs);
      if (!pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);
      asn1Init_e2ap_E2nodeComponentConfigUpdateAck_ItemIEs (pdata);
      stat = asn1PD_e2ap_E2nodeComponentConfigUpdateAck_ItemIEs (pctxt, pdata);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         return LOG_RTERR (pctxt, stat);
      }

      rtxDListAppendNode (ppvalue, pdata);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

void asn1Init_e2ap_E2nodeComponentConfigUpdateAck_List (e2ap_E2nodeComponentConfigUpdateAck_List* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
}

void asn1Free_e2ap_E2nodeComponentConfigUpdateAck_List (OSCTXT* pctxt, e2ap_E2nodeComponentConfigUpdateAck_List* pvalue)
{
   if(pvalue==0) return;
   OSRTDListNode* pnode = pvalue->head;
   while (pnode) {
      e2ap_E2nodeComponentConfigUpdateAck_ItemIEs* pdata = (e2ap_E2nodeComponentConfigUpdateAck_ItemIEs*) pnode->data;
      if (pdata) {
         asn1Free_e2ap_E2nodeComponentConfigUpdateAck_ItemIEs (pctxt, pdata);
         rtxMemFreePtr (pctxt, pdata);
      }
      pnode = pnode->next;
   }
      rtxDListFreeAll(pctxt, pvalue);
}

#if 0
void asn1Free_e2ap_E2nodeComponentConfigUpdateAck_List (OSCTXT* pctxt, e2ap_E2nodeComponentConfigUpdateAck_List* pvalue){
   if(0==pvalue ) return;
   {
      e2ap_E2nodeComponentConfigUpdateAck_ItemIEs * pdata;
      OSRTDListNode *pnode = pvalue->head;
      while(0!=pnode){
         pdata = (e2ap_E2nodeComponentConfigUpdateAck_ItemIEs*)pnode->data;
         asn1Free_e2ap_E2nodeComponentConfigUpdateAck_ItemIEs(pctxt, pdata);
         pnode = pnode->next;
      }
      rtxDListFreeAll(pctxt, pvalue);
   }
}
#endif


int asn1PrtToStr_e2ap_E2nodeComponentConfigUpdateAck_List(const char* name, e2ap_E2nodeComponentConfigUpdateAck_List* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_E2nodeComponentConfigUpdateAck_ItemIEs* pdata;
    OSRTDListNode* pnode;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode = pvalue->head;  xx1 < pvalue->count && pnode != 0; pnode = pnode->next, xx1++){
        pdata = (e2ap_E2nodeComponentConfigUpdateAck_ItemIEs*)pnode->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 1
        if(asn1PrtToStr_e2ap_E2nodeComponentConfigUpdateAck_ItemIEs(nameBuf, pdata, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}
/*****************************************/
/*           E2nodeComponentConfigRemovalAck-Item                */
/*****************************************/
//sequence normal
// Các nội dung cần thiết cho template seq_normal.c.j2

// Các phần còn lại của template seq_normal.c.j2
//contain extensition bit -> theo mau cua GlobalgNB-ID
int asn1PE_e2ap_E2nodeComponentConfigRemovalAck_Item (OSCTXT* pctxt, e2ap_E2nodeComponentConfigRemovalAck_Item* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "E2nodeComponentConfigRemovalAck-Item");

   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field e2nodeComponentInterfaceType - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "e2nodeComponentInterfaceType");
   stat = asn1PE_e2ap_E2nodeComponentInterfaceType (pctxt, pvalue->e2nodeComponentInterfaceType);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /* encode field e2nodeComponentID - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "e2nodeComponentID");
   stat = asn1PE_e2ap_E2nodeComponentID (pctxt, pvalue->e2nodeComponentID);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /* encode field e2nodeComponentConfigurationAck - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "e2nodeComponentConfigurationAck");
   stat = asn1PE_e2ap_E2nodeComponentConfigurationAck (pctxt, pvalue->e2nodeComponentConfigurationAck);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);



   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_E2nodeComponentConfigRemovalAck_Item (OSCTXT* pctxt, e2ap_E2nodeComponentConfigRemovalAck_Item* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[3];

   RTXCTXTPUSHTYPENAME(pctxt, "E2nodeComponentConfigRemovalAck-Item");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field e2nodeComponentInterfaceType */
   RTXCTXTPUSHELEMNAME(pctxt, "e2nodeComponentInterfaceType");
      stat = asn1PD_e2ap_E2nodeComponentInterfaceType (pctxt, &pvalue->e2nodeComponentInterfaceType);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field e2nodeComponentID */
   RTXCTXTPUSHELEMNAME(pctxt, "e2nodeComponentID");
      stat = asn1PD_e2ap_E2nodeComponentID (pctxt, &pvalue->e2nodeComponentID);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field e2nodeComponentConfigurationAck */
   RTXCTXTPUSHELEMNAME(pctxt, "e2nodeComponentConfigurationAck");
      stat = asn1PD_e2ap_E2nodeComponentConfigurationAck (pctxt, &pvalue->e2nodeComponentConfigurationAck);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_E2nodeComponentConfigRemovalAck_Item (e2ap_E2nodeComponentConfigRemovalAck_Item* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_E2nodeComponentInterfaceType (&pvalue->e2nodeComponentInterfaceType);
   asn1Init_e2ap_E2nodeComponentID (&pvalue->e2nodeComponentID);
   asn1Init_e2ap_E2nodeComponentConfigurationAck (&pvalue->e2nodeComponentConfigurationAck);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_E2nodeComponentConfigRemovalAck_Item (OSCTXT* pctxt, e2ap_E2nodeComponentConfigRemovalAck_Item* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_E2nodeComponentInterfaceType (pctxt, &pvalue->e2nodeComponentInterfaceType);
   asn1Free_e2ap_E2nodeComponentID (pctxt, &pvalue->e2nodeComponentID);
   asn1Free_e2ap_E2nodeComponentConfigurationAck (pctxt, &pvalue->e2nodeComponentConfigurationAck);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_E2nodeComponentConfigRemovalAck_Item (const char* name, e2ap_E2nodeComponentConfigRemovalAck_Item* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }
   if(asn1PrtToStr_e2ap_E2nodeComponentInterfaceType ("e2nodeComponentInterfaceType", &pvalue->e2nodeComponentInterfaceType, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_E2nodeComponentID ("e2nodeComponentID", &pvalue->e2nodeComponentID, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_E2nodeComponentConfigurationAck ("e2nodeComponentConfigurationAck", &pvalue->e2nodeComponentConfigurationAck, buffer, bufSize) < 0)
   {
      return -1;
   }



   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           E2nodeComponentConfigRemovalAck_ItemIEs                */
/*****************************************/
/* ie.c.j2 */
/*ie thường*/
int asn1PE_e2ap_E2nodeComponentConfigRemovalAck_ItemIEs (OSCTXT* pctxt, e2ap_E2nodeComponentConfigRemovalAck_ItemIEs* pvalue)
{
   int stat = 0;
   //RTXCTXTPUSHTYPENAME (pctxt, "E2nodeComponentConfigRemovalAck-ItemIEs");

   /* encode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");
   stat = asn1PE_e2ap_ProtocolIE_ID (pctxt, pvalue->id);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");
   stat = asn1PE_e2ap_Criticality (pctxt, pvalue->criticality);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   {
      OSCTXT ictxt;
      OSOCTET* pDynamicEncodeBuffer;
      ASN1OpenType openType;
      OSBOOL  encoded = TRUE;

      openType.numocts = 0;
      openType.data = 0;

      rtxCopyContext (&ictxt, pctxt);
      pctxt->pStream = 0;

      stat = rtxInitContextBuffer (pctxt, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_E2nodeComponentConfigRemovalAck_ItemIEs_id_E2nodeComponentConfigRemovalAck_Item:
         
        // RTXCTXTPUSHELEMNAME (pctxt, "E2nodeComponentConfigRemovalAck_ItemIEs_id_E2nodeComponentConfigRemovalAck_Item");
         RTXCTXTPUSHELEMNAME (pctxt, "E2nodeComponentConfigRemovalAck-Item");
         stat = asn1PE_e2ap_E2nodeComponentConfigRemovalAck_Item (pctxt, pvalue->value.u._e2apE2nodeComponentConfigRemovalAck_ItemIEs_id_E2nodeComponentConfigRemovalAck_Item);
         RTXCTXTPOPELEMNAME (pctxt);
      
         break;

      case T_E2AP_PDU_Contents_e2ap_E2nodeComponentConfigRemovalAck_ItemIEs_UNDEF_:
      {
          if(0!=pvalue->value.u.extElem1){
              openType.numocts = pvalue->value.u.extElem1->numocts;
              openType.data = pvalue->value.u.extElem1->data;
          } else {
              /* No extension element to encode */
          }
          encoded = FALSE;
          break;
      }
      default:
         encoded = FALSE;
         stat = RTERR_INVOPT;
      }

      if (encoded) {
         openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
         openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
      }
      rtxCopyContext (pctxt, &ictxt);
      if(stat ==0) stat = pe_OpenType(pctxt, openType.numocts, openType.data);
      /*free dynamic encode buffer*/
      if(encoded){
          rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
      }
   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);
   //RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

int asn1PD_e2ap_E2nodeComponentConfigRemovalAck_ItemIEs (OSCTXT* pctxt, e2ap_E2nodeComponentConfigRemovalAck_ItemIEs* pvalue)
{
   int stat =0;
   /*deode root element id*/
   RTXCTXTPUSHELEMNAME(pctxt, "id");
   stat = asn1PD_e2ap_ProtocolIE_ID (pctxt, &pvalue->id);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*decode root element criticality*/
   RTXCTXTPUSHELEMNAME(pctxt, "criticality");
   stat = asn1PD_e2ap_Criticality (pctxt, &pvalue->criticality);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   /*decode root element value*/
   RTXCTXTPUSHELEMNAME(pctxt, "value");
   {
      OSUINT32 openTypeLen;
      size_t bitStartOffset, bitLength;
      stat = pd_UnconsLength(pctxt, &openTypeLen);
      if(stat <0) return LOG_RTERR(pctxt, stat);
      else if(stat == RT_OK_FRAG){
         rtxErrAddStrParm(pctxt, "open type with fragmented length use - perindef");
         return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
      }
      bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
      bitLength = openTypeLen * 8;
      switch (pvalue->id){
         case T_E2AP_PDU_Contents_e2ap_E2nodeComponentConfigRemovalAck_ItemIEs_id_E2nodeComponentConfigRemovalAck_Item:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_E2nodeComponentConfigRemovalAck_ItemIEs_id_E2nodeComponentConfigRemovalAck_Item;
            RTXCTXTPUSHELEMNAME(pctxt, "E2nodeComponentConfigRemovalAck-Item");
            //pvalue->value.u._e2ap_E2nodeComponentConfigRemovalAck_ItemIEs_id_id_E2nodeComponentConfigRemovalAck_Item 
             pvalue->value.u._e2apE2nodeComponentConfigRemovalAck_ItemIEs_id_E2nodeComponentConfigRemovalAck_Item 
                    = rtxMemAllocType(pctxt, e2ap_E2nodeComponentConfigRemovalAck_Item);
            //asn1Init_e2ap_E2nodeComponentConfigRemovalAck_Item(pvalue->value.u._e2ap_E2nodeComponentConfigRemovalAck_ItemIEs_id_id_E2nodeComponentConfigRemovalAck_Item);
            asn1Init_e2ap_E2nodeComponentConfigRemovalAck_Item(pvalue->value.u._e2apE2nodeComponentConfigRemovalAck_ItemIEs_id_E2nodeComponentConfigRemovalAck_Item);
            stat = asn1PD_e2ap_E2nodeComponentConfigRemovalAck_Item (pctxt,
                    (e2ap_E2nodeComponentConfigRemovalAck_Item*)pvalue->value.
                    u._e2apE2nodeComponentConfigRemovalAck_ItemIEs_id_E2nodeComponentConfigRemovalAck_Item);
            if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_E2nodeComponentConfigRemovalAck_ItemIEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*)rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
      }
      {
      size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
      size_t bitsConsumed = bitEndOffset - bitStartOffset;
      if(bitsConsumed < bitLength){
         stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
      } else {
         stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
      }
      }
   }
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   return stat;
}

void asn1Init_e2ap_E2nodeComponentConfigRemovalAck_ItemIEs (e2ap_E2nodeComponentConfigRemovalAck_ItemIEs* pvalue)
{
   if (!pvalue) return;
   OSCRTLMEMSET (pvalue, 0, sizeof(e2ap_E2nodeComponentConfigRemovalAck_ItemIEs));
}

#if 0
void asn1Free_e2ap_E2nodeComponentConfigRemovalAck_ItemIEs (OSCTXT* pctxt, e2ap_E2nodeComponentConfigRemovalAck_ItemIEs* pvalue)
{
   if (!pvalue) return;
   if (pvalue->extElem1) {
      rtxMemFreeArray (pctxt, pvalue->extElem1);
      pvalue->extElem1 = 0;
      pvalue->extElem1_n = 0;
   }
}
#endif
void asn1Free_e2ap_E2nodeComponentConfigRemovalAck_ItemIEs (OSCTXT* pctxt, e2ap_E2nodeComponentConfigRemovalAck_ItemIEs* pvalue)
{
   if(0==pvalue) return;
   switch(pvalue->value.t){
      case T_E2AP_PDU_Contents_e2ap_E2nodeComponentConfigRemovalAck_ItemIEs_id_E2nodeComponentConfigRemovalAck_Item:
         asn1Free_e2ap_E2nodeComponentConfigRemovalAck_Item (pctxt, pvalue->value.u._e2apE2nodeComponentConfigRemovalAck_ItemIEs_id_E2nodeComponentConfigRemovalAck_Item);
         rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2apE2nodeComponentConfigRemovalAck_ItemIEs_id_E2nodeComponentConfigRemovalAck_Item);
         pvalue->value.u._e2apE2nodeComponentConfigRemovalAck_ItemIEs_id_E2nodeComponentConfigRemovalAck_Item = 0;
         break;
      case T_E2AP_PDU_Contents_e2ap_E2nodeComponentConfigRemovalAck_ItemIEs_UNDEF_:
         if(0!=pvalue->value.u.extElem1){
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1->data);
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
             pvalue->value.u.extElem1 =0;
         }
         break;
         default:;
   }
}

int  asn1PrtToStr_e2ap_E2nodeComponentConfigRemovalAck_ItemIEs (const char * name, e2ap_E2nodeComponentConfigRemovalAck_ItemIEs* pvalue, char * buffer, OSSIZE bufSize){
   if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
       return -1;

      if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
         return -1;

      if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
         return -1;
      if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
         return -1;
      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_E2nodeComponentConfigRemovalAck_ItemIEs_id_E2nodeComponentConfigRemovalAck_Item:
         if(asn1PrtToStr_e2ap_E2nodeComponentConfigRemovalAck_Item("E2nodeComponentConfigRemovalAck-Item",
                pvalue->value.u._e2apE2nodeComponentConfigRemovalAck_ItemIEs_id_E2nodeComponentConfigRemovalAck_Item, buffer, bufSize)<0)// dungnm23 check lai nhe xem la
            return -1;
         break;
      default:
         if(0!=pvalue -> value.u.extElem1){
             rtPrintToStringIndent(buffer, bufSize);
             rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

         }
      }
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

      return 0;

}
 

/*****************************************/
/*           E2nodeComponentConfigRemovalAck_List                */
/*****************************************/
//seq_of_single_container


int asn1PE_e2ap_E2nodeComponentConfigRemovalAck_List (OSCTXT* pctxt, e2ap_E2nodeComponentConfigRemovalAck_List* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_E2nodeComponentConfigRemovalAck_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "E2nodeComponentConfigRemovalAck-List");

   /* encode length determinant */
   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1024), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;
   for (xx1 = 0; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next, xx1++) {
      pdata = (e2ap_E2nodeComponentConfigRemovalAck_ItemIEs*) pnode->data;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_e2ap_E2nodeComponentConfigRemovalAck_ItemIEs (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      //xx1++;
      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}

int asn1PD_e2ap_E2nodeComponentConfigRemovalAck_List (OSCTXT* pctxt, e2ap_E2nodeComponentConfigRemovalAck_List* ppvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_E2nodeComponentConfigRemovalAck_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "E2nodeComponentConfigRemovalAck-List");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1024), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (ppvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      pdata = rtxMemAllocType (pctxt, e2ap_E2nodeComponentConfigRemovalAck_ItemIEs);
      if (!pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);
      asn1Init_e2ap_E2nodeComponentConfigRemovalAck_ItemIEs (pdata);
      stat = asn1PD_e2ap_E2nodeComponentConfigRemovalAck_ItemIEs (pctxt, pdata);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         return LOG_RTERR (pctxt, stat);
      }

      rtxDListAppendNode (ppvalue, pdata);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

void asn1Init_e2ap_E2nodeComponentConfigRemovalAck_List (e2ap_E2nodeComponentConfigRemovalAck_List* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
}

void asn1Free_e2ap_E2nodeComponentConfigRemovalAck_List (OSCTXT* pctxt, e2ap_E2nodeComponentConfigRemovalAck_List* pvalue)
{
   if(pvalue==0) return;
   OSRTDListNode* pnode = pvalue->head;
   while (pnode) {
      e2ap_E2nodeComponentConfigRemovalAck_ItemIEs* pdata = (e2ap_E2nodeComponentConfigRemovalAck_ItemIEs*) pnode->data;
      if (pdata) {
         asn1Free_e2ap_E2nodeComponentConfigRemovalAck_ItemIEs (pctxt, pdata);
         rtxMemFreePtr (pctxt, pdata);
      }
      pnode = pnode->next;
   }
      rtxDListFreeAll(pctxt, pvalue);
}

#if 0
void asn1Free_e2ap_E2nodeComponentConfigRemovalAck_List (OSCTXT* pctxt, e2ap_E2nodeComponentConfigRemovalAck_List* pvalue){
   if(0==pvalue ) return;
   {
      e2ap_E2nodeComponentConfigRemovalAck_ItemIEs * pdata;
      OSRTDListNode *pnode = pvalue->head;
      while(0!=pnode){
         pdata = (e2ap_E2nodeComponentConfigRemovalAck_ItemIEs*)pnode->data;
         asn1Free_e2ap_E2nodeComponentConfigRemovalAck_ItemIEs(pctxt, pdata);
         pnode = pnode->next;
      }
      rtxDListFreeAll(pctxt, pvalue);
   }
}
#endif


int asn1PrtToStr_e2ap_E2nodeComponentConfigRemovalAck_List(const char* name, e2ap_E2nodeComponentConfigRemovalAck_List* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_E2nodeComponentConfigRemovalAck_ItemIEs* pdata;
    OSRTDListNode* pnode;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode = pvalue->head;  xx1 < pvalue->count && pnode != 0; pnode = pnode->next, xx1++){
        pdata = (e2ap_E2nodeComponentConfigRemovalAck_ItemIEs*)pnode->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 1
        if(asn1PrtToStr_e2ap_E2nodeComponentConfigRemovalAck_ItemIEs(nameBuf, pdata, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}/*****************************************/
/*           E2nodeConfigurationUpdateAcknowledge_IEs                */
/*****************************************/
/* ie.c.j2 */
 /* d là con của msg */
EXTERN int asn1PE_e2ap_E2nodeConfigurationUpdateAcknowledge_protocolIEs_element (OSCTXT* pctxt, e2ap_E2nodeConfigurationUpdateAcknowledge_protocolIEs_element* pvalue)
{
    int stat =0;

    /*encode id*/

    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PE_e2ap_ProtocolIE_ID(pctxt, pvalue->id);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PE_e2ap_Criticality(pctxt, pvalue->criticality);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
    {
        OSCTXT lctxt;
        OSOCTET *pDynamicEncodeBuffer;
        ASN1OpenType openType;
        OSBOOL encoded = TRUE;

        openType.numocts = 0;
        openType.data =0;

        rtxCopyContext(&lctxt, pctxt);
        pctxt->pStream =0;

        stat = rtxInitContextBuffer(pctxt, 0, 0);
        if(stat!=0) return LOG_RTERR(pctxt, stat);

        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_TransactionID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-TransactionID");
                    stat = asn1PE_e2ap_TransactionID (pctxt, pvalue->value.u._e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_TransactionID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_E2nodeComponentConfigAdditionAck:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-E2nodeComponentConfigAdditionAck");
                    stat = asn1PE_e2ap_E2nodeComponentConfigAdditionAck_List (pctxt, pvalue->value.u._e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_E2nodeComponentConfigAdditionAck);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_E2nodeComponentConfigUpdateAck:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-E2nodeComponentConfigUpdateAck");
                    stat = asn1PE_e2ap_E2nodeComponentConfigUpdateAck_List (pctxt, pvalue->value.u._e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_E2nodeComponentConfigUpdateAck);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_E2nodeComponentConfigRemovalAck:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-E2nodeComponentConfigRemovalAck");
                    stat = asn1PE_e2ap_E2nodeComponentConfigRemovalAck_List (pctxt, pvalue->value.u._e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_E2nodeComponentConfigRemovalAck);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_UNDEF_:
            {
                if(0!=pvalue->value.u.extElem1){
                    openType.numocts = pvalue->value.u.extElem1->numocts;
                    openType.data = pvalue->value.u.extElem1->data;
                } else {
                    /* No extension element to encode */
                }
                encoded = FALSE;
                break;
            }

            default:
                encoded = FALSE;
                stat = RTERR_INVOPT;
                break;
        } 

        if(encoded){
            openType.numocts = (OSUINT32)pe_GetMsgLen(pctxt);
            openType.data = pDynamicEncodeBuffer = pctxt -> buffer.data;
        }
        rtxCopyContext(pctxt, &lctxt);

        if(stat == 0) {
            stat = pe_OpenType (pctxt, openType.numocts, openType.data);
        }
    #if 1
        if(encoded){//dungnm23 check lai nhe
            rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
        }
    #endif

    }

    if(stat!=0) return LOG_RTERR(pctxt, stat);  
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}

EXTERN int  asn1PD_e2ap_E2nodeConfigurationUpdateAcknowledge_protocolIEs_element (OSCTXT* pctxt, e2ap_E2nodeConfigurationUpdateAcknowledge_protocolIEs_element* pvalue){
    int stat =0;

    /*decode id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PD_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PD_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");

    {
        OSUINT32 openTypeLen;
        size_t bitStartOffset, bitLength;

        stat = pd_UnconsLength(pctxt, &openTypeLen);
        if(stat<0) return LOG_RTERR(pctxt, stat);
        else if(stat == RT_OK_FRAG){
            rtxErrAddStrParm(pctxt, "open type with fragment length");
            return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
        }
        bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
        bitLength = openTypeLen * 8;

        switch(pvalue->id){//dungnm23 check case lai nhe
        
            case ASN1V_e2ap_id_TransactionID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_TransactionID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-TransactionID");
                pvalue->value.u._e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_TransactionID 
                    = rtxMemAllocType(pctxt, e2ap_TransactionID);

                asn1Init_e2ap_TransactionID(pvalue->value.u._e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_TransactionID);

                stat = asn1PD_e2ap_TransactionID (pctxt,
                        (e2ap_TransactionID*)pvalue->value.
                        u._e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_TransactionID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_E2nodeComponentConfigAdditionAck:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_E2nodeComponentConfigAdditionAck;
            RTXCTXTPUSHELEMNAME(pctxt, "id-E2nodeComponentConfigAdditionAck");
                pvalue->value.u._e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_E2nodeComponentConfigAdditionAck 
                    = rtxMemAllocType(pctxt, e2ap_E2nodeComponentConfigAdditionAck_List);

                asn1Init_e2ap_E2nodeComponentConfigAdditionAck_List(pvalue->value.u._e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_E2nodeComponentConfigAdditionAck);

                stat = asn1PD_e2ap_E2nodeComponentConfigAdditionAck_List (pctxt,
                        (e2ap_E2nodeComponentConfigAdditionAck_List*)pvalue->value.
                        u._e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_E2nodeComponentConfigAdditionAck);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_E2nodeComponentConfigUpdateAck:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_E2nodeComponentConfigUpdateAck;
            RTXCTXTPUSHELEMNAME(pctxt, "id-E2nodeComponentConfigUpdateAck");
                pvalue->value.u._e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_E2nodeComponentConfigUpdateAck 
                    = rtxMemAllocType(pctxt, e2ap_E2nodeComponentConfigUpdateAck_List);

                asn1Init_e2ap_E2nodeComponentConfigUpdateAck_List(pvalue->value.u._e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_E2nodeComponentConfigUpdateAck);

                stat = asn1PD_e2ap_E2nodeComponentConfigUpdateAck_List (pctxt,
                        (e2ap_E2nodeComponentConfigUpdateAck_List*)pvalue->value.
                        u._e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_E2nodeComponentConfigUpdateAck);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_E2nodeComponentConfigRemovalAck:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_E2nodeComponentConfigRemovalAck;
            RTXCTXTPUSHELEMNAME(pctxt, "id-E2nodeComponentConfigRemovalAck");
                pvalue->value.u._e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_E2nodeComponentConfigRemovalAck 
                    = rtxMemAllocType(pctxt, e2ap_E2nodeComponentConfigRemovalAck_List);

                asn1Init_e2ap_E2nodeComponentConfigRemovalAck_List(pvalue->value.u._e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_E2nodeComponentConfigRemovalAck);

                stat = asn1PD_e2ap_E2nodeComponentConfigRemovalAck_List (pctxt,
                        (e2ap_E2nodeComponentConfigRemovalAck_List*)pvalue->value.
                        u._e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_E2nodeComponentConfigRemovalAck);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*) rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
    }
    {
    size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
    size_t bitsConsumed = bitEndOffset-bitStartOffset;
    if(bitsConsumed<bitLength){
        stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
    }
    else stat =(bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
    }}
    if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}


int asn1Init_e2ap_E2nodeConfigurationUpdateAcknowledge_protocolIEs_element(e2ap_E2nodeConfigurationUpdateAcknowledge_protocolIEs_element* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    OSCRTLMEMSET (&pvalue->value, 0, sizeof(pvalue->value));
    return 0;
}


//-----> chuaw có template rtxFreeASN1OpenType

#if 0
void asn1Free_e2ap_E2nodeConfigurationUpdateAcknowledge_protocolIEs_element(OSCTXT* pctxt, e2ap_E2nodeConfigurationUpdateAcknowledge_protocolIEs_element* pvalue)
{
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_id_TransactionID:
            // rtxFreeE2ap_TransactionID(pvalue->value.u._e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_id_TransactionID);

            if(pvalue->value.i._e2ap_E2nodeConfigurationUpdateAcknowledge_id_TransactionID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_TransactionID(pctxt, pvalue->value.u._e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_id_TransactionID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_id_TransactionID);
           // pvalue->value.u._e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_id_TransactionID = NULL;
           pvalue->value.u._e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_TransactionID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_id_E2nodeComponentConfigAdditionAck:
            // rtxFreeE2ap_E2nodeComponentConfigAdditionAck_List(pvalue->value.u._e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_id_E2nodeComponentConfigAdditionAck);

            if(pvalue->value.i._e2ap_E2nodeConfigurationUpdateAcknowledge_id_E2nodeComponentConfigAdditionAck_List!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_E2nodeComponentConfigAdditionAck_List(pctxt, pvalue->value.u._e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_id_E2nodeComponentConfigAdditionAck);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_id_E2nodeComponentConfigAdditionAck);
           // pvalue->value.u._e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_id_E2nodeComponentConfigAdditionAck = NULL;
           pvalue->value.u._e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_E2nodeComponentConfigAdditionAck = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_id_E2nodeComponentConfigUpdateAck:
            // rtxFreeE2ap_E2nodeComponentConfigUpdateAck_List(pvalue->value.u._e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_id_E2nodeComponentConfigUpdateAck);

            if(pvalue->value.i._e2ap_E2nodeConfigurationUpdateAcknowledge_id_E2nodeComponentConfigUpdateAck_List!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_E2nodeComponentConfigUpdateAck_List(pctxt, pvalue->value.u._e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_id_E2nodeComponentConfigUpdateAck);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_id_E2nodeComponentConfigUpdateAck);
           // pvalue->value.u._e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_id_E2nodeComponentConfigUpdateAck = NULL;
           pvalue->value.u._e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_E2nodeComponentConfigUpdateAck = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_id_E2nodeComponentConfigRemovalAck:
            // rtxFreeE2ap_E2nodeComponentConfigRemovalAck_List(pvalue->value.u._e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_id_E2nodeComponentConfigRemovalAck);

            if(pvalue->value.i._e2ap_E2nodeConfigurationUpdateAcknowledge_id_E2nodeComponentConfigRemovalAck_List!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_E2nodeComponentConfigRemovalAck_List(pctxt, pvalue->value.u._e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_id_E2nodeComponentConfigRemovalAck);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_id_E2nodeComponentConfigRemovalAck);
           // pvalue->value.u._e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_id_E2nodeComponentConfigRemovalAck = NULL;
           pvalue->value.u._e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_E2nodeComponentConfigRemovalAck = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_UNDEF_:
            rtxFreeASN1OpenType(pvalue->value.u.extElem1);
            break;
        default:
            break;
    }
}

int asn1PrtToStr_e2ap_E2nodeConfigurationUpdateAcknowledge_protocolIEs_element(OSCTXT* pctxt, e2ap_E2nodeConfigurationUpdateAcknowledge_protocolIEs_element* pvalue)
{
    int stat =0;
    RTXCTXTPUSHELEMNAME(pctxt, "e2ap_E2nodeConfigurationUpdateAcknowledge_protocolIEs_element");

    /*print id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PrtToStr_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PrtToStr_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_id_TransactionID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "TransactionID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_TransactionID (pctxt, pvalue->value.u._e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_id_TransactionID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_id_E2nodeComponentConfigAdditionAck:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "E2nodeComponentConfigAdditionAck-List");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_E2nodeComponentConfigAdditionAck_List (pctxt, pvalue->value.u._e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_id_E2nodeComponentConfigAdditionAck);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_id_E2nodeComponentConfigUpdateAck:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "E2nodeComponentConfigUpdateAck-List");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_E2nodeComponentConfigUpdateAck_List (pctxt, pvalue->value.u._e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_id_E2nodeComponentConfigUpdateAck);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_id_E2nodeComponentConfigRemovalAck:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "E2nodeComponentConfigRemovalAck-List");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_E2nodeComponentConfigRemovalAck_List (pctxt, pvalue->value.u._e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_id_E2nodeComponentConfigRemovalAck);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_UNDEF_:
            {
                rtxPLogMsg(pctxt, "Extension element present - raw data not printed.\n");
                break;
            }

            default:
                stat = RTERR_INVOPT;
                return LOG_RTERR(pctxt, stat);
        }
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);
}
#endif


int asn1PrtToStr_e2ap_E2nodeConfigurationUpdateAcknowledge_protocolIEs_element (const char * name,
 e2ap_E2nodeConfigurationUpdateAcknowledge_protocolIEs_element* pvalue, 
 char * buffer, OSSIZE bufSize){
    if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
        return -1;
    if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
        return -1;

    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_TransactionID:
            if(asn1PrtToStr_e2ap_TransactionID("TransactionID", 
                    pvalue->value.u._e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_TransactionID, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_E2nodeComponentConfigAdditionAck:
            if(asn1PrtToStr_e2ap_E2nodeComponentConfigAdditionAck_List("E2nodeComponentConfigAdditionAck-List", 
                    pvalue->value.u._e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_E2nodeComponentConfigAdditionAck, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_E2nodeComponentConfigUpdateAck:
            if(asn1PrtToStr_e2ap_E2nodeComponentConfigUpdateAck_List("E2nodeComponentConfigUpdateAck-List", 
                    pvalue->value.u._e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_E2nodeComponentConfigUpdateAck, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_E2nodeComponentConfigRemovalAck:
            if(asn1PrtToStr_e2ap_E2nodeComponentConfigRemovalAck_List("E2nodeComponentConfigRemovalAck-List", 
                    pvalue->value.u._e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_E2nodeComponentConfigRemovalAck, buffer, bufSize)<0)
                return -1;
            break;    
        default:
        if(0!=pvalue -> value.u.extElem1){
            rtPrintToStringIndent(buffer, bufSize);
            rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

        }
        }
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

    return 0;

 }

 void asn1Free_e2ap_E2nodeConfigurationUpdateAcknowledge_protocolIEs_element(OSCTXT* pctxt, e2ap_E2nodeConfigurationUpdateAcknowledge_protocolIEs_element* pvalue){
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_TransactionID:
            if(pvalue->value.u._e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_TransactionID!=NULL){
            asn1Free_e2ap_TransactionID(pctxt, pvalue->value.u._e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_TransactionID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_TransactionID);
            pvalue->value.u._e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_TransactionID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_E2nodeComponentConfigAdditionAck:
            if(pvalue->value.u._e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_E2nodeComponentConfigAdditionAck!=NULL){
            asn1Free_e2ap_E2nodeComponentConfigAdditionAck_List(pctxt, pvalue->value.u._e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_E2nodeComponentConfigAdditionAck);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_E2nodeComponentConfigAdditionAck);
            pvalue->value.u._e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_E2nodeComponentConfigAdditionAck = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_E2nodeComponentConfigUpdateAck:
            if(pvalue->value.u._e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_E2nodeComponentConfigUpdateAck!=NULL){
            asn1Free_e2ap_E2nodeComponentConfigUpdateAck_List(pctxt, pvalue->value.u._e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_E2nodeComponentConfigUpdateAck);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_E2nodeComponentConfigUpdateAck);
            pvalue->value.u._e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_E2nodeComponentConfigUpdateAck = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_E2nodeComponentConfigRemovalAck:
            if(pvalue->value.u._e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_E2nodeComponentConfigRemovalAck!=NULL){
            asn1Free_e2ap_E2nodeComponentConfigRemovalAck_List(pctxt, pvalue->value.u._e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_E2nodeComponentConfigRemovalAck);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_E2nodeComponentConfigRemovalAck);
            pvalue->value.u._e2ap_E2nodeConfigurationUpdateAcknowledge_IEs_id_E2nodeComponentConfigRemovalAck = NULL;
            }
            break;
        default:
            break;


    }
 }

 

/*****************************************/
/*           E2nodeConfigurationUpdateAcknowledge                */
/*****************************************/
//2_container.c
/* 1. xxx_ProtocolIE -> mẫu cũ ở ie_big_msg */
EXTERN int asn1PE_e2ap_E2nodeConfigurationUpdateAcknowledge_protocolIEs (OSCTXT* pctxt, e2ap_E2nodeConfigurationUpdateAcknowledge_protocolIEs* pvalue)
{
    int stat =0;
    OSRTDListNode* pnode;
    OSUINT32 xx1;

    /*encode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pe_Length(pctxt, pvalue->count);
    if(stat<0) return LOG_RTERR(pctxt, stat);

    /*encode each element*/
    xx1 =0;
    for(pnode = pvalue->head; pnode != 0 && xx1<pvalue->count; pnode = pnode->next){
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE", xx1);
        stat = asn1PE_e2ap_E2nodeConfigurationUpdateAcknowledge_protocolIEs_element (pctxt, ((e2ap_E2nodeConfigurationUpdateAcknowledge_protocolIEs_element*)pnode->data));
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        xx1++;
        RTXCTXTPOPARRAYELEMNAME(pctxt);
    }

    return (stat);
}

EXTERN int  asn1PD_e2ap_E2nodeConfigurationUpdateAcknowledge_protocolIEs(OSCTXT* pctxt, e2ap_E2nodeConfigurationUpdateAcknowledge_protocolIEs* pvalue)
{
     int stat =0;
     OSRTDListNode* pnode;
     OSSIZE count =0;
     OSSIZE xx1=0;


     /*decode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pd_Length64(pctxt, &count); //tai sao lai 64
    if(stat!=0) return LOG_RTERR(pctxt, stat);

    /*decode each element*/
    rtxDListInit(pvalue);

    for(xx1=0; xx1 < count; xx1++){
        e2ap_E2nodeConfigurationUpdateAcknowledge_protocolIEs_element* pdata;
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE",xx1);

        if(pnode == NULL) return LOG_RTERR(pctxt, RTERR_NOMEM);

        asn1Init_e2ap_E2nodeConfigurationUpdateAcknowledge_protocolIEs_element(pdata);
        rtxDListAppendNode(pvalue, pnode);
        stat = asn1PD_e2ap_E2nodeConfigurationUpdateAcknowledge_protocolIEs_element (pctxt, pdata);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        RTXCTXTPOPARRAYELEMNAME(pctxt);

    }
    return (stat);
}


int asn1Init_e2ap_E2nodeConfigurationUpdateAcknowledge_protocolIEs(e2ap_E2nodeConfigurationUpdateAcknowledge_protocolIEs* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    rtxDListFastInit (pvalue);
    return 0;
}
#if 1 //ao that day
void asn1Free_e2ap_E2nodeConfigurationUpdateAcknowledge_protocolIEs(OSCTXT* pctxt, e2ap_E2nodeConfigurationUpdateAcknowledge_protocolIEs* pvalue)
{
    if(0==pvalue) return;   
    e2ap_E2nodeConfigurationUpdateAcknowledge_protocolIEs_element* pdata;
    OSRTDListNode* pnode=pvalue->head;
    while(0!=pnode){
        pdata = (e2ap_E2nodeConfigurationUpdateAcknowledge_protocolIEs_element*)pnode->data;
       // asn1Free_e2ap_E2nodeConfigurationUpdateAcknowledge_protocolIEs_element(pctxt, pdata);
        pnode = pnode->next;
    }
    rtxDListFreeAll(pctxt, pvalue);
}
#endif


EXTERN int asn1PrtToStr_e2ap_E2nodeConfigurationUpdateAcknowledge_protocolIEs(const char* name, e2ap_E2nodeConfigurationUpdateAcknowledge_protocolIEs* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_E2nodeConfigurationUpdateAcknowledge_protocolIEs_element* pdata0;
    OSRTDListNode* pnode0;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode0 = pvalue->head;  xx1 < pvalue->count && pnode0 != 0; pnode0 = pnode0->next, xx1++){
        pdata0 = (e2ap_E2nodeConfigurationUpdateAcknowledge_protocolIEs_element*)pnode0->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 0
        if(asn1PrtToStr_e2ap_E2nodeConfigurationUpdateAcknowledge_protocolIEs_element(nameBuf, pdata0, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}


/*2 . E2nodeConfigurationUpdateAcknowledge -> mẫu cũ ở seq_normal*/

int asn1PE_e2ap_E2nodeConfigurationUpdateAcknowledge (OSCTXT* pctxt, e2ap_E2nodeConfigurationUpdateAcknowledge* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "E2nodeConfigurationUpdateAcknowledge");
   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field protocolIEs - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
   stat = asn1PE_e2ap_E2nodeConfigurationUpdateAcknowledge_protocolIEs (pctxt, &pvalue->protocolIEs);
   if(stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_E2nodeConfigurationUpdateAcknowledge (OSCTXT* pctxt, e2ap_E2nodeConfigurationUpdateAcknowledge* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME(pctxt, "E2nodeConfigurationUpdateAcknowledge");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field protocolIEs */
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
      stat = asn1PD_e2ap_E2nodeConfigurationUpdateAcknowledge_protocolIEs (pctxt, &pvalue->protocolIEs);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_E2nodeConfigurationUpdateAcknowledge (e2ap_E2nodeConfigurationUpdateAcknowledge* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_E2nodeConfigurationUpdateAcknowledge_protocolIEs(&pvalue->protocolIEs);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_E2nodeConfigurationUpdateAcknowledge (OSCTXT* pctxt, e2ap_E2nodeConfigurationUpdateAcknowledge* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_E2nodeConfigurationUpdateAcknowledge_protocolIEs(pctxt, &pvalue->protocolIEs);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_E2nodeConfigurationUpdateAcknowledge (const char* name, e2ap_E2nodeConfigurationUpdateAcknowledge* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }

   if(asn1PrtToStr_e2ap_E2nodeConfigurationUpdateAcknowledge_protocolIEs("protocolIEs", &pvalue->protocolIEs, buffer, bufSize) <0){
      return -1;
   }

   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           E2nodeConfigurationUpdateFailure_IEs                */
/*****************************************/
/* ie.c.j2 */
 /* d là con của msg */
EXTERN int asn1PE_e2ap_E2nodeConfigurationUpdateFailure_protocolIEs_element (OSCTXT* pctxt, e2ap_E2nodeConfigurationUpdateFailure_protocolIEs_element* pvalue)
{
    int stat =0;

    /*encode id*/

    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PE_e2ap_ProtocolIE_ID(pctxt, pvalue->id);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PE_e2ap_Criticality(pctxt, pvalue->criticality);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
    {
        OSCTXT lctxt;
        OSOCTET *pDynamicEncodeBuffer;
        ASN1OpenType openType;
        OSBOOL encoded = TRUE;

        openType.numocts = 0;
        openType.data =0;

        rtxCopyContext(&lctxt, pctxt);
        pctxt->pStream =0;

        stat = rtxInitContextBuffer(pctxt, 0, 0);
        if(stat!=0) return LOG_RTERR(pctxt, stat);

        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdateFailure_IEs_id_TransactionID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-TransactionID");
                    stat = asn1PE_e2ap_TransactionID (pctxt, pvalue->value.u._e2ap_E2nodeConfigurationUpdateFailure_IEs_id_TransactionID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdateFailure_IEs_id_Cause:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-Cause");
                    stat = asn1PE_e2ap_Cause (pctxt, pvalue->value.u._e2ap_E2nodeConfigurationUpdateFailure_IEs_id_Cause);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdateFailure_IEs_id_TimeToWait:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-TimeToWait");
                    stat = asn1PE_e2ap_TimeToWait (pctxt, pvalue->value.u._e2ap_E2nodeConfigurationUpdateFailure_IEs_id_TimeToWait);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdateFailure_IEs_id_CriticalityDiagnostics:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-CriticalityDiagnostics");
                    stat = asn1PE_e2ap_CriticalityDiagnostics (pctxt, pvalue->value.u._e2ap_E2nodeConfigurationUpdateFailure_IEs_id_CriticalityDiagnostics);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdateFailure_IEs_UNDEF_:
            {
                if(0!=pvalue->value.u.extElem1){
                    openType.numocts = pvalue->value.u.extElem1->numocts;
                    openType.data = pvalue->value.u.extElem1->data;
                } else {
                    /* No extension element to encode */
                }
                encoded = FALSE;
                break;
            }

            default:
                encoded = FALSE;
                stat = RTERR_INVOPT;
                break;
        } 

        if(encoded){
            openType.numocts = (OSUINT32)pe_GetMsgLen(pctxt);
            openType.data = pDynamicEncodeBuffer = pctxt -> buffer.data;
        }
        rtxCopyContext(pctxt, &lctxt);

        if(stat == 0) {
            stat = pe_OpenType (pctxt, openType.numocts, openType.data);
        }
    #if 1
        if(encoded){//dungnm23 check lai nhe
            rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
        }
    #endif

    }

    if(stat!=0) return LOG_RTERR(pctxt, stat);  
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}

EXTERN int  asn1PD_e2ap_E2nodeConfigurationUpdateFailure_protocolIEs_element (OSCTXT* pctxt, e2ap_E2nodeConfigurationUpdateFailure_protocolIEs_element* pvalue){
    int stat =0;

    /*decode id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PD_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PD_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");

    {
        OSUINT32 openTypeLen;
        size_t bitStartOffset, bitLength;

        stat = pd_UnconsLength(pctxt, &openTypeLen);
        if(stat<0) return LOG_RTERR(pctxt, stat);
        else if(stat == RT_OK_FRAG){
            rtxErrAddStrParm(pctxt, "open type with fragment length");
            return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
        }
        bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
        bitLength = openTypeLen * 8;

        switch(pvalue->id){//dungnm23 check case lai nhe
        
            case ASN1V_e2ap_id_TransactionID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdateFailure_IEs_id_TransactionID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-TransactionID");
                pvalue->value.u._e2ap_E2nodeConfigurationUpdateFailure_IEs_id_TransactionID 
                    = rtxMemAllocType(pctxt, e2ap_TransactionID);

                asn1Init_e2ap_TransactionID(pvalue->value.u._e2ap_E2nodeConfigurationUpdateFailure_IEs_id_TransactionID);

                stat = asn1PD_e2ap_TransactionID (pctxt,
                        (e2ap_TransactionID*)pvalue->value.
                        u._e2ap_E2nodeConfigurationUpdateFailure_IEs_id_TransactionID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_Cause:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdateFailure_IEs_id_Cause;
            RTXCTXTPUSHELEMNAME(pctxt, "id-Cause");
                pvalue->value.u._e2ap_E2nodeConfigurationUpdateFailure_IEs_id_Cause 
                    = rtxMemAllocType(pctxt, e2ap_Cause);

                asn1Init_e2ap_Cause(pvalue->value.u._e2ap_E2nodeConfigurationUpdateFailure_IEs_id_Cause);

                stat = asn1PD_e2ap_Cause (pctxt,
                        (e2ap_Cause*)pvalue->value.
                        u._e2ap_E2nodeConfigurationUpdateFailure_IEs_id_Cause);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_TimeToWait:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdateFailure_IEs_id_TimeToWait;
            RTXCTXTPUSHELEMNAME(pctxt, "id-TimeToWait");
                pvalue->value.u._e2ap_E2nodeConfigurationUpdateFailure_IEs_id_TimeToWait 
                    = rtxMemAllocType(pctxt, e2ap_TimeToWait);

                asn1Init_e2ap_TimeToWait(pvalue->value.u._e2ap_E2nodeConfigurationUpdateFailure_IEs_id_TimeToWait);

                stat = asn1PD_e2ap_TimeToWait (pctxt,
                        (e2ap_TimeToWait*)pvalue->value.
                        u._e2ap_E2nodeConfigurationUpdateFailure_IEs_id_TimeToWait);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_CriticalityDiagnostics:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdateFailure_IEs_id_CriticalityDiagnostics;
            RTXCTXTPUSHELEMNAME(pctxt, "id-CriticalityDiagnostics");
                pvalue->value.u._e2ap_E2nodeConfigurationUpdateFailure_IEs_id_CriticalityDiagnostics 
                    = rtxMemAllocType(pctxt, e2ap_CriticalityDiagnostics);

                asn1Init_e2ap_CriticalityDiagnostics(pvalue->value.u._e2ap_E2nodeConfigurationUpdateFailure_IEs_id_CriticalityDiagnostics);

                stat = asn1PD_e2ap_CriticalityDiagnostics (pctxt,
                        (e2ap_CriticalityDiagnostics*)pvalue->value.
                        u._e2ap_E2nodeConfigurationUpdateFailure_IEs_id_CriticalityDiagnostics);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdateFailure_IEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*) rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
    }
    {
    size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
    size_t bitsConsumed = bitEndOffset-bitStartOffset;
    if(bitsConsumed<bitLength){
        stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
    }
    else stat =(bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
    }}
    if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}


int asn1Init_e2ap_E2nodeConfigurationUpdateFailure_protocolIEs_element(e2ap_E2nodeConfigurationUpdateFailure_protocolIEs_element* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    OSCRTLMEMSET (&pvalue->value, 0, sizeof(pvalue->value));
    return 0;
}


//-----> chuaw có template rtxFreeASN1OpenType

#if 0
void asn1Free_e2ap_E2nodeConfigurationUpdateFailure_protocolIEs_element(OSCTXT* pctxt, e2ap_E2nodeConfigurationUpdateFailure_protocolIEs_element* pvalue)
{
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdateFailure_IEs_id_id_TransactionID:
            // rtxFreeE2ap_TransactionID(pvalue->value.u._e2ap_E2nodeConfigurationUpdateFailure_IEs_id_id_TransactionID);

            if(pvalue->value.i._e2ap_E2nodeConfigurationUpdateFailure_id_TransactionID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_TransactionID(pctxt, pvalue->value.u._e2ap_E2nodeConfigurationUpdateFailure_IEs_id_id_TransactionID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2nodeConfigurationUpdateFailure_IEs_id_id_TransactionID);
           // pvalue->value.u._e2ap_E2nodeConfigurationUpdateFailure_IEs_id_id_TransactionID = NULL;
           pvalue->value.u._e2ap_E2nodeConfigurationUpdateFailure_IEs_id_TransactionID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdateFailure_IEs_id_id_Cause:
            // rtxFreeE2ap_Cause(pvalue->value.u._e2ap_E2nodeConfigurationUpdateFailure_IEs_id_id_Cause);

            if(pvalue->value.i._e2ap_E2nodeConfigurationUpdateFailure_id_Cause!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_Cause(pctxt, pvalue->value.u._e2ap_E2nodeConfigurationUpdateFailure_IEs_id_id_Cause);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2nodeConfigurationUpdateFailure_IEs_id_id_Cause);
           // pvalue->value.u._e2ap_E2nodeConfigurationUpdateFailure_IEs_id_id_Cause = NULL;
           pvalue->value.u._e2ap_E2nodeConfigurationUpdateFailure_IEs_id_Cause = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdateFailure_IEs_id_id_TimeToWait:
            // rtxFreeE2ap_TimeToWait(pvalue->value.u._e2ap_E2nodeConfigurationUpdateFailure_IEs_id_id_TimeToWait);

            if(pvalue->value.i._e2ap_E2nodeConfigurationUpdateFailure_id_TimeToWait!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_TimeToWait(pctxt, pvalue->value.u._e2ap_E2nodeConfigurationUpdateFailure_IEs_id_id_TimeToWait);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2nodeConfigurationUpdateFailure_IEs_id_id_TimeToWait);
           // pvalue->value.u._e2ap_E2nodeConfigurationUpdateFailure_IEs_id_id_TimeToWait = NULL;
           pvalue->value.u._e2ap_E2nodeConfigurationUpdateFailure_IEs_id_TimeToWait = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdateFailure_IEs_id_id_CriticalityDiagnostics:
            // rtxFreeE2ap_CriticalityDiagnostics(pvalue->value.u._e2ap_E2nodeConfigurationUpdateFailure_IEs_id_id_CriticalityDiagnostics);

            if(pvalue->value.i._e2ap_E2nodeConfigurationUpdateFailure_id_CriticalityDiagnostics!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_CriticalityDiagnostics(pctxt, pvalue->value.u._e2ap_E2nodeConfigurationUpdateFailure_IEs_id_id_CriticalityDiagnostics);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2nodeConfigurationUpdateFailure_IEs_id_id_CriticalityDiagnostics);
           // pvalue->value.u._e2ap_E2nodeConfigurationUpdateFailure_IEs_id_id_CriticalityDiagnostics = NULL;
           pvalue->value.u._e2ap_E2nodeConfigurationUpdateFailure_IEs_id_CriticalityDiagnostics = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdateFailure_IEs_UNDEF_:
            rtxFreeASN1OpenType(pvalue->value.u.extElem1);
            break;
        default:
            break;
    }
}

int asn1PrtToStr_e2ap_E2nodeConfigurationUpdateFailure_protocolIEs_element(OSCTXT* pctxt, e2ap_E2nodeConfigurationUpdateFailure_protocolIEs_element* pvalue)
{
    int stat =0;
    RTXCTXTPUSHELEMNAME(pctxt, "e2ap_E2nodeConfigurationUpdateFailure_protocolIEs_element");

    /*print id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PrtToStr_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PrtToStr_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdateFailure_IEs_id_id_TransactionID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "TransactionID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_TransactionID (pctxt, pvalue->value.u._e2ap_E2nodeConfigurationUpdateFailure_IEs_id_id_TransactionID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdateFailure_IEs_id_id_Cause:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "Cause");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_Cause (pctxt, pvalue->value.u._e2ap_E2nodeConfigurationUpdateFailure_IEs_id_id_Cause);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdateFailure_IEs_id_id_TimeToWait:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "TimeToWait");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_TimeToWait (pctxt, pvalue->value.u._e2ap_E2nodeConfigurationUpdateFailure_IEs_id_id_TimeToWait);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdateFailure_IEs_id_id_CriticalityDiagnostics:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "CriticalityDiagnostics");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_CriticalityDiagnostics (pctxt, pvalue->value.u._e2ap_E2nodeConfigurationUpdateFailure_IEs_id_id_CriticalityDiagnostics);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdateFailure_IEs_UNDEF_:
            {
                rtxPLogMsg(pctxt, "Extension element present - raw data not printed.\n");
                break;
            }

            default:
                stat = RTERR_INVOPT;
                return LOG_RTERR(pctxt, stat);
        }
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);
}
#endif


int asn1PrtToStr_e2ap_E2nodeConfigurationUpdateFailure_protocolIEs_element (const char * name,
 e2ap_E2nodeConfigurationUpdateFailure_protocolIEs_element* pvalue, 
 char * buffer, OSSIZE bufSize){
    if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
        return -1;
    if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
        return -1;

    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdateFailure_IEs_id_TransactionID:
            if(asn1PrtToStr_e2ap_TransactionID("TransactionID", 
                    pvalue->value.u._e2ap_E2nodeConfigurationUpdateFailure_IEs_id_TransactionID, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdateFailure_IEs_id_Cause:
            if(asn1PrtToStr_e2ap_Cause("Cause", 
                    pvalue->value.u._e2ap_E2nodeConfigurationUpdateFailure_IEs_id_Cause, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdateFailure_IEs_id_TimeToWait:
            if(asn1PrtToStr_e2ap_TimeToWait("TimeToWait", 
                    pvalue->value.u._e2ap_E2nodeConfigurationUpdateFailure_IEs_id_TimeToWait, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdateFailure_IEs_id_CriticalityDiagnostics:
            if(asn1PrtToStr_e2ap_CriticalityDiagnostics("CriticalityDiagnostics", 
                    pvalue->value.u._e2ap_E2nodeConfigurationUpdateFailure_IEs_id_CriticalityDiagnostics, buffer, bufSize)<0)
                return -1;
            break;    
        default:
        if(0!=pvalue -> value.u.extElem1){
            rtPrintToStringIndent(buffer, bufSize);
            rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

        }
        }
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

    return 0;

 }

 void asn1Free_e2ap_E2nodeConfigurationUpdateFailure_protocolIEs_element(OSCTXT* pctxt, e2ap_E2nodeConfigurationUpdateFailure_protocolIEs_element* pvalue){
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdateFailure_IEs_id_TransactionID:
            if(pvalue->value.u._e2ap_E2nodeConfigurationUpdateFailure_IEs_id_TransactionID!=NULL){
            asn1Free_e2ap_TransactionID(pctxt, pvalue->value.u._e2ap_E2nodeConfigurationUpdateFailure_IEs_id_TransactionID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2nodeConfigurationUpdateFailure_IEs_id_TransactionID);
            pvalue->value.u._e2ap_E2nodeConfigurationUpdateFailure_IEs_id_TransactionID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdateFailure_IEs_id_Cause:
            if(pvalue->value.u._e2ap_E2nodeConfigurationUpdateFailure_IEs_id_Cause!=NULL){
            asn1Free_e2ap_Cause(pctxt, pvalue->value.u._e2ap_E2nodeConfigurationUpdateFailure_IEs_id_Cause);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2nodeConfigurationUpdateFailure_IEs_id_Cause);
            pvalue->value.u._e2ap_E2nodeConfigurationUpdateFailure_IEs_id_Cause = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdateFailure_IEs_id_TimeToWait:
            if(pvalue->value.u._e2ap_E2nodeConfigurationUpdateFailure_IEs_id_TimeToWait!=NULL){
            asn1Free_e2ap_TimeToWait(pctxt, pvalue->value.u._e2ap_E2nodeConfigurationUpdateFailure_IEs_id_TimeToWait);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2nodeConfigurationUpdateFailure_IEs_id_TimeToWait);
            pvalue->value.u._e2ap_E2nodeConfigurationUpdateFailure_IEs_id_TimeToWait = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_E2nodeConfigurationUpdateFailure_IEs_id_CriticalityDiagnostics:
            if(pvalue->value.u._e2ap_E2nodeConfigurationUpdateFailure_IEs_id_CriticalityDiagnostics!=NULL){
            asn1Free_e2ap_CriticalityDiagnostics(pctxt, pvalue->value.u._e2ap_E2nodeConfigurationUpdateFailure_IEs_id_CriticalityDiagnostics);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2nodeConfigurationUpdateFailure_IEs_id_CriticalityDiagnostics);
            pvalue->value.u._e2ap_E2nodeConfigurationUpdateFailure_IEs_id_CriticalityDiagnostics = NULL;
            }
            break;
        default:
            break;


    }
 }

 

/*****************************************/
/*           E2nodeConfigurationUpdateFailure                */
/*****************************************/
//2_container.c
/* 1. xxx_ProtocolIE -> mẫu cũ ở ie_big_msg */
EXTERN int asn1PE_e2ap_E2nodeConfigurationUpdateFailure_protocolIEs (OSCTXT* pctxt, e2ap_E2nodeConfigurationUpdateFailure_protocolIEs* pvalue)
{
    int stat =0;
    OSRTDListNode* pnode;
    OSUINT32 xx1;

    /*encode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pe_Length(pctxt, pvalue->count);
    if(stat<0) return LOG_RTERR(pctxt, stat);

    /*encode each element*/
    xx1 =0;
    for(pnode = pvalue->head; pnode != 0 && xx1<pvalue->count; pnode = pnode->next){
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE", xx1);
        stat = asn1PE_e2ap_E2nodeConfigurationUpdateFailure_protocolIEs_element (pctxt, ((e2ap_E2nodeConfigurationUpdateFailure_protocolIEs_element*)pnode->data));
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        xx1++;
        RTXCTXTPOPARRAYELEMNAME(pctxt);
    }

    return (stat);
}

EXTERN int  asn1PD_e2ap_E2nodeConfigurationUpdateFailure_protocolIEs(OSCTXT* pctxt, e2ap_E2nodeConfigurationUpdateFailure_protocolIEs* pvalue)
{
     int stat =0;
     OSRTDListNode* pnode;
     OSSIZE count =0;
     OSSIZE xx1=0;


     /*decode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pd_Length64(pctxt, &count); //tai sao lai 64
    if(stat!=0) return LOG_RTERR(pctxt, stat);

    /*decode each element*/
    rtxDListInit(pvalue);

    for(xx1=0; xx1 < count; xx1++){
        e2ap_E2nodeConfigurationUpdateFailure_protocolIEs_element* pdata;
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE",xx1);

        if(pnode == NULL) return LOG_RTERR(pctxt, RTERR_NOMEM);

        asn1Init_e2ap_E2nodeConfigurationUpdateFailure_protocolIEs_element(pdata);
        rtxDListAppendNode(pvalue, pnode);
        stat = asn1PD_e2ap_E2nodeConfigurationUpdateFailure_protocolIEs_element (pctxt, pdata);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        RTXCTXTPOPARRAYELEMNAME(pctxt);

    }
    return (stat);
}


int asn1Init_e2ap_E2nodeConfigurationUpdateFailure_protocolIEs(e2ap_E2nodeConfigurationUpdateFailure_protocolIEs* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    rtxDListFastInit (pvalue);
    return 0;
}
#if 1 //ao that day
void asn1Free_e2ap_E2nodeConfigurationUpdateFailure_protocolIEs(OSCTXT* pctxt, e2ap_E2nodeConfigurationUpdateFailure_protocolIEs* pvalue)
{
    if(0==pvalue) return;   
    e2ap_E2nodeConfigurationUpdateFailure_protocolIEs_element* pdata;
    OSRTDListNode* pnode=pvalue->head;
    while(0!=pnode){
        pdata = (e2ap_E2nodeConfigurationUpdateFailure_protocolIEs_element*)pnode->data;
       // asn1Free_e2ap_E2nodeConfigurationUpdateFailure_protocolIEs_element(pctxt, pdata);
        pnode = pnode->next;
    }
    rtxDListFreeAll(pctxt, pvalue);
}
#endif


EXTERN int asn1PrtToStr_e2ap_E2nodeConfigurationUpdateFailure_protocolIEs(const char* name, e2ap_E2nodeConfigurationUpdateFailure_protocolIEs* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_E2nodeConfigurationUpdateFailure_protocolIEs_element* pdata0;
    OSRTDListNode* pnode0;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode0 = pvalue->head;  xx1 < pvalue->count && pnode0 != 0; pnode0 = pnode0->next, xx1++){
        pdata0 = (e2ap_E2nodeConfigurationUpdateFailure_protocolIEs_element*)pnode0->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 0
        if(asn1PrtToStr_e2ap_E2nodeConfigurationUpdateFailure_protocolIEs_element(nameBuf, pdata0, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}


/*2 . E2nodeConfigurationUpdateFailure -> mẫu cũ ở seq_normal*/

int asn1PE_e2ap_E2nodeConfigurationUpdateFailure (OSCTXT* pctxt, e2ap_E2nodeConfigurationUpdateFailure* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "E2nodeConfigurationUpdateFailure");
   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field protocolIEs - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
   stat = asn1PE_e2ap_E2nodeConfigurationUpdateFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
   if(stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_E2nodeConfigurationUpdateFailure (OSCTXT* pctxt, e2ap_E2nodeConfigurationUpdateFailure* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME(pctxt, "E2nodeConfigurationUpdateFailure");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field protocolIEs */
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
      stat = asn1PD_e2ap_E2nodeConfigurationUpdateFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_E2nodeConfigurationUpdateFailure (e2ap_E2nodeConfigurationUpdateFailure* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_E2nodeConfigurationUpdateFailure_protocolIEs(&pvalue->protocolIEs);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_E2nodeConfigurationUpdateFailure (OSCTXT* pctxt, e2ap_E2nodeConfigurationUpdateFailure* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_E2nodeConfigurationUpdateFailure_protocolIEs(pctxt, &pvalue->protocolIEs);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_E2nodeConfigurationUpdateFailure (const char* name, e2ap_E2nodeConfigurationUpdateFailure* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }

   if(asn1PrtToStr_e2ap_E2nodeConfigurationUpdateFailure_protocolIEs("protocolIEs", &pvalue->protocolIEs, buffer, bufSize) <0){
      return -1;
   }

   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           E2RemovalRequestIEs                */
/*****************************************/
/* ie.c.j2 */
 /* d là con của msg */
EXTERN int asn1PE_e2ap_E2RemovalRequest_protocolIEs_element (OSCTXT* pctxt, e2ap_E2RemovalRequest_protocolIEs_element* pvalue)
{
    int stat =0;

    /*encode id*/

    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PE_e2ap_ProtocolIE_ID(pctxt, pvalue->id);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PE_e2ap_Criticality(pctxt, pvalue->criticality);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
    {
        OSCTXT lctxt;
        OSOCTET *pDynamicEncodeBuffer;
        ASN1OpenType openType;
        OSBOOL encoded = TRUE;

        openType.numocts = 0;
        openType.data =0;

        rtxCopyContext(&lctxt, pctxt);
        pctxt->pStream =0;

        stat = rtxInitContextBuffer(pctxt, 0, 0);
        if(stat!=0) return LOG_RTERR(pctxt, stat);

        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_E2RemovalRequestIEs_id_TransactionID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-TransactionID");
                    stat = asn1PE_e2ap_TransactionID (pctxt, pvalue->value.u._e2ap_E2RemovalRequestIEs_id_TransactionID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_E2RemovalRequestIEs_UNDEF_:
            {
                if(0!=pvalue->value.u.extElem1){
                    openType.numocts = pvalue->value.u.extElem1->numocts;
                    openType.data = pvalue->value.u.extElem1->data;
                } else {
                    /* No extension element to encode */
                }
                encoded = FALSE;
                break;
            }

            default:
                encoded = FALSE;
                stat = RTERR_INVOPT;
                break;
        } 

        if(encoded){
            openType.numocts = (OSUINT32)pe_GetMsgLen(pctxt);
            openType.data = pDynamicEncodeBuffer = pctxt -> buffer.data;
        }
        rtxCopyContext(pctxt, &lctxt);

        if(stat == 0) {
            stat = pe_OpenType (pctxt, openType.numocts, openType.data);
        }
    #if 1
        if(encoded){//dungnm23 check lai nhe
            rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
        }
    #endif

    }

    if(stat!=0) return LOG_RTERR(pctxt, stat);  
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}

EXTERN int  asn1PD_e2ap_E2RemovalRequest_protocolIEs_element (OSCTXT* pctxt, e2ap_E2RemovalRequest_protocolIEs_element* pvalue){
    int stat =0;

    /*decode id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PD_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PD_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");

    {
        OSUINT32 openTypeLen;
        size_t bitStartOffset, bitLength;

        stat = pd_UnconsLength(pctxt, &openTypeLen);
        if(stat<0) return LOG_RTERR(pctxt, stat);
        else if(stat == RT_OK_FRAG){
            rtxErrAddStrParm(pctxt, "open type with fragment length");
            return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
        }
        bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
        bitLength = openTypeLen * 8;

        switch(pvalue->id){//dungnm23 check case lai nhe
        
            case ASN1V_e2ap_id_TransactionID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_E2RemovalRequestIEs_id_TransactionID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-TransactionID");
                pvalue->value.u._e2ap_E2RemovalRequestIEs_id_TransactionID 
                    = rtxMemAllocType(pctxt, e2ap_TransactionID);

                asn1Init_e2ap_TransactionID(pvalue->value.u._e2ap_E2RemovalRequestIEs_id_TransactionID);

                stat = asn1PD_e2ap_TransactionID (pctxt,
                        (e2ap_TransactionID*)pvalue->value.
                        u._e2ap_E2RemovalRequestIEs_id_TransactionID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_E2RemovalRequestIEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*) rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
    }
    {
    size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
    size_t bitsConsumed = bitEndOffset-bitStartOffset;
    if(bitsConsumed<bitLength){
        stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
    }
    else stat =(bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
    }}
    if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}


int asn1Init_e2ap_E2RemovalRequest_protocolIEs_element(e2ap_E2RemovalRequest_protocolIEs_element* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    OSCRTLMEMSET (&pvalue->value, 0, sizeof(pvalue->value));
    return 0;
}


//-----> chuaw có template rtxFreeASN1OpenType

#if 0
void asn1Free_e2ap_E2RemovalRequest_protocolIEs_element(OSCTXT* pctxt, e2ap_E2RemovalRequest_protocolIEs_element* pvalue)
{
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_E2RemovalRequestIEs_id_id_TransactionID:
            // rtxFreeE2ap_TransactionID(pvalue->value.u._e2ap_E2RemovalRequestIEs_id_id_TransactionID);

            if(pvalue->value.i._e2ap_E2RemovalRequest_id_TransactionID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_TransactionID(pctxt, pvalue->value.u._e2ap_E2RemovalRequestIEs_id_id_TransactionID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2RemovalRequestIEs_id_id_TransactionID);
           // pvalue->value.u._e2ap_E2RemovalRequestIEs_id_id_TransactionID = NULL;
           pvalue->value.u._e2ap_E2RemovalRequestIEs_id_TransactionID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_E2RemovalRequestIEs_UNDEF_:
            rtxFreeASN1OpenType(pvalue->value.u.extElem1);
            break;
        default:
            break;
    }
}

int asn1PrtToStr_e2ap_E2RemovalRequest_protocolIEs_element(OSCTXT* pctxt, e2ap_E2RemovalRequest_protocolIEs_element* pvalue)
{
    int stat =0;
    RTXCTXTPUSHELEMNAME(pctxt, "e2ap_E2RemovalRequest_protocolIEs_element");

    /*print id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PrtToStr_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PrtToStr_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_E2RemovalRequestIEs_id_id_TransactionID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "TransactionID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_TransactionID (pctxt, pvalue->value.u._e2ap_E2RemovalRequestIEs_id_id_TransactionID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_E2RemovalRequestIEs_UNDEF_:
            {
                rtxPLogMsg(pctxt, "Extension element present - raw data not printed.\n");
                break;
            }

            default:
                stat = RTERR_INVOPT;
                return LOG_RTERR(pctxt, stat);
        }
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);
}
#endif


int asn1PrtToStr_e2ap_E2RemovalRequest_protocolIEs_element (const char * name,
 e2ap_E2RemovalRequest_protocolIEs_element* pvalue, 
 char * buffer, OSSIZE bufSize){
    if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
        return -1;
    if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
        return -1;

    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_E2RemovalRequestIEs_id_TransactionID:
            if(asn1PrtToStr_e2ap_TransactionID("TransactionID", 
                    pvalue->value.u._e2ap_E2RemovalRequestIEs_id_TransactionID, buffer, bufSize)<0)
                return -1;
            break;    
        default:
        if(0!=pvalue -> value.u.extElem1){
            rtPrintToStringIndent(buffer, bufSize);
            rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

        }
        }
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

    return 0;

 }

 void asn1Free_e2ap_E2RemovalRequest_protocolIEs_element(OSCTXT* pctxt, e2ap_E2RemovalRequest_protocolIEs_element* pvalue){
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_E2RemovalRequestIEs_id_TransactionID:
            if(pvalue->value.u._e2ap_E2RemovalRequestIEs_id_TransactionID!=NULL){
            asn1Free_e2ap_TransactionID(pctxt, pvalue->value.u._e2ap_E2RemovalRequestIEs_id_TransactionID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2RemovalRequestIEs_id_TransactionID);
            pvalue->value.u._e2ap_E2RemovalRequestIEs_id_TransactionID = NULL;
            }
            break;
        default:
            break;


    }
 }

 

/*****************************************/
/*           E2RemovalRequest                */
/*****************************************/
//2_container.c
/* 1. xxx_ProtocolIE -> mẫu cũ ở ie_big_msg */
EXTERN int asn1PE_e2ap_E2RemovalRequest_protocolIEs (OSCTXT* pctxt, e2ap_E2RemovalRequest_protocolIEs* pvalue)
{
    int stat =0;
    OSRTDListNode* pnode;
    OSUINT32 xx1;

    /*encode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pe_Length(pctxt, pvalue->count);
    if(stat<0) return LOG_RTERR(pctxt, stat);

    /*encode each element*/
    xx1 =0;
    for(pnode = pvalue->head; pnode != 0 && xx1<pvalue->count; pnode = pnode->next){
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE", xx1);
        stat = asn1PE_e2ap_E2RemovalRequest_protocolIEs_element (pctxt, ((e2ap_E2RemovalRequest_protocolIEs_element*)pnode->data));
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        xx1++;
        RTXCTXTPOPARRAYELEMNAME(pctxt);
    }

    return (stat);
}

EXTERN int  asn1PD_e2ap_E2RemovalRequest_protocolIEs(OSCTXT* pctxt, e2ap_E2RemovalRequest_protocolIEs* pvalue)
{
     int stat =0;
     OSRTDListNode* pnode;
     OSSIZE count =0;
     OSSIZE xx1=0;


     /*decode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pd_Length64(pctxt, &count); //tai sao lai 64
    if(stat!=0) return LOG_RTERR(pctxt, stat);

    /*decode each element*/
    rtxDListInit(pvalue);

    for(xx1=0; xx1 < count; xx1++){
        e2ap_E2RemovalRequest_protocolIEs_element* pdata;
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE",xx1);

        if(pnode == NULL) return LOG_RTERR(pctxt, RTERR_NOMEM);

        asn1Init_e2ap_E2RemovalRequest_protocolIEs_element(pdata);
        rtxDListAppendNode(pvalue, pnode);
        stat = asn1PD_e2ap_E2RemovalRequest_protocolIEs_element (pctxt, pdata);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        RTXCTXTPOPARRAYELEMNAME(pctxt);

    }
    return (stat);
}


int asn1Init_e2ap_E2RemovalRequest_protocolIEs(e2ap_E2RemovalRequest_protocolIEs* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    rtxDListFastInit (pvalue);
    return 0;
}
#if 1 //ao that day
void asn1Free_e2ap_E2RemovalRequest_protocolIEs(OSCTXT* pctxt, e2ap_E2RemovalRequest_protocolIEs* pvalue)
{
    if(0==pvalue) return;   
    e2ap_E2RemovalRequest_protocolIEs_element* pdata;
    OSRTDListNode* pnode=pvalue->head;
    while(0!=pnode){
        pdata = (e2ap_E2RemovalRequest_protocolIEs_element*)pnode->data;
       // asn1Free_e2ap_E2RemovalRequest_protocolIEs_element(pctxt, pdata);
        pnode = pnode->next;
    }
    rtxDListFreeAll(pctxt, pvalue);
}
#endif


EXTERN int asn1PrtToStr_e2ap_E2RemovalRequest_protocolIEs(const char* name, e2ap_E2RemovalRequest_protocolIEs* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_E2RemovalRequest_protocolIEs_element* pdata0;
    OSRTDListNode* pnode0;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode0 = pvalue->head;  xx1 < pvalue->count && pnode0 != 0; pnode0 = pnode0->next, xx1++){
        pdata0 = (e2ap_E2RemovalRequest_protocolIEs_element*)pnode0->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 0
        if(asn1PrtToStr_e2ap_E2RemovalRequest_protocolIEs_element(nameBuf, pdata0, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}


/*2 . E2RemovalRequest -> mẫu cũ ở seq_normal*/

int asn1PE_e2ap_E2RemovalRequest (OSCTXT* pctxt, e2ap_E2RemovalRequest* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "E2RemovalRequest");
   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field protocolIEs - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
   stat = asn1PE_e2ap_E2RemovalRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if(stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_E2RemovalRequest (OSCTXT* pctxt, e2ap_E2RemovalRequest* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME(pctxt, "E2RemovalRequest");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field protocolIEs */
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
      stat = asn1PD_e2ap_E2RemovalRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_E2RemovalRequest (e2ap_E2RemovalRequest* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_E2RemovalRequest_protocolIEs(&pvalue->protocolIEs);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_E2RemovalRequest (OSCTXT* pctxt, e2ap_E2RemovalRequest* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_E2RemovalRequest_protocolIEs(pctxt, &pvalue->protocolIEs);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_E2RemovalRequest (const char* name, e2ap_E2RemovalRequest* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }

   if(asn1PrtToStr_e2ap_E2RemovalRequest_protocolIEs("protocolIEs", &pvalue->protocolIEs, buffer, bufSize) <0){
      return -1;
   }

   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           E2RemovalResponseIEs                */
/*****************************************/
/* ie.c.j2 */
 /* d là con của msg */
EXTERN int asn1PE_e2ap_E2RemovalResponse_protocolIEs_element (OSCTXT* pctxt, e2ap_E2RemovalResponse_protocolIEs_element* pvalue)
{
    int stat =0;

    /*encode id*/

    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PE_e2ap_ProtocolIE_ID(pctxt, pvalue->id);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PE_e2ap_Criticality(pctxt, pvalue->criticality);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
    {
        OSCTXT lctxt;
        OSOCTET *pDynamicEncodeBuffer;
        ASN1OpenType openType;
        OSBOOL encoded = TRUE;

        openType.numocts = 0;
        openType.data =0;

        rtxCopyContext(&lctxt, pctxt);
        pctxt->pStream =0;

        stat = rtxInitContextBuffer(pctxt, 0, 0);
        if(stat!=0) return LOG_RTERR(pctxt, stat);

        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_E2RemovalResponseIEs_id_TransactionID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-TransactionID");
                    stat = asn1PE_e2ap_TransactionID (pctxt, pvalue->value.u._e2ap_E2RemovalResponseIEs_id_TransactionID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_E2RemovalResponseIEs_id_CriticalityDiagnostics:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-CriticalityDiagnostics");
                    stat = asn1PE_e2ap_CriticalityDiagnostics (pctxt, pvalue->value.u._e2ap_E2RemovalResponseIEs_id_CriticalityDiagnostics);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_E2RemovalResponseIEs_UNDEF_:
            {
                if(0!=pvalue->value.u.extElem1){
                    openType.numocts = pvalue->value.u.extElem1->numocts;
                    openType.data = pvalue->value.u.extElem1->data;
                } else {
                    /* No extension element to encode */
                }
                encoded = FALSE;
                break;
            }

            default:
                encoded = FALSE;
                stat = RTERR_INVOPT;
                break;
        } 

        if(encoded){
            openType.numocts = (OSUINT32)pe_GetMsgLen(pctxt);
            openType.data = pDynamicEncodeBuffer = pctxt -> buffer.data;
        }
        rtxCopyContext(pctxt, &lctxt);

        if(stat == 0) {
            stat = pe_OpenType (pctxt, openType.numocts, openType.data);
        }
    #if 1
        if(encoded){//dungnm23 check lai nhe
            rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
        }
    #endif

    }

    if(stat!=0) return LOG_RTERR(pctxt, stat);  
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}

EXTERN int  asn1PD_e2ap_E2RemovalResponse_protocolIEs_element (OSCTXT* pctxt, e2ap_E2RemovalResponse_protocolIEs_element* pvalue){
    int stat =0;

    /*decode id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PD_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PD_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");

    {
        OSUINT32 openTypeLen;
        size_t bitStartOffset, bitLength;

        stat = pd_UnconsLength(pctxt, &openTypeLen);
        if(stat<0) return LOG_RTERR(pctxt, stat);
        else if(stat == RT_OK_FRAG){
            rtxErrAddStrParm(pctxt, "open type with fragment length");
            return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
        }
        bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
        bitLength = openTypeLen * 8;

        switch(pvalue->id){//dungnm23 check case lai nhe
        
            case ASN1V_e2ap_id_TransactionID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_E2RemovalResponseIEs_id_TransactionID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-TransactionID");
                pvalue->value.u._e2ap_E2RemovalResponseIEs_id_TransactionID 
                    = rtxMemAllocType(pctxt, e2ap_TransactionID);

                asn1Init_e2ap_TransactionID(pvalue->value.u._e2ap_E2RemovalResponseIEs_id_TransactionID);

                stat = asn1PD_e2ap_TransactionID (pctxt,
                        (e2ap_TransactionID*)pvalue->value.
                        u._e2ap_E2RemovalResponseIEs_id_TransactionID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_CriticalityDiagnostics:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_E2RemovalResponseIEs_id_CriticalityDiagnostics;
            RTXCTXTPUSHELEMNAME(pctxt, "id-CriticalityDiagnostics");
                pvalue->value.u._e2ap_E2RemovalResponseIEs_id_CriticalityDiagnostics 
                    = rtxMemAllocType(pctxt, e2ap_CriticalityDiagnostics);

                asn1Init_e2ap_CriticalityDiagnostics(pvalue->value.u._e2ap_E2RemovalResponseIEs_id_CriticalityDiagnostics);

                stat = asn1PD_e2ap_CriticalityDiagnostics (pctxt,
                        (e2ap_CriticalityDiagnostics*)pvalue->value.
                        u._e2ap_E2RemovalResponseIEs_id_CriticalityDiagnostics);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_E2RemovalResponseIEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*) rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
    }
    {
    size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
    size_t bitsConsumed = bitEndOffset-bitStartOffset;
    if(bitsConsumed<bitLength){
        stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
    }
    else stat =(bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
    }}
    if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}


int asn1Init_e2ap_E2RemovalResponse_protocolIEs_element(e2ap_E2RemovalResponse_protocolIEs_element* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    OSCRTLMEMSET (&pvalue->value, 0, sizeof(pvalue->value));
    return 0;
}


//-----> chuaw có template rtxFreeASN1OpenType

#if 0
void asn1Free_e2ap_E2RemovalResponse_protocolIEs_element(OSCTXT* pctxt, e2ap_E2RemovalResponse_protocolIEs_element* pvalue)
{
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_E2RemovalResponseIEs_id_id_TransactionID:
            // rtxFreeE2ap_TransactionID(pvalue->value.u._e2ap_E2RemovalResponseIEs_id_id_TransactionID);

            if(pvalue->value.i._e2ap_E2RemovalResponse_id_TransactionID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_TransactionID(pctxt, pvalue->value.u._e2ap_E2RemovalResponseIEs_id_id_TransactionID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2RemovalResponseIEs_id_id_TransactionID);
           // pvalue->value.u._e2ap_E2RemovalResponseIEs_id_id_TransactionID = NULL;
           pvalue->value.u._e2ap_E2RemovalResponseIEs_id_TransactionID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_E2RemovalResponseIEs_id_id_CriticalityDiagnostics:
            // rtxFreeE2ap_CriticalityDiagnostics(pvalue->value.u._e2ap_E2RemovalResponseIEs_id_id_CriticalityDiagnostics);

            if(pvalue->value.i._e2ap_E2RemovalResponse_id_CriticalityDiagnostics!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_CriticalityDiagnostics(pctxt, pvalue->value.u._e2ap_E2RemovalResponseIEs_id_id_CriticalityDiagnostics);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2RemovalResponseIEs_id_id_CriticalityDiagnostics);
           // pvalue->value.u._e2ap_E2RemovalResponseIEs_id_id_CriticalityDiagnostics = NULL;
           pvalue->value.u._e2ap_E2RemovalResponseIEs_id_CriticalityDiagnostics = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_E2RemovalResponseIEs_UNDEF_:
            rtxFreeASN1OpenType(pvalue->value.u.extElem1);
            break;
        default:
            break;
    }
}

int asn1PrtToStr_e2ap_E2RemovalResponse_protocolIEs_element(OSCTXT* pctxt, e2ap_E2RemovalResponse_protocolIEs_element* pvalue)
{
    int stat =0;
    RTXCTXTPUSHELEMNAME(pctxt, "e2ap_E2RemovalResponse_protocolIEs_element");

    /*print id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PrtToStr_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PrtToStr_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_E2RemovalResponseIEs_id_id_TransactionID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "TransactionID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_TransactionID (pctxt, pvalue->value.u._e2ap_E2RemovalResponseIEs_id_id_TransactionID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_E2RemovalResponseIEs_id_id_CriticalityDiagnostics:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "CriticalityDiagnostics");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_CriticalityDiagnostics (pctxt, pvalue->value.u._e2ap_E2RemovalResponseIEs_id_id_CriticalityDiagnostics);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_E2RemovalResponseIEs_UNDEF_:
            {
                rtxPLogMsg(pctxt, "Extension element present - raw data not printed.\n");
                break;
            }

            default:
                stat = RTERR_INVOPT;
                return LOG_RTERR(pctxt, stat);
        }
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);
}
#endif


int asn1PrtToStr_e2ap_E2RemovalResponse_protocolIEs_element (const char * name,
 e2ap_E2RemovalResponse_protocolIEs_element* pvalue, 
 char * buffer, OSSIZE bufSize){
    if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
        return -1;
    if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
        return -1;

    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_E2RemovalResponseIEs_id_TransactionID:
            if(asn1PrtToStr_e2ap_TransactionID("TransactionID", 
                    pvalue->value.u._e2ap_E2RemovalResponseIEs_id_TransactionID, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_E2RemovalResponseIEs_id_CriticalityDiagnostics:
            if(asn1PrtToStr_e2ap_CriticalityDiagnostics("CriticalityDiagnostics", 
                    pvalue->value.u._e2ap_E2RemovalResponseIEs_id_CriticalityDiagnostics, buffer, bufSize)<0)
                return -1;
            break;    
        default:
        if(0!=pvalue -> value.u.extElem1){
            rtPrintToStringIndent(buffer, bufSize);
            rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

        }
        }
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

    return 0;

 }

 void asn1Free_e2ap_E2RemovalResponse_protocolIEs_element(OSCTXT* pctxt, e2ap_E2RemovalResponse_protocolIEs_element* pvalue){
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_E2RemovalResponseIEs_id_TransactionID:
            if(pvalue->value.u._e2ap_E2RemovalResponseIEs_id_TransactionID!=NULL){
            asn1Free_e2ap_TransactionID(pctxt, pvalue->value.u._e2ap_E2RemovalResponseIEs_id_TransactionID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2RemovalResponseIEs_id_TransactionID);
            pvalue->value.u._e2ap_E2RemovalResponseIEs_id_TransactionID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_E2RemovalResponseIEs_id_CriticalityDiagnostics:
            if(pvalue->value.u._e2ap_E2RemovalResponseIEs_id_CriticalityDiagnostics!=NULL){
            asn1Free_e2ap_CriticalityDiagnostics(pctxt, pvalue->value.u._e2ap_E2RemovalResponseIEs_id_CriticalityDiagnostics);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2RemovalResponseIEs_id_CriticalityDiagnostics);
            pvalue->value.u._e2ap_E2RemovalResponseIEs_id_CriticalityDiagnostics = NULL;
            }
            break;
        default:
            break;


    }
 }

 

/*****************************************/
/*           E2RemovalResponse                */
/*****************************************/
//2_container.c
/* 1. xxx_ProtocolIE -> mẫu cũ ở ie_big_msg */
EXTERN int asn1PE_e2ap_E2RemovalResponse_protocolIEs (OSCTXT* pctxt, e2ap_E2RemovalResponse_protocolIEs* pvalue)
{
    int stat =0;
    OSRTDListNode* pnode;
    OSUINT32 xx1;

    /*encode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pe_Length(pctxt, pvalue->count);
    if(stat<0) return LOG_RTERR(pctxt, stat);

    /*encode each element*/
    xx1 =0;
    for(pnode = pvalue->head; pnode != 0 && xx1<pvalue->count; pnode = pnode->next){
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE", xx1);
        stat = asn1PE_e2ap_E2RemovalResponse_protocolIEs_element (pctxt, ((e2ap_E2RemovalResponse_protocolIEs_element*)pnode->data));
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        xx1++;
        RTXCTXTPOPARRAYELEMNAME(pctxt);
    }

    return (stat);
}

EXTERN int  asn1PD_e2ap_E2RemovalResponse_protocolIEs(OSCTXT* pctxt, e2ap_E2RemovalResponse_protocolIEs* pvalue)
{
     int stat =0;
     OSRTDListNode* pnode;
     OSSIZE count =0;
     OSSIZE xx1=0;


     /*decode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pd_Length64(pctxt, &count); //tai sao lai 64
    if(stat!=0) return LOG_RTERR(pctxt, stat);

    /*decode each element*/
    rtxDListInit(pvalue);

    for(xx1=0; xx1 < count; xx1++){
        e2ap_E2RemovalResponse_protocolIEs_element* pdata;
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE",xx1);

        if(pnode == NULL) return LOG_RTERR(pctxt, RTERR_NOMEM);

        asn1Init_e2ap_E2RemovalResponse_protocolIEs_element(pdata);
        rtxDListAppendNode(pvalue, pnode);
        stat = asn1PD_e2ap_E2RemovalResponse_protocolIEs_element (pctxt, pdata);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        RTXCTXTPOPARRAYELEMNAME(pctxt);

    }
    return (stat);
}


int asn1Init_e2ap_E2RemovalResponse_protocolIEs(e2ap_E2RemovalResponse_protocolIEs* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    rtxDListFastInit (pvalue);
    return 0;
}
#if 1 //ao that day
void asn1Free_e2ap_E2RemovalResponse_protocolIEs(OSCTXT* pctxt, e2ap_E2RemovalResponse_protocolIEs* pvalue)
{
    if(0==pvalue) return;   
    e2ap_E2RemovalResponse_protocolIEs_element* pdata;
    OSRTDListNode* pnode=pvalue->head;
    while(0!=pnode){
        pdata = (e2ap_E2RemovalResponse_protocolIEs_element*)pnode->data;
       // asn1Free_e2ap_E2RemovalResponse_protocolIEs_element(pctxt, pdata);
        pnode = pnode->next;
    }
    rtxDListFreeAll(pctxt, pvalue);
}
#endif


EXTERN int asn1PrtToStr_e2ap_E2RemovalResponse_protocolIEs(const char* name, e2ap_E2RemovalResponse_protocolIEs* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_E2RemovalResponse_protocolIEs_element* pdata0;
    OSRTDListNode* pnode0;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode0 = pvalue->head;  xx1 < pvalue->count && pnode0 != 0; pnode0 = pnode0->next, xx1++){
        pdata0 = (e2ap_E2RemovalResponse_protocolIEs_element*)pnode0->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 0
        if(asn1PrtToStr_e2ap_E2RemovalResponse_protocolIEs_element(nameBuf, pdata0, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}


/*2 . E2RemovalResponse -> mẫu cũ ở seq_normal*/

int asn1PE_e2ap_E2RemovalResponse (OSCTXT* pctxt, e2ap_E2RemovalResponse* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "E2RemovalResponse");
   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field protocolIEs - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
   stat = asn1PE_e2ap_E2RemovalResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
   if(stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_E2RemovalResponse (OSCTXT* pctxt, e2ap_E2RemovalResponse* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME(pctxt, "E2RemovalResponse");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field protocolIEs */
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
      stat = asn1PD_e2ap_E2RemovalResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_E2RemovalResponse (e2ap_E2RemovalResponse* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_E2RemovalResponse_protocolIEs(&pvalue->protocolIEs);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_E2RemovalResponse (OSCTXT* pctxt, e2ap_E2RemovalResponse* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_E2RemovalResponse_protocolIEs(pctxt, &pvalue->protocolIEs);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_E2RemovalResponse (const char* name, e2ap_E2RemovalResponse* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }

   if(asn1PrtToStr_e2ap_E2RemovalResponse_protocolIEs("protocolIEs", &pvalue->protocolIEs, buffer, bufSize) <0){
      return -1;
   }

   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           E2RemovalFailureIEs                */
/*****************************************/
/* ie.c.j2 */
 /* d là con của msg */
EXTERN int asn1PE_e2ap_E2RemovalFailure_protocolIEs_element (OSCTXT* pctxt, e2ap_E2RemovalFailure_protocolIEs_element* pvalue)
{
    int stat =0;

    /*encode id*/

    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PE_e2ap_ProtocolIE_ID(pctxt, pvalue->id);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PE_e2ap_Criticality(pctxt, pvalue->criticality);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
    {
        OSCTXT lctxt;
        OSOCTET *pDynamicEncodeBuffer;
        ASN1OpenType openType;
        OSBOOL encoded = TRUE;

        openType.numocts = 0;
        openType.data =0;

        rtxCopyContext(&lctxt, pctxt);
        pctxt->pStream =0;

        stat = rtxInitContextBuffer(pctxt, 0, 0);
        if(stat!=0) return LOG_RTERR(pctxt, stat);

        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_E2RemovalFailureIEs_id_TransactionID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-TransactionID");
                    stat = asn1PE_e2ap_TransactionID (pctxt, pvalue->value.u._e2ap_E2RemovalFailureIEs_id_TransactionID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_E2RemovalFailureIEs_id_Cause:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-Cause");
                    stat = asn1PE_e2ap_Cause (pctxt, pvalue->value.u._e2ap_E2RemovalFailureIEs_id_Cause);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_E2RemovalFailureIEs_id_CriticalityDiagnostics:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-CriticalityDiagnostics");
                    stat = asn1PE_e2ap_CriticalityDiagnostics (pctxt, pvalue->value.u._e2ap_E2RemovalFailureIEs_id_CriticalityDiagnostics);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_E2RemovalFailureIEs_UNDEF_:
            {
                if(0!=pvalue->value.u.extElem1){
                    openType.numocts = pvalue->value.u.extElem1->numocts;
                    openType.data = pvalue->value.u.extElem1->data;
                } else {
                    /* No extension element to encode */
                }
                encoded = FALSE;
                break;
            }

            default:
                encoded = FALSE;
                stat = RTERR_INVOPT;
                break;
        } 

        if(encoded){
            openType.numocts = (OSUINT32)pe_GetMsgLen(pctxt);
            openType.data = pDynamicEncodeBuffer = pctxt -> buffer.data;
        }
        rtxCopyContext(pctxt, &lctxt);

        if(stat == 0) {
            stat = pe_OpenType (pctxt, openType.numocts, openType.data);
        }
    #if 1
        if(encoded){//dungnm23 check lai nhe
            rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
        }
    #endif

    }

    if(stat!=0) return LOG_RTERR(pctxt, stat);  
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}

EXTERN int  asn1PD_e2ap_E2RemovalFailure_protocolIEs_element (OSCTXT* pctxt, e2ap_E2RemovalFailure_protocolIEs_element* pvalue){
    int stat =0;

    /*decode id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PD_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PD_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");

    {
        OSUINT32 openTypeLen;
        size_t bitStartOffset, bitLength;

        stat = pd_UnconsLength(pctxt, &openTypeLen);
        if(stat<0) return LOG_RTERR(pctxt, stat);
        else if(stat == RT_OK_FRAG){
            rtxErrAddStrParm(pctxt, "open type with fragment length");
            return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
        }
        bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
        bitLength = openTypeLen * 8;

        switch(pvalue->id){//dungnm23 check case lai nhe
        
            case ASN1V_e2ap_id_TransactionID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_E2RemovalFailureIEs_id_TransactionID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-TransactionID");
                pvalue->value.u._e2ap_E2RemovalFailureIEs_id_TransactionID 
                    = rtxMemAllocType(pctxt, e2ap_TransactionID);

                asn1Init_e2ap_TransactionID(pvalue->value.u._e2ap_E2RemovalFailureIEs_id_TransactionID);

                stat = asn1PD_e2ap_TransactionID (pctxt,
                        (e2ap_TransactionID*)pvalue->value.
                        u._e2ap_E2RemovalFailureIEs_id_TransactionID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_Cause:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_E2RemovalFailureIEs_id_Cause;
            RTXCTXTPUSHELEMNAME(pctxt, "id-Cause");
                pvalue->value.u._e2ap_E2RemovalFailureIEs_id_Cause 
                    = rtxMemAllocType(pctxt, e2ap_Cause);

                asn1Init_e2ap_Cause(pvalue->value.u._e2ap_E2RemovalFailureIEs_id_Cause);

                stat = asn1PD_e2ap_Cause (pctxt,
                        (e2ap_Cause*)pvalue->value.
                        u._e2ap_E2RemovalFailureIEs_id_Cause);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_CriticalityDiagnostics:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_E2RemovalFailureIEs_id_CriticalityDiagnostics;
            RTXCTXTPUSHELEMNAME(pctxt, "id-CriticalityDiagnostics");
                pvalue->value.u._e2ap_E2RemovalFailureIEs_id_CriticalityDiagnostics 
                    = rtxMemAllocType(pctxt, e2ap_CriticalityDiagnostics);

                asn1Init_e2ap_CriticalityDiagnostics(pvalue->value.u._e2ap_E2RemovalFailureIEs_id_CriticalityDiagnostics);

                stat = asn1PD_e2ap_CriticalityDiagnostics (pctxt,
                        (e2ap_CriticalityDiagnostics*)pvalue->value.
                        u._e2ap_E2RemovalFailureIEs_id_CriticalityDiagnostics);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_E2RemovalFailureIEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*) rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
    }
    {
    size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
    size_t bitsConsumed = bitEndOffset-bitStartOffset;
    if(bitsConsumed<bitLength){
        stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
    }
    else stat =(bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
    }}
    if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}


int asn1Init_e2ap_E2RemovalFailure_protocolIEs_element(e2ap_E2RemovalFailure_protocolIEs_element* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    OSCRTLMEMSET (&pvalue->value, 0, sizeof(pvalue->value));
    return 0;
}


//-----> chuaw có template rtxFreeASN1OpenType

#if 0
void asn1Free_e2ap_E2RemovalFailure_protocolIEs_element(OSCTXT* pctxt, e2ap_E2RemovalFailure_protocolIEs_element* pvalue)
{
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_E2RemovalFailureIEs_id_id_TransactionID:
            // rtxFreeE2ap_TransactionID(pvalue->value.u._e2ap_E2RemovalFailureIEs_id_id_TransactionID);

            if(pvalue->value.i._e2ap_E2RemovalFailure_id_TransactionID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_TransactionID(pctxt, pvalue->value.u._e2ap_E2RemovalFailureIEs_id_id_TransactionID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2RemovalFailureIEs_id_id_TransactionID);
           // pvalue->value.u._e2ap_E2RemovalFailureIEs_id_id_TransactionID = NULL;
           pvalue->value.u._e2ap_E2RemovalFailureIEs_id_TransactionID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_E2RemovalFailureIEs_id_id_Cause:
            // rtxFreeE2ap_Cause(pvalue->value.u._e2ap_E2RemovalFailureIEs_id_id_Cause);

            if(pvalue->value.i._e2ap_E2RemovalFailure_id_Cause!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_Cause(pctxt, pvalue->value.u._e2ap_E2RemovalFailureIEs_id_id_Cause);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2RemovalFailureIEs_id_id_Cause);
           // pvalue->value.u._e2ap_E2RemovalFailureIEs_id_id_Cause = NULL;
           pvalue->value.u._e2ap_E2RemovalFailureIEs_id_Cause = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_E2RemovalFailureIEs_id_id_CriticalityDiagnostics:
            // rtxFreeE2ap_CriticalityDiagnostics(pvalue->value.u._e2ap_E2RemovalFailureIEs_id_id_CriticalityDiagnostics);

            if(pvalue->value.i._e2ap_E2RemovalFailure_id_CriticalityDiagnostics!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_CriticalityDiagnostics(pctxt, pvalue->value.u._e2ap_E2RemovalFailureIEs_id_id_CriticalityDiagnostics);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2RemovalFailureIEs_id_id_CriticalityDiagnostics);
           // pvalue->value.u._e2ap_E2RemovalFailureIEs_id_id_CriticalityDiagnostics = NULL;
           pvalue->value.u._e2ap_E2RemovalFailureIEs_id_CriticalityDiagnostics = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_E2RemovalFailureIEs_UNDEF_:
            rtxFreeASN1OpenType(pvalue->value.u.extElem1);
            break;
        default:
            break;
    }
}

int asn1PrtToStr_e2ap_E2RemovalFailure_protocolIEs_element(OSCTXT* pctxt, e2ap_E2RemovalFailure_protocolIEs_element* pvalue)
{
    int stat =0;
    RTXCTXTPUSHELEMNAME(pctxt, "e2ap_E2RemovalFailure_protocolIEs_element");

    /*print id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PrtToStr_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PrtToStr_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_E2RemovalFailureIEs_id_id_TransactionID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "TransactionID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_TransactionID (pctxt, pvalue->value.u._e2ap_E2RemovalFailureIEs_id_id_TransactionID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_E2RemovalFailureIEs_id_id_Cause:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "Cause");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_Cause (pctxt, pvalue->value.u._e2ap_E2RemovalFailureIEs_id_id_Cause);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_E2RemovalFailureIEs_id_id_CriticalityDiagnostics:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "CriticalityDiagnostics");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_CriticalityDiagnostics (pctxt, pvalue->value.u._e2ap_E2RemovalFailureIEs_id_id_CriticalityDiagnostics);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_E2RemovalFailureIEs_UNDEF_:
            {
                rtxPLogMsg(pctxt, "Extension element present - raw data not printed.\n");
                break;
            }

            default:
                stat = RTERR_INVOPT;
                return LOG_RTERR(pctxt, stat);
        }
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);
}
#endif


int asn1PrtToStr_e2ap_E2RemovalFailure_protocolIEs_element (const char * name,
 e2ap_E2RemovalFailure_protocolIEs_element* pvalue, 
 char * buffer, OSSIZE bufSize){
    if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
        return -1;
    if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
        return -1;

    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_E2RemovalFailureIEs_id_TransactionID:
            if(asn1PrtToStr_e2ap_TransactionID("TransactionID", 
                    pvalue->value.u._e2ap_E2RemovalFailureIEs_id_TransactionID, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_E2RemovalFailureIEs_id_Cause:
            if(asn1PrtToStr_e2ap_Cause("Cause", 
                    pvalue->value.u._e2ap_E2RemovalFailureIEs_id_Cause, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_E2RemovalFailureIEs_id_CriticalityDiagnostics:
            if(asn1PrtToStr_e2ap_CriticalityDiagnostics("CriticalityDiagnostics", 
                    pvalue->value.u._e2ap_E2RemovalFailureIEs_id_CriticalityDiagnostics, buffer, bufSize)<0)
                return -1;
            break;    
        default:
        if(0!=pvalue -> value.u.extElem1){
            rtPrintToStringIndent(buffer, bufSize);
            rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

        }
        }
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

    return 0;

 }

 void asn1Free_e2ap_E2RemovalFailure_protocolIEs_element(OSCTXT* pctxt, e2ap_E2RemovalFailure_protocolIEs_element* pvalue){
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_E2RemovalFailureIEs_id_TransactionID:
            if(pvalue->value.u._e2ap_E2RemovalFailureIEs_id_TransactionID!=NULL){
            asn1Free_e2ap_TransactionID(pctxt, pvalue->value.u._e2ap_E2RemovalFailureIEs_id_TransactionID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2RemovalFailureIEs_id_TransactionID);
            pvalue->value.u._e2ap_E2RemovalFailureIEs_id_TransactionID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_E2RemovalFailureIEs_id_Cause:
            if(pvalue->value.u._e2ap_E2RemovalFailureIEs_id_Cause!=NULL){
            asn1Free_e2ap_Cause(pctxt, pvalue->value.u._e2ap_E2RemovalFailureIEs_id_Cause);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2RemovalFailureIEs_id_Cause);
            pvalue->value.u._e2ap_E2RemovalFailureIEs_id_Cause = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_E2RemovalFailureIEs_id_CriticalityDiagnostics:
            if(pvalue->value.u._e2ap_E2RemovalFailureIEs_id_CriticalityDiagnostics!=NULL){
            asn1Free_e2ap_CriticalityDiagnostics(pctxt, pvalue->value.u._e2ap_E2RemovalFailureIEs_id_CriticalityDiagnostics);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2RemovalFailureIEs_id_CriticalityDiagnostics);
            pvalue->value.u._e2ap_E2RemovalFailureIEs_id_CriticalityDiagnostics = NULL;
            }
            break;
        default:
            break;


    }
 }

 

/*****************************************/
/*           E2RemovalFailure                */
/*****************************************/
//2_container.c
/* 1. xxx_ProtocolIE -> mẫu cũ ở ie_big_msg */
EXTERN int asn1PE_e2ap_E2RemovalFailure_protocolIEs (OSCTXT* pctxt, e2ap_E2RemovalFailure_protocolIEs* pvalue)
{
    int stat =0;
    OSRTDListNode* pnode;
    OSUINT32 xx1;

    /*encode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pe_Length(pctxt, pvalue->count);
    if(stat<0) return LOG_RTERR(pctxt, stat);

    /*encode each element*/
    xx1 =0;
    for(pnode = pvalue->head; pnode != 0 && xx1<pvalue->count; pnode = pnode->next){
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE", xx1);
        stat = asn1PE_e2ap_E2RemovalFailure_protocolIEs_element (pctxt, ((e2ap_E2RemovalFailure_protocolIEs_element*)pnode->data));
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        xx1++;
        RTXCTXTPOPARRAYELEMNAME(pctxt);
    }

    return (stat);
}

EXTERN int  asn1PD_e2ap_E2RemovalFailure_protocolIEs(OSCTXT* pctxt, e2ap_E2RemovalFailure_protocolIEs* pvalue)
{
     int stat =0;
     OSRTDListNode* pnode;
     OSSIZE count =0;
     OSSIZE xx1=0;


     /*decode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pd_Length64(pctxt, &count); //tai sao lai 64
    if(stat!=0) return LOG_RTERR(pctxt, stat);

    /*decode each element*/
    rtxDListInit(pvalue);

    for(xx1=0; xx1 < count; xx1++){
        e2ap_E2RemovalFailure_protocolIEs_element* pdata;
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE",xx1);

        if(pnode == NULL) return LOG_RTERR(pctxt, RTERR_NOMEM);

        asn1Init_e2ap_E2RemovalFailure_protocolIEs_element(pdata);
        rtxDListAppendNode(pvalue, pnode);
        stat = asn1PD_e2ap_E2RemovalFailure_protocolIEs_element (pctxt, pdata);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        RTXCTXTPOPARRAYELEMNAME(pctxt);

    }
    return (stat);
}


int asn1Init_e2ap_E2RemovalFailure_protocolIEs(e2ap_E2RemovalFailure_protocolIEs* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    rtxDListFastInit (pvalue);
    return 0;
}
#if 1 //ao that day
void asn1Free_e2ap_E2RemovalFailure_protocolIEs(OSCTXT* pctxt, e2ap_E2RemovalFailure_protocolIEs* pvalue)
{
    if(0==pvalue) return;   
    e2ap_E2RemovalFailure_protocolIEs_element* pdata;
    OSRTDListNode* pnode=pvalue->head;
    while(0!=pnode){
        pdata = (e2ap_E2RemovalFailure_protocolIEs_element*)pnode->data;
       // asn1Free_e2ap_E2RemovalFailure_protocolIEs_element(pctxt, pdata);
        pnode = pnode->next;
    }
    rtxDListFreeAll(pctxt, pvalue);
}
#endif


EXTERN int asn1PrtToStr_e2ap_E2RemovalFailure_protocolIEs(const char* name, e2ap_E2RemovalFailure_protocolIEs* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_E2RemovalFailure_protocolIEs_element* pdata0;
    OSRTDListNode* pnode0;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode0 = pvalue->head;  xx1 < pvalue->count && pnode0 != 0; pnode0 = pnode0->next, xx1++){
        pdata0 = (e2ap_E2RemovalFailure_protocolIEs_element*)pnode0->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 0
        if(asn1PrtToStr_e2ap_E2RemovalFailure_protocolIEs_element(nameBuf, pdata0, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}


/*2 . E2RemovalFailure -> mẫu cũ ở seq_normal*/

int asn1PE_e2ap_E2RemovalFailure (OSCTXT* pctxt, e2ap_E2RemovalFailure* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "E2RemovalFailure");
   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field protocolIEs - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
   stat = asn1PE_e2ap_E2RemovalFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
   if(stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_E2RemovalFailure (OSCTXT* pctxt, e2ap_E2RemovalFailure* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME(pctxt, "E2RemovalFailure");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field protocolIEs */
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
      stat = asn1PD_e2ap_E2RemovalFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_E2RemovalFailure (e2ap_E2RemovalFailure* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_E2RemovalFailure_protocolIEs(&pvalue->protocolIEs);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_E2RemovalFailure (OSCTXT* pctxt, e2ap_E2RemovalFailure* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_E2RemovalFailure_protocolIEs(pctxt, &pvalue->protocolIEs);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_E2RemovalFailure (const char* name, e2ap_E2RemovalFailure* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }

   if(asn1PrtToStr_e2ap_E2RemovalFailure_protocolIEs("protocolIEs", &pvalue->protocolIEs, buffer, bufSize) <0){
      return -1;
   }

   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           E2setupFailureIEs                */
/*****************************************/
/* ie.c.j2 */
 /* d là con của msg */
EXTERN int asn1PE_e2ap_E2setupFailure_protocolIEs_element (OSCTXT* pctxt, e2ap_E2setupFailure_protocolIEs_element* pvalue)
{
    int stat =0;

    /*encode id*/

    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PE_e2ap_ProtocolIE_ID(pctxt, pvalue->id);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PE_e2ap_Criticality(pctxt, pvalue->criticality);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
    {
        OSCTXT lctxt;
        OSOCTET *pDynamicEncodeBuffer;
        ASN1OpenType openType;
        OSBOOL encoded = TRUE;

        openType.numocts = 0;
        openType.data =0;

        rtxCopyContext(&lctxt, pctxt);
        pctxt->pStream =0;

        stat = rtxInitContextBuffer(pctxt, 0, 0);
        if(stat!=0) return LOG_RTERR(pctxt, stat);

        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_E2setupFailureIEs_id_TransactionID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-TransactionID");
                    stat = asn1PE_e2ap_TransactionID (pctxt, pvalue->value.u._e2ap_E2setupFailureIEs_id_TransactionID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_E2setupFailureIEs_id_Cause:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-Cause");
                    stat = asn1PE_e2ap_Cause (pctxt, pvalue->value.u._e2ap_E2setupFailureIEs_id_Cause);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_E2setupFailureIEs_id_TimeToWait:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-TimeToWait");
                    stat = asn1PE_e2ap_TimeToWait (pctxt, pvalue->value.u._e2ap_E2setupFailureIEs_id_TimeToWait);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_E2setupFailureIEs_id_CriticalityDiagnostics:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-CriticalityDiagnostics");
                    stat = asn1PE_e2ap_CriticalityDiagnostics (pctxt, pvalue->value.u._e2ap_E2setupFailureIEs_id_CriticalityDiagnostics);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_E2setupFailureIEs_id_TNLinformation:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-TNLinformation");
                    stat = asn1PE_e2ap_TNLinformation (pctxt, pvalue->value.u._e2ap_E2setupFailureIEs_id_TNLinformation);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_E2setupFailureIEs_UNDEF_:
            {
                if(0!=pvalue->value.u.extElem1){
                    openType.numocts = pvalue->value.u.extElem1->numocts;
                    openType.data = pvalue->value.u.extElem1->data;
                } else {
                    /* No extension element to encode */
                }
                encoded = FALSE;
                break;
            }

            default:
                encoded = FALSE;
                stat = RTERR_INVOPT;
                break;
        } 

        if(encoded){
            openType.numocts = (OSUINT32)pe_GetMsgLen(pctxt);
            openType.data = pDynamicEncodeBuffer = pctxt -> buffer.data;
        }
        rtxCopyContext(pctxt, &lctxt);

        if(stat == 0) {
            stat = pe_OpenType (pctxt, openType.numocts, openType.data);
        }
    #if 1
        if(encoded){//dungnm23 check lai nhe
            rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
        }
    #endif

    }

    if(stat!=0) return LOG_RTERR(pctxt, stat);  
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}

EXTERN int  asn1PD_e2ap_E2setupFailure_protocolIEs_element (OSCTXT* pctxt, e2ap_E2setupFailure_protocolIEs_element* pvalue){
    int stat =0;

    /*decode id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PD_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PD_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");

    {
        OSUINT32 openTypeLen;
        size_t bitStartOffset, bitLength;

        stat = pd_UnconsLength(pctxt, &openTypeLen);
        if(stat<0) return LOG_RTERR(pctxt, stat);
        else if(stat == RT_OK_FRAG){
            rtxErrAddStrParm(pctxt, "open type with fragment length");
            return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
        }
        bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
        bitLength = openTypeLen * 8;

        switch(pvalue->id){//dungnm23 check case lai nhe
        
            case ASN1V_e2ap_id_TransactionID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_E2setupFailureIEs_id_TransactionID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-TransactionID");
                pvalue->value.u._e2ap_E2setupFailureIEs_id_TransactionID 
                    = rtxMemAllocType(pctxt, e2ap_TransactionID);

                asn1Init_e2ap_TransactionID(pvalue->value.u._e2ap_E2setupFailureIEs_id_TransactionID);

                stat = asn1PD_e2ap_TransactionID (pctxt,
                        (e2ap_TransactionID*)pvalue->value.
                        u._e2ap_E2setupFailureIEs_id_TransactionID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_Cause:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_E2setupFailureIEs_id_Cause;
            RTXCTXTPUSHELEMNAME(pctxt, "id-Cause");
                pvalue->value.u._e2ap_E2setupFailureIEs_id_Cause 
                    = rtxMemAllocType(pctxt, e2ap_Cause);

                asn1Init_e2ap_Cause(pvalue->value.u._e2ap_E2setupFailureIEs_id_Cause);

                stat = asn1PD_e2ap_Cause (pctxt,
                        (e2ap_Cause*)pvalue->value.
                        u._e2ap_E2setupFailureIEs_id_Cause);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_TimeToWait:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_E2setupFailureIEs_id_TimeToWait;
            RTXCTXTPUSHELEMNAME(pctxt, "id-TimeToWait");
                pvalue->value.u._e2ap_E2setupFailureIEs_id_TimeToWait 
                    = rtxMemAllocType(pctxt, e2ap_TimeToWait);

                asn1Init_e2ap_TimeToWait(pvalue->value.u._e2ap_E2setupFailureIEs_id_TimeToWait);

                stat = asn1PD_e2ap_TimeToWait (pctxt,
                        (e2ap_TimeToWait*)pvalue->value.
                        u._e2ap_E2setupFailureIEs_id_TimeToWait);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_CriticalityDiagnostics:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_E2setupFailureIEs_id_CriticalityDiagnostics;
            RTXCTXTPUSHELEMNAME(pctxt, "id-CriticalityDiagnostics");
                pvalue->value.u._e2ap_E2setupFailureIEs_id_CriticalityDiagnostics 
                    = rtxMemAllocType(pctxt, e2ap_CriticalityDiagnostics);

                asn1Init_e2ap_CriticalityDiagnostics(pvalue->value.u._e2ap_E2setupFailureIEs_id_CriticalityDiagnostics);

                stat = asn1PD_e2ap_CriticalityDiagnostics (pctxt,
                        (e2ap_CriticalityDiagnostics*)pvalue->value.
                        u._e2ap_E2setupFailureIEs_id_CriticalityDiagnostics);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_TNLinformation:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_E2setupFailureIEs_id_TNLinformation;
            RTXCTXTPUSHELEMNAME(pctxt, "id-TNLinformation");
                pvalue->value.u._e2ap_E2setupFailureIEs_id_TNLinformation 
                    = rtxMemAllocType(pctxt, e2ap_TNLinformation);

                asn1Init_e2ap_TNLinformation(pvalue->value.u._e2ap_E2setupFailureIEs_id_TNLinformation);

                stat = asn1PD_e2ap_TNLinformation (pctxt,
                        (e2ap_TNLinformation*)pvalue->value.
                        u._e2ap_E2setupFailureIEs_id_TNLinformation);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_E2setupFailureIEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*) rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
    }
    {
    size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
    size_t bitsConsumed = bitEndOffset-bitStartOffset;
    if(bitsConsumed<bitLength){
        stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
    }
    else stat =(bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
    }}
    if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}


int asn1Init_e2ap_E2setupFailure_protocolIEs_element(e2ap_E2setupFailure_protocolIEs_element* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    OSCRTLMEMSET (&pvalue->value, 0, sizeof(pvalue->value));
    return 0;
}


//-----> chuaw có template rtxFreeASN1OpenType

#if 0
void asn1Free_e2ap_E2setupFailure_protocolIEs_element(OSCTXT* pctxt, e2ap_E2setupFailure_protocolIEs_element* pvalue)
{
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_E2setupFailureIEs_id_id_TransactionID:
            // rtxFreeE2ap_TransactionID(pvalue->value.u._e2ap_E2setupFailureIEs_id_id_TransactionID);

            if(pvalue->value.i._e2ap_E2setupFailure_id_TransactionID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_TransactionID(pctxt, pvalue->value.u._e2ap_E2setupFailureIEs_id_id_TransactionID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2setupFailureIEs_id_id_TransactionID);
           // pvalue->value.u._e2ap_E2setupFailureIEs_id_id_TransactionID = NULL;
           pvalue->value.u._e2ap_E2setupFailureIEs_id_TransactionID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_E2setupFailureIEs_id_id_Cause:
            // rtxFreeE2ap_Cause(pvalue->value.u._e2ap_E2setupFailureIEs_id_id_Cause);

            if(pvalue->value.i._e2ap_E2setupFailure_id_Cause!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_Cause(pctxt, pvalue->value.u._e2ap_E2setupFailureIEs_id_id_Cause);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2setupFailureIEs_id_id_Cause);
           // pvalue->value.u._e2ap_E2setupFailureIEs_id_id_Cause = NULL;
           pvalue->value.u._e2ap_E2setupFailureIEs_id_Cause = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_E2setupFailureIEs_id_id_TimeToWait:
            // rtxFreeE2ap_TimeToWait(pvalue->value.u._e2ap_E2setupFailureIEs_id_id_TimeToWait);

            if(pvalue->value.i._e2ap_E2setupFailure_id_TimeToWait!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_TimeToWait(pctxt, pvalue->value.u._e2ap_E2setupFailureIEs_id_id_TimeToWait);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2setupFailureIEs_id_id_TimeToWait);
           // pvalue->value.u._e2ap_E2setupFailureIEs_id_id_TimeToWait = NULL;
           pvalue->value.u._e2ap_E2setupFailureIEs_id_TimeToWait = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_E2setupFailureIEs_id_id_CriticalityDiagnostics:
            // rtxFreeE2ap_CriticalityDiagnostics(pvalue->value.u._e2ap_E2setupFailureIEs_id_id_CriticalityDiagnostics);

            if(pvalue->value.i._e2ap_E2setupFailure_id_CriticalityDiagnostics!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_CriticalityDiagnostics(pctxt, pvalue->value.u._e2ap_E2setupFailureIEs_id_id_CriticalityDiagnostics);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2setupFailureIEs_id_id_CriticalityDiagnostics);
           // pvalue->value.u._e2ap_E2setupFailureIEs_id_id_CriticalityDiagnostics = NULL;
           pvalue->value.u._e2ap_E2setupFailureIEs_id_CriticalityDiagnostics = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_E2setupFailureIEs_id_id_TNLinformation:
            // rtxFreeE2ap_TNLinformation(pvalue->value.u._e2ap_E2setupFailureIEs_id_id_TNLinformation);

            if(pvalue->value.i._e2ap_E2setupFailure_id_TNLinformation!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_TNLinformation(pctxt, pvalue->value.u._e2ap_E2setupFailureIEs_id_id_TNLinformation);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2setupFailureIEs_id_id_TNLinformation);
           // pvalue->value.u._e2ap_E2setupFailureIEs_id_id_TNLinformation = NULL;
           pvalue->value.u._e2ap_E2setupFailureIEs_id_TNLinformation = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_E2setupFailureIEs_UNDEF_:
            rtxFreeASN1OpenType(pvalue->value.u.extElem1);
            break;
        default:
            break;
    }
}

int asn1PrtToStr_e2ap_E2setupFailure_protocolIEs_element(OSCTXT* pctxt, e2ap_E2setupFailure_protocolIEs_element* pvalue)
{
    int stat =0;
    RTXCTXTPUSHELEMNAME(pctxt, "e2ap_E2setupFailure_protocolIEs_element");

    /*print id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PrtToStr_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PrtToStr_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_E2setupFailureIEs_id_id_TransactionID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "TransactionID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_TransactionID (pctxt, pvalue->value.u._e2ap_E2setupFailureIEs_id_id_TransactionID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_E2setupFailureIEs_id_id_Cause:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "Cause");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_Cause (pctxt, pvalue->value.u._e2ap_E2setupFailureIEs_id_id_Cause);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_E2setupFailureIEs_id_id_TimeToWait:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "TimeToWait");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_TimeToWait (pctxt, pvalue->value.u._e2ap_E2setupFailureIEs_id_id_TimeToWait);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_E2setupFailureIEs_id_id_CriticalityDiagnostics:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "CriticalityDiagnostics");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_CriticalityDiagnostics (pctxt, pvalue->value.u._e2ap_E2setupFailureIEs_id_id_CriticalityDiagnostics);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_E2setupFailureIEs_id_id_TNLinformation:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "TNLinformation");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_TNLinformation (pctxt, pvalue->value.u._e2ap_E2setupFailureIEs_id_id_TNLinformation);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_E2setupFailureIEs_UNDEF_:
            {
                rtxPLogMsg(pctxt, "Extension element present - raw data not printed.\n");
                break;
            }

            default:
                stat = RTERR_INVOPT;
                return LOG_RTERR(pctxt, stat);
        }
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);
}
#endif


int asn1PrtToStr_e2ap_E2setupFailure_protocolIEs_element (const char * name,
 e2ap_E2setupFailure_protocolIEs_element* pvalue, 
 char * buffer, OSSIZE bufSize){
    if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
        return -1;
    if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
        return -1;

    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_E2setupFailureIEs_id_TransactionID:
            if(asn1PrtToStr_e2ap_TransactionID("TransactionID", 
                    pvalue->value.u._e2ap_E2setupFailureIEs_id_TransactionID, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_E2setupFailureIEs_id_Cause:
            if(asn1PrtToStr_e2ap_Cause("Cause", 
                    pvalue->value.u._e2ap_E2setupFailureIEs_id_Cause, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_E2setupFailureIEs_id_TimeToWait:
            if(asn1PrtToStr_e2ap_TimeToWait("TimeToWait", 
                    pvalue->value.u._e2ap_E2setupFailureIEs_id_TimeToWait, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_E2setupFailureIEs_id_CriticalityDiagnostics:
            if(asn1PrtToStr_e2ap_CriticalityDiagnostics("CriticalityDiagnostics", 
                    pvalue->value.u._e2ap_E2setupFailureIEs_id_CriticalityDiagnostics, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_E2setupFailureIEs_id_TNLinformation:
            if(asn1PrtToStr_e2ap_TNLinformation("TNLinformation", 
                    pvalue->value.u._e2ap_E2setupFailureIEs_id_TNLinformation, buffer, bufSize)<0)
                return -1;
            break;    
        default:
        if(0!=pvalue -> value.u.extElem1){
            rtPrintToStringIndent(buffer, bufSize);
            rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

        }
        }
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

    return 0;

 }

 void asn1Free_e2ap_E2setupFailure_protocolIEs_element(OSCTXT* pctxt, e2ap_E2setupFailure_protocolIEs_element* pvalue){
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_E2setupFailureIEs_id_TransactionID:
            if(pvalue->value.u._e2ap_E2setupFailureIEs_id_TransactionID!=NULL){
            asn1Free_e2ap_TransactionID(pctxt, pvalue->value.u._e2ap_E2setupFailureIEs_id_TransactionID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2setupFailureIEs_id_TransactionID);
            pvalue->value.u._e2ap_E2setupFailureIEs_id_TransactionID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_E2setupFailureIEs_id_Cause:
            if(pvalue->value.u._e2ap_E2setupFailureIEs_id_Cause!=NULL){
            asn1Free_e2ap_Cause(pctxt, pvalue->value.u._e2ap_E2setupFailureIEs_id_Cause);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2setupFailureIEs_id_Cause);
            pvalue->value.u._e2ap_E2setupFailureIEs_id_Cause = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_E2setupFailureIEs_id_TimeToWait:
            if(pvalue->value.u._e2ap_E2setupFailureIEs_id_TimeToWait!=NULL){
            asn1Free_e2ap_TimeToWait(pctxt, pvalue->value.u._e2ap_E2setupFailureIEs_id_TimeToWait);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2setupFailureIEs_id_TimeToWait);
            pvalue->value.u._e2ap_E2setupFailureIEs_id_TimeToWait = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_E2setupFailureIEs_id_CriticalityDiagnostics:
            if(pvalue->value.u._e2ap_E2setupFailureIEs_id_CriticalityDiagnostics!=NULL){
            asn1Free_e2ap_CriticalityDiagnostics(pctxt, pvalue->value.u._e2ap_E2setupFailureIEs_id_CriticalityDiagnostics);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2setupFailureIEs_id_CriticalityDiagnostics);
            pvalue->value.u._e2ap_E2setupFailureIEs_id_CriticalityDiagnostics = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_E2setupFailureIEs_id_TNLinformation:
            if(pvalue->value.u._e2ap_E2setupFailureIEs_id_TNLinformation!=NULL){
            asn1Free_e2ap_TNLinformation(pctxt, pvalue->value.u._e2ap_E2setupFailureIEs_id_TNLinformation);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2setupFailureIEs_id_TNLinformation);
            pvalue->value.u._e2ap_E2setupFailureIEs_id_TNLinformation = NULL;
            }
            break;
        default:
            break;


    }
 }

 

/*****************************************/
/*           E2setupFailure                */
/*****************************************/
//2_container.c
/* 1. xxx_ProtocolIE -> mẫu cũ ở ie_big_msg */
EXTERN int asn1PE_e2ap_E2setupFailure_protocolIEs (OSCTXT* pctxt, e2ap_E2setupFailure_protocolIEs* pvalue)
{
    int stat =0;
    OSRTDListNode* pnode;
    OSUINT32 xx1;

    /*encode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pe_Length(pctxt, pvalue->count);
    if(stat<0) return LOG_RTERR(pctxt, stat);

    /*encode each element*/
    xx1 =0;
    for(pnode = pvalue->head; pnode != 0 && xx1<pvalue->count; pnode = pnode->next){
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE", xx1);
        stat = asn1PE_e2ap_E2setupFailure_protocolIEs_element (pctxt, ((e2ap_E2setupFailure_protocolIEs_element*)pnode->data));
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        xx1++;
        RTXCTXTPOPARRAYELEMNAME(pctxt);
    }

    return (stat);
}

EXTERN int  asn1PD_e2ap_E2setupFailure_protocolIEs(OSCTXT* pctxt, e2ap_E2setupFailure_protocolIEs* pvalue)
{
     int stat =0;
     OSRTDListNode* pnode;
     OSSIZE count =0;
     OSSIZE xx1=0;


     /*decode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pd_Length64(pctxt, &count); //tai sao lai 64
    if(stat!=0) return LOG_RTERR(pctxt, stat);

    /*decode each element*/
    rtxDListInit(pvalue);

    for(xx1=0; xx1 < count; xx1++){
        e2ap_E2setupFailure_protocolIEs_element* pdata;
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE",xx1);

        if(pnode == NULL) return LOG_RTERR(pctxt, RTERR_NOMEM);

        asn1Init_e2ap_E2setupFailure_protocolIEs_element(pdata);
        rtxDListAppendNode(pvalue, pnode);
        stat = asn1PD_e2ap_E2setupFailure_protocolIEs_element (pctxt, pdata);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        RTXCTXTPOPARRAYELEMNAME(pctxt);

    }
    return (stat);
}


int asn1Init_e2ap_E2setupFailure_protocolIEs(e2ap_E2setupFailure_protocolIEs* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    rtxDListFastInit (pvalue);
    return 0;
}
#if 1 //ao that day
void asn1Free_e2ap_E2setupFailure_protocolIEs(OSCTXT* pctxt, e2ap_E2setupFailure_protocolIEs* pvalue)
{
    if(0==pvalue) return;   
    e2ap_E2setupFailure_protocolIEs_element* pdata;
    OSRTDListNode* pnode=pvalue->head;
    while(0!=pnode){
        pdata = (e2ap_E2setupFailure_protocolIEs_element*)pnode->data;
       // asn1Free_e2ap_E2setupFailure_protocolIEs_element(pctxt, pdata);
        pnode = pnode->next;
    }
    rtxDListFreeAll(pctxt, pvalue);
}
#endif


EXTERN int asn1PrtToStr_e2ap_E2setupFailure_protocolIEs(const char* name, e2ap_E2setupFailure_protocolIEs* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_E2setupFailure_protocolIEs_element* pdata0;
    OSRTDListNode* pnode0;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode0 = pvalue->head;  xx1 < pvalue->count && pnode0 != 0; pnode0 = pnode0->next, xx1++){
        pdata0 = (e2ap_E2setupFailure_protocolIEs_element*)pnode0->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 0
        if(asn1PrtToStr_e2ap_E2setupFailure_protocolIEs_element(nameBuf, pdata0, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}


/*2 . E2setupFailure -> mẫu cũ ở seq_normal*/

int asn1PE_e2ap_E2setupFailure (OSCTXT* pctxt, e2ap_E2setupFailure* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "E2setupFailure");
   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field protocolIEs - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
   stat = asn1PE_e2ap_E2setupFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
   if(stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_E2setupFailure (OSCTXT* pctxt, e2ap_E2setupFailure* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME(pctxt, "E2setupFailure");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field protocolIEs */
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
      stat = asn1PD_e2ap_E2setupFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_E2setupFailure (e2ap_E2setupFailure* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_E2setupFailure_protocolIEs(&pvalue->protocolIEs);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_E2setupFailure (OSCTXT* pctxt, e2ap_E2setupFailure* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_E2setupFailure_protocolIEs(pctxt, &pvalue->protocolIEs);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_E2setupFailure (const char* name, e2ap_E2setupFailure* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }

   if(asn1PrtToStr_e2ap_E2setupFailure_protocolIEs("protocolIEs", &pvalue->protocolIEs, buffer, bufSize) <0){
      return -1;
   }

   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           RANfunctionID                */
/*****************************************/
//6 mau integer
// mau integer size(a...b) mau la procedurecode
EXTERN int asn1PE_e2ap_RANfunctionID (OSCTXT* pctxt, e2ap_RANfunctionID value){
    int stat = 0;
    RTXCTCXTPUSHTYPENAME (pctxt, "RANfunctionID");
    stat = pe_ConsUnsigned (pctxt, value, 0, 4095);
    if (stat != 0) return LOG_RTERR (pctxt, stat);
    RTXCTXTPOPTYPENAME (pctxt);
    return stat;
}
EXTERN int asn1PD_e2ap_RANfunctionID (OSCTXT* pctxt, e2ap_RANfunctionID* pvalue){
    int stat = 0;
    RTXCTCXTPUSHTYPENAME (pctxt, "RANfunctionID");
    if(pctxt->buffer.aligned){
        int stat2 = PD_BYTE_ALIGN(pctxt);
        if(stat2 != 0) return LOG_RTERR (pctxt, stat2);
    }
    stat = rtxDecBitsToByte(pctxt, pvalue, 0);
    if (stat != 0) return LOG_RTERR (pctxt, stat);
    RTXCTXTPOPTYPENAME (pctxt);
    return stat;
}
//EXTERN int asn1Print_e2ap_RANfunctionID (const char* name, const e2ap_RANfunctionID* pvalue);
//EXTERN int asn1PrtToStr_e2ap_RANfunctionID (const char* name, e2ap_RANfunctionID* pvalue, char* buffer, OSSIZE bufSize);
//EXTERN int asn1PrtToStrm_e2ap_RANfunctionID (OSCTXT* pctxt, const char* name, const e2ap_RANfunctionID* pvalue);
EXTERN int asn1Init_e2ap_RANfunctionID (e2ap_RANfunctionID* pvalue){
    //if (pvalue == 0) return RTERR_NULLPTR;
    //*pvalue = 0;
    return 0;
}
EXTERN int asn1Free_e2ap_RANfunctionID (OSCTXT* pctxt, e2ap_RANfunctionID* pvalue){
    // No dynamic memory to free for integer
    return 0;
}
/*****************************************/
/*           RANfunctionDefinition                */
/*****************************************/
//9 mau octet string
//type 9  mau la octet string no size mau la pdusessioncommonnetworkinstance

EXTERN int asn1PE_e2ap_RANfunctionDefinition (OSCTXT* pctxt, e2ap_RANfunctionDefinition value){
   int stat = 0
   RTXCTCXTPUSHTYPENAME (pctxt, "RANfunctionDefinition");
   stat = pe_OctetString(pctxt, value.numocts, value.data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPTYPENAME (pctxt);

}
EXTERN int asn1PD_e2ap_RANfunctionDefinition (OSCTXT* pctxt, e2ap_RANfunctionDefinition* pvalue){
   int stat = 0;
   RTXCTCXTPUSHTYPENAME (pctxt, "RANfunctionDefinition");
   stat = pd_DynOctetString(pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}
EXTERN int asn1PrtToStr_e2ap_RANfunctionDefinition (const char* name, e2ap_RANfunctionDefinition *pvalue, char* buffer, OSSIZE bufSize){
   if(rtPrintToStringIndent(buffer, bufSize) < 0) return -1;
   if(rtPrintToStringHexStr(name, pvalue->numocts, pvalue->data, buffer, bufSize) < 0) return -1;
   return 0;
}
EXTERN int asn1PrtToStrm_e2ap_RANfunctionDefinition (OSCTXT* pctxt, const char* name, const e2ap_RANfunctionDefinition* pvalue){
   int stat =0;
   stat = rtPrintToStreamIndent(pctxt);
   if(stat !=0) return LOG_RTERR(pctxt, stat);
   stat = rtPrintToStreamHexStr(pctxt, name, pvalue->numocts, pvalue->data);
   if(stat !=0) return LOG_RTERR(pctxt, stat);
   return stat;
}
//EXTERN int asn1Copy_e2ap_RANfunctionDefinition (OSCTXT* pctxt, const e2ap_RANfunctionDefinition* pSrcValue, e2ap_RANfunctionDefinition* pDstValue);
 int asn1Init_e2ap_RANfunctionDefinition (e2ap_RANfunctionDefinition* pvalue){
   if (pvalue == 0) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   pvalue->data = 0;
   return 0;
}
 void asn1Free_e2ap_RANfunctionDefinition (OSCTXT* pctxt, e2ap_RANfunctionDefinition* pvalue){
   if (pvalue == 0) return;
   if(pvalue->numocts>0){
       rtxMemFreePtr(pctxt, (void*)pvalue->data);
       pvalue->data = 0;
       pvalue->numocts = 0;
   }
}
int asn1Init_e2ap_RANfunctionDefinition (e2ap_RANfunctionDefinition* pvalue){
   if (pvalue == 0) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   pvalue->data = 0;
   return 0;
}
/*****************************************/
/*           RANfunctionRevision                */
/*****************************************/
//6 mau integer
// mau integer size(a...b) mau la procedurecode
EXTERN int asn1PE_e2ap_RANfunctionRevision (OSCTXT* pctxt, e2ap_RANfunctionRevision value){
    int stat = 0;
    RTXCTCXTPUSHTYPENAME (pctxt, "RANfunctionRevision");
    stat = pe_ConsUnsigned (pctxt, value, 0, 4095);
    if (stat != 0) return LOG_RTERR (pctxt, stat);
    RTXCTXTPOPTYPENAME (pctxt);
    return stat;
}
EXTERN int asn1PD_e2ap_RANfunctionRevision (OSCTXT* pctxt, e2ap_RANfunctionRevision* pvalue){
    int stat = 0;
    RTXCTCXTPUSHTYPENAME (pctxt, "RANfunctionRevision");
    if(pctxt->buffer.aligned){
        int stat2 = PD_BYTE_ALIGN(pctxt);
        if(stat2 != 0) return LOG_RTERR (pctxt, stat2);
    }
    stat = rtxDecBitsToByte(pctxt, pvalue, 0);
    if (stat != 0) return LOG_RTERR (pctxt, stat);
    RTXCTXTPOPTYPENAME (pctxt);
    return stat;
}
//EXTERN int asn1Print_e2ap_RANfunctionRevision (const char* name, const e2ap_RANfunctionRevision* pvalue);
//EXTERN int asn1PrtToStr_e2ap_RANfunctionRevision (const char* name, e2ap_RANfunctionRevision* pvalue, char* buffer, OSSIZE bufSize);
//EXTERN int asn1PrtToStrm_e2ap_RANfunctionRevision (OSCTXT* pctxt, const char* name, const e2ap_RANfunctionRevision* pvalue);
EXTERN int asn1Init_e2ap_RANfunctionRevision (e2ap_RANfunctionRevision* pvalue){
    //if (pvalue == 0) return RTERR_NULLPTR;
    //*pvalue = 0;
    return 0;
}
EXTERN int asn1Free_e2ap_RANfunctionRevision (OSCTXT* pctxt, e2ap_RANfunctionRevision* pvalue){
    // No dynamic memory to free for integer
    return 0;
}
/* e2ap_RANfunctionOID.c */

//printable string
/*****************************************/
/*           RANfunctionOID                */
/*****************************************/

/* Constrained PrintableString */
EXTERN int asn1PE_e2ap_RANfunctionOID (OSCTXT* pctxt, e2ap_RANfunctionOID value)
{
   int stat = 0;
   RTXCTXTPUSHTYPENAME (pctxt, "RANfunctionOID");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1000), OSUINTCONST(0), OSUINT32_MAX);

   char c = (char) rtValidateStr (19, value);  /* 19 = PrintableString */
   if (c != 0) {
      char lbuf[2];
      lbuf[0] = c;
      lbuf[1] = 0;

      rtxErrAddEleNameParm(pctxt);
      rtxErrAddStrParm (pctxt, lbuf);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   stat = pe_ConstrainedStringEx (pctxt, value, 0, 8, 7, 7);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}

EXTERN int asn1PD_e2ap_RANfunctionOID (OSCTXT* pctxt, e2ap_RANfunctionOID* ppvalue)
{
   int stat = 0;
   RTXCTXTPUSHTYPENAME (pctxt, "RANfunctionOID");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1000), OSUINTCONST(0), OSUINT32_MAX);

   stat = pd_ConstrainedStringEx (pctxt, ppvalue, 0, 8, 7, 7);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}


void asn1Free_e2ap_RANfunctionOID (OSCTXT* pctxt, e2ap_RANfunctionOID pvalue)
{
   if(0==pvalue) return;
   rtxMemFreePtr (pctxt, (void*)pvalue);
   pvalue = 0;
}

/* Print to string */
int asn1PrtToStr_e2ap_RANfunctionOID (const char* name, e2ap_RANfunctionOID pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringIndent (buffer, bufSize) < 0) return -1;
   if (rtPrintToStringCharStr (name, pvalue, buffer, bufSize) < 0) return -1;
   return 0;
}

EXTERN int asn1Init_e2ap_RANfunctionOID (e2ap_RANfunctionOID* pvalue){
   //if(0==pvalue) return RTERR_NULLPTR;
   //pvalue = 0;
   return 0;
}
/*****************************************/
/*           RANfunction-Item                */
/*****************************************/
//sequence normal
// Các nội dung cần thiết cho template seq_normal.c.j2

// Các phần còn lại của template seq_normal.c.j2
//contain extensition bit -> theo mau cua GlobalgNB-ID
int asn1PE_e2ap_RANfunction_Item (OSCTXT* pctxt, e2ap_RANfunction_Item* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RANfunction-Item");

   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field ranFunctionID - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "ranFunctionID");
   stat = asn1PE_e2ap_RANfunctionID (pctxt, pvalue->ranFunctionID);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /* encode field ranFunctionDefinition - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "ranFunctionDefinition");
   stat = asn1PE_e2ap_RANfunctionDefinition (pctxt, pvalue->ranFunctionDefinition);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /* encode field ranFunctionRevision - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "ranFunctionRevision");
   stat = asn1PE_e2ap_RANfunctionRevision (pctxt, pvalue->ranFunctionRevision);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /* encode field ranFunctionOID - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "ranFunctionOID");
   stat = asn1PE_e2ap_RANfunctionOID (pctxt, pvalue->ranFunctionOID);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);



   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RANfunction_Item (OSCTXT* pctxt, e2ap_RANfunction_Item* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[4];

   RTXCTXTPUSHTYPENAME(pctxt, "RANfunction-Item");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 4; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field ranFunctionID */
   RTXCTXTPUSHELEMNAME(pctxt, "ranFunctionID");
      stat = asn1PD_e2ap_RANfunctionID (pctxt, &pvalue->ranFunctionID);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field ranFunctionDefinition */
   RTXCTXTPUSHELEMNAME(pctxt, "ranFunctionDefinition");
      stat = asn1PD_e2ap_RANfunctionDefinition (pctxt, &pvalue->ranFunctionDefinition);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field ranFunctionRevision */
   RTXCTXTPUSHELEMNAME(pctxt, "ranFunctionRevision");
      stat = asn1PD_e2ap_RANfunctionRevision (pctxt, &pvalue->ranFunctionRevision);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field ranFunctionOID */
   RTXCTXTPUSHELEMNAME(pctxt, "ranFunctionOID");
      stat = asn1PD_e2ap_RANfunctionOID (pctxt, &pvalue->ranFunctionOID);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RANfunction_Item (e2ap_RANfunction_Item* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RANfunctionID (&pvalue->ranFunctionID);
   asn1Init_e2ap_RANfunctionDefinition (&pvalue->ranFunctionDefinition);
   asn1Init_e2ap_RANfunctionRevision (&pvalue->ranFunctionRevision);
   asn1Init_e2ap_RANfunctionOID (&pvalue->ranFunctionOID);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RANfunction_Item (OSCTXT* pctxt, e2ap_RANfunction_Item* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_RANfunctionID (pctxt, &pvalue->ranFunctionID);
   asn1Free_e2ap_RANfunctionDefinition (pctxt, &pvalue->ranFunctionDefinition);
   asn1Free_e2ap_RANfunctionRevision (pctxt, &pvalue->ranFunctionRevision);
   asn1Free_e2ap_RANfunctionOID (pctxt, &pvalue->ranFunctionOID);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RANfunction_Item (const char* name, e2ap_RANfunction_Item* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }
   if(asn1PrtToStr_e2ap_RANfunctionID ("ranFunctionID", &pvalue->ranFunctionID, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_RANfunctionDefinition ("ranFunctionDefinition", &pvalue->ranFunctionDefinition, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_RANfunctionRevision ("ranFunctionRevision", &pvalue->ranFunctionRevision, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_RANfunctionOID ("ranFunctionOID", &pvalue->ranFunctionOID, buffer, bufSize) < 0)
   {
      return -1;
   }



   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           RANfunction_ItemIEs                */
/*****************************************/
/* ie.c.j2 */
/*ie thường*/
int asn1PE_e2ap_RANfunction_ItemIEs (OSCTXT* pctxt, e2ap_RANfunction_ItemIEs* pvalue)
{
   int stat = 0;
   //RTXCTXTPUSHTYPENAME (pctxt, "RANfunction-ItemIEs");

   /* encode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");
   stat = asn1PE_e2ap_ProtocolIE_ID (pctxt, pvalue->id);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");
   stat = asn1PE_e2ap_Criticality (pctxt, pvalue->criticality);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   {
      OSCTXT ictxt;
      OSOCTET* pDynamicEncodeBuffer;
      ASN1OpenType openType;
      OSBOOL  encoded = TRUE;

      openType.numocts = 0;
      openType.data = 0;

      rtxCopyContext (&ictxt, pctxt);
      pctxt->pStream = 0;

      stat = rtxInitContextBuffer (pctxt, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_RANfunction_ItemIEs_id_RANfunction_Item:
         
        // RTXCTXTPUSHELEMNAME (pctxt, "RANfunction_ItemIEs_id_RANfunction_Item");
         RTXCTXTPUSHELEMNAME (pctxt, "RANfunction-Item");
         stat = asn1PE_e2ap_RANfunction_Item (pctxt, pvalue->value.u._e2apRANfunction_ItemIEs_id_RANfunction_Item);
         RTXCTXTPOPELEMNAME (pctxt);
      
         break;

      case T_E2AP_PDU_Contents_e2ap_RANfunction_ItemIEs_UNDEF_:
      {
          if(0!=pvalue->value.u.extElem1){
              openType.numocts = pvalue->value.u.extElem1->numocts;
              openType.data = pvalue->value.u.extElem1->data;
          } else {
              /* No extension element to encode */
          }
          encoded = FALSE;
          break;
      }
      default:
         encoded = FALSE;
         stat = RTERR_INVOPT;
      }

      if (encoded) {
         openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
         openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
      }
      rtxCopyContext (pctxt, &ictxt);
      if(stat ==0) stat = pe_OpenType(pctxt, openType.numocts, openType.data);
      /*free dynamic encode buffer*/
      if(encoded){
          rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
      }
   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);
   //RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

int asn1PD_e2ap_RANfunction_ItemIEs (OSCTXT* pctxt, e2ap_RANfunction_ItemIEs* pvalue)
{
   int stat =0;
   /*deode root element id*/
   RTXCTXTPUSHELEMNAME(pctxt, "id");
   stat = asn1PD_e2ap_ProtocolIE_ID (pctxt, &pvalue->id);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*decode root element criticality*/
   RTXCTXTPUSHELEMNAME(pctxt, "criticality");
   stat = asn1PD_e2ap_Criticality (pctxt, &pvalue->criticality);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   /*decode root element value*/
   RTXCTXTPUSHELEMNAME(pctxt, "value");
   {
      OSUINT32 openTypeLen;
      size_t bitStartOffset, bitLength;
      stat = pd_UnconsLength(pctxt, &openTypeLen);
      if(stat <0) return LOG_RTERR(pctxt, stat);
      else if(stat == RT_OK_FRAG){
         rtxErrAddStrParm(pctxt, "open type with fragmented length use - perindef");
         return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
      }
      bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
      bitLength = openTypeLen * 8;
      switch (pvalue->id){
         case T_E2AP_PDU_Contents_e2ap_RANfunction_ItemIEs_id_RANfunction_Item:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RANfunction_ItemIEs_id_RANfunction_Item;
            RTXCTXTPUSHELEMNAME(pctxt, "RANfunction-Item");
            //pvalue->value.u._e2ap_RANfunction_ItemIEs_id_id_RANfunction_Item 
             pvalue->value.u._e2apRANfunction_ItemIEs_id_RANfunction_Item 
                    = rtxMemAllocType(pctxt, e2ap_RANfunction_Item);
            //asn1Init_e2ap_RANfunction_Item(pvalue->value.u._e2ap_RANfunction_ItemIEs_id_id_RANfunction_Item);
            asn1Init_e2ap_RANfunction_Item(pvalue->value.u._e2apRANfunction_ItemIEs_id_RANfunction_Item);
            stat = asn1PD_e2ap_RANfunction_Item (pctxt,
                    (e2ap_RANfunction_Item*)pvalue->value.
                    u._e2apRANfunction_ItemIEs_id_RANfunction_Item);
            if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RANfunction_ItemIEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*)rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
      }
      {
      size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
      size_t bitsConsumed = bitEndOffset - bitStartOffset;
      if(bitsConsumed < bitLength){
         stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
      } else {
         stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
      }
      }
   }
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   return stat;
}

void asn1Init_e2ap_RANfunction_ItemIEs (e2ap_RANfunction_ItemIEs* pvalue)
{
   if (!pvalue) return;
   OSCRTLMEMSET (pvalue, 0, sizeof(e2ap_RANfunction_ItemIEs));
}

#if 0
void asn1Free_e2ap_RANfunction_ItemIEs (OSCTXT* pctxt, e2ap_RANfunction_ItemIEs* pvalue)
{
   if (!pvalue) return;
   if (pvalue->extElem1) {
      rtxMemFreeArray (pctxt, pvalue->extElem1);
      pvalue->extElem1 = 0;
      pvalue->extElem1_n = 0;
   }
}
#endif
void asn1Free_e2ap_RANfunction_ItemIEs (OSCTXT* pctxt, e2ap_RANfunction_ItemIEs* pvalue)
{
   if(0==pvalue) return;
   switch(pvalue->value.t){
      case T_E2AP_PDU_Contents_e2ap_RANfunction_ItemIEs_id_RANfunction_Item:
         asn1Free_e2ap_RANfunction_Item (pctxt, pvalue->value.u._e2apRANfunction_ItemIEs_id_RANfunction_Item);
         rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2apRANfunction_ItemIEs_id_RANfunction_Item);
         pvalue->value.u._e2apRANfunction_ItemIEs_id_RANfunction_Item = 0;
         break;
      case T_E2AP_PDU_Contents_e2ap_RANfunction_ItemIEs_UNDEF_:
         if(0!=pvalue->value.u.extElem1){
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1->data);
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
             pvalue->value.u.extElem1 =0;
         }
         break;
         default:;
   }
}

int  asn1PrtToStr_e2ap_RANfunction_ItemIEs (const char * name, e2ap_RANfunction_ItemIEs* pvalue, char * buffer, OSSIZE bufSize){
   if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
       return -1;

      if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
         return -1;

      if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
         return -1;
      if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
         return -1;
      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_RANfunction_ItemIEs_id_RANfunction_Item:
         if(asn1PrtToStr_e2ap_RANfunction_Item("RANfunction-Item",
                pvalue->value.u._e2apRANfunction_ItemIEs_id_RANfunction_Item, buffer, bufSize)<0)// dungnm23 check lai nhe xem la
            return -1;
         break;
      default:
         if(0!=pvalue -> value.u.extElem1){
             rtPrintToStringIndent(buffer, bufSize);
             rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

         }
      }
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

      return 0;

}
 

/*****************************************/
/*           RANfunctions_List                */
/*****************************************/
//seq_of_single_container


int asn1PE_e2ap_RANfunctions_List (OSCTXT* pctxt, e2ap_RANfunctions_List* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_RANfunction_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "RANfunctions-List");

   /* encode length determinant */
   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(256), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;
   for (xx1 = 0; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next, xx1++) {
      pdata = (e2ap_RANfunction_ItemIEs*) pnode->data;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_e2ap_RANfunction_ItemIEs (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      //xx1++;
      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}

int asn1PD_e2ap_RANfunctions_List (OSCTXT* pctxt, e2ap_RANfunctions_List* ppvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_RANfunction_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "RANfunctions-List");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(256), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (ppvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      pdata = rtxMemAllocType (pctxt, e2ap_RANfunction_ItemIEs);
      if (!pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);
      asn1Init_e2ap_RANfunction_ItemIEs (pdata);
      stat = asn1PD_e2ap_RANfunction_ItemIEs (pctxt, pdata);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         return LOG_RTERR (pctxt, stat);
      }

      rtxDListAppendNode (ppvalue, pdata);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

void asn1Init_e2ap_RANfunctions_List (e2ap_RANfunctions_List* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
}

void asn1Free_e2ap_RANfunctions_List (OSCTXT* pctxt, e2ap_RANfunctions_List* pvalue)
{
   if(pvalue==0) return;
   OSRTDListNode* pnode = pvalue->head;
   while (pnode) {
      e2ap_RANfunction_ItemIEs* pdata = (e2ap_RANfunction_ItemIEs*) pnode->data;
      if (pdata) {
         asn1Free_e2ap_RANfunction_ItemIEs (pctxt, pdata);
         rtxMemFreePtr (pctxt, pdata);
      }
      pnode = pnode->next;
   }
      rtxDListFreeAll(pctxt, pvalue);
}

#if 0
void asn1Free_e2ap_RANfunctions_List (OSCTXT* pctxt, e2ap_RANfunctions_List* pvalue){
   if(0==pvalue ) return;
   {
      e2ap_RANfunction_ItemIEs * pdata;
      OSRTDListNode *pnode = pvalue->head;
      while(0!=pnode){
         pdata = (e2ap_RANfunction_ItemIEs*)pnode->data;
         asn1Free_e2ap_RANfunction_ItemIEs(pctxt, pdata);
         pnode = pnode->next;
      }
      rtxDListFreeAll(pctxt, pvalue);
   }
}
#endif


int asn1PrtToStr_e2ap_RANfunctions_List(const char* name, e2ap_RANfunctions_List* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_RANfunction_ItemIEs* pdata;
    OSRTDListNode* pnode;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode = pvalue->head;  xx1 < pvalue->count && pnode != 0; pnode = pnode->next, xx1++){
        pdata = (e2ap_RANfunction_ItemIEs*)pnode->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 1
        if(asn1PrtToStr_e2ap_RANfunction_ItemIEs(nameBuf, pdata, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}/*****************************************/
/*           E2setupRequestIEs                */
/*****************************************/
/* ie.c.j2 */
 /* d là con của msg */
EXTERN int asn1PE_e2ap_E2setupRequest_protocolIEs_element (OSCTXT* pctxt, e2ap_E2setupRequest_protocolIEs_element* pvalue)
{
    int stat =0;

    /*encode id*/

    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PE_e2ap_ProtocolIE_ID(pctxt, pvalue->id);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PE_e2ap_Criticality(pctxt, pvalue->criticality);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
    {
        OSCTXT lctxt;
        OSOCTET *pDynamicEncodeBuffer;
        ASN1OpenType openType;
        OSBOOL encoded = TRUE;

        openType.numocts = 0;
        openType.data =0;

        rtxCopyContext(&lctxt, pctxt);
        pctxt->pStream =0;

        stat = rtxInitContextBuffer(pctxt, 0, 0);
        if(stat!=0) return LOG_RTERR(pctxt, stat);

        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_E2setupRequestIEs_id_TransactionID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-TransactionID");
                    stat = asn1PE_e2ap_TransactionID (pctxt, pvalue->value.u._e2ap_E2setupRequestIEs_id_TransactionID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_E2setupRequestIEs_id_GlobalE2node_ID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-GlobalE2node-ID");
                    stat = asn1PE_e2ap_GlobalE2node_ID (pctxt, pvalue->value.u._e2ap_E2setupRequestIEs_id_GlobalE2node_ID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_E2setupRequestIEs_id_RANfunctionsAdded:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RANfunctionsAdded");
                    stat = asn1PE_e2ap_RANfunctions_List (pctxt, pvalue->value.u._e2ap_E2setupRequestIEs_id_RANfunctionsAdded);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_E2setupRequestIEs_id_E2nodeComponentConfigAddition:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-E2nodeComponentConfigAddition");
                    stat = asn1PE_e2ap_E2nodeComponentConfigAddition_List (pctxt, pvalue->value.u._e2ap_E2setupRequestIEs_id_E2nodeComponentConfigAddition);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_E2setupRequestIEs_UNDEF_:
            {
                if(0!=pvalue->value.u.extElem1){
                    openType.numocts = pvalue->value.u.extElem1->numocts;
                    openType.data = pvalue->value.u.extElem1->data;
                } else {
                    /* No extension element to encode */
                }
                encoded = FALSE;
                break;
            }

            default:
                encoded = FALSE;
                stat = RTERR_INVOPT;
                break;
        } 

        if(encoded){
            openType.numocts = (OSUINT32)pe_GetMsgLen(pctxt);
            openType.data = pDynamicEncodeBuffer = pctxt -> buffer.data;
        }
        rtxCopyContext(pctxt, &lctxt);

        if(stat == 0) {
            stat = pe_OpenType (pctxt, openType.numocts, openType.data);
        }
    #if 1
        if(encoded){//dungnm23 check lai nhe
            rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
        }
    #endif

    }

    if(stat!=0) return LOG_RTERR(pctxt, stat);  
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}

EXTERN int  asn1PD_e2ap_E2setupRequest_protocolIEs_element (OSCTXT* pctxt, e2ap_E2setupRequest_protocolIEs_element* pvalue){
    int stat =0;

    /*decode id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PD_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PD_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");

    {
        OSUINT32 openTypeLen;
        size_t bitStartOffset, bitLength;

        stat = pd_UnconsLength(pctxt, &openTypeLen);
        if(stat<0) return LOG_RTERR(pctxt, stat);
        else if(stat == RT_OK_FRAG){
            rtxErrAddStrParm(pctxt, "open type with fragment length");
            return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
        }
        bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
        bitLength = openTypeLen * 8;

        switch(pvalue->id){//dungnm23 check case lai nhe
        
            case ASN1V_e2ap_id_TransactionID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_E2setupRequestIEs_id_TransactionID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-TransactionID");
                pvalue->value.u._e2ap_E2setupRequestIEs_id_TransactionID 
                    = rtxMemAllocType(pctxt, e2ap_TransactionID);

                asn1Init_e2ap_TransactionID(pvalue->value.u._e2ap_E2setupRequestIEs_id_TransactionID);

                stat = asn1PD_e2ap_TransactionID (pctxt,
                        (e2ap_TransactionID*)pvalue->value.
                        u._e2ap_E2setupRequestIEs_id_TransactionID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_GlobalE2node_ID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_E2setupRequestIEs_id_GlobalE2node_ID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-GlobalE2node-ID");
                pvalue->value.u._e2ap_E2setupRequestIEs_id_GlobalE2node_ID 
                    = rtxMemAllocType(pctxt, e2ap_GlobalE2node_ID);

                asn1Init_e2ap_GlobalE2node_ID(pvalue->value.u._e2ap_E2setupRequestIEs_id_GlobalE2node_ID);

                stat = asn1PD_e2ap_GlobalE2node_ID (pctxt,
                        (e2ap_GlobalE2node_ID*)pvalue->value.
                        u._e2ap_E2setupRequestIEs_id_GlobalE2node_ID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RANfunctionsAdded:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_E2setupRequestIEs_id_RANfunctionsAdded;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RANfunctionsAdded");
                pvalue->value.u._e2ap_E2setupRequestIEs_id_RANfunctionsAdded 
                    = rtxMemAllocType(pctxt, e2ap_RANfunctions_List);

                asn1Init_e2ap_RANfunctions_List(pvalue->value.u._e2ap_E2setupRequestIEs_id_RANfunctionsAdded);

                stat = asn1PD_e2ap_RANfunctions_List (pctxt,
                        (e2ap_RANfunctions_List*)pvalue->value.
                        u._e2ap_E2setupRequestIEs_id_RANfunctionsAdded);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_E2nodeComponentConfigAddition:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_E2setupRequestIEs_id_E2nodeComponentConfigAddition;
            RTXCTXTPUSHELEMNAME(pctxt, "id-E2nodeComponentConfigAddition");
                pvalue->value.u._e2ap_E2setupRequestIEs_id_E2nodeComponentConfigAddition 
                    = rtxMemAllocType(pctxt, e2ap_E2nodeComponentConfigAddition_List);

                asn1Init_e2ap_E2nodeComponentConfigAddition_List(pvalue->value.u._e2ap_E2setupRequestIEs_id_E2nodeComponentConfigAddition);

                stat = asn1PD_e2ap_E2nodeComponentConfigAddition_List (pctxt,
                        (e2ap_E2nodeComponentConfigAddition_List*)pvalue->value.
                        u._e2ap_E2setupRequestIEs_id_E2nodeComponentConfigAddition);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_E2setupRequestIEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*) rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
    }
    {
    size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
    size_t bitsConsumed = bitEndOffset-bitStartOffset;
    if(bitsConsumed<bitLength){
        stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
    }
    else stat =(bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
    }}
    if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}


int asn1Init_e2ap_E2setupRequest_protocolIEs_element(e2ap_E2setupRequest_protocolIEs_element* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    OSCRTLMEMSET (&pvalue->value, 0, sizeof(pvalue->value));
    return 0;
}


//-----> chuaw có template rtxFreeASN1OpenType

#if 0
void asn1Free_e2ap_E2setupRequest_protocolIEs_element(OSCTXT* pctxt, e2ap_E2setupRequest_protocolIEs_element* pvalue)
{
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_E2setupRequestIEs_id_id_TransactionID:
            // rtxFreeE2ap_TransactionID(pvalue->value.u._e2ap_E2setupRequestIEs_id_id_TransactionID);

            if(pvalue->value.i._e2ap_E2setupRequest_id_TransactionID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_TransactionID(pctxt, pvalue->value.u._e2ap_E2setupRequestIEs_id_id_TransactionID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2setupRequestIEs_id_id_TransactionID);
           // pvalue->value.u._e2ap_E2setupRequestIEs_id_id_TransactionID = NULL;
           pvalue->value.u._e2ap_E2setupRequestIEs_id_TransactionID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_E2setupRequestIEs_id_id_GlobalE2node_ID:
            // rtxFreeE2ap_GlobalE2node_ID(pvalue->value.u._e2ap_E2setupRequestIEs_id_id_GlobalE2node_ID);

            if(pvalue->value.i._e2ap_E2setupRequest_id_GlobalE2node_ID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_GlobalE2node_ID(pctxt, pvalue->value.u._e2ap_E2setupRequestIEs_id_id_GlobalE2node_ID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2setupRequestIEs_id_id_GlobalE2node_ID);
           // pvalue->value.u._e2ap_E2setupRequestIEs_id_id_GlobalE2node_ID = NULL;
           pvalue->value.u._e2ap_E2setupRequestIEs_id_GlobalE2node_ID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_E2setupRequestIEs_id_id_RANfunctionsAdded:
            // rtxFreeE2ap_RANfunctions_List(pvalue->value.u._e2ap_E2setupRequestIEs_id_id_RANfunctionsAdded);

            if(pvalue->value.i._e2ap_E2setupRequest_id_RANfunctions_List!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RANfunctions_List(pctxt, pvalue->value.u._e2ap_E2setupRequestIEs_id_id_RANfunctionsAdded);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2setupRequestIEs_id_id_RANfunctionsAdded);
           // pvalue->value.u._e2ap_E2setupRequestIEs_id_id_RANfunctionsAdded = NULL;
           pvalue->value.u._e2ap_E2setupRequestIEs_id_RANfunctionsAdded = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_E2setupRequestIEs_id_id_E2nodeComponentConfigAddition:
            // rtxFreeE2ap_E2nodeComponentConfigAddition_List(pvalue->value.u._e2ap_E2setupRequestIEs_id_id_E2nodeComponentConfigAddition);

            if(pvalue->value.i._e2ap_E2setupRequest_id_E2nodeComponentConfigAddition_List!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_E2nodeComponentConfigAddition_List(pctxt, pvalue->value.u._e2ap_E2setupRequestIEs_id_id_E2nodeComponentConfigAddition);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2setupRequestIEs_id_id_E2nodeComponentConfigAddition);
           // pvalue->value.u._e2ap_E2setupRequestIEs_id_id_E2nodeComponentConfigAddition = NULL;
           pvalue->value.u._e2ap_E2setupRequestIEs_id_E2nodeComponentConfigAddition = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_E2setupRequestIEs_UNDEF_:
            rtxFreeASN1OpenType(pvalue->value.u.extElem1);
            break;
        default:
            break;
    }
}

int asn1PrtToStr_e2ap_E2setupRequest_protocolIEs_element(OSCTXT* pctxt, e2ap_E2setupRequest_protocolIEs_element* pvalue)
{
    int stat =0;
    RTXCTXTPUSHELEMNAME(pctxt, "e2ap_E2setupRequest_protocolIEs_element");

    /*print id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PrtToStr_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PrtToStr_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_E2setupRequestIEs_id_id_TransactionID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "TransactionID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_TransactionID (pctxt, pvalue->value.u._e2ap_E2setupRequestIEs_id_id_TransactionID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_E2setupRequestIEs_id_id_GlobalE2node_ID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "GlobalE2node-ID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_GlobalE2node_ID (pctxt, pvalue->value.u._e2ap_E2setupRequestIEs_id_id_GlobalE2node_ID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_E2setupRequestIEs_id_id_RANfunctionsAdded:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RANfunctions-List");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RANfunctions_List (pctxt, pvalue->value.u._e2ap_E2setupRequestIEs_id_id_RANfunctionsAdded);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_E2setupRequestIEs_id_id_E2nodeComponentConfigAddition:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "E2nodeComponentConfigAddition-List");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_E2nodeComponentConfigAddition_List (pctxt, pvalue->value.u._e2ap_E2setupRequestIEs_id_id_E2nodeComponentConfigAddition);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_E2setupRequestIEs_UNDEF_:
            {
                rtxPLogMsg(pctxt, "Extension element present - raw data not printed.\n");
                break;
            }

            default:
                stat = RTERR_INVOPT;
                return LOG_RTERR(pctxt, stat);
        }
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);
}
#endif


int asn1PrtToStr_e2ap_E2setupRequest_protocolIEs_element (const char * name,
 e2ap_E2setupRequest_protocolIEs_element* pvalue, 
 char * buffer, OSSIZE bufSize){
    if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
        return -1;
    if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
        return -1;

    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_E2setupRequestIEs_id_TransactionID:
            if(asn1PrtToStr_e2ap_TransactionID("TransactionID", 
                    pvalue->value.u._e2ap_E2setupRequestIEs_id_TransactionID, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_E2setupRequestIEs_id_GlobalE2node_ID:
            if(asn1PrtToStr_e2ap_GlobalE2node_ID("GlobalE2node-ID", 
                    pvalue->value.u._e2ap_E2setupRequestIEs_id_GlobalE2node_ID, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_E2setupRequestIEs_id_RANfunctionsAdded:
            if(asn1PrtToStr_e2ap_RANfunctions_List("RANfunctions-List", 
                    pvalue->value.u._e2ap_E2setupRequestIEs_id_RANfunctionsAdded, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_E2setupRequestIEs_id_E2nodeComponentConfigAddition:
            if(asn1PrtToStr_e2ap_E2nodeComponentConfigAddition_List("E2nodeComponentConfigAddition-List", 
                    pvalue->value.u._e2ap_E2setupRequestIEs_id_E2nodeComponentConfigAddition, buffer, bufSize)<0)
                return -1;
            break;    
        default:
        if(0!=pvalue -> value.u.extElem1){
            rtPrintToStringIndent(buffer, bufSize);
            rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

        }
        }
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

    return 0;

 }

 void asn1Free_e2ap_E2setupRequest_protocolIEs_element(OSCTXT* pctxt, e2ap_E2setupRequest_protocolIEs_element* pvalue){
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_E2setupRequestIEs_id_TransactionID:
            if(pvalue->value.u._e2ap_E2setupRequestIEs_id_TransactionID!=NULL){
            asn1Free_e2ap_TransactionID(pctxt, pvalue->value.u._e2ap_E2setupRequestIEs_id_TransactionID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2setupRequestIEs_id_TransactionID);
            pvalue->value.u._e2ap_E2setupRequestIEs_id_TransactionID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_E2setupRequestIEs_id_GlobalE2node_ID:
            if(pvalue->value.u._e2ap_E2setupRequestIEs_id_GlobalE2node_ID!=NULL){
            asn1Free_e2ap_GlobalE2node_ID(pctxt, pvalue->value.u._e2ap_E2setupRequestIEs_id_GlobalE2node_ID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2setupRequestIEs_id_GlobalE2node_ID);
            pvalue->value.u._e2ap_E2setupRequestIEs_id_GlobalE2node_ID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_E2setupRequestIEs_id_RANfunctionsAdded:
            if(pvalue->value.u._e2ap_E2setupRequestIEs_id_RANfunctionsAdded!=NULL){
            asn1Free_e2ap_RANfunctions_List(pctxt, pvalue->value.u._e2ap_E2setupRequestIEs_id_RANfunctionsAdded);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2setupRequestIEs_id_RANfunctionsAdded);
            pvalue->value.u._e2ap_E2setupRequestIEs_id_RANfunctionsAdded = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_E2setupRequestIEs_id_E2nodeComponentConfigAddition:
            if(pvalue->value.u._e2ap_E2setupRequestIEs_id_E2nodeComponentConfigAddition!=NULL){
            asn1Free_e2ap_E2nodeComponentConfigAddition_List(pctxt, pvalue->value.u._e2ap_E2setupRequestIEs_id_E2nodeComponentConfigAddition);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2setupRequestIEs_id_E2nodeComponentConfigAddition);
            pvalue->value.u._e2ap_E2setupRequestIEs_id_E2nodeComponentConfigAddition = NULL;
            }
            break;
        default:
            break;


    }
 }

 

/*****************************************/
/*           E2setupRequest                */
/*****************************************/
//2_container.c
/* 1. xxx_ProtocolIE -> mẫu cũ ở ie_big_msg */
EXTERN int asn1PE_e2ap_E2setupRequest_protocolIEs (OSCTXT* pctxt, e2ap_E2setupRequest_protocolIEs* pvalue)
{
    int stat =0;
    OSRTDListNode* pnode;
    OSUINT32 xx1;

    /*encode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pe_Length(pctxt, pvalue->count);
    if(stat<0) return LOG_RTERR(pctxt, stat);

    /*encode each element*/
    xx1 =0;
    for(pnode = pvalue->head; pnode != 0 && xx1<pvalue->count; pnode = pnode->next){
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE", xx1);
        stat = asn1PE_e2ap_E2setupRequest_protocolIEs_element (pctxt, ((e2ap_E2setupRequest_protocolIEs_element*)pnode->data));
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        xx1++;
        RTXCTXTPOPARRAYELEMNAME(pctxt);
    }

    return (stat);
}

EXTERN int  asn1PD_e2ap_E2setupRequest_protocolIEs(OSCTXT* pctxt, e2ap_E2setupRequest_protocolIEs* pvalue)
{
     int stat =0;
     OSRTDListNode* pnode;
     OSSIZE count =0;
     OSSIZE xx1=0;


     /*decode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pd_Length64(pctxt, &count); //tai sao lai 64
    if(stat!=0) return LOG_RTERR(pctxt, stat);

    /*decode each element*/
    rtxDListInit(pvalue);

    for(xx1=0; xx1 < count; xx1++){
        e2ap_E2setupRequest_protocolIEs_element* pdata;
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE",xx1);

        if(pnode == NULL) return LOG_RTERR(pctxt, RTERR_NOMEM);

        asn1Init_e2ap_E2setupRequest_protocolIEs_element(pdata);
        rtxDListAppendNode(pvalue, pnode);
        stat = asn1PD_e2ap_E2setupRequest_protocolIEs_element (pctxt, pdata);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        RTXCTXTPOPARRAYELEMNAME(pctxt);

    }
    return (stat);
}


int asn1Init_e2ap_E2setupRequest_protocolIEs(e2ap_E2setupRequest_protocolIEs* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    rtxDListFastInit (pvalue);
    return 0;
}
#if 1 //ao that day
void asn1Free_e2ap_E2setupRequest_protocolIEs(OSCTXT* pctxt, e2ap_E2setupRequest_protocolIEs* pvalue)
{
    if(0==pvalue) return;   
    e2ap_E2setupRequest_protocolIEs_element* pdata;
    OSRTDListNode* pnode=pvalue->head;
    while(0!=pnode){
        pdata = (e2ap_E2setupRequest_protocolIEs_element*)pnode->data;
       // asn1Free_e2ap_E2setupRequest_protocolIEs_element(pctxt, pdata);
        pnode = pnode->next;
    }
    rtxDListFreeAll(pctxt, pvalue);
}
#endif


EXTERN int asn1PrtToStr_e2ap_E2setupRequest_protocolIEs(const char* name, e2ap_E2setupRequest_protocolIEs* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_E2setupRequest_protocolIEs_element* pdata0;
    OSRTDListNode* pnode0;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode0 = pvalue->head;  xx1 < pvalue->count && pnode0 != 0; pnode0 = pnode0->next, xx1++){
        pdata0 = (e2ap_E2setupRequest_protocolIEs_element*)pnode0->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 0
        if(asn1PrtToStr_e2ap_E2setupRequest_protocolIEs_element(nameBuf, pdata0, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}


/*2 . E2setupRequest -> mẫu cũ ở seq_normal*/

int asn1PE_e2ap_E2setupRequest (OSCTXT* pctxt, e2ap_E2setupRequest* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "E2setupRequest");
   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field protocolIEs - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
   stat = asn1PE_e2ap_E2setupRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if(stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_E2setupRequest (OSCTXT* pctxt, e2ap_E2setupRequest* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME(pctxt, "E2setupRequest");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field protocolIEs */
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
      stat = asn1PD_e2ap_E2setupRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_E2setupRequest (e2ap_E2setupRequest* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_E2setupRequest_protocolIEs(&pvalue->protocolIEs);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_E2setupRequest (OSCTXT* pctxt, e2ap_E2setupRequest* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_E2setupRequest_protocolIEs(pctxt, &pvalue->protocolIEs);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_E2setupRequest (const char* name, e2ap_E2setupRequest* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }

   if(asn1PrtToStr_e2ap_E2setupRequest_protocolIEs("protocolIEs", &pvalue->protocolIEs, buffer, bufSize) <0){
      return -1;
   }

   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}
/*****************************************/
/*           GlobalRIC-ID                */
/*****************************************/
//sequence normal
// Các nội dung cần thiết cho template seq_normal.c.j2
    // Nội dung của file .c cho primitive BIT STRING (SIZE (20))
    /* bitstring intergrate header file */
//metadata.parsed.primitive_id == 3

//mau rnti_full ben xn  bitstring (n)

EXTERN int asn1PE_e2ap_GlobalRIC_ID_ric_ID(OSCTXT* pctxt, e2ap_GlobalRIC_ID_ric_ID* pvalue){
    int stat =0;
    //RTXCTXTPUSHTYPENAME(pctxt, "ric-ID");
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(20), OSUINTCONST(20), 0, 0);
    stat = pe_BitString (pctxt, OS_MIN(pvalue->numbits, 20), pvalue->data);
    if(stat != 0) return LOG_RTERR (pctxt, stat);
    //RTXCTXTPOPTYPENAME(pctxt);
    return stat;
}
EXTERN int asn1PD_e2ap_GlobalRIC_ID_ric_ID(OSCTXT* pctxt, e2ap_GlobalRIC_ID_ric_ID* pvalue){
    int stat =0;
    //RTXCTXTPUSHTYPENAME(pctxt, "ric-ID");
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(20), OSUINTCONST(20), 0, 0);
    stat = pd_BitString (pctxt, &pvalue->numbits, pvalue->data, sizeof(pvalue->data));
    if(stat != 0) return LOG_RTERR (pctxt, stat);
    //RTXCTXTPOPTYPENAME(pctxt);
    return stat;
}
EXTERN int asn1PrtToStr_e2ap_GlobalRIC_ID_ric_ID (const char* name, e2ap_GlobalRIC_ID_ric_ID* pvalue, char* buffer, OSSIZE bufSize){
    if(rtPrintToStringIndent(buffer, bufSize) < 0) return -1;
    if(rtPrintToStringBitStrBraceText (name, OS_MIN(pvalue->numbits, 20), pvalue->data, buffer, bufSize) < 0) return -1;
    return 0;
}
//EXTERN int asn1PrtToStrm_e2ap_GlobalRIC_ID_ric_ID (OSCTXT* pctxt, const char* name, const e2ap_GlobalRIC_ID_ric_ID* pvalue);
//EXTERN int asn1Copy_e2ap_GlobalRIC_ID_ric_ID(OSCTXT* pctxt,const e2ap_GlobalRIC_ID_ric_ID* pSrcValue,  e2ap_GlobalRIC_ID_ric_ID* pDstValue);
EXTERN int asn1Init_e2ap_GlobalRIC_ID_ric_ID(e2ap_GlobalRIC_ID_ric_ID* pvalue){
    if(0==pvalue) return RTERR_NULLPTR;
    pvalue->numbits=0;
    return 0;
}
EXTERN void asn1Free_e2ap_GlobalRIC_ID_ric_ID(OSCTXT* pctxt, e2ap_GlobalRIC_ID_ric_ID* pvalue){
    // No dynamic memory to free for fixed-size BIT STRING
    return;
}




// Các phần còn lại của template seq_normal.c.j2
//contain extensition bit -> theo mau cua GlobalgNB-ID
int asn1PE_e2ap_GlobalRIC_ID (OSCTXT* pctxt, e2ap_GlobalRIC_ID* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "GlobalRIC-ID");

   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field pLMN_Identity - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "pLMN-Identity");
   stat = asn1PE_e2ap_PLMN_Identity (pctxt, pvalue->pLMN_Identity);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /* encode field ric_ID - id = 3*/  
   RTXCTXTPUSHELEMNAME(pctxt, "ric-ID");
   stat = asn1PE_e2ap_GlobalRIC_ID_ric_ID(pctxt, &pvalue->ric_ID); //primitive
  
  
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);



   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_GlobalRIC_ID (OSCTXT* pctxt, e2ap_GlobalRIC_ID* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME(pctxt, "GlobalRIC-ID");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field pLMN_Identity */
   RTXCTXTPUSHELEMNAME(pctxt, "pLMN-Identity");
      stat = asn1PD_e2ap_PLMN_Identity (pctxt, &pvalue->pLMN_Identity);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field ric_ID */
   RTXCTXTPUSHELEMNAME(pctxt, "ric-ID");
      stat = asn1PD_e2ap_GlobalRIC_ID_ric_ID (pctxt, &pvalue->ric_ID); //primitive
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_GlobalRIC_ID (e2ap_GlobalRIC_ID* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_PLMN_Identity (&pvalue->pLMN_Identity);
   asn1Init_e2ap_GlobalRIC_ID_ric_ID (&pvalue->ric_ID); //primitive delete &
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_GlobalRIC_ID (OSCTXT* pctxt, e2ap_GlobalRIC_ID* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_PLMN_Identity (pctxt, &pvalue->pLMN_Identity);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_GlobalRIC_ID (const char* name, e2ap_GlobalRIC_ID* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }
   if(asn1PrtToStr_e2ap_PLMN_Identity ("pLMN_Identity", &pvalue->pLMN_Identity, buffer, bufSize) < 0)
   {
      return -1;
   }



   if(asn1PrtToStr_e2ap_GlobalRIC_ID_ric_ID ("ric_ID", &pvalue->ric_ID, buffer, bufSize) < 0)
   {
      return -1;
   }


   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}
/*****************************************/
/*           RANfunctionID-Item                */
/*****************************************/
//sequence normal
// Các nội dung cần thiết cho template seq_normal.c.j2

// Các phần còn lại của template seq_normal.c.j2
//contain extensition bit -> theo mau cua GlobalgNB-ID
int asn1PE_e2ap_RANfunctionID_Item (OSCTXT* pctxt, e2ap_RANfunctionID_Item* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RANfunctionID-Item");

   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field ranFunctionID - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "ranFunctionID");
   stat = asn1PE_e2ap_RANfunctionID (pctxt, pvalue->ranFunctionID);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /* encode field ranFunctionRevision - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "ranFunctionRevision");
   stat = asn1PE_e2ap_RANfunctionRevision (pctxt, pvalue->ranFunctionRevision);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);



   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RANfunctionID_Item (OSCTXT* pctxt, e2ap_RANfunctionID_Item* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME(pctxt, "RANfunctionID-Item");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field ranFunctionID */
   RTXCTXTPUSHELEMNAME(pctxt, "ranFunctionID");
      stat = asn1PD_e2ap_RANfunctionID (pctxt, &pvalue->ranFunctionID);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field ranFunctionRevision */
   RTXCTXTPUSHELEMNAME(pctxt, "ranFunctionRevision");
      stat = asn1PD_e2ap_RANfunctionRevision (pctxt, &pvalue->ranFunctionRevision);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RANfunctionID_Item (e2ap_RANfunctionID_Item* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RANfunctionID (&pvalue->ranFunctionID);
   asn1Init_e2ap_RANfunctionRevision (&pvalue->ranFunctionRevision);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RANfunctionID_Item (OSCTXT* pctxt, e2ap_RANfunctionID_Item* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_RANfunctionID (pctxt, &pvalue->ranFunctionID);
   asn1Free_e2ap_RANfunctionRevision (pctxt, &pvalue->ranFunctionRevision);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RANfunctionID_Item (const char* name, e2ap_RANfunctionID_Item* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }
   if(asn1PrtToStr_e2ap_RANfunctionID ("ranFunctionID", &pvalue->ranFunctionID, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_RANfunctionRevision ("ranFunctionRevision", &pvalue->ranFunctionRevision, buffer, bufSize) < 0)
   {
      return -1;
   }



   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           RANfunctionID_ItemIEs                */
/*****************************************/
/* ie.c.j2 */
/*ie thường*/
int asn1PE_e2ap_RANfunctionID_ItemIEs (OSCTXT* pctxt, e2ap_RANfunctionID_ItemIEs* pvalue)
{
   int stat = 0;
   //RTXCTXTPUSHTYPENAME (pctxt, "RANfunctionID-ItemIEs");

   /* encode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");
   stat = asn1PE_e2ap_ProtocolIE_ID (pctxt, pvalue->id);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");
   stat = asn1PE_e2ap_Criticality (pctxt, pvalue->criticality);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   {
      OSCTXT ictxt;
      OSOCTET* pDynamicEncodeBuffer;
      ASN1OpenType openType;
      OSBOOL  encoded = TRUE;

      openType.numocts = 0;
      openType.data = 0;

      rtxCopyContext (&ictxt, pctxt);
      pctxt->pStream = 0;

      stat = rtxInitContextBuffer (pctxt, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_RANfunctionID_ItemIEs_id_RANfunctionID_Item:
         
        // RTXCTXTPUSHELEMNAME (pctxt, "RANfunctionID_ItemIEs_id_RANfunctionID_Item");
         RTXCTXTPUSHELEMNAME (pctxt, "RANfunctionID-Item");
         stat = asn1PE_e2ap_RANfunctionID_Item (pctxt, pvalue->value.u._e2apRANfunctionID_ItemIEs_id_RANfunctionID_Item);
         RTXCTXTPOPELEMNAME (pctxt);
      
         break;

      case T_E2AP_PDU_Contents_e2ap_RANfunctionID_ItemIEs_UNDEF_:
      {
          if(0!=pvalue->value.u.extElem1){
              openType.numocts = pvalue->value.u.extElem1->numocts;
              openType.data = pvalue->value.u.extElem1->data;
          } else {
              /* No extension element to encode */
          }
          encoded = FALSE;
          break;
      }
      default:
         encoded = FALSE;
         stat = RTERR_INVOPT;
      }

      if (encoded) {
         openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
         openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
      }
      rtxCopyContext (pctxt, &ictxt);
      if(stat ==0) stat = pe_OpenType(pctxt, openType.numocts, openType.data);
      /*free dynamic encode buffer*/
      if(encoded){
          rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
      }
   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);
   //RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

int asn1PD_e2ap_RANfunctionID_ItemIEs (OSCTXT* pctxt, e2ap_RANfunctionID_ItemIEs* pvalue)
{
   int stat =0;
   /*deode root element id*/
   RTXCTXTPUSHELEMNAME(pctxt, "id");
   stat = asn1PD_e2ap_ProtocolIE_ID (pctxt, &pvalue->id);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*decode root element criticality*/
   RTXCTXTPUSHELEMNAME(pctxt, "criticality");
   stat = asn1PD_e2ap_Criticality (pctxt, &pvalue->criticality);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   /*decode root element value*/
   RTXCTXTPUSHELEMNAME(pctxt, "value");
   {
      OSUINT32 openTypeLen;
      size_t bitStartOffset, bitLength;
      stat = pd_UnconsLength(pctxt, &openTypeLen);
      if(stat <0) return LOG_RTERR(pctxt, stat);
      else if(stat == RT_OK_FRAG){
         rtxErrAddStrParm(pctxt, "open type with fragmented length use - perindef");
         return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
      }
      bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
      bitLength = openTypeLen * 8;
      switch (pvalue->id){
         case T_E2AP_PDU_Contents_e2ap_RANfunctionID_ItemIEs_id_RANfunctionID_Item:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RANfunctionID_ItemIEs_id_RANfunctionID_Item;
            RTXCTXTPUSHELEMNAME(pctxt, "RANfunctionID-Item");
            //pvalue->value.u._e2ap_RANfunctionID_ItemIEs_id_id_RANfunctionID_Item 
             pvalue->value.u._e2apRANfunctionID_ItemIEs_id_RANfunctionID_Item 
                    = rtxMemAllocType(pctxt, e2ap_RANfunctionID_Item);
            //asn1Init_e2ap_RANfunctionID_Item(pvalue->value.u._e2ap_RANfunctionID_ItemIEs_id_id_RANfunctionID_Item);
            asn1Init_e2ap_RANfunctionID_Item(pvalue->value.u._e2apRANfunctionID_ItemIEs_id_RANfunctionID_Item);
            stat = asn1PD_e2ap_RANfunctionID_Item (pctxt,
                    (e2ap_RANfunctionID_Item*)pvalue->value.
                    u._e2apRANfunctionID_ItemIEs_id_RANfunctionID_Item);
            if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RANfunctionID_ItemIEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*)rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
      }
      {
      size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
      size_t bitsConsumed = bitEndOffset - bitStartOffset;
      if(bitsConsumed < bitLength){
         stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
      } else {
         stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
      }
      }
   }
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   return stat;
}

void asn1Init_e2ap_RANfunctionID_ItemIEs (e2ap_RANfunctionID_ItemIEs* pvalue)
{
   if (!pvalue) return;
   OSCRTLMEMSET (pvalue, 0, sizeof(e2ap_RANfunctionID_ItemIEs));
}

#if 0
void asn1Free_e2ap_RANfunctionID_ItemIEs (OSCTXT* pctxt, e2ap_RANfunctionID_ItemIEs* pvalue)
{
   if (!pvalue) return;
   if (pvalue->extElem1) {
      rtxMemFreeArray (pctxt, pvalue->extElem1);
      pvalue->extElem1 = 0;
      pvalue->extElem1_n = 0;
   }
}
#endif
void asn1Free_e2ap_RANfunctionID_ItemIEs (OSCTXT* pctxt, e2ap_RANfunctionID_ItemIEs* pvalue)
{
   if(0==pvalue) return;
   switch(pvalue->value.t){
      case T_E2AP_PDU_Contents_e2ap_RANfunctionID_ItemIEs_id_RANfunctionID_Item:
         asn1Free_e2ap_RANfunctionID_Item (pctxt, pvalue->value.u._e2apRANfunctionID_ItemIEs_id_RANfunctionID_Item);
         rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2apRANfunctionID_ItemIEs_id_RANfunctionID_Item);
         pvalue->value.u._e2apRANfunctionID_ItemIEs_id_RANfunctionID_Item = 0;
         break;
      case T_E2AP_PDU_Contents_e2ap_RANfunctionID_ItemIEs_UNDEF_:
         if(0!=pvalue->value.u.extElem1){
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1->data);
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
             pvalue->value.u.extElem1 =0;
         }
         break;
         default:;
   }
}

int  asn1PrtToStr_e2ap_RANfunctionID_ItemIEs (const char * name, e2ap_RANfunctionID_ItemIEs* pvalue, char * buffer, OSSIZE bufSize){
   if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
       return -1;

      if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
         return -1;

      if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
         return -1;
      if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
         return -1;
      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_RANfunctionID_ItemIEs_id_RANfunctionID_Item:
         if(asn1PrtToStr_e2ap_RANfunctionID_Item("RANfunctionID-Item",
                pvalue->value.u._e2apRANfunctionID_ItemIEs_id_RANfunctionID_Item, buffer, bufSize)<0)// dungnm23 check lai nhe xem la
            return -1;
         break;
      default:
         if(0!=pvalue -> value.u.extElem1){
             rtPrintToStringIndent(buffer, bufSize);
             rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

         }
      }
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

      return 0;

}
 

/*****************************************/
/*           RANfunctionsID_List                */
/*****************************************/
//seq_of_single_container


int asn1PE_e2ap_RANfunctionsID_List (OSCTXT* pctxt, e2ap_RANfunctionsID_List* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_RANfunctionID_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "RANfunctionsID-List");

   /* encode length determinant */
   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(256), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;
   for (xx1 = 0; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next, xx1++) {
      pdata = (e2ap_RANfunctionID_ItemIEs*) pnode->data;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_e2ap_RANfunctionID_ItemIEs (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      //xx1++;
      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}

int asn1PD_e2ap_RANfunctionsID_List (OSCTXT* pctxt, e2ap_RANfunctionsID_List* ppvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_RANfunctionID_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "RANfunctionsID-List");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(256), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (ppvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      pdata = rtxMemAllocType (pctxt, e2ap_RANfunctionID_ItemIEs);
      if (!pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);
      asn1Init_e2ap_RANfunctionID_ItemIEs (pdata);
      stat = asn1PD_e2ap_RANfunctionID_ItemIEs (pctxt, pdata);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         return LOG_RTERR (pctxt, stat);
      }

      rtxDListAppendNode (ppvalue, pdata);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

void asn1Init_e2ap_RANfunctionsID_List (e2ap_RANfunctionsID_List* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
}

void asn1Free_e2ap_RANfunctionsID_List (OSCTXT* pctxt, e2ap_RANfunctionsID_List* pvalue)
{
   if(pvalue==0) return;
   OSRTDListNode* pnode = pvalue->head;
   while (pnode) {
      e2ap_RANfunctionID_ItemIEs* pdata = (e2ap_RANfunctionID_ItemIEs*) pnode->data;
      if (pdata) {
         asn1Free_e2ap_RANfunctionID_ItemIEs (pctxt, pdata);
         rtxMemFreePtr (pctxt, pdata);
      }
      pnode = pnode->next;
   }
      rtxDListFreeAll(pctxt, pvalue);
}

#if 0
void asn1Free_e2ap_RANfunctionsID_List (OSCTXT* pctxt, e2ap_RANfunctionsID_List* pvalue){
   if(0==pvalue ) return;
   {
      e2ap_RANfunctionID_ItemIEs * pdata;
      OSRTDListNode *pnode = pvalue->head;
      while(0!=pnode){
         pdata = (e2ap_RANfunctionID_ItemIEs*)pnode->data;
         asn1Free_e2ap_RANfunctionID_ItemIEs(pctxt, pdata);
         pnode = pnode->next;
      }
      rtxDListFreeAll(pctxt, pvalue);
   }
}
#endif


int asn1PrtToStr_e2ap_RANfunctionsID_List(const char* name, e2ap_RANfunctionsID_List* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_RANfunctionID_ItemIEs* pdata;
    OSRTDListNode* pnode;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode = pvalue->head;  xx1 < pvalue->count && pnode != 0; pnode = pnode->next, xx1++){
        pdata = (e2ap_RANfunctionID_ItemIEs*)pnode->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 1
        if(asn1PrtToStr_e2ap_RANfunctionID_ItemIEs(nameBuf, pdata, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}
/*****************************************/
/*           RANfunctionIDcause-Item                */
/*****************************************/
//sequence normal
// Các nội dung cần thiết cho template seq_normal.c.j2

// Các phần còn lại của template seq_normal.c.j2
//contain extensition bit -> theo mau cua GlobalgNB-ID
int asn1PE_e2ap_RANfunctionIDcause_Item (OSCTXT* pctxt, e2ap_RANfunctionIDcause_Item* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RANfunctionIDcause-Item");

   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field ranFunctionID - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "ranFunctionID");
   stat = asn1PE_e2ap_RANfunctionID (pctxt, pvalue->ranFunctionID);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /* encode field cause - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "cause");
   stat = asn1PE_e2ap_Cause (pctxt, pvalue->cause);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);



   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RANfunctionIDcause_Item (OSCTXT* pctxt, e2ap_RANfunctionIDcause_Item* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME(pctxt, "RANfunctionIDcause-Item");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field ranFunctionID */
   RTXCTXTPUSHELEMNAME(pctxt, "ranFunctionID");
      stat = asn1PD_e2ap_RANfunctionID (pctxt, &pvalue->ranFunctionID);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field cause */
   RTXCTXTPUSHELEMNAME(pctxt, "cause");
      stat = asn1PD_e2ap_Cause (pctxt, &pvalue->cause);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RANfunctionIDcause_Item (e2ap_RANfunctionIDcause_Item* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RANfunctionID (&pvalue->ranFunctionID);
   asn1Init_e2ap_Cause (&pvalue->cause);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RANfunctionIDcause_Item (OSCTXT* pctxt, e2ap_RANfunctionIDcause_Item* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_RANfunctionID (pctxt, &pvalue->ranFunctionID);
   asn1Free_e2ap_Cause (pctxt, &pvalue->cause);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RANfunctionIDcause_Item (const char* name, e2ap_RANfunctionIDcause_Item* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }
   if(asn1PrtToStr_e2ap_RANfunctionID ("ranFunctionID", &pvalue->ranFunctionID, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_Cause ("cause", &pvalue->cause, buffer, bufSize) < 0)
   {
      return -1;
   }



   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           RANfunctionIDcause_ItemIEs                */
/*****************************************/
/* ie.c.j2 */
/*ie thường*/
int asn1PE_e2ap_RANfunctionIDcause_ItemIEs (OSCTXT* pctxt, e2ap_RANfunctionIDcause_ItemIEs* pvalue)
{
   int stat = 0;
   //RTXCTXTPUSHTYPENAME (pctxt, "RANfunctionIDcause-ItemIEs");

   /* encode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");
   stat = asn1PE_e2ap_ProtocolIE_ID (pctxt, pvalue->id);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");
   stat = asn1PE_e2ap_Criticality (pctxt, pvalue->criticality);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   {
      OSCTXT ictxt;
      OSOCTET* pDynamicEncodeBuffer;
      ASN1OpenType openType;
      OSBOOL  encoded = TRUE;

      openType.numocts = 0;
      openType.data = 0;

      rtxCopyContext (&ictxt, pctxt);
      pctxt->pStream = 0;

      stat = rtxInitContextBuffer (pctxt, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_RANfunctionIDcause_ItemIEs_id_RANfunctionIEcause_Item:
         
        // RTXCTXTPUSHELEMNAME (pctxt, "RANfunctionIDcause_ItemIEs_id_RANfunctionIDcause_Item");
         RTXCTXTPUSHELEMNAME (pctxt, "RANfunctionIDcause-Item");
         stat = asn1PE_e2ap_RANfunctionIDcause_Item (pctxt, pvalue->value.u._e2apRANfunctionIDcause_ItemIEs_id_RANfunctionIEcause_Item);
         RTXCTXTPOPELEMNAME (pctxt);
      
         break;

      case T_E2AP_PDU_Contents_e2ap_RANfunctionIDcause_ItemIEs_UNDEF_:
      {
          if(0!=pvalue->value.u.extElem1){
              openType.numocts = pvalue->value.u.extElem1->numocts;
              openType.data = pvalue->value.u.extElem1->data;
          } else {
              /* No extension element to encode */
          }
          encoded = FALSE;
          break;
      }
      default:
         encoded = FALSE;
         stat = RTERR_INVOPT;
      }

      if (encoded) {
         openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
         openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
      }
      rtxCopyContext (pctxt, &ictxt);
      if(stat ==0) stat = pe_OpenType(pctxt, openType.numocts, openType.data);
      /*free dynamic encode buffer*/
      if(encoded){
          rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
      }
   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);
   //RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

int asn1PD_e2ap_RANfunctionIDcause_ItemIEs (OSCTXT* pctxt, e2ap_RANfunctionIDcause_ItemIEs* pvalue)
{
   int stat =0;
   /*deode root element id*/
   RTXCTXTPUSHELEMNAME(pctxt, "id");
   stat = asn1PD_e2ap_ProtocolIE_ID (pctxt, &pvalue->id);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*decode root element criticality*/
   RTXCTXTPUSHELEMNAME(pctxt, "criticality");
   stat = asn1PD_e2ap_Criticality (pctxt, &pvalue->criticality);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   /*decode root element value*/
   RTXCTXTPUSHELEMNAME(pctxt, "value");
   {
      OSUINT32 openTypeLen;
      size_t bitStartOffset, bitLength;
      stat = pd_UnconsLength(pctxt, &openTypeLen);
      if(stat <0) return LOG_RTERR(pctxt, stat);
      else if(stat == RT_OK_FRAG){
         rtxErrAddStrParm(pctxt, "open type with fragmented length use - perindef");
         return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
      }
      bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
      bitLength = openTypeLen * 8;
      switch (pvalue->id){
         case T_E2AP_PDU_Contents_e2ap_RANfunctionIDcause_ItemIEs_id_RANfunctionIEcause_Item:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RANfunctionIDcause_ItemIEs_id_RANfunctionIEcause_Item;
            RTXCTXTPUSHELEMNAME(pctxt, "RANfunctionIDcause-Item");
            //pvalue->value.u._e2ap_RANfunctionIDcause_ItemIEs_id_id_RANfunctionIEcause_Item 
             pvalue->value.u._e2apRANfunctionIDcause_ItemIEs_id_RANfunctionIEcause_Item 
                    = rtxMemAllocType(pctxt, e2ap_RANfunctionIDcause_Item);
            //asn1Init_e2ap_RANfunctionIDcause_Item(pvalue->value.u._e2ap_RANfunctionIDcause_ItemIEs_id_id_RANfunctionIEcause_Item);
            asn1Init_e2ap_RANfunctionIDcause_Item(pvalue->value.u._e2apRANfunctionIDcause_ItemIEs_id_RANfunctionIEcause_Item);
            stat = asn1PD_e2ap_RANfunctionIDcause_Item (pctxt,
                    (e2ap_RANfunctionIDcause_Item*)pvalue->value.
                    u._e2apRANfunctionIDcause_ItemIEs_id_RANfunctionIEcause_Item);
            if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RANfunctionIDcause_ItemIEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*)rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
      }
      {
      size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
      size_t bitsConsumed = bitEndOffset - bitStartOffset;
      if(bitsConsumed < bitLength){
         stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
      } else {
         stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
      }
      }
   }
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   return stat;
}

void asn1Init_e2ap_RANfunctionIDcause_ItemIEs (e2ap_RANfunctionIDcause_ItemIEs* pvalue)
{
   if (!pvalue) return;
   OSCRTLMEMSET (pvalue, 0, sizeof(e2ap_RANfunctionIDcause_ItemIEs));
}

#if 0
void asn1Free_e2ap_RANfunctionIDcause_ItemIEs (OSCTXT* pctxt, e2ap_RANfunctionIDcause_ItemIEs* pvalue)
{
   if (!pvalue) return;
   if (pvalue->extElem1) {
      rtxMemFreeArray (pctxt, pvalue->extElem1);
      pvalue->extElem1 = 0;
      pvalue->extElem1_n = 0;
   }
}
#endif
void asn1Free_e2ap_RANfunctionIDcause_ItemIEs (OSCTXT* pctxt, e2ap_RANfunctionIDcause_ItemIEs* pvalue)
{
   if(0==pvalue) return;
   switch(pvalue->value.t){
      case T_E2AP_PDU_Contents_e2ap_RANfunctionIDcause_ItemIEs_id_RANfunctionIEcause_Item:
         asn1Free_e2ap_RANfunctionIDcause_Item (pctxt, pvalue->value.u._e2apRANfunctionIDcause_ItemIEs_id_RANfunctionIEcause_Item);
         rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2apRANfunctionIDcause_ItemIEs_id_RANfunctionIEcause_Item);
         pvalue->value.u._e2apRANfunctionIDcause_ItemIEs_id_RANfunctionIEcause_Item = 0;
         break;
      case T_E2AP_PDU_Contents_e2ap_RANfunctionIDcause_ItemIEs_UNDEF_:
         if(0!=pvalue->value.u.extElem1){
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1->data);
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
             pvalue->value.u.extElem1 =0;
         }
         break;
         default:;
   }
}

int  asn1PrtToStr_e2ap_RANfunctionIDcause_ItemIEs (const char * name, e2ap_RANfunctionIDcause_ItemIEs* pvalue, char * buffer, OSSIZE bufSize){
   if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
       return -1;

      if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
         return -1;

      if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
         return -1;
      if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
         return -1;
      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_RANfunctionIDcause_ItemIEs_id_RANfunctionIEcause_Item:
         if(asn1PrtToStr_e2ap_RANfunctionIDcause_Item("RANfunctionIDcause-Item",
                pvalue->value.u._e2apRANfunctionIDcause_ItemIEs_id_RANfunctionIEcause_Item, buffer, bufSize)<0)// dungnm23 check lai nhe xem la
            return -1;
         break;
      default:
         if(0!=pvalue -> value.u.extElem1){
             rtPrintToStringIndent(buffer, bufSize);
             rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

         }
      }
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

      return 0;

}
 

/*****************************************/
/*           RANfunctionsIDcause_List                */
/*****************************************/
//seq_of_single_container


int asn1PE_e2ap_RANfunctionsIDcause_List (OSCTXT* pctxt, e2ap_RANfunctionsIDcause_List* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_RANfunctionIDcause_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "RANfunctionsIDcause-List");

   /* encode length determinant */
   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(256), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;
   for (xx1 = 0; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next, xx1++) {
      pdata = (e2ap_RANfunctionIDcause_ItemIEs*) pnode->data;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_e2ap_RANfunctionIDcause_ItemIEs (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      //xx1++;
      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}

int asn1PD_e2ap_RANfunctionsIDcause_List (OSCTXT* pctxt, e2ap_RANfunctionsIDcause_List* ppvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_RANfunctionIDcause_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "RANfunctionsIDcause-List");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(256), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (ppvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      pdata = rtxMemAllocType (pctxt, e2ap_RANfunctionIDcause_ItemIEs);
      if (!pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);
      asn1Init_e2ap_RANfunctionIDcause_ItemIEs (pdata);
      stat = asn1PD_e2ap_RANfunctionIDcause_ItemIEs (pctxt, pdata);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         return LOG_RTERR (pctxt, stat);
      }

      rtxDListAppendNode (ppvalue, pdata);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

void asn1Init_e2ap_RANfunctionsIDcause_List (e2ap_RANfunctionsIDcause_List* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
}

void asn1Free_e2ap_RANfunctionsIDcause_List (OSCTXT* pctxt, e2ap_RANfunctionsIDcause_List* pvalue)
{
   if(pvalue==0) return;
   OSRTDListNode* pnode = pvalue->head;
   while (pnode) {
      e2ap_RANfunctionIDcause_ItemIEs* pdata = (e2ap_RANfunctionIDcause_ItemIEs*) pnode->data;
      if (pdata) {
         asn1Free_e2ap_RANfunctionIDcause_ItemIEs (pctxt, pdata);
         rtxMemFreePtr (pctxt, pdata);
      }
      pnode = pnode->next;
   }
      rtxDListFreeAll(pctxt, pvalue);
}

#if 0
void asn1Free_e2ap_RANfunctionsIDcause_List (OSCTXT* pctxt, e2ap_RANfunctionsIDcause_List* pvalue){
   if(0==pvalue ) return;
   {
      e2ap_RANfunctionIDcause_ItemIEs * pdata;
      OSRTDListNode *pnode = pvalue->head;
      while(0!=pnode){
         pdata = (e2ap_RANfunctionIDcause_ItemIEs*)pnode->data;
         asn1Free_e2ap_RANfunctionIDcause_ItemIEs(pctxt, pdata);
         pnode = pnode->next;
      }
      rtxDListFreeAll(pctxt, pvalue);
   }
}
#endif


int asn1PrtToStr_e2ap_RANfunctionsIDcause_List(const char* name, e2ap_RANfunctionsIDcause_List* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_RANfunctionIDcause_ItemIEs* pdata;
    OSRTDListNode* pnode;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode = pvalue->head;  xx1 < pvalue->count && pnode != 0; pnode = pnode->next, xx1++){
        pdata = (e2ap_RANfunctionIDcause_ItemIEs*)pnode->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 1
        if(asn1PrtToStr_e2ap_RANfunctionIDcause_ItemIEs(nameBuf, pdata, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}/*****************************************/
/*           E2setupResponseIEs                */
/*****************************************/
/* ie.c.j2 */
 /* d là con của msg */
EXTERN int asn1PE_e2ap_E2setupResponse_protocolIEs_element (OSCTXT* pctxt, e2ap_E2setupResponse_protocolIEs_element* pvalue)
{
    int stat =0;

    /*encode id*/

    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PE_e2ap_ProtocolIE_ID(pctxt, pvalue->id);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PE_e2ap_Criticality(pctxt, pvalue->criticality);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
    {
        OSCTXT lctxt;
        OSOCTET *pDynamicEncodeBuffer;
        ASN1OpenType openType;
        OSBOOL encoded = TRUE;

        openType.numocts = 0;
        openType.data =0;

        rtxCopyContext(&lctxt, pctxt);
        pctxt->pStream =0;

        stat = rtxInitContextBuffer(pctxt, 0, 0);
        if(stat!=0) return LOG_RTERR(pctxt, stat);

        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_E2setupResponseIEs_id_TransactionID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-TransactionID");
                    stat = asn1PE_e2ap_TransactionID (pctxt, pvalue->value.u._e2ap_E2setupResponseIEs_id_TransactionID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_E2setupResponseIEs_id_GlobalRIC_ID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-GlobalRIC-ID");
                    stat = asn1PE_e2ap_GlobalRIC_ID (pctxt, pvalue->value.u._e2ap_E2setupResponseIEs_id_GlobalRIC_ID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_E2setupResponseIEs_id_RANfunctionsAccepted:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RANfunctionsAccepted");
                    stat = asn1PE_e2ap_RANfunctionsID_List (pctxt, pvalue->value.u._e2ap_E2setupResponseIEs_id_RANfunctionsAccepted);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_E2setupResponseIEs_id_RANfunctionsRejected:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RANfunctionsRejected");
                    stat = asn1PE_e2ap_RANfunctionsIDcause_List (pctxt, pvalue->value.u._e2ap_E2setupResponseIEs_id_RANfunctionsRejected);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_E2setupResponseIEs_id_E2nodeComponentConfigAdditionAck:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-E2nodeComponentConfigAdditionAck");
                    stat = asn1PE_e2ap_E2nodeComponentConfigAdditionAck_List (pctxt, pvalue->value.u._e2ap_E2setupResponseIEs_id_E2nodeComponentConfigAdditionAck);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_E2setupResponseIEs_UNDEF_:
            {
                if(0!=pvalue->value.u.extElem1){
                    openType.numocts = pvalue->value.u.extElem1->numocts;
                    openType.data = pvalue->value.u.extElem1->data;
                } else {
                    /* No extension element to encode */
                }
                encoded = FALSE;
                break;
            }

            default:
                encoded = FALSE;
                stat = RTERR_INVOPT;
                break;
        } 

        if(encoded){
            openType.numocts = (OSUINT32)pe_GetMsgLen(pctxt);
            openType.data = pDynamicEncodeBuffer = pctxt -> buffer.data;
        }
        rtxCopyContext(pctxt, &lctxt);

        if(stat == 0) {
            stat = pe_OpenType (pctxt, openType.numocts, openType.data);
        }
    #if 1
        if(encoded){//dungnm23 check lai nhe
            rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
        }
    #endif

    }

    if(stat!=0) return LOG_RTERR(pctxt, stat);  
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}

EXTERN int  asn1PD_e2ap_E2setupResponse_protocolIEs_element (OSCTXT* pctxt, e2ap_E2setupResponse_protocolIEs_element* pvalue){
    int stat =0;

    /*decode id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PD_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PD_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");

    {
        OSUINT32 openTypeLen;
        size_t bitStartOffset, bitLength;

        stat = pd_UnconsLength(pctxt, &openTypeLen);
        if(stat<0) return LOG_RTERR(pctxt, stat);
        else if(stat == RT_OK_FRAG){
            rtxErrAddStrParm(pctxt, "open type with fragment length");
            return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
        }
        bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
        bitLength = openTypeLen * 8;

        switch(pvalue->id){//dungnm23 check case lai nhe
        
            case ASN1V_e2ap_id_TransactionID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_E2setupResponseIEs_id_TransactionID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-TransactionID");
                pvalue->value.u._e2ap_E2setupResponseIEs_id_TransactionID 
                    = rtxMemAllocType(pctxt, e2ap_TransactionID);

                asn1Init_e2ap_TransactionID(pvalue->value.u._e2ap_E2setupResponseIEs_id_TransactionID);

                stat = asn1PD_e2ap_TransactionID (pctxt,
                        (e2ap_TransactionID*)pvalue->value.
                        u._e2ap_E2setupResponseIEs_id_TransactionID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_GlobalRIC_ID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_E2setupResponseIEs_id_GlobalRIC_ID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-GlobalRIC-ID");
                pvalue->value.u._e2ap_E2setupResponseIEs_id_GlobalRIC_ID 
                    = rtxMemAllocType(pctxt, e2ap_GlobalRIC_ID);

                asn1Init_e2ap_GlobalRIC_ID(pvalue->value.u._e2ap_E2setupResponseIEs_id_GlobalRIC_ID);

                stat = asn1PD_e2ap_GlobalRIC_ID (pctxt,
                        (e2ap_GlobalRIC_ID*)pvalue->value.
                        u._e2ap_E2setupResponseIEs_id_GlobalRIC_ID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RANfunctionsAccepted:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_E2setupResponseIEs_id_RANfunctionsAccepted;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RANfunctionsAccepted");
                pvalue->value.u._e2ap_E2setupResponseIEs_id_RANfunctionsAccepted 
                    = rtxMemAllocType(pctxt, e2ap_RANfunctionsID_List);

                asn1Init_e2ap_RANfunctionsID_List(pvalue->value.u._e2ap_E2setupResponseIEs_id_RANfunctionsAccepted);

                stat = asn1PD_e2ap_RANfunctionsID_List (pctxt,
                        (e2ap_RANfunctionsID_List*)pvalue->value.
                        u._e2ap_E2setupResponseIEs_id_RANfunctionsAccepted);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RANfunctionsRejected:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_E2setupResponseIEs_id_RANfunctionsRejected;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RANfunctionsRejected");
                pvalue->value.u._e2ap_E2setupResponseIEs_id_RANfunctionsRejected 
                    = rtxMemAllocType(pctxt, e2ap_RANfunctionsIDcause_List);

                asn1Init_e2ap_RANfunctionsIDcause_List(pvalue->value.u._e2ap_E2setupResponseIEs_id_RANfunctionsRejected);

                stat = asn1PD_e2ap_RANfunctionsIDcause_List (pctxt,
                        (e2ap_RANfunctionsIDcause_List*)pvalue->value.
                        u._e2ap_E2setupResponseIEs_id_RANfunctionsRejected);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_E2nodeComponentConfigAdditionAck:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_E2setupResponseIEs_id_E2nodeComponentConfigAdditionAck;
            RTXCTXTPUSHELEMNAME(pctxt, "id-E2nodeComponentConfigAdditionAck");
                pvalue->value.u._e2ap_E2setupResponseIEs_id_E2nodeComponentConfigAdditionAck 
                    = rtxMemAllocType(pctxt, e2ap_E2nodeComponentConfigAdditionAck_List);

                asn1Init_e2ap_E2nodeComponentConfigAdditionAck_List(pvalue->value.u._e2ap_E2setupResponseIEs_id_E2nodeComponentConfigAdditionAck);

                stat = asn1PD_e2ap_E2nodeComponentConfigAdditionAck_List (pctxt,
                        (e2ap_E2nodeComponentConfigAdditionAck_List*)pvalue->value.
                        u._e2ap_E2setupResponseIEs_id_E2nodeComponentConfigAdditionAck);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_E2setupResponseIEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*) rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
    }
    {
    size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
    size_t bitsConsumed = bitEndOffset-bitStartOffset;
    if(bitsConsumed<bitLength){
        stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
    }
    else stat =(bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
    }}
    if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}


int asn1Init_e2ap_E2setupResponse_protocolIEs_element(e2ap_E2setupResponse_protocolIEs_element* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    OSCRTLMEMSET (&pvalue->value, 0, sizeof(pvalue->value));
    return 0;
}


//-----> chuaw có template rtxFreeASN1OpenType

#if 0
void asn1Free_e2ap_E2setupResponse_protocolIEs_element(OSCTXT* pctxt, e2ap_E2setupResponse_protocolIEs_element* pvalue)
{
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_E2setupResponseIEs_id_id_TransactionID:
            // rtxFreeE2ap_TransactionID(pvalue->value.u._e2ap_E2setupResponseIEs_id_id_TransactionID);

            if(pvalue->value.i._e2ap_E2setupResponse_id_TransactionID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_TransactionID(pctxt, pvalue->value.u._e2ap_E2setupResponseIEs_id_id_TransactionID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2setupResponseIEs_id_id_TransactionID);
           // pvalue->value.u._e2ap_E2setupResponseIEs_id_id_TransactionID = NULL;
           pvalue->value.u._e2ap_E2setupResponseIEs_id_TransactionID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_E2setupResponseIEs_id_id_GlobalRIC_ID:
            // rtxFreeE2ap_GlobalRIC_ID(pvalue->value.u._e2ap_E2setupResponseIEs_id_id_GlobalRIC_ID);

            if(pvalue->value.i._e2ap_E2setupResponse_id_GlobalRIC_ID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_GlobalRIC_ID(pctxt, pvalue->value.u._e2ap_E2setupResponseIEs_id_id_GlobalRIC_ID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2setupResponseIEs_id_id_GlobalRIC_ID);
           // pvalue->value.u._e2ap_E2setupResponseIEs_id_id_GlobalRIC_ID = NULL;
           pvalue->value.u._e2ap_E2setupResponseIEs_id_GlobalRIC_ID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_E2setupResponseIEs_id_id_RANfunctionsAccepted:
            // rtxFreeE2ap_RANfunctionsID_List(pvalue->value.u._e2ap_E2setupResponseIEs_id_id_RANfunctionsAccepted);

            if(pvalue->value.i._e2ap_E2setupResponse_id_RANfunctionsID_List!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RANfunctionsID_List(pctxt, pvalue->value.u._e2ap_E2setupResponseIEs_id_id_RANfunctionsAccepted);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2setupResponseIEs_id_id_RANfunctionsAccepted);
           // pvalue->value.u._e2ap_E2setupResponseIEs_id_id_RANfunctionsAccepted = NULL;
           pvalue->value.u._e2ap_E2setupResponseIEs_id_RANfunctionsAccepted = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_E2setupResponseIEs_id_id_RANfunctionsRejected:
            // rtxFreeE2ap_RANfunctionsIDcause_List(pvalue->value.u._e2ap_E2setupResponseIEs_id_id_RANfunctionsRejected);

            if(pvalue->value.i._e2ap_E2setupResponse_id_RANfunctionsIDcause_List!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RANfunctionsIDcause_List(pctxt, pvalue->value.u._e2ap_E2setupResponseIEs_id_id_RANfunctionsRejected);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2setupResponseIEs_id_id_RANfunctionsRejected);
           // pvalue->value.u._e2ap_E2setupResponseIEs_id_id_RANfunctionsRejected = NULL;
           pvalue->value.u._e2ap_E2setupResponseIEs_id_RANfunctionsRejected = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_E2setupResponseIEs_id_id_E2nodeComponentConfigAdditionAck:
            // rtxFreeE2ap_E2nodeComponentConfigAdditionAck_List(pvalue->value.u._e2ap_E2setupResponseIEs_id_id_E2nodeComponentConfigAdditionAck);

            if(pvalue->value.i._e2ap_E2setupResponse_id_E2nodeComponentConfigAdditionAck_List!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_E2nodeComponentConfigAdditionAck_List(pctxt, pvalue->value.u._e2ap_E2setupResponseIEs_id_id_E2nodeComponentConfigAdditionAck);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2setupResponseIEs_id_id_E2nodeComponentConfigAdditionAck);
           // pvalue->value.u._e2ap_E2setupResponseIEs_id_id_E2nodeComponentConfigAdditionAck = NULL;
           pvalue->value.u._e2ap_E2setupResponseIEs_id_E2nodeComponentConfigAdditionAck = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_E2setupResponseIEs_UNDEF_:
            rtxFreeASN1OpenType(pvalue->value.u.extElem1);
            break;
        default:
            break;
    }
}

int asn1PrtToStr_e2ap_E2setupResponse_protocolIEs_element(OSCTXT* pctxt, e2ap_E2setupResponse_protocolIEs_element* pvalue)
{
    int stat =0;
    RTXCTXTPUSHELEMNAME(pctxt, "e2ap_E2setupResponse_protocolIEs_element");

    /*print id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PrtToStr_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PrtToStr_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_E2setupResponseIEs_id_id_TransactionID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "TransactionID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_TransactionID (pctxt, pvalue->value.u._e2ap_E2setupResponseIEs_id_id_TransactionID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_E2setupResponseIEs_id_id_GlobalRIC_ID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "GlobalRIC-ID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_GlobalRIC_ID (pctxt, pvalue->value.u._e2ap_E2setupResponseIEs_id_id_GlobalRIC_ID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_E2setupResponseIEs_id_id_RANfunctionsAccepted:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RANfunctionsID-List");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RANfunctionsID_List (pctxt, pvalue->value.u._e2ap_E2setupResponseIEs_id_id_RANfunctionsAccepted);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_E2setupResponseIEs_id_id_RANfunctionsRejected:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RANfunctionsIDcause-List");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RANfunctionsIDcause_List (pctxt, pvalue->value.u._e2ap_E2setupResponseIEs_id_id_RANfunctionsRejected);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_E2setupResponseIEs_id_id_E2nodeComponentConfigAdditionAck:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "E2nodeComponentConfigAdditionAck-List");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_E2nodeComponentConfigAdditionAck_List (pctxt, pvalue->value.u._e2ap_E2setupResponseIEs_id_id_E2nodeComponentConfigAdditionAck);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_E2setupResponseIEs_UNDEF_:
            {
                rtxPLogMsg(pctxt, "Extension element present - raw data not printed.\n");
                break;
            }

            default:
                stat = RTERR_INVOPT;
                return LOG_RTERR(pctxt, stat);
        }
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);
}
#endif


int asn1PrtToStr_e2ap_E2setupResponse_protocolIEs_element (const char * name,
 e2ap_E2setupResponse_protocolIEs_element* pvalue, 
 char * buffer, OSSIZE bufSize){
    if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
        return -1;
    if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
        return -1;

    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_E2setupResponseIEs_id_TransactionID:
            if(asn1PrtToStr_e2ap_TransactionID("TransactionID", 
                    pvalue->value.u._e2ap_E2setupResponseIEs_id_TransactionID, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_E2setupResponseIEs_id_GlobalRIC_ID:
            if(asn1PrtToStr_e2ap_GlobalRIC_ID("GlobalRIC-ID", 
                    pvalue->value.u._e2ap_E2setupResponseIEs_id_GlobalRIC_ID, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_E2setupResponseIEs_id_RANfunctionsAccepted:
            if(asn1PrtToStr_e2ap_RANfunctionsID_List("RANfunctionsID-List", 
                    pvalue->value.u._e2ap_E2setupResponseIEs_id_RANfunctionsAccepted, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_E2setupResponseIEs_id_RANfunctionsRejected:
            if(asn1PrtToStr_e2ap_RANfunctionsIDcause_List("RANfunctionsIDcause-List", 
                    pvalue->value.u._e2ap_E2setupResponseIEs_id_RANfunctionsRejected, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_E2setupResponseIEs_id_E2nodeComponentConfigAdditionAck:
            if(asn1PrtToStr_e2ap_E2nodeComponentConfigAdditionAck_List("E2nodeComponentConfigAdditionAck-List", 
                    pvalue->value.u._e2ap_E2setupResponseIEs_id_E2nodeComponentConfigAdditionAck, buffer, bufSize)<0)
                return -1;
            break;    
        default:
        if(0!=pvalue -> value.u.extElem1){
            rtPrintToStringIndent(buffer, bufSize);
            rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

        }
        }
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

    return 0;

 }

 void asn1Free_e2ap_E2setupResponse_protocolIEs_element(OSCTXT* pctxt, e2ap_E2setupResponse_protocolIEs_element* pvalue){
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_E2setupResponseIEs_id_TransactionID:
            if(pvalue->value.u._e2ap_E2setupResponseIEs_id_TransactionID!=NULL){
            asn1Free_e2ap_TransactionID(pctxt, pvalue->value.u._e2ap_E2setupResponseIEs_id_TransactionID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2setupResponseIEs_id_TransactionID);
            pvalue->value.u._e2ap_E2setupResponseIEs_id_TransactionID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_E2setupResponseIEs_id_GlobalRIC_ID:
            if(pvalue->value.u._e2ap_E2setupResponseIEs_id_GlobalRIC_ID!=NULL){
            asn1Free_e2ap_GlobalRIC_ID(pctxt, pvalue->value.u._e2ap_E2setupResponseIEs_id_GlobalRIC_ID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2setupResponseIEs_id_GlobalRIC_ID);
            pvalue->value.u._e2ap_E2setupResponseIEs_id_GlobalRIC_ID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_E2setupResponseIEs_id_RANfunctionsAccepted:
            if(pvalue->value.u._e2ap_E2setupResponseIEs_id_RANfunctionsAccepted!=NULL){
            asn1Free_e2ap_RANfunctionsID_List(pctxt, pvalue->value.u._e2ap_E2setupResponseIEs_id_RANfunctionsAccepted);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2setupResponseIEs_id_RANfunctionsAccepted);
            pvalue->value.u._e2ap_E2setupResponseIEs_id_RANfunctionsAccepted = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_E2setupResponseIEs_id_RANfunctionsRejected:
            if(pvalue->value.u._e2ap_E2setupResponseIEs_id_RANfunctionsRejected!=NULL){
            asn1Free_e2ap_RANfunctionsIDcause_List(pctxt, pvalue->value.u._e2ap_E2setupResponseIEs_id_RANfunctionsRejected);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2setupResponseIEs_id_RANfunctionsRejected);
            pvalue->value.u._e2ap_E2setupResponseIEs_id_RANfunctionsRejected = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_E2setupResponseIEs_id_E2nodeComponentConfigAdditionAck:
            if(pvalue->value.u._e2ap_E2setupResponseIEs_id_E2nodeComponentConfigAdditionAck!=NULL){
            asn1Free_e2ap_E2nodeComponentConfigAdditionAck_List(pctxt, pvalue->value.u._e2ap_E2setupResponseIEs_id_E2nodeComponentConfigAdditionAck);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_E2setupResponseIEs_id_E2nodeComponentConfigAdditionAck);
            pvalue->value.u._e2ap_E2setupResponseIEs_id_E2nodeComponentConfigAdditionAck = NULL;
            }
            break;
        default:
            break;


    }
 }

 

/*****************************************/
/*           E2setupResponse                */
/*****************************************/
//2_container.c
/* 1. xxx_ProtocolIE -> mẫu cũ ở ie_big_msg */
EXTERN int asn1PE_e2ap_E2setupResponse_protocolIEs (OSCTXT* pctxt, e2ap_E2setupResponse_protocolIEs* pvalue)
{
    int stat =0;
    OSRTDListNode* pnode;
    OSUINT32 xx1;

    /*encode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pe_Length(pctxt, pvalue->count);
    if(stat<0) return LOG_RTERR(pctxt, stat);

    /*encode each element*/
    xx1 =0;
    for(pnode = pvalue->head; pnode != 0 && xx1<pvalue->count; pnode = pnode->next){
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE", xx1);
        stat = asn1PE_e2ap_E2setupResponse_protocolIEs_element (pctxt, ((e2ap_E2setupResponse_protocolIEs_element*)pnode->data));
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        xx1++;
        RTXCTXTPOPARRAYELEMNAME(pctxt);
    }

    return (stat);
}

EXTERN int  asn1PD_e2ap_E2setupResponse_protocolIEs(OSCTXT* pctxt, e2ap_E2setupResponse_protocolIEs* pvalue)
{
     int stat =0;
     OSRTDListNode* pnode;
     OSSIZE count =0;
     OSSIZE xx1=0;


     /*decode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pd_Length64(pctxt, &count); //tai sao lai 64
    if(stat!=0) return LOG_RTERR(pctxt, stat);

    /*decode each element*/
    rtxDListInit(pvalue);

    for(xx1=0; xx1 < count; xx1++){
        e2ap_E2setupResponse_protocolIEs_element* pdata;
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE",xx1);

        if(pnode == NULL) return LOG_RTERR(pctxt, RTERR_NOMEM);

        asn1Init_e2ap_E2setupResponse_protocolIEs_element(pdata);
        rtxDListAppendNode(pvalue, pnode);
        stat = asn1PD_e2ap_E2setupResponse_protocolIEs_element (pctxt, pdata);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        RTXCTXTPOPARRAYELEMNAME(pctxt);

    }
    return (stat);
}


int asn1Init_e2ap_E2setupResponse_protocolIEs(e2ap_E2setupResponse_protocolIEs* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    rtxDListFastInit (pvalue);
    return 0;
}
#if 1 //ao that day
void asn1Free_e2ap_E2setupResponse_protocolIEs(OSCTXT* pctxt, e2ap_E2setupResponse_protocolIEs* pvalue)
{
    if(0==pvalue) return;   
    e2ap_E2setupResponse_protocolIEs_element* pdata;
    OSRTDListNode* pnode=pvalue->head;
    while(0!=pnode){
        pdata = (e2ap_E2setupResponse_protocolIEs_element*)pnode->data;
       // asn1Free_e2ap_E2setupResponse_protocolIEs_element(pctxt, pdata);
        pnode = pnode->next;
    }
    rtxDListFreeAll(pctxt, pvalue);
}
#endif


EXTERN int asn1PrtToStr_e2ap_E2setupResponse_protocolIEs(const char* name, e2ap_E2setupResponse_protocolIEs* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_E2setupResponse_protocolIEs_element* pdata0;
    OSRTDListNode* pnode0;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode0 = pvalue->head;  xx1 < pvalue->count && pnode0 != 0; pnode0 = pnode0->next, xx1++){
        pdata0 = (e2ap_E2setupResponse_protocolIEs_element*)pnode0->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 0
        if(asn1PrtToStr_e2ap_E2setupResponse_protocolIEs_element(nameBuf, pdata0, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}


/*2 . E2setupResponse -> mẫu cũ ở seq_normal*/

int asn1PE_e2ap_E2setupResponse (OSCTXT* pctxt, e2ap_E2setupResponse* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "E2setupResponse");
   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field protocolIEs - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
   stat = asn1PE_e2ap_E2setupResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
   if(stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_E2setupResponse (OSCTXT* pctxt, e2ap_E2setupResponse* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME(pctxt, "E2setupResponse");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field protocolIEs */
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
      stat = asn1PD_e2ap_E2setupResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_E2setupResponse (e2ap_E2setupResponse* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_E2setupResponse_protocolIEs(&pvalue->protocolIEs);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_E2setupResponse (OSCTXT* pctxt, e2ap_E2setupResponse* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_E2setupResponse_protocolIEs(pctxt, &pvalue->protocolIEs);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_E2setupResponse (const char* name, e2ap_E2setupResponse* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }

   if(asn1PrtToStr_e2ap_E2setupResponse_protocolIEs("protocolIEs", &pvalue->protocolIEs, buffer, bufSize) <0){
      return -1;
   }

   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           ErrorIndication_IEs                */
/*****************************************/
/* ie.c.j2 */
 /* d là con của msg */
EXTERN int asn1PE_e2ap_ErrorIndication_protocolIEs_element (OSCTXT* pctxt, e2ap_ErrorIndication_protocolIEs_element* pvalue)
{
    int stat =0;

    /*encode id*/

    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PE_e2ap_ProtocolIE_ID(pctxt, pvalue->id);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PE_e2ap_Criticality(pctxt, pvalue->criticality);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
    {
        OSCTXT lctxt;
        OSOCTET *pDynamicEncodeBuffer;
        ASN1OpenType openType;
        OSBOOL encoded = TRUE;

        openType.numocts = 0;
        openType.data =0;

        rtxCopyContext(&lctxt, pctxt);
        pctxt->pStream =0;

        stat = rtxInitContextBuffer(pctxt, 0, 0);
        if(stat!=0) return LOG_RTERR(pctxt, stat);

        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_ErrorIndication_IEs_id_TransactionID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-TransactionID");
                    stat = asn1PE_e2ap_TransactionID (pctxt, pvalue->value.u._e2ap_ErrorIndication_IEs_id_TransactionID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_ErrorIndication_IEs_id_RICrequestID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICrequestID");
                    stat = asn1PE_e2ap_RICrequestID (pctxt, pvalue->value.u._e2ap_ErrorIndication_IEs_id_RICrequestID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_ErrorIndication_IEs_id_RANfunctionID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RANfunctionID");
                    stat = asn1PE_e2ap_RANfunctionID (pctxt, pvalue->value.u._e2ap_ErrorIndication_IEs_id_RANfunctionID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_ErrorIndication_IEs_id_Cause:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-Cause");
                    stat = asn1PE_e2ap_Cause (pctxt, pvalue->value.u._e2ap_ErrorIndication_IEs_id_Cause);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_ErrorIndication_IEs_id_CriticalityDiagnostics:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-CriticalityDiagnostics");
                    stat = asn1PE_e2ap_CriticalityDiagnostics (pctxt, pvalue->value.u._e2ap_ErrorIndication_IEs_id_CriticalityDiagnostics);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_ErrorIndication_IEs_UNDEF_:
            {
                if(0!=pvalue->value.u.extElem1){
                    openType.numocts = pvalue->value.u.extElem1->numocts;
                    openType.data = pvalue->value.u.extElem1->data;
                } else {
                    /* No extension element to encode */
                }
                encoded = FALSE;
                break;
            }

            default:
                encoded = FALSE;
                stat = RTERR_INVOPT;
                break;
        } 

        if(encoded){
            openType.numocts = (OSUINT32)pe_GetMsgLen(pctxt);
            openType.data = pDynamicEncodeBuffer = pctxt -> buffer.data;
        }
        rtxCopyContext(pctxt, &lctxt);

        if(stat == 0) {
            stat = pe_OpenType (pctxt, openType.numocts, openType.data);
        }
    #if 1
        if(encoded){//dungnm23 check lai nhe
            rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
        }
    #endif

    }

    if(stat!=0) return LOG_RTERR(pctxt, stat);  
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}

EXTERN int  asn1PD_e2ap_ErrorIndication_protocolIEs_element (OSCTXT* pctxt, e2ap_ErrorIndication_protocolIEs_element* pvalue){
    int stat =0;

    /*decode id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PD_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PD_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");

    {
        OSUINT32 openTypeLen;
        size_t bitStartOffset, bitLength;

        stat = pd_UnconsLength(pctxt, &openTypeLen);
        if(stat<0) return LOG_RTERR(pctxt, stat);
        else if(stat == RT_OK_FRAG){
            rtxErrAddStrParm(pctxt, "open type with fragment length");
            return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
        }
        bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
        bitLength = openTypeLen * 8;

        switch(pvalue->id){//dungnm23 check case lai nhe
        
            case ASN1V_e2ap_id_TransactionID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_ErrorIndication_IEs_id_TransactionID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-TransactionID");
                pvalue->value.u._e2ap_ErrorIndication_IEs_id_TransactionID 
                    = rtxMemAllocType(pctxt, e2ap_TransactionID);

                asn1Init_e2ap_TransactionID(pvalue->value.u._e2ap_ErrorIndication_IEs_id_TransactionID);

                stat = asn1PD_e2ap_TransactionID (pctxt,
                        (e2ap_TransactionID*)pvalue->value.
                        u._e2ap_ErrorIndication_IEs_id_TransactionID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RICrequestID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_ErrorIndication_IEs_id_RICrequestID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICrequestID");
                pvalue->value.u._e2ap_ErrorIndication_IEs_id_RICrequestID 
                    = rtxMemAllocType(pctxt, e2ap_RICrequestID);

                asn1Init_e2ap_RICrequestID(pvalue->value.u._e2ap_ErrorIndication_IEs_id_RICrequestID);

                stat = asn1PD_e2ap_RICrequestID (pctxt,
                        (e2ap_RICrequestID*)pvalue->value.
                        u._e2ap_ErrorIndication_IEs_id_RICrequestID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RANfunctionID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_ErrorIndication_IEs_id_RANfunctionID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RANfunctionID");
                pvalue->value.u._e2ap_ErrorIndication_IEs_id_RANfunctionID 
                    = rtxMemAllocType(pctxt, e2ap_RANfunctionID);

                asn1Init_e2ap_RANfunctionID(pvalue->value.u._e2ap_ErrorIndication_IEs_id_RANfunctionID);

                stat = asn1PD_e2ap_RANfunctionID (pctxt,
                        (e2ap_RANfunctionID*)pvalue->value.
                        u._e2ap_ErrorIndication_IEs_id_RANfunctionID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_Cause:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_ErrorIndication_IEs_id_Cause;
            RTXCTXTPUSHELEMNAME(pctxt, "id-Cause");
                pvalue->value.u._e2ap_ErrorIndication_IEs_id_Cause 
                    = rtxMemAllocType(pctxt, e2ap_Cause);

                asn1Init_e2ap_Cause(pvalue->value.u._e2ap_ErrorIndication_IEs_id_Cause);

                stat = asn1PD_e2ap_Cause (pctxt,
                        (e2ap_Cause*)pvalue->value.
                        u._e2ap_ErrorIndication_IEs_id_Cause);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_CriticalityDiagnostics:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_ErrorIndication_IEs_id_CriticalityDiagnostics;
            RTXCTXTPUSHELEMNAME(pctxt, "id-CriticalityDiagnostics");
                pvalue->value.u._e2ap_ErrorIndication_IEs_id_CriticalityDiagnostics 
                    = rtxMemAllocType(pctxt, e2ap_CriticalityDiagnostics);

                asn1Init_e2ap_CriticalityDiagnostics(pvalue->value.u._e2ap_ErrorIndication_IEs_id_CriticalityDiagnostics);

                stat = asn1PD_e2ap_CriticalityDiagnostics (pctxt,
                        (e2ap_CriticalityDiagnostics*)pvalue->value.
                        u._e2ap_ErrorIndication_IEs_id_CriticalityDiagnostics);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_ErrorIndication_IEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*) rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
    }
    {
    size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
    size_t bitsConsumed = bitEndOffset-bitStartOffset;
    if(bitsConsumed<bitLength){
        stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
    }
    else stat =(bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
    }}
    if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}


int asn1Init_e2ap_ErrorIndication_protocolIEs_element(e2ap_ErrorIndication_protocolIEs_element* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    OSCRTLMEMSET (&pvalue->value, 0, sizeof(pvalue->value));
    return 0;
}


//-----> chuaw có template rtxFreeASN1OpenType

#if 0
void asn1Free_e2ap_ErrorIndication_protocolIEs_element(OSCTXT* pctxt, e2ap_ErrorIndication_protocolIEs_element* pvalue)
{
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_ErrorIndication_IEs_id_id_TransactionID:
            // rtxFreeE2ap_TransactionID(pvalue->value.u._e2ap_ErrorIndication_IEs_id_id_TransactionID);

            if(pvalue->value.i._e2ap_ErrorIndication_id_TransactionID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_TransactionID(pctxt, pvalue->value.u._e2ap_ErrorIndication_IEs_id_id_TransactionID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_ErrorIndication_IEs_id_id_TransactionID);
           // pvalue->value.u._e2ap_ErrorIndication_IEs_id_id_TransactionID = NULL;
           pvalue->value.u._e2ap_ErrorIndication_IEs_id_TransactionID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_ErrorIndication_IEs_id_id_RICrequestID:
            // rtxFreeE2ap_RICrequestID(pvalue->value.u._e2ap_ErrorIndication_IEs_id_id_RICrequestID);

            if(pvalue->value.i._e2ap_ErrorIndication_id_RICrequestID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICrequestID(pctxt, pvalue->value.u._e2ap_ErrorIndication_IEs_id_id_RICrequestID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_ErrorIndication_IEs_id_id_RICrequestID);
           // pvalue->value.u._e2ap_ErrorIndication_IEs_id_id_RICrequestID = NULL;
           pvalue->value.u._e2ap_ErrorIndication_IEs_id_RICrequestID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_ErrorIndication_IEs_id_id_RANfunctionID:
            // rtxFreeE2ap_RANfunctionID(pvalue->value.u._e2ap_ErrorIndication_IEs_id_id_RANfunctionID);

            if(pvalue->value.i._e2ap_ErrorIndication_id_RANfunctionID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RANfunctionID(pctxt, pvalue->value.u._e2ap_ErrorIndication_IEs_id_id_RANfunctionID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_ErrorIndication_IEs_id_id_RANfunctionID);
           // pvalue->value.u._e2ap_ErrorIndication_IEs_id_id_RANfunctionID = NULL;
           pvalue->value.u._e2ap_ErrorIndication_IEs_id_RANfunctionID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_ErrorIndication_IEs_id_id_Cause:
            // rtxFreeE2ap_Cause(pvalue->value.u._e2ap_ErrorIndication_IEs_id_id_Cause);

            if(pvalue->value.i._e2ap_ErrorIndication_id_Cause!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_Cause(pctxt, pvalue->value.u._e2ap_ErrorIndication_IEs_id_id_Cause);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_ErrorIndication_IEs_id_id_Cause);
           // pvalue->value.u._e2ap_ErrorIndication_IEs_id_id_Cause = NULL;
           pvalue->value.u._e2ap_ErrorIndication_IEs_id_Cause = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_ErrorIndication_IEs_id_id_CriticalityDiagnostics:
            // rtxFreeE2ap_CriticalityDiagnostics(pvalue->value.u._e2ap_ErrorIndication_IEs_id_id_CriticalityDiagnostics);

            if(pvalue->value.i._e2ap_ErrorIndication_id_CriticalityDiagnostics!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_CriticalityDiagnostics(pctxt, pvalue->value.u._e2ap_ErrorIndication_IEs_id_id_CriticalityDiagnostics);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_ErrorIndication_IEs_id_id_CriticalityDiagnostics);
           // pvalue->value.u._e2ap_ErrorIndication_IEs_id_id_CriticalityDiagnostics = NULL;
           pvalue->value.u._e2ap_ErrorIndication_IEs_id_CriticalityDiagnostics = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_ErrorIndication_IEs_UNDEF_:
            rtxFreeASN1OpenType(pvalue->value.u.extElem1);
            break;
        default:
            break;
    }
}

int asn1PrtToStr_e2ap_ErrorIndication_protocolIEs_element(OSCTXT* pctxt, e2ap_ErrorIndication_protocolIEs_element* pvalue)
{
    int stat =0;
    RTXCTXTPUSHELEMNAME(pctxt, "e2ap_ErrorIndication_protocolIEs_element");

    /*print id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PrtToStr_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PrtToStr_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_ErrorIndication_IEs_id_id_TransactionID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "TransactionID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_TransactionID (pctxt, pvalue->value.u._e2ap_ErrorIndication_IEs_id_id_TransactionID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_ErrorIndication_IEs_id_id_RICrequestID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICrequestID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICrequestID (pctxt, pvalue->value.u._e2ap_ErrorIndication_IEs_id_id_RICrequestID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_ErrorIndication_IEs_id_id_RANfunctionID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RANfunctionID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RANfunctionID (pctxt, pvalue->value.u._e2ap_ErrorIndication_IEs_id_id_RANfunctionID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_ErrorIndication_IEs_id_id_Cause:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "Cause");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_Cause (pctxt, pvalue->value.u._e2ap_ErrorIndication_IEs_id_id_Cause);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_ErrorIndication_IEs_id_id_CriticalityDiagnostics:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "CriticalityDiagnostics");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_CriticalityDiagnostics (pctxt, pvalue->value.u._e2ap_ErrorIndication_IEs_id_id_CriticalityDiagnostics);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_ErrorIndication_IEs_UNDEF_:
            {
                rtxPLogMsg(pctxt, "Extension element present - raw data not printed.\n");
                break;
            }

            default:
                stat = RTERR_INVOPT;
                return LOG_RTERR(pctxt, stat);
        }
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);
}
#endif


int asn1PrtToStr_e2ap_ErrorIndication_protocolIEs_element (const char * name,
 e2ap_ErrorIndication_protocolIEs_element* pvalue, 
 char * buffer, OSSIZE bufSize){
    if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
        return -1;
    if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
        return -1;

    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_ErrorIndication_IEs_id_TransactionID:
            if(asn1PrtToStr_e2ap_TransactionID("TransactionID", 
                    pvalue->value.u._e2ap_ErrorIndication_IEs_id_TransactionID, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_ErrorIndication_IEs_id_RICrequestID:
            if(asn1PrtToStr_e2ap_RICrequestID("RICrequestID", 
                    pvalue->value.u._e2ap_ErrorIndication_IEs_id_RICrequestID, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_ErrorIndication_IEs_id_RANfunctionID:
            if(asn1PrtToStr_e2ap_RANfunctionID("RANfunctionID", 
                    pvalue->value.u._e2ap_ErrorIndication_IEs_id_RANfunctionID, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_ErrorIndication_IEs_id_Cause:
            if(asn1PrtToStr_e2ap_Cause("Cause", 
                    pvalue->value.u._e2ap_ErrorIndication_IEs_id_Cause, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_ErrorIndication_IEs_id_CriticalityDiagnostics:
            if(asn1PrtToStr_e2ap_CriticalityDiagnostics("CriticalityDiagnostics", 
                    pvalue->value.u._e2ap_ErrorIndication_IEs_id_CriticalityDiagnostics, buffer, bufSize)<0)
                return -1;
            break;    
        default:
        if(0!=pvalue -> value.u.extElem1){
            rtPrintToStringIndent(buffer, bufSize);
            rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

        }
        }
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

    return 0;

 }

 void asn1Free_e2ap_ErrorIndication_protocolIEs_element(OSCTXT* pctxt, e2ap_ErrorIndication_protocolIEs_element* pvalue){
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_ErrorIndication_IEs_id_TransactionID:
            if(pvalue->value.u._e2ap_ErrorIndication_IEs_id_TransactionID!=NULL){
            asn1Free_e2ap_TransactionID(pctxt, pvalue->value.u._e2ap_ErrorIndication_IEs_id_TransactionID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_ErrorIndication_IEs_id_TransactionID);
            pvalue->value.u._e2ap_ErrorIndication_IEs_id_TransactionID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_ErrorIndication_IEs_id_RICrequestID:
            if(pvalue->value.u._e2ap_ErrorIndication_IEs_id_RICrequestID!=NULL){
            asn1Free_e2ap_RICrequestID(pctxt, pvalue->value.u._e2ap_ErrorIndication_IEs_id_RICrequestID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_ErrorIndication_IEs_id_RICrequestID);
            pvalue->value.u._e2ap_ErrorIndication_IEs_id_RICrequestID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_ErrorIndication_IEs_id_RANfunctionID:
            if(pvalue->value.u._e2ap_ErrorIndication_IEs_id_RANfunctionID!=NULL){
            asn1Free_e2ap_RANfunctionID(pctxt, pvalue->value.u._e2ap_ErrorIndication_IEs_id_RANfunctionID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_ErrorIndication_IEs_id_RANfunctionID);
            pvalue->value.u._e2ap_ErrorIndication_IEs_id_RANfunctionID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_ErrorIndication_IEs_id_Cause:
            if(pvalue->value.u._e2ap_ErrorIndication_IEs_id_Cause!=NULL){
            asn1Free_e2ap_Cause(pctxt, pvalue->value.u._e2ap_ErrorIndication_IEs_id_Cause);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_ErrorIndication_IEs_id_Cause);
            pvalue->value.u._e2ap_ErrorIndication_IEs_id_Cause = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_ErrorIndication_IEs_id_CriticalityDiagnostics:
            if(pvalue->value.u._e2ap_ErrorIndication_IEs_id_CriticalityDiagnostics!=NULL){
            asn1Free_e2ap_CriticalityDiagnostics(pctxt, pvalue->value.u._e2ap_ErrorIndication_IEs_id_CriticalityDiagnostics);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_ErrorIndication_IEs_id_CriticalityDiagnostics);
            pvalue->value.u._e2ap_ErrorIndication_IEs_id_CriticalityDiagnostics = NULL;
            }
            break;
        default:
            break;


    }
 }

 

/*****************************************/
/*           ErrorIndication                */
/*****************************************/
//2_container.c
/* 1. xxx_ProtocolIE -> mẫu cũ ở ie_big_msg */
EXTERN int asn1PE_e2ap_ErrorIndication_protocolIEs (OSCTXT* pctxt, e2ap_ErrorIndication_protocolIEs* pvalue)
{
    int stat =0;
    OSRTDListNode* pnode;
    OSUINT32 xx1;

    /*encode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pe_Length(pctxt, pvalue->count);
    if(stat<0) return LOG_RTERR(pctxt, stat);

    /*encode each element*/
    xx1 =0;
    for(pnode = pvalue->head; pnode != 0 && xx1<pvalue->count; pnode = pnode->next){
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE", xx1);
        stat = asn1PE_e2ap_ErrorIndication_protocolIEs_element (pctxt, ((e2ap_ErrorIndication_protocolIEs_element*)pnode->data));
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        xx1++;
        RTXCTXTPOPARRAYELEMNAME(pctxt);
    }

    return (stat);
}

EXTERN int  asn1PD_e2ap_ErrorIndication_protocolIEs(OSCTXT* pctxt, e2ap_ErrorIndication_protocolIEs* pvalue)
{
     int stat =0;
     OSRTDListNode* pnode;
     OSSIZE count =0;
     OSSIZE xx1=0;


     /*decode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pd_Length64(pctxt, &count); //tai sao lai 64
    if(stat!=0) return LOG_RTERR(pctxt, stat);

    /*decode each element*/
    rtxDListInit(pvalue);

    for(xx1=0; xx1 < count; xx1++){
        e2ap_ErrorIndication_protocolIEs_element* pdata;
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE",xx1);

        if(pnode == NULL) return LOG_RTERR(pctxt, RTERR_NOMEM);

        asn1Init_e2ap_ErrorIndication_protocolIEs_element(pdata);
        rtxDListAppendNode(pvalue, pnode);
        stat = asn1PD_e2ap_ErrorIndication_protocolIEs_element (pctxt, pdata);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        RTXCTXTPOPARRAYELEMNAME(pctxt);

    }
    return (stat);
}


int asn1Init_e2ap_ErrorIndication_protocolIEs(e2ap_ErrorIndication_protocolIEs* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    rtxDListFastInit (pvalue);
    return 0;
}
#if 1 //ao that day
void asn1Free_e2ap_ErrorIndication_protocolIEs(OSCTXT* pctxt, e2ap_ErrorIndication_protocolIEs* pvalue)
{
    if(0==pvalue) return;   
    e2ap_ErrorIndication_protocolIEs_element* pdata;
    OSRTDListNode* pnode=pvalue->head;
    while(0!=pnode){
        pdata = (e2ap_ErrorIndication_protocolIEs_element*)pnode->data;
       // asn1Free_e2ap_ErrorIndication_protocolIEs_element(pctxt, pdata);
        pnode = pnode->next;
    }
    rtxDListFreeAll(pctxt, pvalue);
}
#endif


EXTERN int asn1PrtToStr_e2ap_ErrorIndication_protocolIEs(const char* name, e2ap_ErrorIndication_protocolIEs* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_ErrorIndication_protocolIEs_element* pdata0;
    OSRTDListNode* pnode0;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode0 = pvalue->head;  xx1 < pvalue->count && pnode0 != 0; pnode0 = pnode0->next, xx1++){
        pdata0 = (e2ap_ErrorIndication_protocolIEs_element*)pnode0->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 0
        if(asn1PrtToStr_e2ap_ErrorIndication_protocolIEs_element(nameBuf, pdata0, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}


/*2 . ErrorIndication -> mẫu cũ ở seq_normal*/

int asn1PE_e2ap_ErrorIndication (OSCTXT* pctxt, e2ap_ErrorIndication* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "ErrorIndication");
   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field protocolIEs - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
   stat = asn1PE_e2ap_ErrorIndication_protocolIEs (pctxt, &pvalue->protocolIEs);
   if(stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_ErrorIndication (OSCTXT* pctxt, e2ap_ErrorIndication* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME(pctxt, "ErrorIndication");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field protocolIEs */
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
      stat = asn1PD_e2ap_ErrorIndication_protocolIEs (pctxt, &pvalue->protocolIEs);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_ErrorIndication (e2ap_ErrorIndication* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_ErrorIndication_protocolIEs(&pvalue->protocolIEs);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_ErrorIndication (OSCTXT* pctxt, e2ap_ErrorIndication* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_ErrorIndication_protocolIEs(pctxt, &pvalue->protocolIEs);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_ErrorIndication (const char* name, e2ap_ErrorIndication* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }

   if(asn1PrtToStr_e2ap_ErrorIndication_protocolIEs("protocolIEs", &pvalue->protocolIEs, buffer, bufSize) <0){
      return -1;
   }

   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           ResetRequestIEs                */
/*****************************************/
/* ie.c.j2 */
 /* d là con của msg */
EXTERN int asn1PE_e2ap_ResetRequest_protocolIEs_element (OSCTXT* pctxt, e2ap_ResetRequest_protocolIEs_element* pvalue)
{
    int stat =0;

    /*encode id*/

    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PE_e2ap_ProtocolIE_ID(pctxt, pvalue->id);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PE_e2ap_Criticality(pctxt, pvalue->criticality);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
    {
        OSCTXT lctxt;
        OSOCTET *pDynamicEncodeBuffer;
        ASN1OpenType openType;
        OSBOOL encoded = TRUE;

        openType.numocts = 0;
        openType.data =0;

        rtxCopyContext(&lctxt, pctxt);
        pctxt->pStream =0;

        stat = rtxInitContextBuffer(pctxt, 0, 0);
        if(stat!=0) return LOG_RTERR(pctxt, stat);

        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_ResetRequestIEs_id_TransactionID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-TransactionID");
                    stat = asn1PE_e2ap_TransactionID (pctxt, pvalue->value.u._e2ap_ResetRequestIEs_id_TransactionID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_ResetRequestIEs_id_Cause:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-Cause");
                    stat = asn1PE_e2ap_Cause (pctxt, pvalue->value.u._e2ap_ResetRequestIEs_id_Cause);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_ResetRequestIEs_UNDEF_:
            {
                if(0!=pvalue->value.u.extElem1){
                    openType.numocts = pvalue->value.u.extElem1->numocts;
                    openType.data = pvalue->value.u.extElem1->data;
                } else {
                    /* No extension element to encode */
                }
                encoded = FALSE;
                break;
            }

            default:
                encoded = FALSE;
                stat = RTERR_INVOPT;
                break;
        } 

        if(encoded){
            openType.numocts = (OSUINT32)pe_GetMsgLen(pctxt);
            openType.data = pDynamicEncodeBuffer = pctxt -> buffer.data;
        }
        rtxCopyContext(pctxt, &lctxt);

        if(stat == 0) {
            stat = pe_OpenType (pctxt, openType.numocts, openType.data);
        }
    #if 1
        if(encoded){//dungnm23 check lai nhe
            rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
        }
    #endif

    }

    if(stat!=0) return LOG_RTERR(pctxt, stat);  
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}

EXTERN int  asn1PD_e2ap_ResetRequest_protocolIEs_element (OSCTXT* pctxt, e2ap_ResetRequest_protocolIEs_element* pvalue){
    int stat =0;

    /*decode id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PD_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PD_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");

    {
        OSUINT32 openTypeLen;
        size_t bitStartOffset, bitLength;

        stat = pd_UnconsLength(pctxt, &openTypeLen);
        if(stat<0) return LOG_RTERR(pctxt, stat);
        else if(stat == RT_OK_FRAG){
            rtxErrAddStrParm(pctxt, "open type with fragment length");
            return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
        }
        bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
        bitLength = openTypeLen * 8;

        switch(pvalue->id){//dungnm23 check case lai nhe
        
            case ASN1V_e2ap_id_TransactionID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_ResetRequestIEs_id_TransactionID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-TransactionID");
                pvalue->value.u._e2ap_ResetRequestIEs_id_TransactionID 
                    = rtxMemAllocType(pctxt, e2ap_TransactionID);

                asn1Init_e2ap_TransactionID(pvalue->value.u._e2ap_ResetRequestIEs_id_TransactionID);

                stat = asn1PD_e2ap_TransactionID (pctxt,
                        (e2ap_TransactionID*)pvalue->value.
                        u._e2ap_ResetRequestIEs_id_TransactionID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_Cause:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_ResetRequestIEs_id_Cause;
            RTXCTXTPUSHELEMNAME(pctxt, "id-Cause");
                pvalue->value.u._e2ap_ResetRequestIEs_id_Cause 
                    = rtxMemAllocType(pctxt, e2ap_Cause);

                asn1Init_e2ap_Cause(pvalue->value.u._e2ap_ResetRequestIEs_id_Cause);

                stat = asn1PD_e2ap_Cause (pctxt,
                        (e2ap_Cause*)pvalue->value.
                        u._e2ap_ResetRequestIEs_id_Cause);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_ResetRequestIEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*) rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
    }
    {
    size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
    size_t bitsConsumed = bitEndOffset-bitStartOffset;
    if(bitsConsumed<bitLength){
        stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
    }
    else stat =(bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
    }}
    if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}


int asn1Init_e2ap_ResetRequest_protocolIEs_element(e2ap_ResetRequest_protocolIEs_element* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    OSCRTLMEMSET (&pvalue->value, 0, sizeof(pvalue->value));
    return 0;
}


//-----> chuaw có template rtxFreeASN1OpenType

#if 0
void asn1Free_e2ap_ResetRequest_protocolIEs_element(OSCTXT* pctxt, e2ap_ResetRequest_protocolIEs_element* pvalue)
{
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_ResetRequestIEs_id_id_TransactionID:
            // rtxFreeE2ap_TransactionID(pvalue->value.u._e2ap_ResetRequestIEs_id_id_TransactionID);

            if(pvalue->value.i._e2ap_ResetRequest_id_TransactionID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_TransactionID(pctxt, pvalue->value.u._e2ap_ResetRequestIEs_id_id_TransactionID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_ResetRequestIEs_id_id_TransactionID);
           // pvalue->value.u._e2ap_ResetRequestIEs_id_id_TransactionID = NULL;
           pvalue->value.u._e2ap_ResetRequestIEs_id_TransactionID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_ResetRequestIEs_id_id_Cause:
            // rtxFreeE2ap_Cause(pvalue->value.u._e2ap_ResetRequestIEs_id_id_Cause);

            if(pvalue->value.i._e2ap_ResetRequest_id_Cause!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_Cause(pctxt, pvalue->value.u._e2ap_ResetRequestIEs_id_id_Cause);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_ResetRequestIEs_id_id_Cause);
           // pvalue->value.u._e2ap_ResetRequestIEs_id_id_Cause = NULL;
           pvalue->value.u._e2ap_ResetRequestIEs_id_Cause = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_ResetRequestIEs_UNDEF_:
            rtxFreeASN1OpenType(pvalue->value.u.extElem1);
            break;
        default:
            break;
    }
}

int asn1PrtToStr_e2ap_ResetRequest_protocolIEs_element(OSCTXT* pctxt, e2ap_ResetRequest_protocolIEs_element* pvalue)
{
    int stat =0;
    RTXCTXTPUSHELEMNAME(pctxt, "e2ap_ResetRequest_protocolIEs_element");

    /*print id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PrtToStr_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PrtToStr_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_ResetRequestIEs_id_id_TransactionID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "TransactionID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_TransactionID (pctxt, pvalue->value.u._e2ap_ResetRequestIEs_id_id_TransactionID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_ResetRequestIEs_id_id_Cause:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "Cause");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_Cause (pctxt, pvalue->value.u._e2ap_ResetRequestIEs_id_id_Cause);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_ResetRequestIEs_UNDEF_:
            {
                rtxPLogMsg(pctxt, "Extension element present - raw data not printed.\n");
                break;
            }

            default:
                stat = RTERR_INVOPT;
                return LOG_RTERR(pctxt, stat);
        }
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);
}
#endif


int asn1PrtToStr_e2ap_ResetRequest_protocolIEs_element (const char * name,
 e2ap_ResetRequest_protocolIEs_element* pvalue, 
 char * buffer, OSSIZE bufSize){
    if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
        return -1;
    if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
        return -1;

    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_ResetRequestIEs_id_TransactionID:
            if(asn1PrtToStr_e2ap_TransactionID("TransactionID", 
                    pvalue->value.u._e2ap_ResetRequestIEs_id_TransactionID, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_ResetRequestIEs_id_Cause:
            if(asn1PrtToStr_e2ap_Cause("Cause", 
                    pvalue->value.u._e2ap_ResetRequestIEs_id_Cause, buffer, bufSize)<0)
                return -1;
            break;    
        default:
        if(0!=pvalue -> value.u.extElem1){
            rtPrintToStringIndent(buffer, bufSize);
            rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

        }
        }
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

    return 0;

 }

 void asn1Free_e2ap_ResetRequest_protocolIEs_element(OSCTXT* pctxt, e2ap_ResetRequest_protocolIEs_element* pvalue){
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_ResetRequestIEs_id_TransactionID:
            if(pvalue->value.u._e2ap_ResetRequestIEs_id_TransactionID!=NULL){
            asn1Free_e2ap_TransactionID(pctxt, pvalue->value.u._e2ap_ResetRequestIEs_id_TransactionID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_ResetRequestIEs_id_TransactionID);
            pvalue->value.u._e2ap_ResetRequestIEs_id_TransactionID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_ResetRequestIEs_id_Cause:
            if(pvalue->value.u._e2ap_ResetRequestIEs_id_Cause!=NULL){
            asn1Free_e2ap_Cause(pctxt, pvalue->value.u._e2ap_ResetRequestIEs_id_Cause);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_ResetRequestIEs_id_Cause);
            pvalue->value.u._e2ap_ResetRequestIEs_id_Cause = NULL;
            }
            break;
        default:
            break;


    }
 }

 

/*****************************************/
/*           ResetRequest                */
/*****************************************/
//2_container.c
/* 1. xxx_ProtocolIE -> mẫu cũ ở ie_big_msg */
EXTERN int asn1PE_e2ap_ResetRequest_protocolIEs (OSCTXT* pctxt, e2ap_ResetRequest_protocolIEs* pvalue)
{
    int stat =0;
    OSRTDListNode* pnode;
    OSUINT32 xx1;

    /*encode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pe_Length(pctxt, pvalue->count);
    if(stat<0) return LOG_RTERR(pctxt, stat);

    /*encode each element*/
    xx1 =0;
    for(pnode = pvalue->head; pnode != 0 && xx1<pvalue->count; pnode = pnode->next){
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE", xx1);
        stat = asn1PE_e2ap_ResetRequest_protocolIEs_element (pctxt, ((e2ap_ResetRequest_protocolIEs_element*)pnode->data));
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        xx1++;
        RTXCTXTPOPARRAYELEMNAME(pctxt);
    }

    return (stat);
}

EXTERN int  asn1PD_e2ap_ResetRequest_protocolIEs(OSCTXT* pctxt, e2ap_ResetRequest_protocolIEs* pvalue)
{
     int stat =0;
     OSRTDListNode* pnode;
     OSSIZE count =0;
     OSSIZE xx1=0;


     /*decode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pd_Length64(pctxt, &count); //tai sao lai 64
    if(stat!=0) return LOG_RTERR(pctxt, stat);

    /*decode each element*/
    rtxDListInit(pvalue);

    for(xx1=0; xx1 < count; xx1++){
        e2ap_ResetRequest_protocolIEs_element* pdata;
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE",xx1);

        if(pnode == NULL) return LOG_RTERR(pctxt, RTERR_NOMEM);

        asn1Init_e2ap_ResetRequest_protocolIEs_element(pdata);
        rtxDListAppendNode(pvalue, pnode);
        stat = asn1PD_e2ap_ResetRequest_protocolIEs_element (pctxt, pdata);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        RTXCTXTPOPARRAYELEMNAME(pctxt);

    }
    return (stat);
}


int asn1Init_e2ap_ResetRequest_protocolIEs(e2ap_ResetRequest_protocolIEs* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    rtxDListFastInit (pvalue);
    return 0;
}
#if 1 //ao that day
void asn1Free_e2ap_ResetRequest_protocolIEs(OSCTXT* pctxt, e2ap_ResetRequest_protocolIEs* pvalue)
{
    if(0==pvalue) return;   
    e2ap_ResetRequest_protocolIEs_element* pdata;
    OSRTDListNode* pnode=pvalue->head;
    while(0!=pnode){
        pdata = (e2ap_ResetRequest_protocolIEs_element*)pnode->data;
       // asn1Free_e2ap_ResetRequest_protocolIEs_element(pctxt, pdata);
        pnode = pnode->next;
    }
    rtxDListFreeAll(pctxt, pvalue);
}
#endif


EXTERN int asn1PrtToStr_e2ap_ResetRequest_protocolIEs(const char* name, e2ap_ResetRequest_protocolIEs* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_ResetRequest_protocolIEs_element* pdata0;
    OSRTDListNode* pnode0;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode0 = pvalue->head;  xx1 < pvalue->count && pnode0 != 0; pnode0 = pnode0->next, xx1++){
        pdata0 = (e2ap_ResetRequest_protocolIEs_element*)pnode0->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 0
        if(asn1PrtToStr_e2ap_ResetRequest_protocolIEs_element(nameBuf, pdata0, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}


/*2 . ResetRequest -> mẫu cũ ở seq_normal*/

int asn1PE_e2ap_ResetRequest (OSCTXT* pctxt, e2ap_ResetRequest* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "ResetRequest");
   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field protocolIEs - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
   stat = asn1PE_e2ap_ResetRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if(stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_ResetRequest (OSCTXT* pctxt, e2ap_ResetRequest* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME(pctxt, "ResetRequest");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field protocolIEs */
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
      stat = asn1PD_e2ap_ResetRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_ResetRequest (e2ap_ResetRequest* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_ResetRequest_protocolIEs(&pvalue->protocolIEs);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_ResetRequest (OSCTXT* pctxt, e2ap_ResetRequest* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_ResetRequest_protocolIEs(pctxt, &pvalue->protocolIEs);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_ResetRequest (const char* name, e2ap_ResetRequest* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }

   if(asn1PrtToStr_e2ap_ResetRequest_protocolIEs("protocolIEs", &pvalue->protocolIEs, buffer, bufSize) <0){
      return -1;
   }

   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           ResetResponseIEs                */
/*****************************************/
/* ie.c.j2 */
 /* d là con của msg */
EXTERN int asn1PE_e2ap_ResetResponse_protocolIEs_element (OSCTXT* pctxt, e2ap_ResetResponse_protocolIEs_element* pvalue)
{
    int stat =0;

    /*encode id*/

    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PE_e2ap_ProtocolIE_ID(pctxt, pvalue->id);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PE_e2ap_Criticality(pctxt, pvalue->criticality);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
    {
        OSCTXT lctxt;
        OSOCTET *pDynamicEncodeBuffer;
        ASN1OpenType openType;
        OSBOOL encoded = TRUE;

        openType.numocts = 0;
        openType.data =0;

        rtxCopyContext(&lctxt, pctxt);
        pctxt->pStream =0;

        stat = rtxInitContextBuffer(pctxt, 0, 0);
        if(stat!=0) return LOG_RTERR(pctxt, stat);

        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_ResetResponseIEs_id_TransactionID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-TransactionID");
                    stat = asn1PE_e2ap_TransactionID (pctxt, pvalue->value.u._e2ap_ResetResponseIEs_id_TransactionID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_ResetResponseIEs_id_CriticalityDiagnostics:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-CriticalityDiagnostics");
                    stat = asn1PE_e2ap_CriticalityDiagnostics (pctxt, pvalue->value.u._e2ap_ResetResponseIEs_id_CriticalityDiagnostics);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_ResetResponseIEs_UNDEF_:
            {
                if(0!=pvalue->value.u.extElem1){
                    openType.numocts = pvalue->value.u.extElem1->numocts;
                    openType.data = pvalue->value.u.extElem1->data;
                } else {
                    /* No extension element to encode */
                }
                encoded = FALSE;
                break;
            }

            default:
                encoded = FALSE;
                stat = RTERR_INVOPT;
                break;
        } 

        if(encoded){
            openType.numocts = (OSUINT32)pe_GetMsgLen(pctxt);
            openType.data = pDynamicEncodeBuffer = pctxt -> buffer.data;
        }
        rtxCopyContext(pctxt, &lctxt);

        if(stat == 0) {
            stat = pe_OpenType (pctxt, openType.numocts, openType.data);
        }
    #if 1
        if(encoded){//dungnm23 check lai nhe
            rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
        }
    #endif

    }

    if(stat!=0) return LOG_RTERR(pctxt, stat);  
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}

EXTERN int  asn1PD_e2ap_ResetResponse_protocolIEs_element (OSCTXT* pctxt, e2ap_ResetResponse_protocolIEs_element* pvalue){
    int stat =0;

    /*decode id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PD_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PD_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");

    {
        OSUINT32 openTypeLen;
        size_t bitStartOffset, bitLength;

        stat = pd_UnconsLength(pctxt, &openTypeLen);
        if(stat<0) return LOG_RTERR(pctxt, stat);
        else if(stat == RT_OK_FRAG){
            rtxErrAddStrParm(pctxt, "open type with fragment length");
            return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
        }
        bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
        bitLength = openTypeLen * 8;

        switch(pvalue->id){//dungnm23 check case lai nhe
        
            case ASN1V_e2ap_id_TransactionID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_ResetResponseIEs_id_TransactionID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-TransactionID");
                pvalue->value.u._e2ap_ResetResponseIEs_id_TransactionID 
                    = rtxMemAllocType(pctxt, e2ap_TransactionID);

                asn1Init_e2ap_TransactionID(pvalue->value.u._e2ap_ResetResponseIEs_id_TransactionID);

                stat = asn1PD_e2ap_TransactionID (pctxt,
                        (e2ap_TransactionID*)pvalue->value.
                        u._e2ap_ResetResponseIEs_id_TransactionID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_CriticalityDiagnostics:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_ResetResponseIEs_id_CriticalityDiagnostics;
            RTXCTXTPUSHELEMNAME(pctxt, "id-CriticalityDiagnostics");
                pvalue->value.u._e2ap_ResetResponseIEs_id_CriticalityDiagnostics 
                    = rtxMemAllocType(pctxt, e2ap_CriticalityDiagnostics);

                asn1Init_e2ap_CriticalityDiagnostics(pvalue->value.u._e2ap_ResetResponseIEs_id_CriticalityDiagnostics);

                stat = asn1PD_e2ap_CriticalityDiagnostics (pctxt,
                        (e2ap_CriticalityDiagnostics*)pvalue->value.
                        u._e2ap_ResetResponseIEs_id_CriticalityDiagnostics);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_ResetResponseIEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*) rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
    }
    {
    size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
    size_t bitsConsumed = bitEndOffset-bitStartOffset;
    if(bitsConsumed<bitLength){
        stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
    }
    else stat =(bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
    }}
    if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}


int asn1Init_e2ap_ResetResponse_protocolIEs_element(e2ap_ResetResponse_protocolIEs_element* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    OSCRTLMEMSET (&pvalue->value, 0, sizeof(pvalue->value));
    return 0;
}


//-----> chuaw có template rtxFreeASN1OpenType

#if 0
void asn1Free_e2ap_ResetResponse_protocolIEs_element(OSCTXT* pctxt, e2ap_ResetResponse_protocolIEs_element* pvalue)
{
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_ResetResponseIEs_id_id_TransactionID:
            // rtxFreeE2ap_TransactionID(pvalue->value.u._e2ap_ResetResponseIEs_id_id_TransactionID);

            if(pvalue->value.i._e2ap_ResetResponse_id_TransactionID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_TransactionID(pctxt, pvalue->value.u._e2ap_ResetResponseIEs_id_id_TransactionID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_ResetResponseIEs_id_id_TransactionID);
           // pvalue->value.u._e2ap_ResetResponseIEs_id_id_TransactionID = NULL;
           pvalue->value.u._e2ap_ResetResponseIEs_id_TransactionID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_ResetResponseIEs_id_id_CriticalityDiagnostics:
            // rtxFreeE2ap_CriticalityDiagnostics(pvalue->value.u._e2ap_ResetResponseIEs_id_id_CriticalityDiagnostics);

            if(pvalue->value.i._e2ap_ResetResponse_id_CriticalityDiagnostics!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_CriticalityDiagnostics(pctxt, pvalue->value.u._e2ap_ResetResponseIEs_id_id_CriticalityDiagnostics);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_ResetResponseIEs_id_id_CriticalityDiagnostics);
           // pvalue->value.u._e2ap_ResetResponseIEs_id_id_CriticalityDiagnostics = NULL;
           pvalue->value.u._e2ap_ResetResponseIEs_id_CriticalityDiagnostics = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_ResetResponseIEs_UNDEF_:
            rtxFreeASN1OpenType(pvalue->value.u.extElem1);
            break;
        default:
            break;
    }
}

int asn1PrtToStr_e2ap_ResetResponse_protocolIEs_element(OSCTXT* pctxt, e2ap_ResetResponse_protocolIEs_element* pvalue)
{
    int stat =0;
    RTXCTXTPUSHELEMNAME(pctxt, "e2ap_ResetResponse_protocolIEs_element");

    /*print id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PrtToStr_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PrtToStr_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_ResetResponseIEs_id_id_TransactionID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "TransactionID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_TransactionID (pctxt, pvalue->value.u._e2ap_ResetResponseIEs_id_id_TransactionID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_ResetResponseIEs_id_id_CriticalityDiagnostics:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "CriticalityDiagnostics");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_CriticalityDiagnostics (pctxt, pvalue->value.u._e2ap_ResetResponseIEs_id_id_CriticalityDiagnostics);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_ResetResponseIEs_UNDEF_:
            {
                rtxPLogMsg(pctxt, "Extension element present - raw data not printed.\n");
                break;
            }

            default:
                stat = RTERR_INVOPT;
                return LOG_RTERR(pctxt, stat);
        }
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);
}
#endif


int asn1PrtToStr_e2ap_ResetResponse_protocolIEs_element (const char * name,
 e2ap_ResetResponse_protocolIEs_element* pvalue, 
 char * buffer, OSSIZE bufSize){
    if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
        return -1;
    if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
        return -1;

    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_ResetResponseIEs_id_TransactionID:
            if(asn1PrtToStr_e2ap_TransactionID("TransactionID", 
                    pvalue->value.u._e2ap_ResetResponseIEs_id_TransactionID, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_ResetResponseIEs_id_CriticalityDiagnostics:
            if(asn1PrtToStr_e2ap_CriticalityDiagnostics("CriticalityDiagnostics", 
                    pvalue->value.u._e2ap_ResetResponseIEs_id_CriticalityDiagnostics, buffer, bufSize)<0)
                return -1;
            break;    
        default:
        if(0!=pvalue -> value.u.extElem1){
            rtPrintToStringIndent(buffer, bufSize);
            rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

        }
        }
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

    return 0;

 }

 void asn1Free_e2ap_ResetResponse_protocolIEs_element(OSCTXT* pctxt, e2ap_ResetResponse_protocolIEs_element* pvalue){
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_ResetResponseIEs_id_TransactionID:
            if(pvalue->value.u._e2ap_ResetResponseIEs_id_TransactionID!=NULL){
            asn1Free_e2ap_TransactionID(pctxt, pvalue->value.u._e2ap_ResetResponseIEs_id_TransactionID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_ResetResponseIEs_id_TransactionID);
            pvalue->value.u._e2ap_ResetResponseIEs_id_TransactionID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_ResetResponseIEs_id_CriticalityDiagnostics:
            if(pvalue->value.u._e2ap_ResetResponseIEs_id_CriticalityDiagnostics!=NULL){
            asn1Free_e2ap_CriticalityDiagnostics(pctxt, pvalue->value.u._e2ap_ResetResponseIEs_id_CriticalityDiagnostics);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_ResetResponseIEs_id_CriticalityDiagnostics);
            pvalue->value.u._e2ap_ResetResponseIEs_id_CriticalityDiagnostics = NULL;
            }
            break;
        default:
            break;


    }
 }

 

/*****************************************/
/*           ResetResponse                */
/*****************************************/
//2_container.c
/* 1. xxx_ProtocolIE -> mẫu cũ ở ie_big_msg */
EXTERN int asn1PE_e2ap_ResetResponse_protocolIEs (OSCTXT* pctxt, e2ap_ResetResponse_protocolIEs* pvalue)
{
    int stat =0;
    OSRTDListNode* pnode;
    OSUINT32 xx1;

    /*encode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pe_Length(pctxt, pvalue->count);
    if(stat<0) return LOG_RTERR(pctxt, stat);

    /*encode each element*/
    xx1 =0;
    for(pnode = pvalue->head; pnode != 0 && xx1<pvalue->count; pnode = pnode->next){
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE", xx1);
        stat = asn1PE_e2ap_ResetResponse_protocolIEs_element (pctxt, ((e2ap_ResetResponse_protocolIEs_element*)pnode->data));
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        xx1++;
        RTXCTXTPOPARRAYELEMNAME(pctxt);
    }

    return (stat);
}

EXTERN int  asn1PD_e2ap_ResetResponse_protocolIEs(OSCTXT* pctxt, e2ap_ResetResponse_protocolIEs* pvalue)
{
     int stat =0;
     OSRTDListNode* pnode;
     OSSIZE count =0;
     OSSIZE xx1=0;


     /*decode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pd_Length64(pctxt, &count); //tai sao lai 64
    if(stat!=0) return LOG_RTERR(pctxt, stat);

    /*decode each element*/
    rtxDListInit(pvalue);

    for(xx1=0; xx1 < count; xx1++){
        e2ap_ResetResponse_protocolIEs_element* pdata;
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE",xx1);

        if(pnode == NULL) return LOG_RTERR(pctxt, RTERR_NOMEM);

        asn1Init_e2ap_ResetResponse_protocolIEs_element(pdata);
        rtxDListAppendNode(pvalue, pnode);
        stat = asn1PD_e2ap_ResetResponse_protocolIEs_element (pctxt, pdata);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        RTXCTXTPOPARRAYELEMNAME(pctxt);

    }
    return (stat);
}


int asn1Init_e2ap_ResetResponse_protocolIEs(e2ap_ResetResponse_protocolIEs* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    rtxDListFastInit (pvalue);
    return 0;
}
#if 1 //ao that day
void asn1Free_e2ap_ResetResponse_protocolIEs(OSCTXT* pctxt, e2ap_ResetResponse_protocolIEs* pvalue)
{
    if(0==pvalue) return;   
    e2ap_ResetResponse_protocolIEs_element* pdata;
    OSRTDListNode* pnode=pvalue->head;
    while(0!=pnode){
        pdata = (e2ap_ResetResponse_protocolIEs_element*)pnode->data;
       // asn1Free_e2ap_ResetResponse_protocolIEs_element(pctxt, pdata);
        pnode = pnode->next;
    }
    rtxDListFreeAll(pctxt, pvalue);
}
#endif


EXTERN int asn1PrtToStr_e2ap_ResetResponse_protocolIEs(const char* name, e2ap_ResetResponse_protocolIEs* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_ResetResponse_protocolIEs_element* pdata0;
    OSRTDListNode* pnode0;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode0 = pvalue->head;  xx1 < pvalue->count && pnode0 != 0; pnode0 = pnode0->next, xx1++){
        pdata0 = (e2ap_ResetResponse_protocolIEs_element*)pnode0->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 0
        if(asn1PrtToStr_e2ap_ResetResponse_protocolIEs_element(nameBuf, pdata0, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}


/*2 . ResetResponse -> mẫu cũ ở seq_normal*/

int asn1PE_e2ap_ResetResponse (OSCTXT* pctxt, e2ap_ResetResponse* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "ResetResponse");
   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field protocolIEs - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
   stat = asn1PE_e2ap_ResetResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
   if(stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_ResetResponse (OSCTXT* pctxt, e2ap_ResetResponse* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME(pctxt, "ResetResponse");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field protocolIEs */
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
      stat = asn1PD_e2ap_ResetResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_ResetResponse (e2ap_ResetResponse* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_ResetResponse_protocolIEs(&pvalue->protocolIEs);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_ResetResponse (OSCTXT* pctxt, e2ap_ResetResponse* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_ResetResponse_protocolIEs(pctxt, &pvalue->protocolIEs);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_ResetResponse (const char* name, e2ap_ResetResponse* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }

   if(asn1PrtToStr_e2ap_ResetResponse_protocolIEs("protocolIEs", &pvalue->protocolIEs, buffer, bufSize) <0){
      return -1;
   }

   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           RICassistanceFailure_IEs                */
/*****************************************/
/* ie.c.j2 */
 /* d là con của msg */
EXTERN int asn1PE_e2ap_RICassistanceFailure_protocolIEs_element (OSCTXT* pctxt, e2ap_RICassistanceFailure_protocolIEs_element* pvalue)
{
    int stat =0;

    /*encode id*/

    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PE_e2ap_ProtocolIE_ID(pctxt, pvalue->id);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PE_e2ap_Criticality(pctxt, pvalue->criticality);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
    {
        OSCTXT lctxt;
        OSOCTET *pDynamicEncodeBuffer;
        ASN1OpenType openType;
        OSBOOL encoded = TRUE;

        openType.numocts = 0;
        openType.data =0;

        rtxCopyContext(&lctxt, pctxt);
        pctxt->pStream =0;

        stat = rtxInitContextBuffer(pctxt, 0, 0);
        if(stat!=0) return LOG_RTERR(pctxt, stat);

        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_RICassistanceFailure_IEs_id_RICrequestID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICrequestID");
                    stat = asn1PE_e2ap_RICrequestID (pctxt, pvalue->value.u._e2ap_RICassistanceFailure_IEs_id_RICrequestID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICassistanceFailure_IEs_id_Cause:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-Cause");
                    stat = asn1PE_e2ap_Cause (pctxt, pvalue->value.u._e2ap_RICassistanceFailure_IEs_id_Cause);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICassistanceFailure_IEs_id_CriticalityDiagnostics:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-CriticalityDiagnostics");
                    stat = asn1PE_e2ap_CriticalityDiagnostics (pctxt, pvalue->value.u._e2ap_RICassistanceFailure_IEs_id_CriticalityDiagnostics);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_RICassistanceFailure_IEs_UNDEF_:
            {
                if(0!=pvalue->value.u.extElem1){
                    openType.numocts = pvalue->value.u.extElem1->numocts;
                    openType.data = pvalue->value.u.extElem1->data;
                } else {
                    /* No extension element to encode */
                }
                encoded = FALSE;
                break;
            }

            default:
                encoded = FALSE;
                stat = RTERR_INVOPT;
                break;
        } 

        if(encoded){
            openType.numocts = (OSUINT32)pe_GetMsgLen(pctxt);
            openType.data = pDynamicEncodeBuffer = pctxt -> buffer.data;
        }
        rtxCopyContext(pctxt, &lctxt);

        if(stat == 0) {
            stat = pe_OpenType (pctxt, openType.numocts, openType.data);
        }
    #if 1
        if(encoded){//dungnm23 check lai nhe
            rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
        }
    #endif

    }

    if(stat!=0) return LOG_RTERR(pctxt, stat);  
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}

EXTERN int  asn1PD_e2ap_RICassistanceFailure_protocolIEs_element (OSCTXT* pctxt, e2ap_RICassistanceFailure_protocolIEs_element* pvalue){
    int stat =0;

    /*decode id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PD_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PD_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");

    {
        OSUINT32 openTypeLen;
        size_t bitStartOffset, bitLength;

        stat = pd_UnconsLength(pctxt, &openTypeLen);
        if(stat<0) return LOG_RTERR(pctxt, stat);
        else if(stat == RT_OK_FRAG){
            rtxErrAddStrParm(pctxt, "open type with fragment length");
            return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
        }
        bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
        bitLength = openTypeLen * 8;

        switch(pvalue->id){//dungnm23 check case lai nhe
        
            case ASN1V_e2ap_id_RICrequestID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICassistanceFailure_IEs_id_RICrequestID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICrequestID");
                pvalue->value.u._e2ap_RICassistanceFailure_IEs_id_RICrequestID 
                    = rtxMemAllocType(pctxt, e2ap_RICrequestID);

                asn1Init_e2ap_RICrequestID(pvalue->value.u._e2ap_RICassistanceFailure_IEs_id_RICrequestID);

                stat = asn1PD_e2ap_RICrequestID (pctxt,
                        (e2ap_RICrequestID*)pvalue->value.
                        u._e2ap_RICassistanceFailure_IEs_id_RICrequestID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_Cause:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICassistanceFailure_IEs_id_Cause;
            RTXCTXTPUSHELEMNAME(pctxt, "id-Cause");
                pvalue->value.u._e2ap_RICassistanceFailure_IEs_id_Cause 
                    = rtxMemAllocType(pctxt, e2ap_Cause);

                asn1Init_e2ap_Cause(pvalue->value.u._e2ap_RICassistanceFailure_IEs_id_Cause);

                stat = asn1PD_e2ap_Cause (pctxt,
                        (e2ap_Cause*)pvalue->value.
                        u._e2ap_RICassistanceFailure_IEs_id_Cause);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_CriticalityDiagnostics:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICassistanceFailure_IEs_id_CriticalityDiagnostics;
            RTXCTXTPUSHELEMNAME(pctxt, "id-CriticalityDiagnostics");
                pvalue->value.u._e2ap_RICassistanceFailure_IEs_id_CriticalityDiagnostics 
                    = rtxMemAllocType(pctxt, e2ap_CriticalityDiagnostics);

                asn1Init_e2ap_CriticalityDiagnostics(pvalue->value.u._e2ap_RICassistanceFailure_IEs_id_CriticalityDiagnostics);

                stat = asn1PD_e2ap_CriticalityDiagnostics (pctxt,
                        (e2ap_CriticalityDiagnostics*)pvalue->value.
                        u._e2ap_RICassistanceFailure_IEs_id_CriticalityDiagnostics);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICassistanceFailure_IEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*) rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
    }
    {
    size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
    size_t bitsConsumed = bitEndOffset-bitStartOffset;
    if(bitsConsumed<bitLength){
        stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
    }
    else stat =(bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
    }}
    if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}


int asn1Init_e2ap_RICassistanceFailure_protocolIEs_element(e2ap_RICassistanceFailure_protocolIEs_element* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    OSCRTLMEMSET (&pvalue->value, 0, sizeof(pvalue->value));
    return 0;
}


//-----> chuaw có template rtxFreeASN1OpenType

#if 0
void asn1Free_e2ap_RICassistanceFailure_protocolIEs_element(OSCTXT* pctxt, e2ap_RICassistanceFailure_protocolIEs_element* pvalue)
{
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICassistanceFailure_IEs_id_id_RICrequestID:
            // rtxFreeE2ap_RICrequestID(pvalue->value.u._e2ap_RICassistanceFailure_IEs_id_id_RICrequestID);

            if(pvalue->value.i._e2ap_RICassistanceFailure_id_RICrequestID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICrequestID(pctxt, pvalue->value.u._e2ap_RICassistanceFailure_IEs_id_id_RICrequestID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICassistanceFailure_IEs_id_id_RICrequestID);
           // pvalue->value.u._e2ap_RICassistanceFailure_IEs_id_id_RICrequestID = NULL;
           pvalue->value.u._e2ap_RICassistanceFailure_IEs_id_RICrequestID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICassistanceFailure_IEs_id_id_Cause:
            // rtxFreeE2ap_Cause(pvalue->value.u._e2ap_RICassistanceFailure_IEs_id_id_Cause);

            if(pvalue->value.i._e2ap_RICassistanceFailure_id_Cause!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_Cause(pctxt, pvalue->value.u._e2ap_RICassistanceFailure_IEs_id_id_Cause);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICassistanceFailure_IEs_id_id_Cause);
           // pvalue->value.u._e2ap_RICassistanceFailure_IEs_id_id_Cause = NULL;
           pvalue->value.u._e2ap_RICassistanceFailure_IEs_id_Cause = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICassistanceFailure_IEs_id_id_CriticalityDiagnostics:
            // rtxFreeE2ap_CriticalityDiagnostics(pvalue->value.u._e2ap_RICassistanceFailure_IEs_id_id_CriticalityDiagnostics);

            if(pvalue->value.i._e2ap_RICassistanceFailure_id_CriticalityDiagnostics!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_CriticalityDiagnostics(pctxt, pvalue->value.u._e2ap_RICassistanceFailure_IEs_id_id_CriticalityDiagnostics);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICassistanceFailure_IEs_id_id_CriticalityDiagnostics);
           // pvalue->value.u._e2ap_RICassistanceFailure_IEs_id_id_CriticalityDiagnostics = NULL;
           pvalue->value.u._e2ap_RICassistanceFailure_IEs_id_CriticalityDiagnostics = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICassistanceFailure_IEs_UNDEF_:
            rtxFreeASN1OpenType(pvalue->value.u.extElem1);
            break;
        default:
            break;
    }
}

int asn1PrtToStr_e2ap_RICassistanceFailure_protocolIEs_element(OSCTXT* pctxt, e2ap_RICassistanceFailure_protocolIEs_element* pvalue)
{
    int stat =0;
    RTXCTXTPUSHELEMNAME(pctxt, "e2ap_RICassistanceFailure_protocolIEs_element");

    /*print id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PrtToStr_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PrtToStr_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_RICassistanceFailure_IEs_id_id_RICrequestID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICrequestID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICrequestID (pctxt, pvalue->value.u._e2ap_RICassistanceFailure_IEs_id_id_RICrequestID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICassistanceFailure_IEs_id_id_Cause:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "Cause");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_Cause (pctxt, pvalue->value.u._e2ap_RICassistanceFailure_IEs_id_id_Cause);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICassistanceFailure_IEs_id_id_CriticalityDiagnostics:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "CriticalityDiagnostics");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_CriticalityDiagnostics (pctxt, pvalue->value.u._e2ap_RICassistanceFailure_IEs_id_id_CriticalityDiagnostics);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_RICassistanceFailure_IEs_UNDEF_:
            {
                rtxPLogMsg(pctxt, "Extension element present - raw data not printed.\n");
                break;
            }

            default:
                stat = RTERR_INVOPT;
                return LOG_RTERR(pctxt, stat);
        }
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);
}
#endif


int asn1PrtToStr_e2ap_RICassistanceFailure_protocolIEs_element (const char * name,
 e2ap_RICassistanceFailure_protocolIEs_element* pvalue, 
 char * buffer, OSSIZE bufSize){
    if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
        return -1;
    if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
        return -1;

    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICassistanceFailure_IEs_id_RICrequestID:
            if(asn1PrtToStr_e2ap_RICrequestID("RICrequestID", 
                    pvalue->value.u._e2ap_RICassistanceFailure_IEs_id_RICrequestID, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICassistanceFailure_IEs_id_Cause:
            if(asn1PrtToStr_e2ap_Cause("Cause", 
                    pvalue->value.u._e2ap_RICassistanceFailure_IEs_id_Cause, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICassistanceFailure_IEs_id_CriticalityDiagnostics:
            if(asn1PrtToStr_e2ap_CriticalityDiagnostics("CriticalityDiagnostics", 
                    pvalue->value.u._e2ap_RICassistanceFailure_IEs_id_CriticalityDiagnostics, buffer, bufSize)<0)
                return -1;
            break;    
        default:
        if(0!=pvalue -> value.u.extElem1){
            rtPrintToStringIndent(buffer, bufSize);
            rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

        }
        }
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

    return 0;

 }

 void asn1Free_e2ap_RICassistanceFailure_protocolIEs_element(OSCTXT* pctxt, e2ap_RICassistanceFailure_protocolIEs_element* pvalue){
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICassistanceFailure_IEs_id_RICrequestID:
            if(pvalue->value.u._e2ap_RICassistanceFailure_IEs_id_RICrequestID!=NULL){
            asn1Free_e2ap_RICrequestID(pctxt, pvalue->value.u._e2ap_RICassistanceFailure_IEs_id_RICrequestID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICassistanceFailure_IEs_id_RICrequestID);
            pvalue->value.u._e2ap_RICassistanceFailure_IEs_id_RICrequestID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICassistanceFailure_IEs_id_Cause:
            if(pvalue->value.u._e2ap_RICassistanceFailure_IEs_id_Cause!=NULL){
            asn1Free_e2ap_Cause(pctxt, pvalue->value.u._e2ap_RICassistanceFailure_IEs_id_Cause);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICassistanceFailure_IEs_id_Cause);
            pvalue->value.u._e2ap_RICassistanceFailure_IEs_id_Cause = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICassistanceFailure_IEs_id_CriticalityDiagnostics:
            if(pvalue->value.u._e2ap_RICassistanceFailure_IEs_id_CriticalityDiagnostics!=NULL){
            asn1Free_e2ap_CriticalityDiagnostics(pctxt, pvalue->value.u._e2ap_RICassistanceFailure_IEs_id_CriticalityDiagnostics);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICassistanceFailure_IEs_id_CriticalityDiagnostics);
            pvalue->value.u._e2ap_RICassistanceFailure_IEs_id_CriticalityDiagnostics = NULL;
            }
            break;
        default:
            break;


    }
 }

 

/*****************************************/
/*           RICassistanceFailure                */
/*****************************************/
//2_container.c
/* 1. xxx_ProtocolIE -> mẫu cũ ở ie_big_msg */
EXTERN int asn1PE_e2ap_RICassistanceFailure_protocolIEs (OSCTXT* pctxt, e2ap_RICassistanceFailure_protocolIEs* pvalue)
{
    int stat =0;
    OSRTDListNode* pnode;
    OSUINT32 xx1;

    /*encode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pe_Length(pctxt, pvalue->count);
    if(stat<0) return LOG_RTERR(pctxt, stat);

    /*encode each element*/
    xx1 =0;
    for(pnode = pvalue->head; pnode != 0 && xx1<pvalue->count; pnode = pnode->next){
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE", xx1);
        stat = asn1PE_e2ap_RICassistanceFailure_protocolIEs_element (pctxt, ((e2ap_RICassistanceFailure_protocolIEs_element*)pnode->data));
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        xx1++;
        RTXCTXTPOPARRAYELEMNAME(pctxt);
    }

    return (stat);
}

EXTERN int  asn1PD_e2ap_RICassistanceFailure_protocolIEs(OSCTXT* pctxt, e2ap_RICassistanceFailure_protocolIEs* pvalue)
{
     int stat =0;
     OSRTDListNode* pnode;
     OSSIZE count =0;
     OSSIZE xx1=0;


     /*decode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pd_Length64(pctxt, &count); //tai sao lai 64
    if(stat!=0) return LOG_RTERR(pctxt, stat);

    /*decode each element*/
    rtxDListInit(pvalue);

    for(xx1=0; xx1 < count; xx1++){
        e2ap_RICassistanceFailure_protocolIEs_element* pdata;
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE",xx1);

        if(pnode == NULL) return LOG_RTERR(pctxt, RTERR_NOMEM);

        asn1Init_e2ap_RICassistanceFailure_protocolIEs_element(pdata);
        rtxDListAppendNode(pvalue, pnode);
        stat = asn1PD_e2ap_RICassistanceFailure_protocolIEs_element (pctxt, pdata);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        RTXCTXTPOPARRAYELEMNAME(pctxt);

    }
    return (stat);
}


int asn1Init_e2ap_RICassistanceFailure_protocolIEs(e2ap_RICassistanceFailure_protocolIEs* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    rtxDListFastInit (pvalue);
    return 0;
}
#if 1 //ao that day
void asn1Free_e2ap_RICassistanceFailure_protocolIEs(OSCTXT* pctxt, e2ap_RICassistanceFailure_protocolIEs* pvalue)
{
    if(0==pvalue) return;   
    e2ap_RICassistanceFailure_protocolIEs_element* pdata;
    OSRTDListNode* pnode=pvalue->head;
    while(0!=pnode){
        pdata = (e2ap_RICassistanceFailure_protocolIEs_element*)pnode->data;
       // asn1Free_e2ap_RICassistanceFailure_protocolIEs_element(pctxt, pdata);
        pnode = pnode->next;
    }
    rtxDListFreeAll(pctxt, pvalue);
}
#endif


EXTERN int asn1PrtToStr_e2ap_RICassistanceFailure_protocolIEs(const char* name, e2ap_RICassistanceFailure_protocolIEs* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_RICassistanceFailure_protocolIEs_element* pdata0;
    OSRTDListNode* pnode0;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode0 = pvalue->head;  xx1 < pvalue->count && pnode0 != 0; pnode0 = pnode0->next, xx1++){
        pdata0 = (e2ap_RICassistanceFailure_protocolIEs_element*)pnode0->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 0
        if(asn1PrtToStr_e2ap_RICassistanceFailure_protocolIEs_element(nameBuf, pdata0, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}


/*2 . RICassistanceFailure -> mẫu cũ ở seq_normal*/

int asn1PE_e2ap_RICassistanceFailure (OSCTXT* pctxt, e2ap_RICassistanceFailure* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RICassistanceFailure");
   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field protocolIEs - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
   stat = asn1PE_e2ap_RICassistanceFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
   if(stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RICassistanceFailure (OSCTXT* pctxt, e2ap_RICassistanceFailure* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME(pctxt, "RICassistanceFailure");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field protocolIEs */
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
      stat = asn1PD_e2ap_RICassistanceFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RICassistanceFailure (e2ap_RICassistanceFailure* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RICassistanceFailure_protocolIEs(&pvalue->protocolIEs);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RICassistanceFailure (OSCTXT* pctxt, e2ap_RICassistanceFailure* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_RICassistanceFailure_protocolIEs(pctxt, &pvalue->protocolIEs);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RICassistanceFailure (const char* name, e2ap_RICassistanceFailure* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }

   if(asn1PrtToStr_e2ap_RICassistanceFailure_protocolIEs("protocolIEs", &pvalue->protocolIEs, buffer, bufSize) <0){
      return -1;
   }

   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           RICassistanceSN                */
/*****************************************/
//6 mau integer
// mau integer size(a...b) mau la procedurecode
EXTERN int asn1PE_e2ap_RICassistanceSN (OSCTXT* pctxt, e2ap_RICassistanceSN value){
    int stat = 0;
    RTXCTCXTPUSHTYPENAME (pctxt, "RICassistanceSN");
    stat = pe_ConsUnsigned (pctxt, value, 0, 65535);
    if (stat != 0) return LOG_RTERR (pctxt, stat);
    RTXCTXTPOPTYPENAME (pctxt);
    return stat;
}
EXTERN int asn1PD_e2ap_RICassistanceSN (OSCTXT* pctxt, e2ap_RICassistanceSN* pvalue){
    int stat = 0;
    RTXCTCXTPUSHTYPENAME (pctxt, "RICassistanceSN");
    if(pctxt->buffer.aligned){
        int stat2 = PD_BYTE_ALIGN(pctxt);
        if(stat2 != 0) return LOG_RTERR (pctxt, stat2);
    }
    stat = rtxDecBitsToByte(pctxt, pvalue, 0);
    if (stat != 0) return LOG_RTERR (pctxt, stat);
    RTXCTXTPOPTYPENAME (pctxt);
    return stat;
}
//EXTERN int asn1Print_e2ap_RICassistanceSN (const char* name, const e2ap_RICassistanceSN* pvalue);
//EXTERN int asn1PrtToStr_e2ap_RICassistanceSN (const char* name, e2ap_RICassistanceSN* pvalue, char* buffer, OSSIZE bufSize);
//EXTERN int asn1PrtToStrm_e2ap_RICassistanceSN (OSCTXT* pctxt, const char* name, const e2ap_RICassistanceSN* pvalue);
EXTERN int asn1Init_e2ap_RICassistanceSN (e2ap_RICassistanceSN* pvalue){
    //if (pvalue == 0) return RTERR_NULLPTR;
    //*pvalue = 0;
    return 0;
}
EXTERN int asn1Free_e2ap_RICassistanceSN (OSCTXT* pctxt, e2ap_RICassistanceSN* pvalue){
    // No dynamic memory to free for integer
    return 0;
}
/*****************************************/
/*           RICassistanceHeader                */
/*****************************************/
//9 mau octet string
//type 9  mau la octet string no size mau la pdusessioncommonnetworkinstance

EXTERN int asn1PE_e2ap_RICassistanceHeader (OSCTXT* pctxt, e2ap_RICassistanceHeader value){
   int stat = 0
   RTXCTCXTPUSHTYPENAME (pctxt, "RICassistanceHeader");
   stat = pe_OctetString(pctxt, value.numocts, value.data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPTYPENAME (pctxt);

}
EXTERN int asn1PD_e2ap_RICassistanceHeader (OSCTXT* pctxt, e2ap_RICassistanceHeader* pvalue){
   int stat = 0;
   RTXCTCXTPUSHTYPENAME (pctxt, "RICassistanceHeader");
   stat = pd_DynOctetString(pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}
EXTERN int asn1PrtToStr_e2ap_RICassistanceHeader (const char* name, e2ap_RICassistanceHeader *pvalue, char* buffer, OSSIZE bufSize){
   if(rtPrintToStringIndent(buffer, bufSize) < 0) return -1;
   if(rtPrintToStringHexStr(name, pvalue->numocts, pvalue->data, buffer, bufSize) < 0) return -1;
   return 0;
}
EXTERN int asn1PrtToStrm_e2ap_RICassistanceHeader (OSCTXT* pctxt, const char* name, const e2ap_RICassistanceHeader* pvalue){
   int stat =0;
   stat = rtPrintToStreamIndent(pctxt);
   if(stat !=0) return LOG_RTERR(pctxt, stat);
   stat = rtPrintToStreamHexStr(pctxt, name, pvalue->numocts, pvalue->data);
   if(stat !=0) return LOG_RTERR(pctxt, stat);
   return stat;
}
//EXTERN int asn1Copy_e2ap_RICassistanceHeader (OSCTXT* pctxt, const e2ap_RICassistanceHeader* pSrcValue, e2ap_RICassistanceHeader* pDstValue);
 int asn1Init_e2ap_RICassistanceHeader (e2ap_RICassistanceHeader* pvalue){
   if (pvalue == 0) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   pvalue->data = 0;
   return 0;
}
 void asn1Free_e2ap_RICassistanceHeader (OSCTXT* pctxt, e2ap_RICassistanceHeader* pvalue){
   if (pvalue == 0) return;
   if(pvalue->numocts>0){
       rtxMemFreePtr(pctxt, (void*)pvalue->data);
       pvalue->data = 0;
       pvalue->numocts = 0;
   }
}
int asn1Init_e2ap_RICassistanceHeader (e2ap_RICassistanceHeader* pvalue){
   if (pvalue == 0) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   pvalue->data = 0;
   return 0;
}
/*****************************************/
/*           RICassistanceOutcome                */
/*****************************************/
//9 mau octet string
//type 9  mau la octet string no size mau la pdusessioncommonnetworkinstance

EXTERN int asn1PE_e2ap_RICassistanceOutcome (OSCTXT* pctxt, e2ap_RICassistanceOutcome value){
   int stat = 0
   RTXCTCXTPUSHTYPENAME (pctxt, "RICassistanceOutcome");
   stat = pe_OctetString(pctxt, value.numocts, value.data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPTYPENAME (pctxt);

}
EXTERN int asn1PD_e2ap_RICassistanceOutcome (OSCTXT* pctxt, e2ap_RICassistanceOutcome* pvalue){
   int stat = 0;
   RTXCTCXTPUSHTYPENAME (pctxt, "RICassistanceOutcome");
   stat = pd_DynOctetString(pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}
EXTERN int asn1PrtToStr_e2ap_RICassistanceOutcome (const char* name, e2ap_RICassistanceOutcome *pvalue, char* buffer, OSSIZE bufSize){
   if(rtPrintToStringIndent(buffer, bufSize) < 0) return -1;
   if(rtPrintToStringHexStr(name, pvalue->numocts, pvalue->data, buffer, bufSize) < 0) return -1;
   return 0;
}
EXTERN int asn1PrtToStrm_e2ap_RICassistanceOutcome (OSCTXT* pctxt, const char* name, const e2ap_RICassistanceOutcome* pvalue){
   int stat =0;
   stat = rtPrintToStreamIndent(pctxt);
   if(stat !=0) return LOG_RTERR(pctxt, stat);
   stat = rtPrintToStreamHexStr(pctxt, name, pvalue->numocts, pvalue->data);
   if(stat !=0) return LOG_RTERR(pctxt, stat);
   return stat;
}
//EXTERN int asn1Copy_e2ap_RICassistanceOutcome (OSCTXT* pctxt, const e2ap_RICassistanceOutcome* pSrcValue, e2ap_RICassistanceOutcome* pDstValue);
 int asn1Init_e2ap_RICassistanceOutcome (e2ap_RICassistanceOutcome* pvalue){
   if (pvalue == 0) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   pvalue->data = 0;
   return 0;
}
 void asn1Free_e2ap_RICassistanceOutcome (OSCTXT* pctxt, e2ap_RICassistanceOutcome* pvalue){
   if (pvalue == 0) return;
   if(pvalue->numocts>0){
       rtxMemFreePtr(pctxt, (void*)pvalue->data);
       pvalue->data = 0;
       pvalue->numocts = 0;
   }
}
int asn1Init_e2ap_RICassistanceOutcome (e2ap_RICassistanceOutcome* pvalue){
   if (pvalue == 0) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   pvalue->data = 0;
   return 0;
}
/*****************************************/
/*           RICassistanceIndication_IEs                */
/*****************************************/
/* ie.c.j2 */
 /* d là con của msg */
EXTERN int asn1PE_e2ap_RICassistanceIndication_protocolIEs_element (OSCTXT* pctxt, e2ap_RICassistanceIndication_protocolIEs_element* pvalue)
{
    int stat =0;

    /*encode id*/

    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PE_e2ap_ProtocolIE_ID(pctxt, pvalue->id);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PE_e2ap_Criticality(pctxt, pvalue->criticality);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
    {
        OSCTXT lctxt;
        OSOCTET *pDynamicEncodeBuffer;
        ASN1OpenType openType;
        OSBOOL encoded = TRUE;

        openType.numocts = 0;
        openType.data =0;

        rtxCopyContext(&lctxt, pctxt);
        pctxt->pStream =0;

        stat = rtxInitContextBuffer(pctxt, 0, 0);
        if(stat!=0) return LOG_RTERR(pctxt, stat);

        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_RICassistanceIndication_IEs_id_RICrequestID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICrequestID");
                    stat = asn1PE_e2ap_RICrequestID (pctxt, pvalue->value.u._e2ap_RICassistanceIndication_IEs_id_RICrequestID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICassistanceIndication_IEs_id_RICassistanceSN:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICassistanceSN");
                    stat = asn1PE_e2ap_RICassistanceSN (pctxt, pvalue->value.u._e2ap_RICassistanceIndication_IEs_id_RICassistanceSN);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICassistanceIndication_IEs_id_RICassistanceHeader:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICassistanceHeader");
                    stat = asn1PE_e2ap_RICassistanceHeader (pctxt, pvalue->value.u._e2ap_RICassistanceIndication_IEs_id_RICassistanceHeader);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICassistanceIndication_IEs_id_RICassistanceOutcome:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICassistanceOutcome");
                    stat = asn1PE_e2ap_RICassistanceOutcome (pctxt, pvalue->value.u._e2ap_RICassistanceIndication_IEs_id_RICassistanceOutcome);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_RICassistanceIndication_IEs_UNDEF_:
            {
                if(0!=pvalue->value.u.extElem1){
                    openType.numocts = pvalue->value.u.extElem1->numocts;
                    openType.data = pvalue->value.u.extElem1->data;
                } else {
                    /* No extension element to encode */
                }
                encoded = FALSE;
                break;
            }

            default:
                encoded = FALSE;
                stat = RTERR_INVOPT;
                break;
        } 

        if(encoded){
            openType.numocts = (OSUINT32)pe_GetMsgLen(pctxt);
            openType.data = pDynamicEncodeBuffer = pctxt -> buffer.data;
        }
        rtxCopyContext(pctxt, &lctxt);

        if(stat == 0) {
            stat = pe_OpenType (pctxt, openType.numocts, openType.data);
        }
    #if 1
        if(encoded){//dungnm23 check lai nhe
            rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
        }
    #endif

    }

    if(stat!=0) return LOG_RTERR(pctxt, stat);  
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}

EXTERN int  asn1PD_e2ap_RICassistanceIndication_protocolIEs_element (OSCTXT* pctxt, e2ap_RICassistanceIndication_protocolIEs_element* pvalue){
    int stat =0;

    /*decode id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PD_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PD_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");

    {
        OSUINT32 openTypeLen;
        size_t bitStartOffset, bitLength;

        stat = pd_UnconsLength(pctxt, &openTypeLen);
        if(stat<0) return LOG_RTERR(pctxt, stat);
        else if(stat == RT_OK_FRAG){
            rtxErrAddStrParm(pctxt, "open type with fragment length");
            return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
        }
        bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
        bitLength = openTypeLen * 8;

        switch(pvalue->id){//dungnm23 check case lai nhe
        
            case ASN1V_e2ap_id_RICrequestID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICassistanceIndication_IEs_id_RICrequestID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICrequestID");
                pvalue->value.u._e2ap_RICassistanceIndication_IEs_id_RICrequestID 
                    = rtxMemAllocType(pctxt, e2ap_RICrequestID);

                asn1Init_e2ap_RICrequestID(pvalue->value.u._e2ap_RICassistanceIndication_IEs_id_RICrequestID);

                stat = asn1PD_e2ap_RICrequestID (pctxt,
                        (e2ap_RICrequestID*)pvalue->value.
                        u._e2ap_RICassistanceIndication_IEs_id_RICrequestID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RICassistanceSN:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICassistanceIndication_IEs_id_RICassistanceSN;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICassistanceSN");
                pvalue->value.u._e2ap_RICassistanceIndication_IEs_id_RICassistanceSN 
                    = rtxMemAllocType(pctxt, e2ap_RICassistanceSN);

                asn1Init_e2ap_RICassistanceSN(pvalue->value.u._e2ap_RICassistanceIndication_IEs_id_RICassistanceSN);

                stat = asn1PD_e2ap_RICassistanceSN (pctxt,
                        (e2ap_RICassistanceSN*)pvalue->value.
                        u._e2ap_RICassistanceIndication_IEs_id_RICassistanceSN);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RICassistanceHeader:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICassistanceIndication_IEs_id_RICassistanceHeader;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICassistanceHeader");
                pvalue->value.u._e2ap_RICassistanceIndication_IEs_id_RICassistanceHeader 
                    = rtxMemAllocType(pctxt, e2ap_RICassistanceHeader);

                asn1Init_e2ap_RICassistanceHeader(pvalue->value.u._e2ap_RICassistanceIndication_IEs_id_RICassistanceHeader);

                stat = asn1PD_e2ap_RICassistanceHeader (pctxt,
                        (e2ap_RICassistanceHeader*)pvalue->value.
                        u._e2ap_RICassistanceIndication_IEs_id_RICassistanceHeader);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RICassistanceOutcome:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICassistanceIndication_IEs_id_RICassistanceOutcome;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICassistanceOutcome");
                pvalue->value.u._e2ap_RICassistanceIndication_IEs_id_RICassistanceOutcome 
                    = rtxMemAllocType(pctxt, e2ap_RICassistanceOutcome);

                asn1Init_e2ap_RICassistanceOutcome(pvalue->value.u._e2ap_RICassistanceIndication_IEs_id_RICassistanceOutcome);

                stat = asn1PD_e2ap_RICassistanceOutcome (pctxt,
                        (e2ap_RICassistanceOutcome*)pvalue->value.
                        u._e2ap_RICassistanceIndication_IEs_id_RICassistanceOutcome);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICassistanceIndication_IEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*) rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
    }
    {
    size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
    size_t bitsConsumed = bitEndOffset-bitStartOffset;
    if(bitsConsumed<bitLength){
        stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
    }
    else stat =(bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
    }}
    if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}


int asn1Init_e2ap_RICassistanceIndication_protocolIEs_element(e2ap_RICassistanceIndication_protocolIEs_element* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    OSCRTLMEMSET (&pvalue->value, 0, sizeof(pvalue->value));
    return 0;
}


//-----> chuaw có template rtxFreeASN1OpenType

#if 0
void asn1Free_e2ap_RICassistanceIndication_protocolIEs_element(OSCTXT* pctxt, e2ap_RICassistanceIndication_protocolIEs_element* pvalue)
{
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICassistanceIndication_IEs_id_id_RICrequestID:
            // rtxFreeE2ap_RICrequestID(pvalue->value.u._e2ap_RICassistanceIndication_IEs_id_id_RICrequestID);

            if(pvalue->value.i._e2ap_RICassistanceIndication_id_RICrequestID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICrequestID(pctxt, pvalue->value.u._e2ap_RICassistanceIndication_IEs_id_id_RICrequestID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICassistanceIndication_IEs_id_id_RICrequestID);
           // pvalue->value.u._e2ap_RICassistanceIndication_IEs_id_id_RICrequestID = NULL;
           pvalue->value.u._e2ap_RICassistanceIndication_IEs_id_RICrequestID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICassistanceIndication_IEs_id_id_RICassistanceSN:
            // rtxFreeE2ap_RICassistanceSN(pvalue->value.u._e2ap_RICassistanceIndication_IEs_id_id_RICassistanceSN);

            if(pvalue->value.i._e2ap_RICassistanceIndication_id_RICassistanceSN!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICassistanceSN(pctxt, pvalue->value.u._e2ap_RICassistanceIndication_IEs_id_id_RICassistanceSN);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICassistanceIndication_IEs_id_id_RICassistanceSN);
           // pvalue->value.u._e2ap_RICassistanceIndication_IEs_id_id_RICassistanceSN = NULL;
           pvalue->value.u._e2ap_RICassistanceIndication_IEs_id_RICassistanceSN = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICassistanceIndication_IEs_id_id_RICassistanceHeader:
            // rtxFreeE2ap_RICassistanceHeader(pvalue->value.u._e2ap_RICassistanceIndication_IEs_id_id_RICassistanceHeader);

            if(pvalue->value.i._e2ap_RICassistanceIndication_id_RICassistanceHeader!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICassistanceHeader(pctxt, pvalue->value.u._e2ap_RICassistanceIndication_IEs_id_id_RICassistanceHeader);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICassistanceIndication_IEs_id_id_RICassistanceHeader);
           // pvalue->value.u._e2ap_RICassistanceIndication_IEs_id_id_RICassistanceHeader = NULL;
           pvalue->value.u._e2ap_RICassistanceIndication_IEs_id_RICassistanceHeader = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICassistanceIndication_IEs_id_id_RICassistanceOutcome:
            // rtxFreeE2ap_RICassistanceOutcome(pvalue->value.u._e2ap_RICassistanceIndication_IEs_id_id_RICassistanceOutcome);

            if(pvalue->value.i._e2ap_RICassistanceIndication_id_RICassistanceOutcome!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICassistanceOutcome(pctxt, pvalue->value.u._e2ap_RICassistanceIndication_IEs_id_id_RICassistanceOutcome);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICassistanceIndication_IEs_id_id_RICassistanceOutcome);
           // pvalue->value.u._e2ap_RICassistanceIndication_IEs_id_id_RICassistanceOutcome = NULL;
           pvalue->value.u._e2ap_RICassistanceIndication_IEs_id_RICassistanceOutcome = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICassistanceIndication_IEs_UNDEF_:
            rtxFreeASN1OpenType(pvalue->value.u.extElem1);
            break;
        default:
            break;
    }
}

int asn1PrtToStr_e2ap_RICassistanceIndication_protocolIEs_element(OSCTXT* pctxt, e2ap_RICassistanceIndication_protocolIEs_element* pvalue)
{
    int stat =0;
    RTXCTXTPUSHELEMNAME(pctxt, "e2ap_RICassistanceIndication_protocolIEs_element");

    /*print id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PrtToStr_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PrtToStr_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_RICassistanceIndication_IEs_id_id_RICrequestID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICrequestID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICrequestID (pctxt, pvalue->value.u._e2ap_RICassistanceIndication_IEs_id_id_RICrequestID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICassistanceIndication_IEs_id_id_RICassistanceSN:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICassistanceSN");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICassistanceSN (pctxt, pvalue->value.u._e2ap_RICassistanceIndication_IEs_id_id_RICassistanceSN);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICassistanceIndication_IEs_id_id_RICassistanceHeader:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICassistanceHeader");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICassistanceHeader (pctxt, pvalue->value.u._e2ap_RICassistanceIndication_IEs_id_id_RICassistanceHeader);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICassistanceIndication_IEs_id_id_RICassistanceOutcome:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICassistanceOutcome");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICassistanceOutcome (pctxt, pvalue->value.u._e2ap_RICassistanceIndication_IEs_id_id_RICassistanceOutcome);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_RICassistanceIndication_IEs_UNDEF_:
            {
                rtxPLogMsg(pctxt, "Extension element present - raw data not printed.\n");
                break;
            }

            default:
                stat = RTERR_INVOPT;
                return LOG_RTERR(pctxt, stat);
        }
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);
}
#endif


int asn1PrtToStr_e2ap_RICassistanceIndication_protocolIEs_element (const char * name,
 e2ap_RICassistanceIndication_protocolIEs_element* pvalue, 
 char * buffer, OSSIZE bufSize){
    if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
        return -1;
    if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
        return -1;

    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICassistanceIndication_IEs_id_RICrequestID:
            if(asn1PrtToStr_e2ap_RICrequestID("RICrequestID", 
                    pvalue->value.u._e2ap_RICassistanceIndication_IEs_id_RICrequestID, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICassistanceIndication_IEs_id_RICassistanceSN:
            if(asn1PrtToStr_e2ap_RICassistanceSN("RICassistanceSN", 
                    pvalue->value.u._e2ap_RICassistanceIndication_IEs_id_RICassistanceSN, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICassistanceIndication_IEs_id_RICassistanceHeader:
            if(asn1PrtToStr_e2ap_RICassistanceHeader("RICassistanceHeader", 
                    pvalue->value.u._e2ap_RICassistanceIndication_IEs_id_RICassistanceHeader, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICassistanceIndication_IEs_id_RICassistanceOutcome:
            if(asn1PrtToStr_e2ap_RICassistanceOutcome("RICassistanceOutcome", 
                    pvalue->value.u._e2ap_RICassistanceIndication_IEs_id_RICassistanceOutcome, buffer, bufSize)<0)
                return -1;
            break;    
        default:
        if(0!=pvalue -> value.u.extElem1){
            rtPrintToStringIndent(buffer, bufSize);
            rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

        }
        }
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

    return 0;

 }

 void asn1Free_e2ap_RICassistanceIndication_protocolIEs_element(OSCTXT* pctxt, e2ap_RICassistanceIndication_protocolIEs_element* pvalue){
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICassistanceIndication_IEs_id_RICrequestID:
            if(pvalue->value.u._e2ap_RICassistanceIndication_IEs_id_RICrequestID!=NULL){
            asn1Free_e2ap_RICrequestID(pctxt, pvalue->value.u._e2ap_RICassistanceIndication_IEs_id_RICrequestID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICassistanceIndication_IEs_id_RICrequestID);
            pvalue->value.u._e2ap_RICassistanceIndication_IEs_id_RICrequestID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICassistanceIndication_IEs_id_RICassistanceSN:
            if(pvalue->value.u._e2ap_RICassistanceIndication_IEs_id_RICassistanceSN!=NULL){
            asn1Free_e2ap_RICassistanceSN(pctxt, pvalue->value.u._e2ap_RICassistanceIndication_IEs_id_RICassistanceSN);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICassistanceIndication_IEs_id_RICassistanceSN);
            pvalue->value.u._e2ap_RICassistanceIndication_IEs_id_RICassistanceSN = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICassistanceIndication_IEs_id_RICassistanceHeader:
            if(pvalue->value.u._e2ap_RICassistanceIndication_IEs_id_RICassistanceHeader!=NULL){
            asn1Free_e2ap_RICassistanceHeader(pctxt, pvalue->value.u._e2ap_RICassistanceIndication_IEs_id_RICassistanceHeader);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICassistanceIndication_IEs_id_RICassistanceHeader);
            pvalue->value.u._e2ap_RICassistanceIndication_IEs_id_RICassistanceHeader = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICassistanceIndication_IEs_id_RICassistanceOutcome:
            if(pvalue->value.u._e2ap_RICassistanceIndication_IEs_id_RICassistanceOutcome!=NULL){
            asn1Free_e2ap_RICassistanceOutcome(pctxt, pvalue->value.u._e2ap_RICassistanceIndication_IEs_id_RICassistanceOutcome);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICassistanceIndication_IEs_id_RICassistanceOutcome);
            pvalue->value.u._e2ap_RICassistanceIndication_IEs_id_RICassistanceOutcome = NULL;
            }
            break;
        default:
            break;


    }
 }

 

/*****************************************/
/*           RICassistanceIndication                */
/*****************************************/
//2_container.c
/* 1. xxx_ProtocolIE -> mẫu cũ ở ie_big_msg */
EXTERN int asn1PE_e2ap_RICassistanceIndication_protocolIEs (OSCTXT* pctxt, e2ap_RICassistanceIndication_protocolIEs* pvalue)
{
    int stat =0;
    OSRTDListNode* pnode;
    OSUINT32 xx1;

    /*encode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pe_Length(pctxt, pvalue->count);
    if(stat<0) return LOG_RTERR(pctxt, stat);

    /*encode each element*/
    xx1 =0;
    for(pnode = pvalue->head; pnode != 0 && xx1<pvalue->count; pnode = pnode->next){
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE", xx1);
        stat = asn1PE_e2ap_RICassistanceIndication_protocolIEs_element (pctxt, ((e2ap_RICassistanceIndication_protocolIEs_element*)pnode->data));
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        xx1++;
        RTXCTXTPOPARRAYELEMNAME(pctxt);
    }

    return (stat);
}

EXTERN int  asn1PD_e2ap_RICassistanceIndication_protocolIEs(OSCTXT* pctxt, e2ap_RICassistanceIndication_protocolIEs* pvalue)
{
     int stat =0;
     OSRTDListNode* pnode;
     OSSIZE count =0;
     OSSIZE xx1=0;


     /*decode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pd_Length64(pctxt, &count); //tai sao lai 64
    if(stat!=0) return LOG_RTERR(pctxt, stat);

    /*decode each element*/
    rtxDListInit(pvalue);

    for(xx1=0; xx1 < count; xx1++){
        e2ap_RICassistanceIndication_protocolIEs_element* pdata;
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE",xx1);

        if(pnode == NULL) return LOG_RTERR(pctxt, RTERR_NOMEM);

        asn1Init_e2ap_RICassistanceIndication_protocolIEs_element(pdata);
        rtxDListAppendNode(pvalue, pnode);
        stat = asn1PD_e2ap_RICassistanceIndication_protocolIEs_element (pctxt, pdata);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        RTXCTXTPOPARRAYELEMNAME(pctxt);

    }
    return (stat);
}


int asn1Init_e2ap_RICassistanceIndication_protocolIEs(e2ap_RICassistanceIndication_protocolIEs* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    rtxDListFastInit (pvalue);
    return 0;
}
#if 1 //ao that day
void asn1Free_e2ap_RICassistanceIndication_protocolIEs(OSCTXT* pctxt, e2ap_RICassistanceIndication_protocolIEs* pvalue)
{
    if(0==pvalue) return;   
    e2ap_RICassistanceIndication_protocolIEs_element* pdata;
    OSRTDListNode* pnode=pvalue->head;
    while(0!=pnode){
        pdata = (e2ap_RICassistanceIndication_protocolIEs_element*)pnode->data;
       // asn1Free_e2ap_RICassistanceIndication_protocolIEs_element(pctxt, pdata);
        pnode = pnode->next;
    }
    rtxDListFreeAll(pctxt, pvalue);
}
#endif


EXTERN int asn1PrtToStr_e2ap_RICassistanceIndication_protocolIEs(const char* name, e2ap_RICassistanceIndication_protocolIEs* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_RICassistanceIndication_protocolIEs_element* pdata0;
    OSRTDListNode* pnode0;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode0 = pvalue->head;  xx1 < pvalue->count && pnode0 != 0; pnode0 = pnode0->next, xx1++){
        pdata0 = (e2ap_RICassistanceIndication_protocolIEs_element*)pnode0->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 0
        if(asn1PrtToStr_e2ap_RICassistanceIndication_protocolIEs_element(nameBuf, pdata0, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}


/*2 . RICassistanceIndication -> mẫu cũ ở seq_normal*/

int asn1PE_e2ap_RICassistanceIndication (OSCTXT* pctxt, e2ap_RICassistanceIndication* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RICassistanceIndication");
   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field protocolIEs - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
   stat = asn1PE_e2ap_RICassistanceIndication_protocolIEs (pctxt, &pvalue->protocolIEs);
   if(stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RICassistanceIndication (OSCTXT* pctxt, e2ap_RICassistanceIndication* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME(pctxt, "RICassistanceIndication");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field protocolIEs */
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
      stat = asn1PD_e2ap_RICassistanceIndication_protocolIEs (pctxt, &pvalue->protocolIEs);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RICassistanceIndication (e2ap_RICassistanceIndication* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RICassistanceIndication_protocolIEs(&pvalue->protocolIEs);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RICassistanceIndication (OSCTXT* pctxt, e2ap_RICassistanceIndication* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_RICassistanceIndication_protocolIEs(pctxt, &pvalue->protocolIEs);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RICassistanceIndication (const char* name, e2ap_RICassistanceIndication* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }

   if(asn1PrtToStr_e2ap_RICassistanceIndication_protocolIEs("protocolIEs", &pvalue->protocolIEs, buffer, bufSize) <0){
      return -1;
   }

   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           RICassistanceHalt_IEs                */
/*****************************************/
/* ie.c.j2 */
 /* d là con của msg */
EXTERN int asn1PE_e2ap_RICassistanceHalt_protocolIEs_element (OSCTXT* pctxt, e2ap_RICassistanceHalt_protocolIEs_element* pvalue)
{
    int stat =0;

    /*encode id*/

    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PE_e2ap_ProtocolIE_ID(pctxt, pvalue->id);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PE_e2ap_Criticality(pctxt, pvalue->criticality);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
    {
        OSCTXT lctxt;
        OSOCTET *pDynamicEncodeBuffer;
        ASN1OpenType openType;
        OSBOOL encoded = TRUE;

        openType.numocts = 0;
        openType.data =0;

        rtxCopyContext(&lctxt, pctxt);
        pctxt->pStream =0;

        stat = rtxInitContextBuffer(pctxt, 0, 0);
        if(stat!=0) return LOG_RTERR(pctxt, stat);

        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_RICassistanceHalt_IEs_id_RICrequestID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICrequestID");
                    stat = asn1PE_e2ap_RICrequestID (pctxt, pvalue->value.u._e2ap_RICassistanceHalt_IEs_id_RICrequestID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_RICassistanceHalt_IEs_UNDEF_:
            {
                if(0!=pvalue->value.u.extElem1){
                    openType.numocts = pvalue->value.u.extElem1->numocts;
                    openType.data = pvalue->value.u.extElem1->data;
                } else {
                    /* No extension element to encode */
                }
                encoded = FALSE;
                break;
            }

            default:
                encoded = FALSE;
                stat = RTERR_INVOPT;
                break;
        } 

        if(encoded){
            openType.numocts = (OSUINT32)pe_GetMsgLen(pctxt);
            openType.data = pDynamicEncodeBuffer = pctxt -> buffer.data;
        }
        rtxCopyContext(pctxt, &lctxt);

        if(stat == 0) {
            stat = pe_OpenType (pctxt, openType.numocts, openType.data);
        }
    #if 1
        if(encoded){//dungnm23 check lai nhe
            rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
        }
    #endif

    }

    if(stat!=0) return LOG_RTERR(pctxt, stat);  
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}

EXTERN int  asn1PD_e2ap_RICassistanceHalt_protocolIEs_element (OSCTXT* pctxt, e2ap_RICassistanceHalt_protocolIEs_element* pvalue){
    int stat =0;

    /*decode id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PD_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PD_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");

    {
        OSUINT32 openTypeLen;
        size_t bitStartOffset, bitLength;

        stat = pd_UnconsLength(pctxt, &openTypeLen);
        if(stat<0) return LOG_RTERR(pctxt, stat);
        else if(stat == RT_OK_FRAG){
            rtxErrAddStrParm(pctxt, "open type with fragment length");
            return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
        }
        bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
        bitLength = openTypeLen * 8;

        switch(pvalue->id){//dungnm23 check case lai nhe
        
            case ASN1V_e2ap_id_RICrequestID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICassistanceHalt_IEs_id_RICrequestID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICrequestID");
                pvalue->value.u._e2ap_RICassistanceHalt_IEs_id_RICrequestID 
                    = rtxMemAllocType(pctxt, e2ap_RICrequestID);

                asn1Init_e2ap_RICrequestID(pvalue->value.u._e2ap_RICassistanceHalt_IEs_id_RICrequestID);

                stat = asn1PD_e2ap_RICrequestID (pctxt,
                        (e2ap_RICrequestID*)pvalue->value.
                        u._e2ap_RICassistanceHalt_IEs_id_RICrequestID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICassistanceHalt_IEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*) rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
    }
    {
    size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
    size_t bitsConsumed = bitEndOffset-bitStartOffset;
    if(bitsConsumed<bitLength){
        stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
    }
    else stat =(bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
    }}
    if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}


int asn1Init_e2ap_RICassistanceHalt_protocolIEs_element(e2ap_RICassistanceHalt_protocolIEs_element* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    OSCRTLMEMSET (&pvalue->value, 0, sizeof(pvalue->value));
    return 0;
}


//-----> chuaw có template rtxFreeASN1OpenType

#if 0
void asn1Free_e2ap_RICassistanceHalt_protocolIEs_element(OSCTXT* pctxt, e2ap_RICassistanceHalt_protocolIEs_element* pvalue)
{
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICassistanceHalt_IEs_id_id_RICrequestID:
            // rtxFreeE2ap_RICrequestID(pvalue->value.u._e2ap_RICassistanceHalt_IEs_id_id_RICrequestID);

            if(pvalue->value.i._e2ap_RICassistanceHalt_id_RICrequestID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICrequestID(pctxt, pvalue->value.u._e2ap_RICassistanceHalt_IEs_id_id_RICrequestID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICassistanceHalt_IEs_id_id_RICrequestID);
           // pvalue->value.u._e2ap_RICassistanceHalt_IEs_id_id_RICrequestID = NULL;
           pvalue->value.u._e2ap_RICassistanceHalt_IEs_id_RICrequestID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICassistanceHalt_IEs_UNDEF_:
            rtxFreeASN1OpenType(pvalue->value.u.extElem1);
            break;
        default:
            break;
    }
}

int asn1PrtToStr_e2ap_RICassistanceHalt_protocolIEs_element(OSCTXT* pctxt, e2ap_RICassistanceHalt_protocolIEs_element* pvalue)
{
    int stat =0;
    RTXCTXTPUSHELEMNAME(pctxt, "e2ap_RICassistanceHalt_protocolIEs_element");

    /*print id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PrtToStr_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PrtToStr_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_RICassistanceHalt_IEs_id_id_RICrequestID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICrequestID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICrequestID (pctxt, pvalue->value.u._e2ap_RICassistanceHalt_IEs_id_id_RICrequestID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_RICassistanceHalt_IEs_UNDEF_:
            {
                rtxPLogMsg(pctxt, "Extension element present - raw data not printed.\n");
                break;
            }

            default:
                stat = RTERR_INVOPT;
                return LOG_RTERR(pctxt, stat);
        }
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);
}
#endif


int asn1PrtToStr_e2ap_RICassistanceHalt_protocolIEs_element (const char * name,
 e2ap_RICassistanceHalt_protocolIEs_element* pvalue, 
 char * buffer, OSSIZE bufSize){
    if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
        return -1;
    if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
        return -1;

    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICassistanceHalt_IEs_id_RICrequestID:
            if(asn1PrtToStr_e2ap_RICrequestID("RICrequestID", 
                    pvalue->value.u._e2ap_RICassistanceHalt_IEs_id_RICrequestID, buffer, bufSize)<0)
                return -1;
            break;    
        default:
        if(0!=pvalue -> value.u.extElem1){
            rtPrintToStringIndent(buffer, bufSize);
            rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

        }
        }
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

    return 0;

 }

 void asn1Free_e2ap_RICassistanceHalt_protocolIEs_element(OSCTXT* pctxt, e2ap_RICassistanceHalt_protocolIEs_element* pvalue){
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICassistanceHalt_IEs_id_RICrequestID:
            if(pvalue->value.u._e2ap_RICassistanceHalt_IEs_id_RICrequestID!=NULL){
            asn1Free_e2ap_RICrequestID(pctxt, pvalue->value.u._e2ap_RICassistanceHalt_IEs_id_RICrequestID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICassistanceHalt_IEs_id_RICrequestID);
            pvalue->value.u._e2ap_RICassistanceHalt_IEs_id_RICrequestID = NULL;
            }
            break;
        default:
            break;


    }
 }

 

/*****************************************/
/*           RICassistanceHalt                */
/*****************************************/
//2_container.c
/* 1. xxx_ProtocolIE -> mẫu cũ ở ie_big_msg */
EXTERN int asn1PE_e2ap_RICassistanceHalt_protocolIEs (OSCTXT* pctxt, e2ap_RICassistanceHalt_protocolIEs* pvalue)
{
    int stat =0;
    OSRTDListNode* pnode;
    OSUINT32 xx1;

    /*encode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pe_Length(pctxt, pvalue->count);
    if(stat<0) return LOG_RTERR(pctxt, stat);

    /*encode each element*/
    xx1 =0;
    for(pnode = pvalue->head; pnode != 0 && xx1<pvalue->count; pnode = pnode->next){
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE", xx1);
        stat = asn1PE_e2ap_RICassistanceHalt_protocolIEs_element (pctxt, ((e2ap_RICassistanceHalt_protocolIEs_element*)pnode->data));
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        xx1++;
        RTXCTXTPOPARRAYELEMNAME(pctxt);
    }

    return (stat);
}

EXTERN int  asn1PD_e2ap_RICassistanceHalt_protocolIEs(OSCTXT* pctxt, e2ap_RICassistanceHalt_protocolIEs* pvalue)
{
     int stat =0;
     OSRTDListNode* pnode;
     OSSIZE count =0;
     OSSIZE xx1=0;


     /*decode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pd_Length64(pctxt, &count); //tai sao lai 64
    if(stat!=0) return LOG_RTERR(pctxt, stat);

    /*decode each element*/
    rtxDListInit(pvalue);

    for(xx1=0; xx1 < count; xx1++){
        e2ap_RICassistanceHalt_protocolIEs_element* pdata;
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE",xx1);

        if(pnode == NULL) return LOG_RTERR(pctxt, RTERR_NOMEM);

        asn1Init_e2ap_RICassistanceHalt_protocolIEs_element(pdata);
        rtxDListAppendNode(pvalue, pnode);
        stat = asn1PD_e2ap_RICassistanceHalt_protocolIEs_element (pctxt, pdata);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        RTXCTXTPOPARRAYELEMNAME(pctxt);

    }
    return (stat);
}


int asn1Init_e2ap_RICassistanceHalt_protocolIEs(e2ap_RICassistanceHalt_protocolIEs* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    rtxDListFastInit (pvalue);
    return 0;
}
#if 1 //ao that day
void asn1Free_e2ap_RICassistanceHalt_protocolIEs(OSCTXT* pctxt, e2ap_RICassistanceHalt_protocolIEs* pvalue)
{
    if(0==pvalue) return;   
    e2ap_RICassistanceHalt_protocolIEs_element* pdata;
    OSRTDListNode* pnode=pvalue->head;
    while(0!=pnode){
        pdata = (e2ap_RICassistanceHalt_protocolIEs_element*)pnode->data;
       // asn1Free_e2ap_RICassistanceHalt_protocolIEs_element(pctxt, pdata);
        pnode = pnode->next;
    }
    rtxDListFreeAll(pctxt, pvalue);
}
#endif


EXTERN int asn1PrtToStr_e2ap_RICassistanceHalt_protocolIEs(const char* name, e2ap_RICassistanceHalt_protocolIEs* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_RICassistanceHalt_protocolIEs_element* pdata0;
    OSRTDListNode* pnode0;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode0 = pvalue->head;  xx1 < pvalue->count && pnode0 != 0; pnode0 = pnode0->next, xx1++){
        pdata0 = (e2ap_RICassistanceHalt_protocolIEs_element*)pnode0->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 0
        if(asn1PrtToStr_e2ap_RICassistanceHalt_protocolIEs_element(nameBuf, pdata0, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}


/*2 . RICassistanceHalt -> mẫu cũ ở seq_normal*/

int asn1PE_e2ap_RICassistanceHalt (OSCTXT* pctxt, e2ap_RICassistanceHalt* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RICassistanceHalt");
   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field protocolIEs - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
   stat = asn1PE_e2ap_RICassistanceHalt_protocolIEs (pctxt, &pvalue->protocolIEs);
   if(stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RICassistanceHalt (OSCTXT* pctxt, e2ap_RICassistanceHalt* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME(pctxt, "RICassistanceHalt");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field protocolIEs */
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
      stat = asn1PD_e2ap_RICassistanceHalt_protocolIEs (pctxt, &pvalue->protocolIEs);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RICassistanceHalt (e2ap_RICassistanceHalt* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RICassistanceHalt_protocolIEs(&pvalue->protocolIEs);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RICassistanceHalt (OSCTXT* pctxt, e2ap_RICassistanceHalt* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_RICassistanceHalt_protocolIEs(pctxt, &pvalue->protocolIEs);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RICassistanceHalt (const char* name, e2ap_RICassistanceHalt* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }

   if(asn1PrtToStr_e2ap_RICassistanceHalt_protocolIEs("protocolIEs", &pvalue->protocolIEs, buffer, bufSize) <0){
      return -1;
   }

   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           RICassistanceMessage                */
/*****************************************/
//9 mau octet string
//type 9  mau la octet string no size mau la pdusessioncommonnetworkinstance

EXTERN int asn1PE_e2ap_RICassistanceMessage (OSCTXT* pctxt, e2ap_RICassistanceMessage value){
   int stat = 0
   RTXCTCXTPUSHTYPENAME (pctxt, "RICassistanceMessage");
   stat = pe_OctetString(pctxt, value.numocts, value.data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPTYPENAME (pctxt);

}
EXTERN int asn1PD_e2ap_RICassistanceMessage (OSCTXT* pctxt, e2ap_RICassistanceMessage* pvalue){
   int stat = 0;
   RTXCTCXTPUSHTYPENAME (pctxt, "RICassistanceMessage");
   stat = pd_DynOctetString(pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}
EXTERN int asn1PrtToStr_e2ap_RICassistanceMessage (const char* name, e2ap_RICassistanceMessage *pvalue, char* buffer, OSSIZE bufSize){
   if(rtPrintToStringIndent(buffer, bufSize) < 0) return -1;
   if(rtPrintToStringHexStr(name, pvalue->numocts, pvalue->data, buffer, bufSize) < 0) return -1;
   return 0;
}
EXTERN int asn1PrtToStrm_e2ap_RICassistanceMessage (OSCTXT* pctxt, const char* name, const e2ap_RICassistanceMessage* pvalue){
   int stat =0;
   stat = rtPrintToStreamIndent(pctxt);
   if(stat !=0) return LOG_RTERR(pctxt, stat);
   stat = rtPrintToStreamHexStr(pctxt, name, pvalue->numocts, pvalue->data);
   if(stat !=0) return LOG_RTERR(pctxt, stat);
   return stat;
}
//EXTERN int asn1Copy_e2ap_RICassistanceMessage (OSCTXT* pctxt, const e2ap_RICassistanceMessage* pSrcValue, e2ap_RICassistanceMessage* pDstValue);
 int asn1Init_e2ap_RICassistanceMessage (e2ap_RICassistanceMessage* pvalue){
   if (pvalue == 0) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   pvalue->data = 0;
   return 0;
}
 void asn1Free_e2ap_RICassistanceMessage (OSCTXT* pctxt, e2ap_RICassistanceMessage* pvalue){
   if (pvalue == 0) return;
   if(pvalue->numocts>0){
       rtxMemFreePtr(pctxt, (void*)pvalue->data);
       pvalue->data = 0;
       pvalue->numocts = 0;
   }
}
int asn1Init_e2ap_RICassistanceMessage (e2ap_RICassistanceMessage* pvalue){
   if (pvalue == 0) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   pvalue->data = 0;
   return 0;
}
/******************************************************/
/*                                                    */
/*    RICassistanceUpdate                          */
/*                                                    */
/******************************************************/
//enumerated


const OSEnumItem e2ap_RICassistanceUpdate_ENUMTAB[] = {
    { OSUTF8("true"), 0, 4, 0 }
};


const OSUTF8CHAR* e2ap_RICassistanceUpdate_ToString (OSUINT32 value){
   OSINT32 idx = value;
   if(idx >=0 && idx < e2ap_RICassistanceUpdate_ENUMTABSIZE){
      return e2ap_RICassistanceUpdate_ENUMTAB[e2ap_RICassistanceUpdate_ENUMTAB[idx].transidx].name;
   }else{
      return OSUTF8("_UNKNOWN_");
   }
}


int e2ap_RICassistanceUpdate_ToEnum (OSCTXT* pctxt, const OSUTF8CHAR* value,e2ap_RICassistanceUpdate* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes(value);
   return e2ap_RICassistanceUpdate_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int e2ap_RICassistanceUpdate_ToEnum2 (OSCTXT* pctxt, const OSUTF8CHAR* value, OSSIZE valueLen,e2ap_RICassistanceUpdate* pvalue)
{
   OSINT32 idx = rtxLookupEnum(value, valueLen,
      e2ap_RICassistanceUpdate_ENUMTAB, e2ap_RICassistanceUpdate_ENUMTABSIZE);
   if (idx >= 0) {
      *pvalue = (e2ap_RICassistanceUpdate)e2ap_RICassistanceUpdate_ENUMTAB[idx].value;
      return 0;
   } else {
      rtxErrAddIntParm (pctxt, (const char*)value);//dungnm23 check xem là Str hay Int
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_e2ap_RICassistanceUpdate (OSCTXT* pctxt, e2ap_RICassistanceUpdate value)
{
   int stat = 0;
   RTXCTXTPUSHTYPENAME (pctxt, "RICassistanceUpdate");
   if (value >= 1) {
      rtxErrAddIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(0));
   if(stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}

EXTERN int asn1PD_e2ap_RICassistanceUpdate (OSCTXT* pctxt, e2ap_RICassistanceUpdate* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RICassistanceUpdate");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(0));
   if(stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return stat;
}

EXTERN int asn1PrtToStr_e2ap_RICassistanceUpdate (const char* name, e2ap_RICassistanceUpdate* pvalue, char* buffer, OSSIZE bufSize)
{
   int stat;

   if(rtPrintToStringIndent(buffer, bufSize) < 0) return -1;
   if(rtPrintToString(name, buffer, bufSize) < 0) return -1;

   switch(*pvalue) {
      case 0:
         stat = rtPrintToString(" = true \n", buffer, bufSize);
         break;
      default:
         stat = rtPrintToString(" = ???\n", buffer, bufSize);
   }

   if (stat < 0) return -1;
   return 0;

}

/*Init*/
EXTERN int asn1Init_e2ap_RICassistanceUpdate (e2ap_RICassistanceUpdate* pvalue){
      //if (pvalue == 0) return RTERR_NULLPTR;
      //*pvalue = 0;
      return 0;
}/*****************************************/
/*           RICassistanceUpdateNumber                */
/*****************************************/
//6 mau integer
// mau integer size(a...b) mau la procedurecode
EXTERN int asn1PE_e2ap_RICassistanceUpdateNumber (OSCTXT* pctxt, e2ap_RICassistanceUpdateNumber value){
    int stat = 0;
    RTXCTCXTPUSHTYPENAME (pctxt, "RICassistanceUpdateNumber");
    stat = pe_ConsUnsigned (pctxt, value, 0, 65535);
    if (stat != 0) return LOG_RTERR (pctxt, stat);
    RTXCTXTPOPTYPENAME (pctxt);
    return stat;
}
EXTERN int asn1PD_e2ap_RICassistanceUpdateNumber (OSCTXT* pctxt, e2ap_RICassistanceUpdateNumber* pvalue){
    int stat = 0;
    RTXCTCXTPUSHTYPENAME (pctxt, "RICassistanceUpdateNumber");
    if(pctxt->buffer.aligned){
        int stat2 = PD_BYTE_ALIGN(pctxt);
        if(stat2 != 0) return LOG_RTERR (pctxt, stat2);
    }
    stat = rtxDecBitsToByte(pctxt, pvalue, 0);
    if (stat != 0) return LOG_RTERR (pctxt, stat);
    RTXCTXTPOPTYPENAME (pctxt);
    return stat;
}
//EXTERN int asn1Print_e2ap_RICassistanceUpdateNumber (const char* name, const e2ap_RICassistanceUpdateNumber* pvalue);
//EXTERN int asn1PrtToStr_e2ap_RICassistanceUpdateNumber (const char* name, e2ap_RICassistanceUpdateNumber* pvalue, char* buffer, OSSIZE bufSize);
//EXTERN int asn1PrtToStrm_e2ap_RICassistanceUpdateNumber (OSCTXT* pctxt, const char* name, const e2ap_RICassistanceUpdateNumber* pvalue);
EXTERN int asn1Init_e2ap_RICassistanceUpdateNumber (e2ap_RICassistanceUpdateNumber* pvalue){
    //if (pvalue == 0) return RTERR_NULLPTR;
    //*pvalue = 0;
    return 0;
}
EXTERN int asn1Free_e2ap_RICassistanceUpdateNumber (OSCTXT* pctxt, e2ap_RICassistanceUpdateNumber* pvalue){
    // No dynamic memory to free for integer
    return 0;
}
/*****************************************/
/*           RICassistanceRequest_IEs                */
/*****************************************/
/* ie.c.j2 */
 /* d là con của msg */
EXTERN int asn1PE_e2ap_RICassistanceRequest_protocolIEs_element (OSCTXT* pctxt, e2ap_RICassistanceRequest_protocolIEs_element* pvalue)
{
    int stat =0;

    /*encode id*/

    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PE_e2ap_ProtocolIE_ID(pctxt, pvalue->id);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PE_e2ap_Criticality(pctxt, pvalue->criticality);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
    {
        OSCTXT lctxt;
        OSOCTET *pDynamicEncodeBuffer;
        ASN1OpenType openType;
        OSBOOL encoded = TRUE;

        openType.numocts = 0;
        openType.data =0;

        rtxCopyContext(&lctxt, pctxt);
        pctxt->pStream =0;

        stat = rtxInitContextBuffer(pctxt, 0, 0);
        if(stat!=0) return LOG_RTERR(pctxt, stat);

        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_RICassistanceRequest_IEs_id_RICrequestID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICrequestID");
                    stat = asn1PE_e2ap_RICrequestID (pctxt, pvalue->value.u._e2ap_RICassistanceRequest_IEs_id_RICrequestID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICassistanceRequest_IEs_id_RICassistanceHeader:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICassistanceHeader");
                    stat = asn1PE_e2ap_RICassistanceHeader (pctxt, pvalue->value.u._e2ap_RICassistanceRequest_IEs_id_RICassistanceHeader);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICassistanceRequest_IEs_id_RICassistanceMessage:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICassistanceMessage");
                    stat = asn1PE_e2ap_RICassistanceMessage (pctxt, pvalue->value.u._e2ap_RICassistanceRequest_IEs_id_RICassistanceMessage);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICassistanceRequest_IEs_id_RICassistanceUpdate:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICassistanceUpdate");
                    stat = asn1PE_e2ap_RICassistanceUpdate (pctxt, pvalue->value.u._e2ap_RICassistanceRequest_IEs_id_RICassistanceUpdate);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICassistanceRequest_IEs_id_RICassistanceUpdateNumber:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICassistanceUpdateNumber");
                    stat = asn1PE_e2ap_RICassistanceUpdateNumber (pctxt, pvalue->value.u._e2ap_RICassistanceRequest_IEs_id_RICassistanceUpdateNumber);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_RICassistanceRequest_IEs_UNDEF_:
            {
                if(0!=pvalue->value.u.extElem1){
                    openType.numocts = pvalue->value.u.extElem1->numocts;
                    openType.data = pvalue->value.u.extElem1->data;
                } else {
                    /* No extension element to encode */
                }
                encoded = FALSE;
                break;
            }

            default:
                encoded = FALSE;
                stat = RTERR_INVOPT;
                break;
        } 

        if(encoded){
            openType.numocts = (OSUINT32)pe_GetMsgLen(pctxt);
            openType.data = pDynamicEncodeBuffer = pctxt -> buffer.data;
        }
        rtxCopyContext(pctxt, &lctxt);

        if(stat == 0) {
            stat = pe_OpenType (pctxt, openType.numocts, openType.data);
        }
    #if 1
        if(encoded){//dungnm23 check lai nhe
            rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
        }
    #endif

    }

    if(stat!=0) return LOG_RTERR(pctxt, stat);  
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}

EXTERN int  asn1PD_e2ap_RICassistanceRequest_protocolIEs_element (OSCTXT* pctxt, e2ap_RICassistanceRequest_protocolIEs_element* pvalue){
    int stat =0;

    /*decode id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PD_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PD_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");

    {
        OSUINT32 openTypeLen;
        size_t bitStartOffset, bitLength;

        stat = pd_UnconsLength(pctxt, &openTypeLen);
        if(stat<0) return LOG_RTERR(pctxt, stat);
        else if(stat == RT_OK_FRAG){
            rtxErrAddStrParm(pctxt, "open type with fragment length");
            return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
        }
        bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
        bitLength = openTypeLen * 8;

        switch(pvalue->id){//dungnm23 check case lai nhe
        
            case ASN1V_e2ap_id_RICrequestID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICassistanceRequest_IEs_id_RICrequestID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICrequestID");
                pvalue->value.u._e2ap_RICassistanceRequest_IEs_id_RICrequestID 
                    = rtxMemAllocType(pctxt, e2ap_RICrequestID);

                asn1Init_e2ap_RICrequestID(pvalue->value.u._e2ap_RICassistanceRequest_IEs_id_RICrequestID);

                stat = asn1PD_e2ap_RICrequestID (pctxt,
                        (e2ap_RICrequestID*)pvalue->value.
                        u._e2ap_RICassistanceRequest_IEs_id_RICrequestID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RICassistanceHeader:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICassistanceRequest_IEs_id_RICassistanceHeader;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICassistanceHeader");
                pvalue->value.u._e2ap_RICassistanceRequest_IEs_id_RICassistanceHeader 
                    = rtxMemAllocType(pctxt, e2ap_RICassistanceHeader);

                asn1Init_e2ap_RICassistanceHeader(pvalue->value.u._e2ap_RICassistanceRequest_IEs_id_RICassistanceHeader);

                stat = asn1PD_e2ap_RICassistanceHeader (pctxt,
                        (e2ap_RICassistanceHeader*)pvalue->value.
                        u._e2ap_RICassistanceRequest_IEs_id_RICassistanceHeader);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RICassistanceMessage:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICassistanceRequest_IEs_id_RICassistanceMessage;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICassistanceMessage");
                pvalue->value.u._e2ap_RICassistanceRequest_IEs_id_RICassistanceMessage 
                    = rtxMemAllocType(pctxt, e2ap_RICassistanceMessage);

                asn1Init_e2ap_RICassistanceMessage(pvalue->value.u._e2ap_RICassistanceRequest_IEs_id_RICassistanceMessage);

                stat = asn1PD_e2ap_RICassistanceMessage (pctxt,
                        (e2ap_RICassistanceMessage*)pvalue->value.
                        u._e2ap_RICassistanceRequest_IEs_id_RICassistanceMessage);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RICassistanceUpdate:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICassistanceRequest_IEs_id_RICassistanceUpdate;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICassistanceUpdate");
                pvalue->value.u._e2ap_RICassistanceRequest_IEs_id_RICassistanceUpdate 
                    = rtxMemAllocType(pctxt, e2ap_RICassistanceUpdate);

                asn1Init_e2ap_RICassistanceUpdate(pvalue->value.u._e2ap_RICassistanceRequest_IEs_id_RICassistanceUpdate);

                stat = asn1PD_e2ap_RICassistanceUpdate (pctxt,
                        (e2ap_RICassistanceUpdate*)pvalue->value.
                        u._e2ap_RICassistanceRequest_IEs_id_RICassistanceUpdate);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RICassistanceUpdateNumber:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICassistanceRequest_IEs_id_RICassistanceUpdateNumber;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICassistanceUpdateNumber");
                pvalue->value.u._e2ap_RICassistanceRequest_IEs_id_RICassistanceUpdateNumber 
                    = rtxMemAllocType(pctxt, e2ap_RICassistanceUpdateNumber);

                asn1Init_e2ap_RICassistanceUpdateNumber(pvalue->value.u._e2ap_RICassistanceRequest_IEs_id_RICassistanceUpdateNumber);

                stat = asn1PD_e2ap_RICassistanceUpdateNumber (pctxt,
                        (e2ap_RICassistanceUpdateNumber*)pvalue->value.
                        u._e2ap_RICassistanceRequest_IEs_id_RICassistanceUpdateNumber);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICassistanceRequest_IEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*) rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
    }
    {
    size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
    size_t bitsConsumed = bitEndOffset-bitStartOffset;
    if(bitsConsumed<bitLength){
        stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
    }
    else stat =(bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
    }}
    if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}


int asn1Init_e2ap_RICassistanceRequest_protocolIEs_element(e2ap_RICassistanceRequest_protocolIEs_element* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    OSCRTLMEMSET (&pvalue->value, 0, sizeof(pvalue->value));
    return 0;
}


//-----> chuaw có template rtxFreeASN1OpenType

#if 0
void asn1Free_e2ap_RICassistanceRequest_protocolIEs_element(OSCTXT* pctxt, e2ap_RICassistanceRequest_protocolIEs_element* pvalue)
{
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICassistanceRequest_IEs_id_id_RICrequestID:
            // rtxFreeE2ap_RICrequestID(pvalue->value.u._e2ap_RICassistanceRequest_IEs_id_id_RICrequestID);

            if(pvalue->value.i._e2ap_RICassistanceRequest_id_RICrequestID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICrequestID(pctxt, pvalue->value.u._e2ap_RICassistanceRequest_IEs_id_id_RICrequestID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICassistanceRequest_IEs_id_id_RICrequestID);
           // pvalue->value.u._e2ap_RICassistanceRequest_IEs_id_id_RICrequestID = NULL;
           pvalue->value.u._e2ap_RICassistanceRequest_IEs_id_RICrequestID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICassistanceRequest_IEs_id_id_RICassistanceHeader:
            // rtxFreeE2ap_RICassistanceHeader(pvalue->value.u._e2ap_RICassistanceRequest_IEs_id_id_RICassistanceHeader);

            if(pvalue->value.i._e2ap_RICassistanceRequest_id_RICassistanceHeader!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICassistanceHeader(pctxt, pvalue->value.u._e2ap_RICassistanceRequest_IEs_id_id_RICassistanceHeader);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICassistanceRequest_IEs_id_id_RICassistanceHeader);
           // pvalue->value.u._e2ap_RICassistanceRequest_IEs_id_id_RICassistanceHeader = NULL;
           pvalue->value.u._e2ap_RICassistanceRequest_IEs_id_RICassistanceHeader = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICassistanceRequest_IEs_id_id_RICassistanceMessage:
            // rtxFreeE2ap_RICassistanceMessage(pvalue->value.u._e2ap_RICassistanceRequest_IEs_id_id_RICassistanceMessage);

            if(pvalue->value.i._e2ap_RICassistanceRequest_id_RICassistanceMessage!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICassistanceMessage(pctxt, pvalue->value.u._e2ap_RICassistanceRequest_IEs_id_id_RICassistanceMessage);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICassistanceRequest_IEs_id_id_RICassistanceMessage);
           // pvalue->value.u._e2ap_RICassistanceRequest_IEs_id_id_RICassistanceMessage = NULL;
           pvalue->value.u._e2ap_RICassistanceRequest_IEs_id_RICassistanceMessage = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICassistanceRequest_IEs_id_id_RICassistanceUpdate:
            // rtxFreeE2ap_RICassistanceUpdate(pvalue->value.u._e2ap_RICassistanceRequest_IEs_id_id_RICassistanceUpdate);

            if(pvalue->value.i._e2ap_RICassistanceRequest_id_RICassistanceUpdate!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICassistanceUpdate(pctxt, pvalue->value.u._e2ap_RICassistanceRequest_IEs_id_id_RICassistanceUpdate);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICassistanceRequest_IEs_id_id_RICassistanceUpdate);
           // pvalue->value.u._e2ap_RICassistanceRequest_IEs_id_id_RICassistanceUpdate = NULL;
           pvalue->value.u._e2ap_RICassistanceRequest_IEs_id_RICassistanceUpdate = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICassistanceRequest_IEs_id_id_RICassistanceUpdateNumber:
            // rtxFreeE2ap_RICassistanceUpdateNumber(pvalue->value.u._e2ap_RICassistanceRequest_IEs_id_id_RICassistanceUpdateNumber);

            if(pvalue->value.i._e2ap_RICassistanceRequest_id_RICassistanceUpdateNumber!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICassistanceUpdateNumber(pctxt, pvalue->value.u._e2ap_RICassistanceRequest_IEs_id_id_RICassistanceUpdateNumber);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICassistanceRequest_IEs_id_id_RICassistanceUpdateNumber);
           // pvalue->value.u._e2ap_RICassistanceRequest_IEs_id_id_RICassistanceUpdateNumber = NULL;
           pvalue->value.u._e2ap_RICassistanceRequest_IEs_id_RICassistanceUpdateNumber = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICassistanceRequest_IEs_UNDEF_:
            rtxFreeASN1OpenType(pvalue->value.u.extElem1);
            break;
        default:
            break;
    }
}

int asn1PrtToStr_e2ap_RICassistanceRequest_protocolIEs_element(OSCTXT* pctxt, e2ap_RICassistanceRequest_protocolIEs_element* pvalue)
{
    int stat =0;
    RTXCTXTPUSHELEMNAME(pctxt, "e2ap_RICassistanceRequest_protocolIEs_element");

    /*print id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PrtToStr_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PrtToStr_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_RICassistanceRequest_IEs_id_id_RICrequestID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICrequestID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICrequestID (pctxt, pvalue->value.u._e2ap_RICassistanceRequest_IEs_id_id_RICrequestID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICassistanceRequest_IEs_id_id_RICassistanceHeader:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICassistanceHeader");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICassistanceHeader (pctxt, pvalue->value.u._e2ap_RICassistanceRequest_IEs_id_id_RICassistanceHeader);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICassistanceRequest_IEs_id_id_RICassistanceMessage:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICassistanceMessage");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICassistanceMessage (pctxt, pvalue->value.u._e2ap_RICassistanceRequest_IEs_id_id_RICassistanceMessage);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICassistanceRequest_IEs_id_id_RICassistanceUpdate:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICassistanceUpdate");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICassistanceUpdate (pctxt, pvalue->value.u._e2ap_RICassistanceRequest_IEs_id_id_RICassistanceUpdate);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICassistanceRequest_IEs_id_id_RICassistanceUpdateNumber:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICassistanceUpdateNumber");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICassistanceUpdateNumber (pctxt, pvalue->value.u._e2ap_RICassistanceRequest_IEs_id_id_RICassistanceUpdateNumber);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_RICassistanceRequest_IEs_UNDEF_:
            {
                rtxPLogMsg(pctxt, "Extension element present - raw data not printed.\n");
                break;
            }

            default:
                stat = RTERR_INVOPT;
                return LOG_RTERR(pctxt, stat);
        }
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);
}
#endif


int asn1PrtToStr_e2ap_RICassistanceRequest_protocolIEs_element (const char * name,
 e2ap_RICassistanceRequest_protocolIEs_element* pvalue, 
 char * buffer, OSSIZE bufSize){
    if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
        return -1;
    if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
        return -1;

    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICassistanceRequest_IEs_id_RICrequestID:
            if(asn1PrtToStr_e2ap_RICrequestID("RICrequestID", 
                    pvalue->value.u._e2ap_RICassistanceRequest_IEs_id_RICrequestID, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICassistanceRequest_IEs_id_RICassistanceHeader:
            if(asn1PrtToStr_e2ap_RICassistanceHeader("RICassistanceHeader", 
                    pvalue->value.u._e2ap_RICassistanceRequest_IEs_id_RICassistanceHeader, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICassistanceRequest_IEs_id_RICassistanceMessage:
            if(asn1PrtToStr_e2ap_RICassistanceMessage("RICassistanceMessage", 
                    pvalue->value.u._e2ap_RICassistanceRequest_IEs_id_RICassistanceMessage, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICassistanceRequest_IEs_id_RICassistanceUpdate:
            if(asn1PrtToStr_e2ap_RICassistanceUpdate("RICassistanceUpdate", 
                    pvalue->value.u._e2ap_RICassistanceRequest_IEs_id_RICassistanceUpdate, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICassistanceRequest_IEs_id_RICassistanceUpdateNumber:
            if(asn1PrtToStr_e2ap_RICassistanceUpdateNumber("RICassistanceUpdateNumber", 
                    pvalue->value.u._e2ap_RICassistanceRequest_IEs_id_RICassistanceUpdateNumber, buffer, bufSize)<0)
                return -1;
            break;    
        default:
        if(0!=pvalue -> value.u.extElem1){
            rtPrintToStringIndent(buffer, bufSize);
            rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

        }
        }
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

    return 0;

 }

 void asn1Free_e2ap_RICassistanceRequest_protocolIEs_element(OSCTXT* pctxt, e2ap_RICassistanceRequest_protocolIEs_element* pvalue){
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICassistanceRequest_IEs_id_RICrequestID:
            if(pvalue->value.u._e2ap_RICassistanceRequest_IEs_id_RICrequestID!=NULL){
            asn1Free_e2ap_RICrequestID(pctxt, pvalue->value.u._e2ap_RICassistanceRequest_IEs_id_RICrequestID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICassistanceRequest_IEs_id_RICrequestID);
            pvalue->value.u._e2ap_RICassistanceRequest_IEs_id_RICrequestID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICassistanceRequest_IEs_id_RICassistanceHeader:
            if(pvalue->value.u._e2ap_RICassistanceRequest_IEs_id_RICassistanceHeader!=NULL){
            asn1Free_e2ap_RICassistanceHeader(pctxt, pvalue->value.u._e2ap_RICassistanceRequest_IEs_id_RICassistanceHeader);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICassistanceRequest_IEs_id_RICassistanceHeader);
            pvalue->value.u._e2ap_RICassistanceRequest_IEs_id_RICassistanceHeader = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICassistanceRequest_IEs_id_RICassistanceMessage:
            if(pvalue->value.u._e2ap_RICassistanceRequest_IEs_id_RICassistanceMessage!=NULL){
            asn1Free_e2ap_RICassistanceMessage(pctxt, pvalue->value.u._e2ap_RICassistanceRequest_IEs_id_RICassistanceMessage);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICassistanceRequest_IEs_id_RICassistanceMessage);
            pvalue->value.u._e2ap_RICassistanceRequest_IEs_id_RICassistanceMessage = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICassistanceRequest_IEs_id_RICassistanceUpdate:
            if(pvalue->value.u._e2ap_RICassistanceRequest_IEs_id_RICassistanceUpdate!=NULL){
            asn1Free_e2ap_RICassistanceUpdate(pctxt, pvalue->value.u._e2ap_RICassistanceRequest_IEs_id_RICassistanceUpdate);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICassistanceRequest_IEs_id_RICassistanceUpdate);
            pvalue->value.u._e2ap_RICassistanceRequest_IEs_id_RICassistanceUpdate = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICassistanceRequest_IEs_id_RICassistanceUpdateNumber:
            if(pvalue->value.u._e2ap_RICassistanceRequest_IEs_id_RICassistanceUpdateNumber!=NULL){
            asn1Free_e2ap_RICassistanceUpdateNumber(pctxt, pvalue->value.u._e2ap_RICassistanceRequest_IEs_id_RICassistanceUpdateNumber);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICassistanceRequest_IEs_id_RICassistanceUpdateNumber);
            pvalue->value.u._e2ap_RICassistanceRequest_IEs_id_RICassistanceUpdateNumber = NULL;
            }
            break;
        default:
            break;


    }
 }

 

/*****************************************/
/*           RICassistanceRequest                */
/*****************************************/
//2_container.c
/* 1. xxx_ProtocolIE -> mẫu cũ ở ie_big_msg */
EXTERN int asn1PE_e2ap_RICassistanceRequest_protocolIEs (OSCTXT* pctxt, e2ap_RICassistanceRequest_protocolIEs* pvalue)
{
    int stat =0;
    OSRTDListNode* pnode;
    OSUINT32 xx1;

    /*encode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pe_Length(pctxt, pvalue->count);
    if(stat<0) return LOG_RTERR(pctxt, stat);

    /*encode each element*/
    xx1 =0;
    for(pnode = pvalue->head; pnode != 0 && xx1<pvalue->count; pnode = pnode->next){
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE", xx1);
        stat = asn1PE_e2ap_RICassistanceRequest_protocolIEs_element (pctxt, ((e2ap_RICassistanceRequest_protocolIEs_element*)pnode->data));
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        xx1++;
        RTXCTXTPOPARRAYELEMNAME(pctxt);
    }

    return (stat);
}

EXTERN int  asn1PD_e2ap_RICassistanceRequest_protocolIEs(OSCTXT* pctxt, e2ap_RICassistanceRequest_protocolIEs* pvalue)
{
     int stat =0;
     OSRTDListNode* pnode;
     OSSIZE count =0;
     OSSIZE xx1=0;


     /*decode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pd_Length64(pctxt, &count); //tai sao lai 64
    if(stat!=0) return LOG_RTERR(pctxt, stat);

    /*decode each element*/
    rtxDListInit(pvalue);

    for(xx1=0; xx1 < count; xx1++){
        e2ap_RICassistanceRequest_protocolIEs_element* pdata;
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE",xx1);

        if(pnode == NULL) return LOG_RTERR(pctxt, RTERR_NOMEM);

        asn1Init_e2ap_RICassistanceRequest_protocolIEs_element(pdata);
        rtxDListAppendNode(pvalue, pnode);
        stat = asn1PD_e2ap_RICassistanceRequest_protocolIEs_element (pctxt, pdata);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        RTXCTXTPOPARRAYELEMNAME(pctxt);

    }
    return (stat);
}


int asn1Init_e2ap_RICassistanceRequest_protocolIEs(e2ap_RICassistanceRequest_protocolIEs* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    rtxDListFastInit (pvalue);
    return 0;
}
#if 1 //ao that day
void asn1Free_e2ap_RICassistanceRequest_protocolIEs(OSCTXT* pctxt, e2ap_RICassistanceRequest_protocolIEs* pvalue)
{
    if(0==pvalue) return;   
    e2ap_RICassistanceRequest_protocolIEs_element* pdata;
    OSRTDListNode* pnode=pvalue->head;
    while(0!=pnode){
        pdata = (e2ap_RICassistanceRequest_protocolIEs_element*)pnode->data;
       // asn1Free_e2ap_RICassistanceRequest_protocolIEs_element(pctxt, pdata);
        pnode = pnode->next;
    }
    rtxDListFreeAll(pctxt, pvalue);
}
#endif


EXTERN int asn1PrtToStr_e2ap_RICassistanceRequest_protocolIEs(const char* name, e2ap_RICassistanceRequest_protocolIEs* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_RICassistanceRequest_protocolIEs_element* pdata0;
    OSRTDListNode* pnode0;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode0 = pvalue->head;  xx1 < pvalue->count && pnode0 != 0; pnode0 = pnode0->next, xx1++){
        pdata0 = (e2ap_RICassistanceRequest_protocolIEs_element*)pnode0->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 0
        if(asn1PrtToStr_e2ap_RICassistanceRequest_protocolIEs_element(nameBuf, pdata0, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}


/*2 . RICassistanceRequest -> mẫu cũ ở seq_normal*/

int asn1PE_e2ap_RICassistanceRequest (OSCTXT* pctxt, e2ap_RICassistanceRequest* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RICassistanceRequest");
   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field protocolIEs - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
   stat = asn1PE_e2ap_RICassistanceRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if(stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RICassistanceRequest (OSCTXT* pctxt, e2ap_RICassistanceRequest* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME(pctxt, "RICassistanceRequest");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field protocolIEs */
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
      stat = asn1PD_e2ap_RICassistanceRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RICassistanceRequest (e2ap_RICassistanceRequest* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RICassistanceRequest_protocolIEs(&pvalue->protocolIEs);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RICassistanceRequest (OSCTXT* pctxt, e2ap_RICassistanceRequest* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_RICassistanceRequest_protocolIEs(pctxt, &pvalue->protocolIEs);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RICassistanceRequest (const char* name, e2ap_RICassistanceRequest* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }

   if(asn1PrtToStr_e2ap_RICassistanceRequest_protocolIEs("protocolIEs", &pvalue->protocolIEs, buffer, bufSize) <0){
      return -1;
   }

   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           RICassistanceResponse_IEs                */
/*****************************************/
/* ie.c.j2 */
 /* d là con của msg */
EXTERN int asn1PE_e2ap_RICassistanceResponse_protocolIEs_element (OSCTXT* pctxt, e2ap_RICassistanceResponse_protocolIEs_element* pvalue)
{
    int stat =0;

    /*encode id*/

    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PE_e2ap_ProtocolIE_ID(pctxt, pvalue->id);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PE_e2ap_Criticality(pctxt, pvalue->criticality);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
    {
        OSCTXT lctxt;
        OSOCTET *pDynamicEncodeBuffer;
        ASN1OpenType openType;
        OSBOOL encoded = TRUE;

        openType.numocts = 0;
        openType.data =0;

        rtxCopyContext(&lctxt, pctxt);
        pctxt->pStream =0;

        stat = rtxInitContextBuffer(pctxt, 0, 0);
        if(stat!=0) return LOG_RTERR(pctxt, stat);

        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_RICassistanceResponse_IEs_id_RICrequestID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICrequestID");
                    stat = asn1PE_e2ap_RICrequestID (pctxt, pvalue->value.u._e2ap_RICassistanceResponse_IEs_id_RICrequestID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICassistanceResponse_IEs_id_RICassistanceHeader:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICassistanceHeader");
                    stat = asn1PE_e2ap_RICassistanceHeader (pctxt, pvalue->value.u._e2ap_RICassistanceResponse_IEs_id_RICassistanceHeader);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICassistanceResponse_IEs_id_RICassistanceOutcome:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICassistanceOutcome");
                    stat = asn1PE_e2ap_RICassistanceOutcome (pctxt, pvalue->value.u._e2ap_RICassistanceResponse_IEs_id_RICassistanceOutcome);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_RICassistanceResponse_IEs_UNDEF_:
            {
                if(0!=pvalue->value.u.extElem1){
                    openType.numocts = pvalue->value.u.extElem1->numocts;
                    openType.data = pvalue->value.u.extElem1->data;
                } else {
                    /* No extension element to encode */
                }
                encoded = FALSE;
                break;
            }

            default:
                encoded = FALSE;
                stat = RTERR_INVOPT;
                break;
        } 

        if(encoded){
            openType.numocts = (OSUINT32)pe_GetMsgLen(pctxt);
            openType.data = pDynamicEncodeBuffer = pctxt -> buffer.data;
        }
        rtxCopyContext(pctxt, &lctxt);

        if(stat == 0) {
            stat = pe_OpenType (pctxt, openType.numocts, openType.data);
        }
    #if 1
        if(encoded){//dungnm23 check lai nhe
            rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
        }
    #endif

    }

    if(stat!=0) return LOG_RTERR(pctxt, stat);  
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}

EXTERN int  asn1PD_e2ap_RICassistanceResponse_protocolIEs_element (OSCTXT* pctxt, e2ap_RICassistanceResponse_protocolIEs_element* pvalue){
    int stat =0;

    /*decode id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PD_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PD_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");

    {
        OSUINT32 openTypeLen;
        size_t bitStartOffset, bitLength;

        stat = pd_UnconsLength(pctxt, &openTypeLen);
        if(stat<0) return LOG_RTERR(pctxt, stat);
        else if(stat == RT_OK_FRAG){
            rtxErrAddStrParm(pctxt, "open type with fragment length");
            return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
        }
        bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
        bitLength = openTypeLen * 8;

        switch(pvalue->id){//dungnm23 check case lai nhe
        
            case ASN1V_e2ap_id_RICrequestID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICassistanceResponse_IEs_id_RICrequestID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICrequestID");
                pvalue->value.u._e2ap_RICassistanceResponse_IEs_id_RICrequestID 
                    = rtxMemAllocType(pctxt, e2ap_RICrequestID);

                asn1Init_e2ap_RICrequestID(pvalue->value.u._e2ap_RICassistanceResponse_IEs_id_RICrequestID);

                stat = asn1PD_e2ap_RICrequestID (pctxt,
                        (e2ap_RICrequestID*)pvalue->value.
                        u._e2ap_RICassistanceResponse_IEs_id_RICrequestID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RICassistanceHeader:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICassistanceResponse_IEs_id_RICassistanceHeader;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICassistanceHeader");
                pvalue->value.u._e2ap_RICassistanceResponse_IEs_id_RICassistanceHeader 
                    = rtxMemAllocType(pctxt, e2ap_RICassistanceHeader);

                asn1Init_e2ap_RICassistanceHeader(pvalue->value.u._e2ap_RICassistanceResponse_IEs_id_RICassistanceHeader);

                stat = asn1PD_e2ap_RICassistanceHeader (pctxt,
                        (e2ap_RICassistanceHeader*)pvalue->value.
                        u._e2ap_RICassistanceResponse_IEs_id_RICassistanceHeader);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RICassistanceOutcome:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICassistanceResponse_IEs_id_RICassistanceOutcome;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICassistanceOutcome");
                pvalue->value.u._e2ap_RICassistanceResponse_IEs_id_RICassistanceOutcome 
                    = rtxMemAllocType(pctxt, e2ap_RICassistanceOutcome);

                asn1Init_e2ap_RICassistanceOutcome(pvalue->value.u._e2ap_RICassistanceResponse_IEs_id_RICassistanceOutcome);

                stat = asn1PD_e2ap_RICassistanceOutcome (pctxt,
                        (e2ap_RICassistanceOutcome*)pvalue->value.
                        u._e2ap_RICassistanceResponse_IEs_id_RICassistanceOutcome);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICassistanceResponse_IEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*) rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
    }
    {
    size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
    size_t bitsConsumed = bitEndOffset-bitStartOffset;
    if(bitsConsumed<bitLength){
        stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
    }
    else stat =(bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
    }}
    if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}


int asn1Init_e2ap_RICassistanceResponse_protocolIEs_element(e2ap_RICassistanceResponse_protocolIEs_element* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    OSCRTLMEMSET (&pvalue->value, 0, sizeof(pvalue->value));
    return 0;
}


//-----> chuaw có template rtxFreeASN1OpenType

#if 0
void asn1Free_e2ap_RICassistanceResponse_protocolIEs_element(OSCTXT* pctxt, e2ap_RICassistanceResponse_protocolIEs_element* pvalue)
{
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICassistanceResponse_IEs_id_id_RICrequestID:
            // rtxFreeE2ap_RICrequestID(pvalue->value.u._e2ap_RICassistanceResponse_IEs_id_id_RICrequestID);

            if(pvalue->value.i._e2ap_RICassistanceResponse_id_RICrequestID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICrequestID(pctxt, pvalue->value.u._e2ap_RICassistanceResponse_IEs_id_id_RICrequestID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICassistanceResponse_IEs_id_id_RICrequestID);
           // pvalue->value.u._e2ap_RICassistanceResponse_IEs_id_id_RICrequestID = NULL;
           pvalue->value.u._e2ap_RICassistanceResponse_IEs_id_RICrequestID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICassistanceResponse_IEs_id_id_RICassistanceHeader:
            // rtxFreeE2ap_RICassistanceHeader(pvalue->value.u._e2ap_RICassistanceResponse_IEs_id_id_RICassistanceHeader);

            if(pvalue->value.i._e2ap_RICassistanceResponse_id_RICassistanceHeader!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICassistanceHeader(pctxt, pvalue->value.u._e2ap_RICassistanceResponse_IEs_id_id_RICassistanceHeader);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICassistanceResponse_IEs_id_id_RICassistanceHeader);
           // pvalue->value.u._e2ap_RICassistanceResponse_IEs_id_id_RICassistanceHeader = NULL;
           pvalue->value.u._e2ap_RICassistanceResponse_IEs_id_RICassistanceHeader = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICassistanceResponse_IEs_id_id_RICassistanceOutcome:
            // rtxFreeE2ap_RICassistanceOutcome(pvalue->value.u._e2ap_RICassistanceResponse_IEs_id_id_RICassistanceOutcome);

            if(pvalue->value.i._e2ap_RICassistanceResponse_id_RICassistanceOutcome!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICassistanceOutcome(pctxt, pvalue->value.u._e2ap_RICassistanceResponse_IEs_id_id_RICassistanceOutcome);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICassistanceResponse_IEs_id_id_RICassistanceOutcome);
           // pvalue->value.u._e2ap_RICassistanceResponse_IEs_id_id_RICassistanceOutcome = NULL;
           pvalue->value.u._e2ap_RICassistanceResponse_IEs_id_RICassistanceOutcome = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICassistanceResponse_IEs_UNDEF_:
            rtxFreeASN1OpenType(pvalue->value.u.extElem1);
            break;
        default:
            break;
    }
}

int asn1PrtToStr_e2ap_RICassistanceResponse_protocolIEs_element(OSCTXT* pctxt, e2ap_RICassistanceResponse_protocolIEs_element* pvalue)
{
    int stat =0;
    RTXCTXTPUSHELEMNAME(pctxt, "e2ap_RICassistanceResponse_protocolIEs_element");

    /*print id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PrtToStr_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PrtToStr_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_RICassistanceResponse_IEs_id_id_RICrequestID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICrequestID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICrequestID (pctxt, pvalue->value.u._e2ap_RICassistanceResponse_IEs_id_id_RICrequestID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICassistanceResponse_IEs_id_id_RICassistanceHeader:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICassistanceHeader");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICassistanceHeader (pctxt, pvalue->value.u._e2ap_RICassistanceResponse_IEs_id_id_RICassistanceHeader);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICassistanceResponse_IEs_id_id_RICassistanceOutcome:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICassistanceOutcome");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICassistanceOutcome (pctxt, pvalue->value.u._e2ap_RICassistanceResponse_IEs_id_id_RICassistanceOutcome);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_RICassistanceResponse_IEs_UNDEF_:
            {
                rtxPLogMsg(pctxt, "Extension element present - raw data not printed.\n");
                break;
            }

            default:
                stat = RTERR_INVOPT;
                return LOG_RTERR(pctxt, stat);
        }
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);
}
#endif


int asn1PrtToStr_e2ap_RICassistanceResponse_protocolIEs_element (const char * name,
 e2ap_RICassistanceResponse_protocolIEs_element* pvalue, 
 char * buffer, OSSIZE bufSize){
    if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
        return -1;
    if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
        return -1;

    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICassistanceResponse_IEs_id_RICrequestID:
            if(asn1PrtToStr_e2ap_RICrequestID("RICrequestID", 
                    pvalue->value.u._e2ap_RICassistanceResponse_IEs_id_RICrequestID, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICassistanceResponse_IEs_id_RICassistanceHeader:
            if(asn1PrtToStr_e2ap_RICassistanceHeader("RICassistanceHeader", 
                    pvalue->value.u._e2ap_RICassistanceResponse_IEs_id_RICassistanceHeader, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICassistanceResponse_IEs_id_RICassistanceOutcome:
            if(asn1PrtToStr_e2ap_RICassistanceOutcome("RICassistanceOutcome", 
                    pvalue->value.u._e2ap_RICassistanceResponse_IEs_id_RICassistanceOutcome, buffer, bufSize)<0)
                return -1;
            break;    
        default:
        if(0!=pvalue -> value.u.extElem1){
            rtPrintToStringIndent(buffer, bufSize);
            rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

        }
        }
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

    return 0;

 }

 void asn1Free_e2ap_RICassistanceResponse_protocolIEs_element(OSCTXT* pctxt, e2ap_RICassistanceResponse_protocolIEs_element* pvalue){
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICassistanceResponse_IEs_id_RICrequestID:
            if(pvalue->value.u._e2ap_RICassistanceResponse_IEs_id_RICrequestID!=NULL){
            asn1Free_e2ap_RICrequestID(pctxt, pvalue->value.u._e2ap_RICassistanceResponse_IEs_id_RICrequestID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICassistanceResponse_IEs_id_RICrequestID);
            pvalue->value.u._e2ap_RICassistanceResponse_IEs_id_RICrequestID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICassistanceResponse_IEs_id_RICassistanceHeader:
            if(pvalue->value.u._e2ap_RICassistanceResponse_IEs_id_RICassistanceHeader!=NULL){
            asn1Free_e2ap_RICassistanceHeader(pctxt, pvalue->value.u._e2ap_RICassistanceResponse_IEs_id_RICassistanceHeader);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICassistanceResponse_IEs_id_RICassistanceHeader);
            pvalue->value.u._e2ap_RICassistanceResponse_IEs_id_RICassistanceHeader = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICassistanceResponse_IEs_id_RICassistanceOutcome:
            if(pvalue->value.u._e2ap_RICassistanceResponse_IEs_id_RICassistanceOutcome!=NULL){
            asn1Free_e2ap_RICassistanceOutcome(pctxt, pvalue->value.u._e2ap_RICassistanceResponse_IEs_id_RICassistanceOutcome);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICassistanceResponse_IEs_id_RICassistanceOutcome);
            pvalue->value.u._e2ap_RICassistanceResponse_IEs_id_RICassistanceOutcome = NULL;
            }
            break;
        default:
            break;


    }
 }

 

/*****************************************/
/*           RICassistanceResponse                */
/*****************************************/
//2_container.c
/* 1. xxx_ProtocolIE -> mẫu cũ ở ie_big_msg */
EXTERN int asn1PE_e2ap_RICassistanceResponse_protocolIEs (OSCTXT* pctxt, e2ap_RICassistanceResponse_protocolIEs* pvalue)
{
    int stat =0;
    OSRTDListNode* pnode;
    OSUINT32 xx1;

    /*encode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pe_Length(pctxt, pvalue->count);
    if(stat<0) return LOG_RTERR(pctxt, stat);

    /*encode each element*/
    xx1 =0;
    for(pnode = pvalue->head; pnode != 0 && xx1<pvalue->count; pnode = pnode->next){
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE", xx1);
        stat = asn1PE_e2ap_RICassistanceResponse_protocolIEs_element (pctxt, ((e2ap_RICassistanceResponse_protocolIEs_element*)pnode->data));
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        xx1++;
        RTXCTXTPOPARRAYELEMNAME(pctxt);
    }

    return (stat);
}

EXTERN int  asn1PD_e2ap_RICassistanceResponse_protocolIEs(OSCTXT* pctxt, e2ap_RICassistanceResponse_protocolIEs* pvalue)
{
     int stat =0;
     OSRTDListNode* pnode;
     OSSIZE count =0;
     OSSIZE xx1=0;


     /*decode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pd_Length64(pctxt, &count); //tai sao lai 64
    if(stat!=0) return LOG_RTERR(pctxt, stat);

    /*decode each element*/
    rtxDListInit(pvalue);

    for(xx1=0; xx1 < count; xx1++){
        e2ap_RICassistanceResponse_protocolIEs_element* pdata;
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE",xx1);

        if(pnode == NULL) return LOG_RTERR(pctxt, RTERR_NOMEM);

        asn1Init_e2ap_RICassistanceResponse_protocolIEs_element(pdata);
        rtxDListAppendNode(pvalue, pnode);
        stat = asn1PD_e2ap_RICassistanceResponse_protocolIEs_element (pctxt, pdata);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        RTXCTXTPOPARRAYELEMNAME(pctxt);

    }
    return (stat);
}


int asn1Init_e2ap_RICassistanceResponse_protocolIEs(e2ap_RICassistanceResponse_protocolIEs* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    rtxDListFastInit (pvalue);
    return 0;
}
#if 1 //ao that day
void asn1Free_e2ap_RICassistanceResponse_protocolIEs(OSCTXT* pctxt, e2ap_RICassistanceResponse_protocolIEs* pvalue)
{
    if(0==pvalue) return;   
    e2ap_RICassistanceResponse_protocolIEs_element* pdata;
    OSRTDListNode* pnode=pvalue->head;
    while(0!=pnode){
        pdata = (e2ap_RICassistanceResponse_protocolIEs_element*)pnode->data;
       // asn1Free_e2ap_RICassistanceResponse_protocolIEs_element(pctxt, pdata);
        pnode = pnode->next;
    }
    rtxDListFreeAll(pctxt, pvalue);
}
#endif


EXTERN int asn1PrtToStr_e2ap_RICassistanceResponse_protocolIEs(const char* name, e2ap_RICassistanceResponse_protocolIEs* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_RICassistanceResponse_protocolIEs_element* pdata0;
    OSRTDListNode* pnode0;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode0 = pvalue->head;  xx1 < pvalue->count && pnode0 != 0; pnode0 = pnode0->next, xx1++){
        pdata0 = (e2ap_RICassistanceResponse_protocolIEs_element*)pnode0->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 0
        if(asn1PrtToStr_e2ap_RICassistanceResponse_protocolIEs_element(nameBuf, pdata0, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}


/*2 . RICassistanceResponse -> mẫu cũ ở seq_normal*/

int asn1PE_e2ap_RICassistanceResponse (OSCTXT* pctxt, e2ap_RICassistanceResponse* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RICassistanceResponse");
   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field protocolIEs - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
   stat = asn1PE_e2ap_RICassistanceResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
   if(stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RICassistanceResponse (OSCTXT* pctxt, e2ap_RICassistanceResponse* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME(pctxt, "RICassistanceResponse");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field protocolIEs */
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
      stat = asn1PD_e2ap_RICassistanceResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RICassistanceResponse (e2ap_RICassistanceResponse* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RICassistanceResponse_protocolIEs(&pvalue->protocolIEs);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RICassistanceResponse (OSCTXT* pctxt, e2ap_RICassistanceResponse* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_RICassistanceResponse_protocolIEs(pctxt, &pvalue->protocolIEs);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RICassistanceResponse (const char* name, e2ap_RICassistanceResponse* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }

   if(asn1PrtToStr_e2ap_RICassistanceResponse_protocolIEs("protocolIEs", &pvalue->protocolIEs, buffer, bufSize) <0){
      return -1;
   }

   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           RICcallProcessID                */
/*****************************************/
//9 mau octet string
//type 9  mau la octet string no size mau la pdusessioncommonnetworkinstance

EXTERN int asn1PE_e2ap_RICcallProcessID (OSCTXT* pctxt, e2ap_RICcallProcessID value){
   int stat = 0
   RTXCTCXTPUSHTYPENAME (pctxt, "RICcallProcessID");
   stat = pe_OctetString(pctxt, value.numocts, value.data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPTYPENAME (pctxt);

}
EXTERN int asn1PD_e2ap_RICcallProcessID (OSCTXT* pctxt, e2ap_RICcallProcessID* pvalue){
   int stat = 0;
   RTXCTCXTPUSHTYPENAME (pctxt, "RICcallProcessID");
   stat = pd_DynOctetString(pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}
EXTERN int asn1PrtToStr_e2ap_RICcallProcessID (const char* name, e2ap_RICcallProcessID *pvalue, char* buffer, OSSIZE bufSize){
   if(rtPrintToStringIndent(buffer, bufSize) < 0) return -1;
   if(rtPrintToStringHexStr(name, pvalue->numocts, pvalue->data, buffer, bufSize) < 0) return -1;
   return 0;
}
EXTERN int asn1PrtToStrm_e2ap_RICcallProcessID (OSCTXT* pctxt, const char* name, const e2ap_RICcallProcessID* pvalue){
   int stat =0;
   stat = rtPrintToStreamIndent(pctxt);
   if(stat !=0) return LOG_RTERR(pctxt, stat);
   stat = rtPrintToStreamHexStr(pctxt, name, pvalue->numocts, pvalue->data);
   if(stat !=0) return LOG_RTERR(pctxt, stat);
   return stat;
}
//EXTERN int asn1Copy_e2ap_RICcallProcessID (OSCTXT* pctxt, const e2ap_RICcallProcessID* pSrcValue, e2ap_RICcallProcessID* pDstValue);
 int asn1Init_e2ap_RICcallProcessID (e2ap_RICcallProcessID* pvalue){
   if (pvalue == 0) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   pvalue->data = 0;
   return 0;
}
 void asn1Free_e2ap_RICcallProcessID (OSCTXT* pctxt, e2ap_RICcallProcessID* pvalue){
   if (pvalue == 0) return;
   if(pvalue->numocts>0){
       rtxMemFreePtr(pctxt, (void*)pvalue->data);
       pvalue->data = 0;
       pvalue->numocts = 0;
   }
}
int asn1Init_e2ap_RICcallProcessID (e2ap_RICcallProcessID* pvalue){
   if (pvalue == 0) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   pvalue->data = 0;
   return 0;
}
/*****************************************/
/*           RICcontrolOutcome                */
/*****************************************/
//9 mau octet string
//type 9  mau la octet string no size mau la pdusessioncommonnetworkinstance

EXTERN int asn1PE_e2ap_RICcontrolOutcome (OSCTXT* pctxt, e2ap_RICcontrolOutcome value){
   int stat = 0
   RTXCTCXTPUSHTYPENAME (pctxt, "RICcontrolOutcome");
   stat = pe_OctetString(pctxt, value.numocts, value.data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPTYPENAME (pctxt);

}
EXTERN int asn1PD_e2ap_RICcontrolOutcome (OSCTXT* pctxt, e2ap_RICcontrolOutcome* pvalue){
   int stat = 0;
   RTXCTCXTPUSHTYPENAME (pctxt, "RICcontrolOutcome");
   stat = pd_DynOctetString(pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}
EXTERN int asn1PrtToStr_e2ap_RICcontrolOutcome (const char* name, e2ap_RICcontrolOutcome *pvalue, char* buffer, OSSIZE bufSize){
   if(rtPrintToStringIndent(buffer, bufSize) < 0) return -1;
   if(rtPrintToStringHexStr(name, pvalue->numocts, pvalue->data, buffer, bufSize) < 0) return -1;
   return 0;
}
EXTERN int asn1PrtToStrm_e2ap_RICcontrolOutcome (OSCTXT* pctxt, const char* name, const e2ap_RICcontrolOutcome* pvalue){
   int stat =0;
   stat = rtPrintToStreamIndent(pctxt);
   if(stat !=0) return LOG_RTERR(pctxt, stat);
   stat = rtPrintToStreamHexStr(pctxt, name, pvalue->numocts, pvalue->data);
   if(stat !=0) return LOG_RTERR(pctxt, stat);
   return stat;
}
//EXTERN int asn1Copy_e2ap_RICcontrolOutcome (OSCTXT* pctxt, const e2ap_RICcontrolOutcome* pSrcValue, e2ap_RICcontrolOutcome* pDstValue);
 int asn1Init_e2ap_RICcontrolOutcome (e2ap_RICcontrolOutcome* pvalue){
   if (pvalue == 0) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   pvalue->data = 0;
   return 0;
}
 void asn1Free_e2ap_RICcontrolOutcome (OSCTXT* pctxt, e2ap_RICcontrolOutcome* pvalue){
   if (pvalue == 0) return;
   if(pvalue->numocts>0){
       rtxMemFreePtr(pctxt, (void*)pvalue->data);
       pvalue->data = 0;
       pvalue->numocts = 0;
   }
}
int asn1Init_e2ap_RICcontrolOutcome (e2ap_RICcontrolOutcome* pvalue){
   if (pvalue == 0) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   pvalue->data = 0;
   return 0;
}
/*****************************************/
/*           RICcontrolAcknowledge_IEs                */
/*****************************************/
/* ie.c.j2 */
 /* d là con của msg */
EXTERN int asn1PE_e2ap_RICcontrolAcknowledge_protocolIEs_element (OSCTXT* pctxt, e2ap_RICcontrolAcknowledge_protocolIEs_element* pvalue)
{
    int stat =0;

    /*encode id*/

    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PE_e2ap_ProtocolIE_ID(pctxt, pvalue->id);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PE_e2ap_Criticality(pctxt, pvalue->criticality);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
    {
        OSCTXT lctxt;
        OSOCTET *pDynamicEncodeBuffer;
        ASN1OpenType openType;
        OSBOOL encoded = TRUE;

        openType.numocts = 0;
        openType.data =0;

        rtxCopyContext(&lctxt, pctxt);
        pctxt->pStream =0;

        stat = rtxInitContextBuffer(pctxt, 0, 0);
        if(stat!=0) return LOG_RTERR(pctxt, stat);

        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_RICcontrolAcknowledge_IEs_id_RICrequestID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICrequestID");
                    stat = asn1PE_e2ap_RICrequestID (pctxt, pvalue->value.u._e2ap_RICcontrolAcknowledge_IEs_id_RICrequestID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICcontrolAcknowledge_IEs_id_RANfunctionID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RANfunctionID");
                    stat = asn1PE_e2ap_RANfunctionID (pctxt, pvalue->value.u._e2ap_RICcontrolAcknowledge_IEs_id_RANfunctionID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICcontrolAcknowledge_IEs_id_RICcallProcessID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICcallProcessID");
                    stat = asn1PE_e2ap_RICcallProcessID (pctxt, pvalue->value.u._e2ap_RICcontrolAcknowledge_IEs_id_RICcallProcessID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICcontrolAcknowledge_IEs_id_RICcontrolOutcome:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICcontrolOutcome");
                    stat = asn1PE_e2ap_RICcontrolOutcome (pctxt, pvalue->value.u._e2ap_RICcontrolAcknowledge_IEs_id_RICcontrolOutcome);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_RICcontrolAcknowledge_IEs_UNDEF_:
            {
                if(0!=pvalue->value.u.extElem1){
                    openType.numocts = pvalue->value.u.extElem1->numocts;
                    openType.data = pvalue->value.u.extElem1->data;
                } else {
                    /* No extension element to encode */
                }
                encoded = FALSE;
                break;
            }

            default:
                encoded = FALSE;
                stat = RTERR_INVOPT;
                break;
        } 

        if(encoded){
            openType.numocts = (OSUINT32)pe_GetMsgLen(pctxt);
            openType.data = pDynamicEncodeBuffer = pctxt -> buffer.data;
        }
        rtxCopyContext(pctxt, &lctxt);

        if(stat == 0) {
            stat = pe_OpenType (pctxt, openType.numocts, openType.data);
        }
    #if 1
        if(encoded){//dungnm23 check lai nhe
            rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
        }
    #endif

    }

    if(stat!=0) return LOG_RTERR(pctxt, stat);  
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}

EXTERN int  asn1PD_e2ap_RICcontrolAcknowledge_protocolIEs_element (OSCTXT* pctxt, e2ap_RICcontrolAcknowledge_protocolIEs_element* pvalue){
    int stat =0;

    /*decode id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PD_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PD_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");

    {
        OSUINT32 openTypeLen;
        size_t bitStartOffset, bitLength;

        stat = pd_UnconsLength(pctxt, &openTypeLen);
        if(stat<0) return LOG_RTERR(pctxt, stat);
        else if(stat == RT_OK_FRAG){
            rtxErrAddStrParm(pctxt, "open type with fragment length");
            return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
        }
        bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
        bitLength = openTypeLen * 8;

        switch(pvalue->id){//dungnm23 check case lai nhe
        
            case ASN1V_e2ap_id_RICrequestID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICcontrolAcknowledge_IEs_id_RICrequestID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICrequestID");
                pvalue->value.u._e2ap_RICcontrolAcknowledge_IEs_id_RICrequestID 
                    = rtxMemAllocType(pctxt, e2ap_RICrequestID);

                asn1Init_e2ap_RICrequestID(pvalue->value.u._e2ap_RICcontrolAcknowledge_IEs_id_RICrequestID);

                stat = asn1PD_e2ap_RICrequestID (pctxt,
                        (e2ap_RICrequestID*)pvalue->value.
                        u._e2ap_RICcontrolAcknowledge_IEs_id_RICrequestID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RANfunctionID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICcontrolAcknowledge_IEs_id_RANfunctionID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RANfunctionID");
                pvalue->value.u._e2ap_RICcontrolAcknowledge_IEs_id_RANfunctionID 
                    = rtxMemAllocType(pctxt, e2ap_RANfunctionID);

                asn1Init_e2ap_RANfunctionID(pvalue->value.u._e2ap_RICcontrolAcknowledge_IEs_id_RANfunctionID);

                stat = asn1PD_e2ap_RANfunctionID (pctxt,
                        (e2ap_RANfunctionID*)pvalue->value.
                        u._e2ap_RICcontrolAcknowledge_IEs_id_RANfunctionID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RICcallProcessID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICcontrolAcknowledge_IEs_id_RICcallProcessID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICcallProcessID");
                pvalue->value.u._e2ap_RICcontrolAcknowledge_IEs_id_RICcallProcessID 
                    = rtxMemAllocType(pctxt, e2ap_RICcallProcessID);

                asn1Init_e2ap_RICcallProcessID(pvalue->value.u._e2ap_RICcontrolAcknowledge_IEs_id_RICcallProcessID);

                stat = asn1PD_e2ap_RICcallProcessID (pctxt,
                        (e2ap_RICcallProcessID*)pvalue->value.
                        u._e2ap_RICcontrolAcknowledge_IEs_id_RICcallProcessID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RICcontrolOutcome:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICcontrolAcknowledge_IEs_id_RICcontrolOutcome;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICcontrolOutcome");
                pvalue->value.u._e2ap_RICcontrolAcknowledge_IEs_id_RICcontrolOutcome 
                    = rtxMemAllocType(pctxt, e2ap_RICcontrolOutcome);

                asn1Init_e2ap_RICcontrolOutcome(pvalue->value.u._e2ap_RICcontrolAcknowledge_IEs_id_RICcontrolOutcome);

                stat = asn1PD_e2ap_RICcontrolOutcome (pctxt,
                        (e2ap_RICcontrolOutcome*)pvalue->value.
                        u._e2ap_RICcontrolAcknowledge_IEs_id_RICcontrolOutcome);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICcontrolAcknowledge_IEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*) rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
    }
    {
    size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
    size_t bitsConsumed = bitEndOffset-bitStartOffset;
    if(bitsConsumed<bitLength){
        stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
    }
    else stat =(bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
    }}
    if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}


int asn1Init_e2ap_RICcontrolAcknowledge_protocolIEs_element(e2ap_RICcontrolAcknowledge_protocolIEs_element* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    OSCRTLMEMSET (&pvalue->value, 0, sizeof(pvalue->value));
    return 0;
}


//-----> chuaw có template rtxFreeASN1OpenType

#if 0
void asn1Free_e2ap_RICcontrolAcknowledge_protocolIEs_element(OSCTXT* pctxt, e2ap_RICcontrolAcknowledge_protocolIEs_element* pvalue)
{
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICcontrolAcknowledge_IEs_id_id_RICrequestID:
            // rtxFreeE2ap_RICrequestID(pvalue->value.u._e2ap_RICcontrolAcknowledge_IEs_id_id_RICrequestID);

            if(pvalue->value.i._e2ap_RICcontrolAcknowledge_id_RICrequestID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICrequestID(pctxt, pvalue->value.u._e2ap_RICcontrolAcknowledge_IEs_id_id_RICrequestID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICcontrolAcknowledge_IEs_id_id_RICrequestID);
           // pvalue->value.u._e2ap_RICcontrolAcknowledge_IEs_id_id_RICrequestID = NULL;
           pvalue->value.u._e2ap_RICcontrolAcknowledge_IEs_id_RICrequestID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICcontrolAcknowledge_IEs_id_id_RANfunctionID:
            // rtxFreeE2ap_RANfunctionID(pvalue->value.u._e2ap_RICcontrolAcknowledge_IEs_id_id_RANfunctionID);

            if(pvalue->value.i._e2ap_RICcontrolAcknowledge_id_RANfunctionID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RANfunctionID(pctxt, pvalue->value.u._e2ap_RICcontrolAcknowledge_IEs_id_id_RANfunctionID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICcontrolAcknowledge_IEs_id_id_RANfunctionID);
           // pvalue->value.u._e2ap_RICcontrolAcknowledge_IEs_id_id_RANfunctionID = NULL;
           pvalue->value.u._e2ap_RICcontrolAcknowledge_IEs_id_RANfunctionID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICcontrolAcknowledge_IEs_id_id_RICcallProcessID:
            // rtxFreeE2ap_RICcallProcessID(pvalue->value.u._e2ap_RICcontrolAcknowledge_IEs_id_id_RICcallProcessID);

            if(pvalue->value.i._e2ap_RICcontrolAcknowledge_id_RICcallProcessID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICcallProcessID(pctxt, pvalue->value.u._e2ap_RICcontrolAcknowledge_IEs_id_id_RICcallProcessID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICcontrolAcknowledge_IEs_id_id_RICcallProcessID);
           // pvalue->value.u._e2ap_RICcontrolAcknowledge_IEs_id_id_RICcallProcessID = NULL;
           pvalue->value.u._e2ap_RICcontrolAcknowledge_IEs_id_RICcallProcessID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICcontrolAcknowledge_IEs_id_id_RICcontrolOutcome:
            // rtxFreeE2ap_RICcontrolOutcome(pvalue->value.u._e2ap_RICcontrolAcknowledge_IEs_id_id_RICcontrolOutcome);

            if(pvalue->value.i._e2ap_RICcontrolAcknowledge_id_RICcontrolOutcome!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICcontrolOutcome(pctxt, pvalue->value.u._e2ap_RICcontrolAcknowledge_IEs_id_id_RICcontrolOutcome);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICcontrolAcknowledge_IEs_id_id_RICcontrolOutcome);
           // pvalue->value.u._e2ap_RICcontrolAcknowledge_IEs_id_id_RICcontrolOutcome = NULL;
           pvalue->value.u._e2ap_RICcontrolAcknowledge_IEs_id_RICcontrolOutcome = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICcontrolAcknowledge_IEs_UNDEF_:
            rtxFreeASN1OpenType(pvalue->value.u.extElem1);
            break;
        default:
            break;
    }
}

int asn1PrtToStr_e2ap_RICcontrolAcknowledge_protocolIEs_element(OSCTXT* pctxt, e2ap_RICcontrolAcknowledge_protocolIEs_element* pvalue)
{
    int stat =0;
    RTXCTXTPUSHELEMNAME(pctxt, "e2ap_RICcontrolAcknowledge_protocolIEs_element");

    /*print id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PrtToStr_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PrtToStr_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_RICcontrolAcknowledge_IEs_id_id_RICrequestID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICrequestID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICrequestID (pctxt, pvalue->value.u._e2ap_RICcontrolAcknowledge_IEs_id_id_RICrequestID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICcontrolAcknowledge_IEs_id_id_RANfunctionID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RANfunctionID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RANfunctionID (pctxt, pvalue->value.u._e2ap_RICcontrolAcknowledge_IEs_id_id_RANfunctionID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICcontrolAcknowledge_IEs_id_id_RICcallProcessID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICcallProcessID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICcallProcessID (pctxt, pvalue->value.u._e2ap_RICcontrolAcknowledge_IEs_id_id_RICcallProcessID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICcontrolAcknowledge_IEs_id_id_RICcontrolOutcome:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICcontrolOutcome");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICcontrolOutcome (pctxt, pvalue->value.u._e2ap_RICcontrolAcknowledge_IEs_id_id_RICcontrolOutcome);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_RICcontrolAcknowledge_IEs_UNDEF_:
            {
                rtxPLogMsg(pctxt, "Extension element present - raw data not printed.\n");
                break;
            }

            default:
                stat = RTERR_INVOPT;
                return LOG_RTERR(pctxt, stat);
        }
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);
}
#endif


int asn1PrtToStr_e2ap_RICcontrolAcknowledge_protocolIEs_element (const char * name,
 e2ap_RICcontrolAcknowledge_protocolIEs_element* pvalue, 
 char * buffer, OSSIZE bufSize){
    if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
        return -1;
    if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
        return -1;

    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICcontrolAcknowledge_IEs_id_RICrequestID:
            if(asn1PrtToStr_e2ap_RICrequestID("RICrequestID", 
                    pvalue->value.u._e2ap_RICcontrolAcknowledge_IEs_id_RICrequestID, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICcontrolAcknowledge_IEs_id_RANfunctionID:
            if(asn1PrtToStr_e2ap_RANfunctionID("RANfunctionID", 
                    pvalue->value.u._e2ap_RICcontrolAcknowledge_IEs_id_RANfunctionID, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICcontrolAcknowledge_IEs_id_RICcallProcessID:
            if(asn1PrtToStr_e2ap_RICcallProcessID("RICcallProcessID", 
                    pvalue->value.u._e2ap_RICcontrolAcknowledge_IEs_id_RICcallProcessID, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICcontrolAcknowledge_IEs_id_RICcontrolOutcome:
            if(asn1PrtToStr_e2ap_RICcontrolOutcome("RICcontrolOutcome", 
                    pvalue->value.u._e2ap_RICcontrolAcknowledge_IEs_id_RICcontrolOutcome, buffer, bufSize)<0)
                return -1;
            break;    
        default:
        if(0!=pvalue -> value.u.extElem1){
            rtPrintToStringIndent(buffer, bufSize);
            rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

        }
        }
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

    return 0;

 }

 void asn1Free_e2ap_RICcontrolAcknowledge_protocolIEs_element(OSCTXT* pctxt, e2ap_RICcontrolAcknowledge_protocolIEs_element* pvalue){
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICcontrolAcknowledge_IEs_id_RICrequestID:
            if(pvalue->value.u._e2ap_RICcontrolAcknowledge_IEs_id_RICrequestID!=NULL){
            asn1Free_e2ap_RICrequestID(pctxt, pvalue->value.u._e2ap_RICcontrolAcknowledge_IEs_id_RICrequestID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICcontrolAcknowledge_IEs_id_RICrequestID);
            pvalue->value.u._e2ap_RICcontrolAcknowledge_IEs_id_RICrequestID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICcontrolAcknowledge_IEs_id_RANfunctionID:
            if(pvalue->value.u._e2ap_RICcontrolAcknowledge_IEs_id_RANfunctionID!=NULL){
            asn1Free_e2ap_RANfunctionID(pctxt, pvalue->value.u._e2ap_RICcontrolAcknowledge_IEs_id_RANfunctionID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICcontrolAcknowledge_IEs_id_RANfunctionID);
            pvalue->value.u._e2ap_RICcontrolAcknowledge_IEs_id_RANfunctionID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICcontrolAcknowledge_IEs_id_RICcallProcessID:
            if(pvalue->value.u._e2ap_RICcontrolAcknowledge_IEs_id_RICcallProcessID!=NULL){
            asn1Free_e2ap_RICcallProcessID(pctxt, pvalue->value.u._e2ap_RICcontrolAcknowledge_IEs_id_RICcallProcessID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICcontrolAcknowledge_IEs_id_RICcallProcessID);
            pvalue->value.u._e2ap_RICcontrolAcknowledge_IEs_id_RICcallProcessID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICcontrolAcknowledge_IEs_id_RICcontrolOutcome:
            if(pvalue->value.u._e2ap_RICcontrolAcknowledge_IEs_id_RICcontrolOutcome!=NULL){
            asn1Free_e2ap_RICcontrolOutcome(pctxt, pvalue->value.u._e2ap_RICcontrolAcknowledge_IEs_id_RICcontrolOutcome);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICcontrolAcknowledge_IEs_id_RICcontrolOutcome);
            pvalue->value.u._e2ap_RICcontrolAcknowledge_IEs_id_RICcontrolOutcome = NULL;
            }
            break;
        default:
            break;


    }
 }

 

/*****************************************/
/*           RICcontrolAcknowledge                */
/*****************************************/
//2_container.c
/* 1. xxx_ProtocolIE -> mẫu cũ ở ie_big_msg */
EXTERN int asn1PE_e2ap_RICcontrolAcknowledge_protocolIEs (OSCTXT* pctxt, e2ap_RICcontrolAcknowledge_protocolIEs* pvalue)
{
    int stat =0;
    OSRTDListNode* pnode;
    OSUINT32 xx1;

    /*encode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pe_Length(pctxt, pvalue->count);
    if(stat<0) return LOG_RTERR(pctxt, stat);

    /*encode each element*/
    xx1 =0;
    for(pnode = pvalue->head; pnode != 0 && xx1<pvalue->count; pnode = pnode->next){
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE", xx1);
        stat = asn1PE_e2ap_RICcontrolAcknowledge_protocolIEs_element (pctxt, ((e2ap_RICcontrolAcknowledge_protocolIEs_element*)pnode->data));
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        xx1++;
        RTXCTXTPOPARRAYELEMNAME(pctxt);
    }

    return (stat);
}

EXTERN int  asn1PD_e2ap_RICcontrolAcknowledge_protocolIEs(OSCTXT* pctxt, e2ap_RICcontrolAcknowledge_protocolIEs* pvalue)
{
     int stat =0;
     OSRTDListNode* pnode;
     OSSIZE count =0;
     OSSIZE xx1=0;


     /*decode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pd_Length64(pctxt, &count); //tai sao lai 64
    if(stat!=0) return LOG_RTERR(pctxt, stat);

    /*decode each element*/
    rtxDListInit(pvalue);

    for(xx1=0; xx1 < count; xx1++){
        e2ap_RICcontrolAcknowledge_protocolIEs_element* pdata;
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE",xx1);

        if(pnode == NULL) return LOG_RTERR(pctxt, RTERR_NOMEM);

        asn1Init_e2ap_RICcontrolAcknowledge_protocolIEs_element(pdata);
        rtxDListAppendNode(pvalue, pnode);
        stat = asn1PD_e2ap_RICcontrolAcknowledge_protocolIEs_element (pctxt, pdata);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        RTXCTXTPOPARRAYELEMNAME(pctxt);

    }
    return (stat);
}


int asn1Init_e2ap_RICcontrolAcknowledge_protocolIEs(e2ap_RICcontrolAcknowledge_protocolIEs* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    rtxDListFastInit (pvalue);
    return 0;
}
#if 1 //ao that day
void asn1Free_e2ap_RICcontrolAcknowledge_protocolIEs(OSCTXT* pctxt, e2ap_RICcontrolAcknowledge_protocolIEs* pvalue)
{
    if(0==pvalue) return;   
    e2ap_RICcontrolAcknowledge_protocolIEs_element* pdata;
    OSRTDListNode* pnode=pvalue->head;
    while(0!=pnode){
        pdata = (e2ap_RICcontrolAcknowledge_protocolIEs_element*)pnode->data;
       // asn1Free_e2ap_RICcontrolAcknowledge_protocolIEs_element(pctxt, pdata);
        pnode = pnode->next;
    }
    rtxDListFreeAll(pctxt, pvalue);
}
#endif


EXTERN int asn1PrtToStr_e2ap_RICcontrolAcknowledge_protocolIEs(const char* name, e2ap_RICcontrolAcknowledge_protocolIEs* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_RICcontrolAcknowledge_protocolIEs_element* pdata0;
    OSRTDListNode* pnode0;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode0 = pvalue->head;  xx1 < pvalue->count && pnode0 != 0; pnode0 = pnode0->next, xx1++){
        pdata0 = (e2ap_RICcontrolAcknowledge_protocolIEs_element*)pnode0->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 0
        if(asn1PrtToStr_e2ap_RICcontrolAcknowledge_protocolIEs_element(nameBuf, pdata0, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}


/*2 . RICcontrolAcknowledge -> mẫu cũ ở seq_normal*/

int asn1PE_e2ap_RICcontrolAcknowledge (OSCTXT* pctxt, e2ap_RICcontrolAcknowledge* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RICcontrolAcknowledge");
   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field protocolIEs - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
   stat = asn1PE_e2ap_RICcontrolAcknowledge_protocolIEs (pctxt, &pvalue->protocolIEs);
   if(stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RICcontrolAcknowledge (OSCTXT* pctxt, e2ap_RICcontrolAcknowledge* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME(pctxt, "RICcontrolAcknowledge");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field protocolIEs */
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
      stat = asn1PD_e2ap_RICcontrolAcknowledge_protocolIEs (pctxt, &pvalue->protocolIEs);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RICcontrolAcknowledge (e2ap_RICcontrolAcknowledge* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RICcontrolAcknowledge_protocolIEs(&pvalue->protocolIEs);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RICcontrolAcknowledge (OSCTXT* pctxt, e2ap_RICcontrolAcknowledge* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_RICcontrolAcknowledge_protocolIEs(pctxt, &pvalue->protocolIEs);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RICcontrolAcknowledge (const char* name, e2ap_RICcontrolAcknowledge* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }

   if(asn1PrtToStr_e2ap_RICcontrolAcknowledge_protocolIEs("protocolIEs", &pvalue->protocolIEs, buffer, bufSize) <0){
      return -1;
   }

   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           RICcontrolFailure_IEs                */
/*****************************************/
/* ie.c.j2 */
 /* d là con của msg */
EXTERN int asn1PE_e2ap_RICcontrolFailure_protocolIEs_element (OSCTXT* pctxt, e2ap_RICcontrolFailure_protocolIEs_element* pvalue)
{
    int stat =0;

    /*encode id*/

    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PE_e2ap_ProtocolIE_ID(pctxt, pvalue->id);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PE_e2ap_Criticality(pctxt, pvalue->criticality);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
    {
        OSCTXT lctxt;
        OSOCTET *pDynamicEncodeBuffer;
        ASN1OpenType openType;
        OSBOOL encoded = TRUE;

        openType.numocts = 0;
        openType.data =0;

        rtxCopyContext(&lctxt, pctxt);
        pctxt->pStream =0;

        stat = rtxInitContextBuffer(pctxt, 0, 0);
        if(stat!=0) return LOG_RTERR(pctxt, stat);

        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_RICcontrolFailure_IEs_id_RICrequestID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICrequestID");
                    stat = asn1PE_e2ap_RICrequestID (pctxt, pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_RICrequestID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICcontrolFailure_IEs_id_RANfunctionID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RANfunctionID");
                    stat = asn1PE_e2ap_RANfunctionID (pctxt, pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_RANfunctionID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICcontrolFailure_IEs_id_RICcallProcessID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICcallProcessID");
                    stat = asn1PE_e2ap_RICcallProcessID (pctxt, pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_RICcallProcessID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICcontrolFailure_IEs_id_Cause:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-Cause");
                    stat = asn1PE_e2ap_Cause (pctxt, pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_Cause);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICcontrolFailure_IEs_id_RICcontrolOutcome:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICcontrolOutcome");
                    stat = asn1PE_e2ap_RICcontrolOutcome (pctxt, pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_RICcontrolOutcome);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICcontrolFailure_IEs_id_CriticalityDiagnostics:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-CriticalityDiagnostics");
                    stat = asn1PE_e2ap_CriticalityDiagnostics (pctxt, pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_CriticalityDiagnostics);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_RICcontrolFailure_IEs_UNDEF_:
            {
                if(0!=pvalue->value.u.extElem1){
                    openType.numocts = pvalue->value.u.extElem1->numocts;
                    openType.data = pvalue->value.u.extElem1->data;
                } else {
                    /* No extension element to encode */
                }
                encoded = FALSE;
                break;
            }

            default:
                encoded = FALSE;
                stat = RTERR_INVOPT;
                break;
        } 

        if(encoded){
            openType.numocts = (OSUINT32)pe_GetMsgLen(pctxt);
            openType.data = pDynamicEncodeBuffer = pctxt -> buffer.data;
        }
        rtxCopyContext(pctxt, &lctxt);

        if(stat == 0) {
            stat = pe_OpenType (pctxt, openType.numocts, openType.data);
        }
    #if 1
        if(encoded){//dungnm23 check lai nhe
            rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
        }
    #endif

    }

    if(stat!=0) return LOG_RTERR(pctxt, stat);  
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}

EXTERN int  asn1PD_e2ap_RICcontrolFailure_protocolIEs_element (OSCTXT* pctxt, e2ap_RICcontrolFailure_protocolIEs_element* pvalue){
    int stat =0;

    /*decode id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PD_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PD_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");

    {
        OSUINT32 openTypeLen;
        size_t bitStartOffset, bitLength;

        stat = pd_UnconsLength(pctxt, &openTypeLen);
        if(stat<0) return LOG_RTERR(pctxt, stat);
        else if(stat == RT_OK_FRAG){
            rtxErrAddStrParm(pctxt, "open type with fragment length");
            return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
        }
        bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
        bitLength = openTypeLen * 8;

        switch(pvalue->id){//dungnm23 check case lai nhe
        
            case ASN1V_e2ap_id_RICrequestID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICcontrolFailure_IEs_id_RICrequestID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICrequestID");
                pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_RICrequestID 
                    = rtxMemAllocType(pctxt, e2ap_RICrequestID);

                asn1Init_e2ap_RICrequestID(pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_RICrequestID);

                stat = asn1PD_e2ap_RICrequestID (pctxt,
                        (e2ap_RICrequestID*)pvalue->value.
                        u._e2ap_RICcontrolFailure_IEs_id_RICrequestID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RANfunctionID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICcontrolFailure_IEs_id_RANfunctionID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RANfunctionID");
                pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_RANfunctionID 
                    = rtxMemAllocType(pctxt, e2ap_RANfunctionID);

                asn1Init_e2ap_RANfunctionID(pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_RANfunctionID);

                stat = asn1PD_e2ap_RANfunctionID (pctxt,
                        (e2ap_RANfunctionID*)pvalue->value.
                        u._e2ap_RICcontrolFailure_IEs_id_RANfunctionID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RICcallProcessID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICcontrolFailure_IEs_id_RICcallProcessID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICcallProcessID");
                pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_RICcallProcessID 
                    = rtxMemAllocType(pctxt, e2ap_RICcallProcessID);

                asn1Init_e2ap_RICcallProcessID(pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_RICcallProcessID);

                stat = asn1PD_e2ap_RICcallProcessID (pctxt,
                        (e2ap_RICcallProcessID*)pvalue->value.
                        u._e2ap_RICcontrolFailure_IEs_id_RICcallProcessID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_Cause:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICcontrolFailure_IEs_id_Cause;
            RTXCTXTPUSHELEMNAME(pctxt, "id-Cause");
                pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_Cause 
                    = rtxMemAllocType(pctxt, e2ap_Cause);

                asn1Init_e2ap_Cause(pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_Cause);

                stat = asn1PD_e2ap_Cause (pctxt,
                        (e2ap_Cause*)pvalue->value.
                        u._e2ap_RICcontrolFailure_IEs_id_Cause);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RICcontrolOutcome:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICcontrolFailure_IEs_id_RICcontrolOutcome;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICcontrolOutcome");
                pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_RICcontrolOutcome 
                    = rtxMemAllocType(pctxt, e2ap_RICcontrolOutcome);

                asn1Init_e2ap_RICcontrolOutcome(pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_RICcontrolOutcome);

                stat = asn1PD_e2ap_RICcontrolOutcome (pctxt,
                        (e2ap_RICcontrolOutcome*)pvalue->value.
                        u._e2ap_RICcontrolFailure_IEs_id_RICcontrolOutcome);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_CriticalityDiagnostics:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICcontrolFailure_IEs_id_CriticalityDiagnostics;
            RTXCTXTPUSHELEMNAME(pctxt, "id-CriticalityDiagnostics");
                pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_CriticalityDiagnostics 
                    = rtxMemAllocType(pctxt, e2ap_CriticalityDiagnostics);

                asn1Init_e2ap_CriticalityDiagnostics(pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_CriticalityDiagnostics);

                stat = asn1PD_e2ap_CriticalityDiagnostics (pctxt,
                        (e2ap_CriticalityDiagnostics*)pvalue->value.
                        u._e2ap_RICcontrolFailure_IEs_id_CriticalityDiagnostics);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICcontrolFailure_IEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*) rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
    }
    {
    size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
    size_t bitsConsumed = bitEndOffset-bitStartOffset;
    if(bitsConsumed<bitLength){
        stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
    }
    else stat =(bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
    }}
    if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}


int asn1Init_e2ap_RICcontrolFailure_protocolIEs_element(e2ap_RICcontrolFailure_protocolIEs_element* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    OSCRTLMEMSET (&pvalue->value, 0, sizeof(pvalue->value));
    return 0;
}


//-----> chuaw có template rtxFreeASN1OpenType

#if 0
void asn1Free_e2ap_RICcontrolFailure_protocolIEs_element(OSCTXT* pctxt, e2ap_RICcontrolFailure_protocolIEs_element* pvalue)
{
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICcontrolFailure_IEs_id_id_RICrequestID:
            // rtxFreeE2ap_RICrequestID(pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_id_RICrequestID);

            if(pvalue->value.i._e2ap_RICcontrolFailure_id_RICrequestID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICrequestID(pctxt, pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_id_RICrequestID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_id_RICrequestID);
           // pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_id_RICrequestID = NULL;
           pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_RICrequestID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICcontrolFailure_IEs_id_id_RANfunctionID:
            // rtxFreeE2ap_RANfunctionID(pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_id_RANfunctionID);

            if(pvalue->value.i._e2ap_RICcontrolFailure_id_RANfunctionID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RANfunctionID(pctxt, pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_id_RANfunctionID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_id_RANfunctionID);
           // pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_id_RANfunctionID = NULL;
           pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_RANfunctionID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICcontrolFailure_IEs_id_id_RICcallProcessID:
            // rtxFreeE2ap_RICcallProcessID(pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_id_RICcallProcessID);

            if(pvalue->value.i._e2ap_RICcontrolFailure_id_RICcallProcessID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICcallProcessID(pctxt, pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_id_RICcallProcessID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_id_RICcallProcessID);
           // pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_id_RICcallProcessID = NULL;
           pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_RICcallProcessID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICcontrolFailure_IEs_id_id_Cause:
            // rtxFreeE2ap_Cause(pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_id_Cause);

            if(pvalue->value.i._e2ap_RICcontrolFailure_id_Cause!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_Cause(pctxt, pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_id_Cause);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_id_Cause);
           // pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_id_Cause = NULL;
           pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_Cause = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICcontrolFailure_IEs_id_id_RICcontrolOutcome:
            // rtxFreeE2ap_RICcontrolOutcome(pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_id_RICcontrolOutcome);

            if(pvalue->value.i._e2ap_RICcontrolFailure_id_RICcontrolOutcome!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICcontrolOutcome(pctxt, pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_id_RICcontrolOutcome);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_id_RICcontrolOutcome);
           // pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_id_RICcontrolOutcome = NULL;
           pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_RICcontrolOutcome = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICcontrolFailure_IEs_id_id_CriticalityDiagnostics:
            // rtxFreeE2ap_CriticalityDiagnostics(pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_id_CriticalityDiagnostics);

            if(pvalue->value.i._e2ap_RICcontrolFailure_id_CriticalityDiagnostics!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_CriticalityDiagnostics(pctxt, pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_id_CriticalityDiagnostics);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_id_CriticalityDiagnostics);
           // pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_id_CriticalityDiagnostics = NULL;
           pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_CriticalityDiagnostics = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICcontrolFailure_IEs_UNDEF_:
            rtxFreeASN1OpenType(pvalue->value.u.extElem1);
            break;
        default:
            break;
    }
}

int asn1PrtToStr_e2ap_RICcontrolFailure_protocolIEs_element(OSCTXT* pctxt, e2ap_RICcontrolFailure_protocolIEs_element* pvalue)
{
    int stat =0;
    RTXCTXTPUSHELEMNAME(pctxt, "e2ap_RICcontrolFailure_protocolIEs_element");

    /*print id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PrtToStr_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PrtToStr_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_RICcontrolFailure_IEs_id_id_RICrequestID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICrequestID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICrequestID (pctxt, pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_id_RICrequestID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICcontrolFailure_IEs_id_id_RANfunctionID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RANfunctionID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RANfunctionID (pctxt, pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_id_RANfunctionID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICcontrolFailure_IEs_id_id_RICcallProcessID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICcallProcessID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICcallProcessID (pctxt, pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_id_RICcallProcessID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICcontrolFailure_IEs_id_id_Cause:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "Cause");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_Cause (pctxt, pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_id_Cause);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICcontrolFailure_IEs_id_id_RICcontrolOutcome:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICcontrolOutcome");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICcontrolOutcome (pctxt, pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_id_RICcontrolOutcome);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICcontrolFailure_IEs_id_id_CriticalityDiagnostics:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "CriticalityDiagnostics");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_CriticalityDiagnostics (pctxt, pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_id_CriticalityDiagnostics);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_RICcontrolFailure_IEs_UNDEF_:
            {
                rtxPLogMsg(pctxt, "Extension element present - raw data not printed.\n");
                break;
            }

            default:
                stat = RTERR_INVOPT;
                return LOG_RTERR(pctxt, stat);
        }
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);
}
#endif


int asn1PrtToStr_e2ap_RICcontrolFailure_protocolIEs_element (const char * name,
 e2ap_RICcontrolFailure_protocolIEs_element* pvalue, 
 char * buffer, OSSIZE bufSize){
    if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
        return -1;
    if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
        return -1;

    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICcontrolFailure_IEs_id_RICrequestID:
            if(asn1PrtToStr_e2ap_RICrequestID("RICrequestID", 
                    pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_RICrequestID, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICcontrolFailure_IEs_id_RANfunctionID:
            if(asn1PrtToStr_e2ap_RANfunctionID("RANfunctionID", 
                    pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_RANfunctionID, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICcontrolFailure_IEs_id_RICcallProcessID:
            if(asn1PrtToStr_e2ap_RICcallProcessID("RICcallProcessID", 
                    pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_RICcallProcessID, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICcontrolFailure_IEs_id_Cause:
            if(asn1PrtToStr_e2ap_Cause("Cause", 
                    pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_Cause, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICcontrolFailure_IEs_id_RICcontrolOutcome:
            if(asn1PrtToStr_e2ap_RICcontrolOutcome("RICcontrolOutcome", 
                    pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_RICcontrolOutcome, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICcontrolFailure_IEs_id_CriticalityDiagnostics:
            if(asn1PrtToStr_e2ap_CriticalityDiagnostics("CriticalityDiagnostics", 
                    pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_CriticalityDiagnostics, buffer, bufSize)<0)
                return -1;
            break;    
        default:
        if(0!=pvalue -> value.u.extElem1){
            rtPrintToStringIndent(buffer, bufSize);
            rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

        }
        }
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

    return 0;

 }

 void asn1Free_e2ap_RICcontrolFailure_protocolIEs_element(OSCTXT* pctxt, e2ap_RICcontrolFailure_protocolIEs_element* pvalue){
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICcontrolFailure_IEs_id_RICrequestID:
            if(pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_RICrequestID!=NULL){
            asn1Free_e2ap_RICrequestID(pctxt, pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_RICrequestID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_RICrequestID);
            pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_RICrequestID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICcontrolFailure_IEs_id_RANfunctionID:
            if(pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_RANfunctionID!=NULL){
            asn1Free_e2ap_RANfunctionID(pctxt, pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_RANfunctionID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_RANfunctionID);
            pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_RANfunctionID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICcontrolFailure_IEs_id_RICcallProcessID:
            if(pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_RICcallProcessID!=NULL){
            asn1Free_e2ap_RICcallProcessID(pctxt, pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_RICcallProcessID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_RICcallProcessID);
            pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_RICcallProcessID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICcontrolFailure_IEs_id_Cause:
            if(pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_Cause!=NULL){
            asn1Free_e2ap_Cause(pctxt, pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_Cause);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_Cause);
            pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_Cause = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICcontrolFailure_IEs_id_RICcontrolOutcome:
            if(pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_RICcontrolOutcome!=NULL){
            asn1Free_e2ap_RICcontrolOutcome(pctxt, pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_RICcontrolOutcome);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_RICcontrolOutcome);
            pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_RICcontrolOutcome = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICcontrolFailure_IEs_id_CriticalityDiagnostics:
            if(pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_CriticalityDiagnostics!=NULL){
            asn1Free_e2ap_CriticalityDiagnostics(pctxt, pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_CriticalityDiagnostics);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_CriticalityDiagnostics);
            pvalue->value.u._e2ap_RICcontrolFailure_IEs_id_CriticalityDiagnostics = NULL;
            }
            break;
        default:
            break;


    }
 }

 

/*****************************************/
/*           RICcontrolFailure                */
/*****************************************/
//2_container.c
/* 1. xxx_ProtocolIE -> mẫu cũ ở ie_big_msg */
EXTERN int asn1PE_e2ap_RICcontrolFailure_protocolIEs (OSCTXT* pctxt, e2ap_RICcontrolFailure_protocolIEs* pvalue)
{
    int stat =0;
    OSRTDListNode* pnode;
    OSUINT32 xx1;

    /*encode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pe_Length(pctxt, pvalue->count);
    if(stat<0) return LOG_RTERR(pctxt, stat);

    /*encode each element*/
    xx1 =0;
    for(pnode = pvalue->head; pnode != 0 && xx1<pvalue->count; pnode = pnode->next){
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE", xx1);
        stat = asn1PE_e2ap_RICcontrolFailure_protocolIEs_element (pctxt, ((e2ap_RICcontrolFailure_protocolIEs_element*)pnode->data));
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        xx1++;
        RTXCTXTPOPARRAYELEMNAME(pctxt);
    }

    return (stat);
}

EXTERN int  asn1PD_e2ap_RICcontrolFailure_protocolIEs(OSCTXT* pctxt, e2ap_RICcontrolFailure_protocolIEs* pvalue)
{
     int stat =0;
     OSRTDListNode* pnode;
     OSSIZE count =0;
     OSSIZE xx1=0;


     /*decode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pd_Length64(pctxt, &count); //tai sao lai 64
    if(stat!=0) return LOG_RTERR(pctxt, stat);

    /*decode each element*/
    rtxDListInit(pvalue);

    for(xx1=0; xx1 < count; xx1++){
        e2ap_RICcontrolFailure_protocolIEs_element* pdata;
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE",xx1);

        if(pnode == NULL) return LOG_RTERR(pctxt, RTERR_NOMEM);

        asn1Init_e2ap_RICcontrolFailure_protocolIEs_element(pdata);
        rtxDListAppendNode(pvalue, pnode);
        stat = asn1PD_e2ap_RICcontrolFailure_protocolIEs_element (pctxt, pdata);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        RTXCTXTPOPARRAYELEMNAME(pctxt);

    }
    return (stat);
}


int asn1Init_e2ap_RICcontrolFailure_protocolIEs(e2ap_RICcontrolFailure_protocolIEs* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    rtxDListFastInit (pvalue);
    return 0;
}
#if 1 //ao that day
void asn1Free_e2ap_RICcontrolFailure_protocolIEs(OSCTXT* pctxt, e2ap_RICcontrolFailure_protocolIEs* pvalue)
{
    if(0==pvalue) return;   
    e2ap_RICcontrolFailure_protocolIEs_element* pdata;
    OSRTDListNode* pnode=pvalue->head;
    while(0!=pnode){
        pdata = (e2ap_RICcontrolFailure_protocolIEs_element*)pnode->data;
       // asn1Free_e2ap_RICcontrolFailure_protocolIEs_element(pctxt, pdata);
        pnode = pnode->next;
    }
    rtxDListFreeAll(pctxt, pvalue);
}
#endif


EXTERN int asn1PrtToStr_e2ap_RICcontrolFailure_protocolIEs(const char* name, e2ap_RICcontrolFailure_protocolIEs* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_RICcontrolFailure_protocolIEs_element* pdata0;
    OSRTDListNode* pnode0;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode0 = pvalue->head;  xx1 < pvalue->count && pnode0 != 0; pnode0 = pnode0->next, xx1++){
        pdata0 = (e2ap_RICcontrolFailure_protocolIEs_element*)pnode0->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 0
        if(asn1PrtToStr_e2ap_RICcontrolFailure_protocolIEs_element(nameBuf, pdata0, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}


/*2 . RICcontrolFailure -> mẫu cũ ở seq_normal*/

int asn1PE_e2ap_RICcontrolFailure (OSCTXT* pctxt, e2ap_RICcontrolFailure* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RICcontrolFailure");
   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field protocolIEs - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
   stat = asn1PE_e2ap_RICcontrolFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
   if(stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RICcontrolFailure (OSCTXT* pctxt, e2ap_RICcontrolFailure* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME(pctxt, "RICcontrolFailure");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field protocolIEs */
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
      stat = asn1PD_e2ap_RICcontrolFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RICcontrolFailure (e2ap_RICcontrolFailure* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RICcontrolFailure_protocolIEs(&pvalue->protocolIEs);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RICcontrolFailure (OSCTXT* pctxt, e2ap_RICcontrolFailure* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_RICcontrolFailure_protocolIEs(pctxt, &pvalue->protocolIEs);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RICcontrolFailure (const char* name, e2ap_RICcontrolFailure* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }

   if(asn1PrtToStr_e2ap_RICcontrolFailure_protocolIEs("protocolIEs", &pvalue->protocolIEs, buffer, bufSize) <0){
      return -1;
   }

   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           RICcontrolHeader                */
/*****************************************/
//9 mau octet string
//type 9  mau la octet string no size mau la pdusessioncommonnetworkinstance

EXTERN int asn1PE_e2ap_RICcontrolHeader (OSCTXT* pctxt, e2ap_RICcontrolHeader value){
   int stat = 0
   RTXCTCXTPUSHTYPENAME (pctxt, "RICcontrolHeader");
   stat = pe_OctetString(pctxt, value.numocts, value.data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPTYPENAME (pctxt);

}
EXTERN int asn1PD_e2ap_RICcontrolHeader (OSCTXT* pctxt, e2ap_RICcontrolHeader* pvalue){
   int stat = 0;
   RTXCTCXTPUSHTYPENAME (pctxt, "RICcontrolHeader");
   stat = pd_DynOctetString(pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}
EXTERN int asn1PrtToStr_e2ap_RICcontrolHeader (const char* name, e2ap_RICcontrolHeader *pvalue, char* buffer, OSSIZE bufSize){
   if(rtPrintToStringIndent(buffer, bufSize) < 0) return -1;
   if(rtPrintToStringHexStr(name, pvalue->numocts, pvalue->data, buffer, bufSize) < 0) return -1;
   return 0;
}
EXTERN int asn1PrtToStrm_e2ap_RICcontrolHeader (OSCTXT* pctxt, const char* name, const e2ap_RICcontrolHeader* pvalue){
   int stat =0;
   stat = rtPrintToStreamIndent(pctxt);
   if(stat !=0) return LOG_RTERR(pctxt, stat);
   stat = rtPrintToStreamHexStr(pctxt, name, pvalue->numocts, pvalue->data);
   if(stat !=0) return LOG_RTERR(pctxt, stat);
   return stat;
}
//EXTERN int asn1Copy_e2ap_RICcontrolHeader (OSCTXT* pctxt, const e2ap_RICcontrolHeader* pSrcValue, e2ap_RICcontrolHeader* pDstValue);
 int asn1Init_e2ap_RICcontrolHeader (e2ap_RICcontrolHeader* pvalue){
   if (pvalue == 0) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   pvalue->data = 0;
   return 0;
}
 void asn1Free_e2ap_RICcontrolHeader (OSCTXT* pctxt, e2ap_RICcontrolHeader* pvalue){
   if (pvalue == 0) return;
   if(pvalue->numocts>0){
       rtxMemFreePtr(pctxt, (void*)pvalue->data);
       pvalue->data = 0;
       pvalue->numocts = 0;
   }
}
int asn1Init_e2ap_RICcontrolHeader (e2ap_RICcontrolHeader* pvalue){
   if (pvalue == 0) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   pvalue->data = 0;
   return 0;
}
/*****************************************/
/*           RICcontrolMessage                */
/*****************************************/
//9 mau octet string
//type 9  mau la octet string no size mau la pdusessioncommonnetworkinstance

EXTERN int asn1PE_e2ap_RICcontrolMessage (OSCTXT* pctxt, e2ap_RICcontrolMessage value){
   int stat = 0
   RTXCTCXTPUSHTYPENAME (pctxt, "RICcontrolMessage");
   stat = pe_OctetString(pctxt, value.numocts, value.data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPTYPENAME (pctxt);

}
EXTERN int asn1PD_e2ap_RICcontrolMessage (OSCTXT* pctxt, e2ap_RICcontrolMessage* pvalue){
   int stat = 0;
   RTXCTCXTPUSHTYPENAME (pctxt, "RICcontrolMessage");
   stat = pd_DynOctetString(pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}
EXTERN int asn1PrtToStr_e2ap_RICcontrolMessage (const char* name, e2ap_RICcontrolMessage *pvalue, char* buffer, OSSIZE bufSize){
   if(rtPrintToStringIndent(buffer, bufSize) < 0) return -1;
   if(rtPrintToStringHexStr(name, pvalue->numocts, pvalue->data, buffer, bufSize) < 0) return -1;
   return 0;
}
EXTERN int asn1PrtToStrm_e2ap_RICcontrolMessage (OSCTXT* pctxt, const char* name, const e2ap_RICcontrolMessage* pvalue){
   int stat =0;
   stat = rtPrintToStreamIndent(pctxt);
   if(stat !=0) return LOG_RTERR(pctxt, stat);
   stat = rtPrintToStreamHexStr(pctxt, name, pvalue->numocts, pvalue->data);
   if(stat !=0) return LOG_RTERR(pctxt, stat);
   return stat;
}
//EXTERN int asn1Copy_e2ap_RICcontrolMessage (OSCTXT* pctxt, const e2ap_RICcontrolMessage* pSrcValue, e2ap_RICcontrolMessage* pDstValue);
 int asn1Init_e2ap_RICcontrolMessage (e2ap_RICcontrolMessage* pvalue){
   if (pvalue == 0) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   pvalue->data = 0;
   return 0;
}
 void asn1Free_e2ap_RICcontrolMessage (OSCTXT* pctxt, e2ap_RICcontrolMessage* pvalue){
   if (pvalue == 0) return;
   if(pvalue->numocts>0){
       rtxMemFreePtr(pctxt, (void*)pvalue->data);
       pvalue->data = 0;
       pvalue->numocts = 0;
   }
}
int asn1Init_e2ap_RICcontrolMessage (e2ap_RICcontrolMessage* pvalue){
   if (pvalue == 0) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   pvalue->data = 0;
   return 0;
}
/******************************************************/
/*                                                    */
/*    RICcontrolAckRequest                          */
/*                                                    */
/******************************************************/
//enumerated


const OSEnumItem e2ap_RICcontrolAckRequest_ENUMTAB[] = {
    { OSUTF8("noAck"), 0, 5, 0 },
    { OSUTF8("ack"), 1, 3, 1 }
};


const OSUTF8CHAR* e2ap_RICcontrolAckRequest_ToString (OSUINT32 value){
   OSINT32 idx = value;
   if(idx >=0 && idx < e2ap_RICcontrolAckRequest_ENUMTABSIZE){
      return e2ap_RICcontrolAckRequest_ENUMTAB[e2ap_RICcontrolAckRequest_ENUMTAB[idx].transidx].name;
   }else{
      return OSUTF8("_UNKNOWN_");
   }
}


int e2ap_RICcontrolAckRequest_ToEnum (OSCTXT* pctxt, const OSUTF8CHAR* value,e2ap_RICcontrolAckRequest* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes(value);
   return e2ap_RICcontrolAckRequest_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int e2ap_RICcontrolAckRequest_ToEnum2 (OSCTXT* pctxt, const OSUTF8CHAR* value, OSSIZE valueLen,e2ap_RICcontrolAckRequest* pvalue)
{
   OSINT32 idx = rtxLookupEnum(value, valueLen,
      e2ap_RICcontrolAckRequest_ENUMTAB, e2ap_RICcontrolAckRequest_ENUMTABSIZE);
   if (idx >= 0) {
      *pvalue = (e2ap_RICcontrolAckRequest)e2ap_RICcontrolAckRequest_ENUMTAB[idx].value;
      return 0;
   } else {
      rtxErrAddIntParm (pctxt, (const char*)value);//dungnm23 check xem là Str hay Int
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_e2ap_RICcontrolAckRequest (OSCTXT* pctxt, e2ap_RICcontrolAckRequest value)
{
   int stat = 0;
   RTXCTXTPUSHTYPENAME (pctxt, "RICcontrolAckRequest");
   if (value >= 2) {
      rtxErrAddIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
   if(stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}

EXTERN int asn1PD_e2ap_RICcontrolAckRequest (OSCTXT* pctxt, e2ap_RICcontrolAckRequest* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RICcontrolAckRequest");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
   if(stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return stat;
}

EXTERN int asn1PrtToStr_e2ap_RICcontrolAckRequest (const char* name, e2ap_RICcontrolAckRequest* pvalue, char* buffer, OSSIZE bufSize)
{
   int stat;

   if(rtPrintToStringIndent(buffer, bufSize) < 0) return -1;
   if(rtPrintToString(name, buffer, bufSize) < 0) return -1;

   switch(*pvalue) {
      case 0:
         stat = rtPrintToString(" = noAck \n", buffer, bufSize);
         break;
      case 1:
         stat = rtPrintToString(" = ack \n", buffer, bufSize);
         break;
      default:
         stat = rtPrintToString(" = ???\n", buffer, bufSize);
   }

   if (stat < 0) return -1;
   return 0;

}

/*Init*/
EXTERN int asn1Init_e2ap_RICcontrolAckRequest (e2ap_RICcontrolAckRequest* pvalue){
      //if (pvalue == 0) return RTERR_NULLPTR;
      //*pvalue = 0;
      return 0;
}/*****************************************/
/*           RICcontrolRequest_IEs                */
/*****************************************/
/* ie.c.j2 */
 /* d là con của msg */
EXTERN int asn1PE_e2ap_RICcontrolRequest_protocolIEs_element (OSCTXT* pctxt, e2ap_RICcontrolRequest_protocolIEs_element* pvalue)
{
    int stat =0;

    /*encode id*/

    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PE_e2ap_ProtocolIE_ID(pctxt, pvalue->id);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PE_e2ap_Criticality(pctxt, pvalue->criticality);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
    {
        OSCTXT lctxt;
        OSOCTET *pDynamicEncodeBuffer;
        ASN1OpenType openType;
        OSBOOL encoded = TRUE;

        openType.numocts = 0;
        openType.data =0;

        rtxCopyContext(&lctxt, pctxt);
        pctxt->pStream =0;

        stat = rtxInitContextBuffer(pctxt, 0, 0);
        if(stat!=0) return LOG_RTERR(pctxt, stat);

        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_RICcontrolRequest_IEs_id_RICrequestID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICrequestID");
                    stat = asn1PE_e2ap_RICrequestID (pctxt, pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_RICrequestID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICcontrolRequest_IEs_id_RANfunctionID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RANfunctionID");
                    stat = asn1PE_e2ap_RANfunctionID (pctxt, pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_RANfunctionID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICcontrolRequest_IEs_id_RICcallProcessID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICcallProcessID");
                    stat = asn1PE_e2ap_RICcallProcessID (pctxt, pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_RICcallProcessID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICcontrolRequest_IEs_id_RICcontrolHeader:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICcontrolHeader");
                    stat = asn1PE_e2ap_RICcontrolHeader (pctxt, pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_RICcontrolHeader);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICcontrolRequest_IEs_id_RICcontrolMessage:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICcontrolMessage");
                    stat = asn1PE_e2ap_RICcontrolMessage (pctxt, pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_RICcontrolMessage);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICcontrolRequest_IEs_id_RICcontrolAckRequest:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICcontrolAckRequest");
                    stat = asn1PE_e2ap_RICcontrolAckRequest (pctxt, pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_RICcontrolAckRequest);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_RICcontrolRequest_IEs_UNDEF_:
            {
                if(0!=pvalue->value.u.extElem1){
                    openType.numocts = pvalue->value.u.extElem1->numocts;
                    openType.data = pvalue->value.u.extElem1->data;
                } else {
                    /* No extension element to encode */
                }
                encoded = FALSE;
                break;
            }

            default:
                encoded = FALSE;
                stat = RTERR_INVOPT;
                break;
        } 

        if(encoded){
            openType.numocts = (OSUINT32)pe_GetMsgLen(pctxt);
            openType.data = pDynamicEncodeBuffer = pctxt -> buffer.data;
        }
        rtxCopyContext(pctxt, &lctxt);

        if(stat == 0) {
            stat = pe_OpenType (pctxt, openType.numocts, openType.data);
        }
    #if 1
        if(encoded){//dungnm23 check lai nhe
            rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
        }
    #endif

    }

    if(stat!=0) return LOG_RTERR(pctxt, stat);  
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}

EXTERN int  asn1PD_e2ap_RICcontrolRequest_protocolIEs_element (OSCTXT* pctxt, e2ap_RICcontrolRequest_protocolIEs_element* pvalue){
    int stat =0;

    /*decode id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PD_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PD_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");

    {
        OSUINT32 openTypeLen;
        size_t bitStartOffset, bitLength;

        stat = pd_UnconsLength(pctxt, &openTypeLen);
        if(stat<0) return LOG_RTERR(pctxt, stat);
        else if(stat == RT_OK_FRAG){
            rtxErrAddStrParm(pctxt, "open type with fragment length");
            return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
        }
        bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
        bitLength = openTypeLen * 8;

        switch(pvalue->id){//dungnm23 check case lai nhe
        
            case ASN1V_e2ap_id_RICrequestID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICcontrolRequest_IEs_id_RICrequestID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICrequestID");
                pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_RICrequestID 
                    = rtxMemAllocType(pctxt, e2ap_RICrequestID);

                asn1Init_e2ap_RICrequestID(pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_RICrequestID);

                stat = asn1PD_e2ap_RICrequestID (pctxt,
                        (e2ap_RICrequestID*)pvalue->value.
                        u._e2ap_RICcontrolRequest_IEs_id_RICrequestID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RANfunctionID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICcontrolRequest_IEs_id_RANfunctionID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RANfunctionID");
                pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_RANfunctionID 
                    = rtxMemAllocType(pctxt, e2ap_RANfunctionID);

                asn1Init_e2ap_RANfunctionID(pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_RANfunctionID);

                stat = asn1PD_e2ap_RANfunctionID (pctxt,
                        (e2ap_RANfunctionID*)pvalue->value.
                        u._e2ap_RICcontrolRequest_IEs_id_RANfunctionID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RICcallProcessID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICcontrolRequest_IEs_id_RICcallProcessID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICcallProcessID");
                pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_RICcallProcessID 
                    = rtxMemAllocType(pctxt, e2ap_RICcallProcessID);

                asn1Init_e2ap_RICcallProcessID(pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_RICcallProcessID);

                stat = asn1PD_e2ap_RICcallProcessID (pctxt,
                        (e2ap_RICcallProcessID*)pvalue->value.
                        u._e2ap_RICcontrolRequest_IEs_id_RICcallProcessID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RICcontrolHeader:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICcontrolRequest_IEs_id_RICcontrolHeader;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICcontrolHeader");
                pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_RICcontrolHeader 
                    = rtxMemAllocType(pctxt, e2ap_RICcontrolHeader);

                asn1Init_e2ap_RICcontrolHeader(pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_RICcontrolHeader);

                stat = asn1PD_e2ap_RICcontrolHeader (pctxt,
                        (e2ap_RICcontrolHeader*)pvalue->value.
                        u._e2ap_RICcontrolRequest_IEs_id_RICcontrolHeader);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RICcontrolMessage:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICcontrolRequest_IEs_id_RICcontrolMessage;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICcontrolMessage");
                pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_RICcontrolMessage 
                    = rtxMemAllocType(pctxt, e2ap_RICcontrolMessage);

                asn1Init_e2ap_RICcontrolMessage(pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_RICcontrolMessage);

                stat = asn1PD_e2ap_RICcontrolMessage (pctxt,
                        (e2ap_RICcontrolMessage*)pvalue->value.
                        u._e2ap_RICcontrolRequest_IEs_id_RICcontrolMessage);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RICcontrolAckRequest:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICcontrolRequest_IEs_id_RICcontrolAckRequest;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICcontrolAckRequest");
                pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_RICcontrolAckRequest 
                    = rtxMemAllocType(pctxt, e2ap_RICcontrolAckRequest);

                asn1Init_e2ap_RICcontrolAckRequest(pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_RICcontrolAckRequest);

                stat = asn1PD_e2ap_RICcontrolAckRequest (pctxt,
                        (e2ap_RICcontrolAckRequest*)pvalue->value.
                        u._e2ap_RICcontrolRequest_IEs_id_RICcontrolAckRequest);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICcontrolRequest_IEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*) rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
    }
    {
    size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
    size_t bitsConsumed = bitEndOffset-bitStartOffset;
    if(bitsConsumed<bitLength){
        stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
    }
    else stat =(bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
    }}
    if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}


int asn1Init_e2ap_RICcontrolRequest_protocolIEs_element(e2ap_RICcontrolRequest_protocolIEs_element* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    OSCRTLMEMSET (&pvalue->value, 0, sizeof(pvalue->value));
    return 0;
}


//-----> chuaw có template rtxFreeASN1OpenType

#if 0
void asn1Free_e2ap_RICcontrolRequest_protocolIEs_element(OSCTXT* pctxt, e2ap_RICcontrolRequest_protocolIEs_element* pvalue)
{
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICcontrolRequest_IEs_id_id_RICrequestID:
            // rtxFreeE2ap_RICrequestID(pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_id_RICrequestID);

            if(pvalue->value.i._e2ap_RICcontrolRequest_id_RICrequestID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICrequestID(pctxt, pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_id_RICrequestID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_id_RICrequestID);
           // pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_id_RICrequestID = NULL;
           pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_RICrequestID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICcontrolRequest_IEs_id_id_RANfunctionID:
            // rtxFreeE2ap_RANfunctionID(pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_id_RANfunctionID);

            if(pvalue->value.i._e2ap_RICcontrolRequest_id_RANfunctionID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RANfunctionID(pctxt, pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_id_RANfunctionID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_id_RANfunctionID);
           // pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_id_RANfunctionID = NULL;
           pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_RANfunctionID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICcontrolRequest_IEs_id_id_RICcallProcessID:
            // rtxFreeE2ap_RICcallProcessID(pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_id_RICcallProcessID);

            if(pvalue->value.i._e2ap_RICcontrolRequest_id_RICcallProcessID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICcallProcessID(pctxt, pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_id_RICcallProcessID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_id_RICcallProcessID);
           // pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_id_RICcallProcessID = NULL;
           pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_RICcallProcessID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICcontrolRequest_IEs_id_id_RICcontrolHeader:
            // rtxFreeE2ap_RICcontrolHeader(pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_id_RICcontrolHeader);

            if(pvalue->value.i._e2ap_RICcontrolRequest_id_RICcontrolHeader!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICcontrolHeader(pctxt, pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_id_RICcontrolHeader);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_id_RICcontrolHeader);
           // pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_id_RICcontrolHeader = NULL;
           pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_RICcontrolHeader = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICcontrolRequest_IEs_id_id_RICcontrolMessage:
            // rtxFreeE2ap_RICcontrolMessage(pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_id_RICcontrolMessage);

            if(pvalue->value.i._e2ap_RICcontrolRequest_id_RICcontrolMessage!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICcontrolMessage(pctxt, pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_id_RICcontrolMessage);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_id_RICcontrolMessage);
           // pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_id_RICcontrolMessage = NULL;
           pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_RICcontrolMessage = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICcontrolRequest_IEs_id_id_RICcontrolAckRequest:
            // rtxFreeE2ap_RICcontrolAckRequest(pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_id_RICcontrolAckRequest);

            if(pvalue->value.i._e2ap_RICcontrolRequest_id_RICcontrolAckRequest!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICcontrolAckRequest(pctxt, pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_id_RICcontrolAckRequest);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_id_RICcontrolAckRequest);
           // pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_id_RICcontrolAckRequest = NULL;
           pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_RICcontrolAckRequest = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICcontrolRequest_IEs_UNDEF_:
            rtxFreeASN1OpenType(pvalue->value.u.extElem1);
            break;
        default:
            break;
    }
}

int asn1PrtToStr_e2ap_RICcontrolRequest_protocolIEs_element(OSCTXT* pctxt, e2ap_RICcontrolRequest_protocolIEs_element* pvalue)
{
    int stat =0;
    RTXCTXTPUSHELEMNAME(pctxt, "e2ap_RICcontrolRequest_protocolIEs_element");

    /*print id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PrtToStr_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PrtToStr_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_RICcontrolRequest_IEs_id_id_RICrequestID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICrequestID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICrequestID (pctxt, pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_id_RICrequestID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICcontrolRequest_IEs_id_id_RANfunctionID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RANfunctionID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RANfunctionID (pctxt, pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_id_RANfunctionID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICcontrolRequest_IEs_id_id_RICcallProcessID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICcallProcessID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICcallProcessID (pctxt, pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_id_RICcallProcessID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICcontrolRequest_IEs_id_id_RICcontrolHeader:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICcontrolHeader");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICcontrolHeader (pctxt, pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_id_RICcontrolHeader);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICcontrolRequest_IEs_id_id_RICcontrolMessage:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICcontrolMessage");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICcontrolMessage (pctxt, pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_id_RICcontrolMessage);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICcontrolRequest_IEs_id_id_RICcontrolAckRequest:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICcontrolAckRequest");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICcontrolAckRequest (pctxt, pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_id_RICcontrolAckRequest);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_RICcontrolRequest_IEs_UNDEF_:
            {
                rtxPLogMsg(pctxt, "Extension element present - raw data not printed.\n");
                break;
            }

            default:
                stat = RTERR_INVOPT;
                return LOG_RTERR(pctxt, stat);
        }
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);
}
#endif


int asn1PrtToStr_e2ap_RICcontrolRequest_protocolIEs_element (const char * name,
 e2ap_RICcontrolRequest_protocolIEs_element* pvalue, 
 char * buffer, OSSIZE bufSize){
    if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
        return -1;
    if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
        return -1;

    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICcontrolRequest_IEs_id_RICrequestID:
            if(asn1PrtToStr_e2ap_RICrequestID("RICrequestID", 
                    pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_RICrequestID, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICcontrolRequest_IEs_id_RANfunctionID:
            if(asn1PrtToStr_e2ap_RANfunctionID("RANfunctionID", 
                    pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_RANfunctionID, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICcontrolRequest_IEs_id_RICcallProcessID:
            if(asn1PrtToStr_e2ap_RICcallProcessID("RICcallProcessID", 
                    pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_RICcallProcessID, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICcontrolRequest_IEs_id_RICcontrolHeader:
            if(asn1PrtToStr_e2ap_RICcontrolHeader("RICcontrolHeader", 
                    pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_RICcontrolHeader, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICcontrolRequest_IEs_id_RICcontrolMessage:
            if(asn1PrtToStr_e2ap_RICcontrolMessage("RICcontrolMessage", 
                    pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_RICcontrolMessage, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICcontrolRequest_IEs_id_RICcontrolAckRequest:
            if(asn1PrtToStr_e2ap_RICcontrolAckRequest("RICcontrolAckRequest", 
                    pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_RICcontrolAckRequest, buffer, bufSize)<0)
                return -1;
            break;    
        default:
        if(0!=pvalue -> value.u.extElem1){
            rtPrintToStringIndent(buffer, bufSize);
            rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

        }
        }
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

    return 0;

 }

 void asn1Free_e2ap_RICcontrolRequest_protocolIEs_element(OSCTXT* pctxt, e2ap_RICcontrolRequest_protocolIEs_element* pvalue){
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICcontrolRequest_IEs_id_RICrequestID:
            if(pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_RICrequestID!=NULL){
            asn1Free_e2ap_RICrequestID(pctxt, pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_RICrequestID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_RICrequestID);
            pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_RICrequestID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICcontrolRequest_IEs_id_RANfunctionID:
            if(pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_RANfunctionID!=NULL){
            asn1Free_e2ap_RANfunctionID(pctxt, pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_RANfunctionID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_RANfunctionID);
            pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_RANfunctionID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICcontrolRequest_IEs_id_RICcallProcessID:
            if(pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_RICcallProcessID!=NULL){
            asn1Free_e2ap_RICcallProcessID(pctxt, pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_RICcallProcessID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_RICcallProcessID);
            pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_RICcallProcessID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICcontrolRequest_IEs_id_RICcontrolHeader:
            if(pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_RICcontrolHeader!=NULL){
            asn1Free_e2ap_RICcontrolHeader(pctxt, pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_RICcontrolHeader);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_RICcontrolHeader);
            pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_RICcontrolHeader = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICcontrolRequest_IEs_id_RICcontrolMessage:
            if(pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_RICcontrolMessage!=NULL){
            asn1Free_e2ap_RICcontrolMessage(pctxt, pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_RICcontrolMessage);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_RICcontrolMessage);
            pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_RICcontrolMessage = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICcontrolRequest_IEs_id_RICcontrolAckRequest:
            if(pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_RICcontrolAckRequest!=NULL){
            asn1Free_e2ap_RICcontrolAckRequest(pctxt, pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_RICcontrolAckRequest);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_RICcontrolAckRequest);
            pvalue->value.u._e2ap_RICcontrolRequest_IEs_id_RICcontrolAckRequest = NULL;
            }
            break;
        default:
            break;


    }
 }

 

/*****************************************/
/*           RICcontrolRequest                */
/*****************************************/
//2_container.c
/* 1. xxx_ProtocolIE -> mẫu cũ ở ie_big_msg */
EXTERN int asn1PE_e2ap_RICcontrolRequest_protocolIEs (OSCTXT* pctxt, e2ap_RICcontrolRequest_protocolIEs* pvalue)
{
    int stat =0;
    OSRTDListNode* pnode;
    OSUINT32 xx1;

    /*encode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pe_Length(pctxt, pvalue->count);
    if(stat<0) return LOG_RTERR(pctxt, stat);

    /*encode each element*/
    xx1 =0;
    for(pnode = pvalue->head; pnode != 0 && xx1<pvalue->count; pnode = pnode->next){
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE", xx1);
        stat = asn1PE_e2ap_RICcontrolRequest_protocolIEs_element (pctxt, ((e2ap_RICcontrolRequest_protocolIEs_element*)pnode->data));
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        xx1++;
        RTXCTXTPOPARRAYELEMNAME(pctxt);
    }

    return (stat);
}

EXTERN int  asn1PD_e2ap_RICcontrolRequest_protocolIEs(OSCTXT* pctxt, e2ap_RICcontrolRequest_protocolIEs* pvalue)
{
     int stat =0;
     OSRTDListNode* pnode;
     OSSIZE count =0;
     OSSIZE xx1=0;


     /*decode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pd_Length64(pctxt, &count); //tai sao lai 64
    if(stat!=0) return LOG_RTERR(pctxt, stat);

    /*decode each element*/
    rtxDListInit(pvalue);

    for(xx1=0; xx1 < count; xx1++){
        e2ap_RICcontrolRequest_protocolIEs_element* pdata;
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE",xx1);

        if(pnode == NULL) return LOG_RTERR(pctxt, RTERR_NOMEM);

        asn1Init_e2ap_RICcontrolRequest_protocolIEs_element(pdata);
        rtxDListAppendNode(pvalue, pnode);
        stat = asn1PD_e2ap_RICcontrolRequest_protocolIEs_element (pctxt, pdata);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        RTXCTXTPOPARRAYELEMNAME(pctxt);

    }
    return (stat);
}


int asn1Init_e2ap_RICcontrolRequest_protocolIEs(e2ap_RICcontrolRequest_protocolIEs* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    rtxDListFastInit (pvalue);
    return 0;
}
#if 1 //ao that day
void asn1Free_e2ap_RICcontrolRequest_protocolIEs(OSCTXT* pctxt, e2ap_RICcontrolRequest_protocolIEs* pvalue)
{
    if(0==pvalue) return;   
    e2ap_RICcontrolRequest_protocolIEs_element* pdata;
    OSRTDListNode* pnode=pvalue->head;
    while(0!=pnode){
        pdata = (e2ap_RICcontrolRequest_protocolIEs_element*)pnode->data;
       // asn1Free_e2ap_RICcontrolRequest_protocolIEs_element(pctxt, pdata);
        pnode = pnode->next;
    }
    rtxDListFreeAll(pctxt, pvalue);
}
#endif


EXTERN int asn1PrtToStr_e2ap_RICcontrolRequest_protocolIEs(const char* name, e2ap_RICcontrolRequest_protocolIEs* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_RICcontrolRequest_protocolIEs_element* pdata0;
    OSRTDListNode* pnode0;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode0 = pvalue->head;  xx1 < pvalue->count && pnode0 != 0; pnode0 = pnode0->next, xx1++){
        pdata0 = (e2ap_RICcontrolRequest_protocolIEs_element*)pnode0->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 0
        if(asn1PrtToStr_e2ap_RICcontrolRequest_protocolIEs_element(nameBuf, pdata0, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}


/*2 . RICcontrolRequest -> mẫu cũ ở seq_normal*/

int asn1PE_e2ap_RICcontrolRequest (OSCTXT* pctxt, e2ap_RICcontrolRequest* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RICcontrolRequest");
   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field protocolIEs - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
   stat = asn1PE_e2ap_RICcontrolRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if(stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RICcontrolRequest (OSCTXT* pctxt, e2ap_RICcontrolRequest* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME(pctxt, "RICcontrolRequest");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field protocolIEs */
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
      stat = asn1PD_e2ap_RICcontrolRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RICcontrolRequest (e2ap_RICcontrolRequest* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RICcontrolRequest_protocolIEs(&pvalue->protocolIEs);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RICcontrolRequest (OSCTXT* pctxt, e2ap_RICcontrolRequest* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_RICcontrolRequest_protocolIEs(pctxt, &pvalue->protocolIEs);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RICcontrolRequest (const char* name, e2ap_RICcontrolRequest* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }

   if(asn1PrtToStr_e2ap_RICcontrolRequest_protocolIEs("protocolIEs", &pvalue->protocolIEs, buffer, bufSize) <0){
      return -1;
   }

   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           RICactionID                */
/*****************************************/
//6 mau integer
// mau integer size(a...b) mau la procedurecode
EXTERN int asn1PE_e2ap_RICactionID (OSCTXT* pctxt, e2ap_RICactionID value){
    int stat = 0;
    RTXCTCXTPUSHTYPENAME (pctxt, "RICactionID");
    stat = pe_ConsUnsigned (pctxt, value, 0, 255);
    if (stat != 0) return LOG_RTERR (pctxt, stat);
    RTXCTXTPOPTYPENAME (pctxt);
    return stat;
}
EXTERN int asn1PD_e2ap_RICactionID (OSCTXT* pctxt, e2ap_RICactionID* pvalue){
    int stat = 0;
    RTXCTCXTPUSHTYPENAME (pctxt, "RICactionID");
    if(pctxt->buffer.aligned){
        int stat2 = PD_BYTE_ALIGN(pctxt);
        if(stat2 != 0) return LOG_RTERR (pctxt, stat2);
    }
    stat = rtxDecBitsToByte(pctxt, pvalue, 0);
    if (stat != 0) return LOG_RTERR (pctxt, stat);
    RTXCTXTPOPTYPENAME (pctxt);
    return stat;
}
//EXTERN int asn1Print_e2ap_RICactionID (const char* name, const e2ap_RICactionID* pvalue);
//EXTERN int asn1PrtToStr_e2ap_RICactionID (const char* name, e2ap_RICactionID* pvalue, char* buffer, OSSIZE bufSize);
//EXTERN int asn1PrtToStrm_e2ap_RICactionID (OSCTXT* pctxt, const char* name, const e2ap_RICactionID* pvalue);
EXTERN int asn1Init_e2ap_RICactionID (e2ap_RICactionID* pvalue){
    //if (pvalue == 0) return RTERR_NULLPTR;
    //*pvalue = 0;
    return 0;
}
EXTERN int asn1Free_e2ap_RICactionID (OSCTXT* pctxt, e2ap_RICactionID* pvalue){
    // No dynamic memory to free for integer
    return 0;
}
/*****************************************/
/*           RICindicationSN                */
/*****************************************/
//6 mau integer
// mau integer size(a...b) mau la procedurecode
EXTERN int asn1PE_e2ap_RICindicationSN (OSCTXT* pctxt, e2ap_RICindicationSN value){
    int stat = 0;
    RTXCTCXTPUSHTYPENAME (pctxt, "RICindicationSN");
    stat = pe_ConsUnsigned (pctxt, value, 0, 65535);
    if (stat != 0) return LOG_RTERR (pctxt, stat);
    RTXCTXTPOPTYPENAME (pctxt);
    return stat;
}
EXTERN int asn1PD_e2ap_RICindicationSN (OSCTXT* pctxt, e2ap_RICindicationSN* pvalue){
    int stat = 0;
    RTXCTCXTPUSHTYPENAME (pctxt, "RICindicationSN");
    if(pctxt->buffer.aligned){
        int stat2 = PD_BYTE_ALIGN(pctxt);
        if(stat2 != 0) return LOG_RTERR (pctxt, stat2);
    }
    stat = rtxDecBitsToByte(pctxt, pvalue, 0);
    if (stat != 0) return LOG_RTERR (pctxt, stat);
    RTXCTXTPOPTYPENAME (pctxt);
    return stat;
}
//EXTERN int asn1Print_e2ap_RICindicationSN (const char* name, const e2ap_RICindicationSN* pvalue);
//EXTERN int asn1PrtToStr_e2ap_RICindicationSN (const char* name, e2ap_RICindicationSN* pvalue, char* buffer, OSSIZE bufSize);
//EXTERN int asn1PrtToStrm_e2ap_RICindicationSN (OSCTXT* pctxt, const char* name, const e2ap_RICindicationSN* pvalue);
EXTERN int asn1Init_e2ap_RICindicationSN (e2ap_RICindicationSN* pvalue){
    //if (pvalue == 0) return RTERR_NULLPTR;
    //*pvalue = 0;
    return 0;
}
EXTERN int asn1Free_e2ap_RICindicationSN (OSCTXT* pctxt, e2ap_RICindicationSN* pvalue){
    // No dynamic memory to free for integer
    return 0;
}
/******************************************************/
/*                                                    */
/*    RICindicationType                          */
/*                                                    */
/******************************************************/
//enumerated


const OSEnumItem e2ap_RICindicationType_ENUMTAB[] = {
    { OSUTF8("report"), 0, 6, 0 },
    { OSUTF8("insert"), 1, 6, 1 }
};


const OSUTF8CHAR* e2ap_RICindicationType_ToString (OSUINT32 value){
   OSINT32 idx = value;
   if(idx >=0 && idx < e2ap_RICindicationType_ENUMTABSIZE){
      return e2ap_RICindicationType_ENUMTAB[e2ap_RICindicationType_ENUMTAB[idx].transidx].name;
   }else{
      return OSUTF8("_UNKNOWN_");
   }
}


int e2ap_RICindicationType_ToEnum (OSCTXT* pctxt, const OSUTF8CHAR* value,e2ap_RICindicationType* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes(value);
   return e2ap_RICindicationType_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int e2ap_RICindicationType_ToEnum2 (OSCTXT* pctxt, const OSUTF8CHAR* value, OSSIZE valueLen,e2ap_RICindicationType* pvalue)
{
   OSINT32 idx = rtxLookupEnum(value, valueLen,
      e2ap_RICindicationType_ENUMTAB, e2ap_RICindicationType_ENUMTABSIZE);
   if (idx >= 0) {
      *pvalue = (e2ap_RICindicationType)e2ap_RICindicationType_ENUMTAB[idx].value;
      return 0;
   } else {
      rtxErrAddIntParm (pctxt, (const char*)value);//dungnm23 check xem là Str hay Int
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_e2ap_RICindicationType (OSCTXT* pctxt, e2ap_RICindicationType value)
{
   int stat = 0;
   RTXCTXTPUSHTYPENAME (pctxt, "RICindicationType");
   if (value >= 2) {
      rtxErrAddIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
   if(stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}

EXTERN int asn1PD_e2ap_RICindicationType (OSCTXT* pctxt, e2ap_RICindicationType* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RICindicationType");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
   if(stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return stat;
}

EXTERN int asn1PrtToStr_e2ap_RICindicationType (const char* name, e2ap_RICindicationType* pvalue, char* buffer, OSSIZE bufSize)
{
   int stat;

   if(rtPrintToStringIndent(buffer, bufSize) < 0) return -1;
   if(rtPrintToString(name, buffer, bufSize) < 0) return -1;

   switch(*pvalue) {
      case 0:
         stat = rtPrintToString(" = report \n", buffer, bufSize);
         break;
      case 1:
         stat = rtPrintToString(" = insert \n", buffer, bufSize);
         break;
      default:
         stat = rtPrintToString(" = ???\n", buffer, bufSize);
   }

   if (stat < 0) return -1;
   return 0;

}

/*Init*/
EXTERN int asn1Init_e2ap_RICindicationType (e2ap_RICindicationType* pvalue){
      //if (pvalue == 0) return RTERR_NULLPTR;
      //*pvalue = 0;
      return 0;
}/*****************************************/
/*           RICindicationHeader                */
/*****************************************/
//9 mau octet string
//type 9  mau la octet string no size mau la pdusessioncommonnetworkinstance

EXTERN int asn1PE_e2ap_RICindicationHeader (OSCTXT* pctxt, e2ap_RICindicationHeader value){
   int stat = 0
   RTXCTCXTPUSHTYPENAME (pctxt, "RICindicationHeader");
   stat = pe_OctetString(pctxt, value.numocts, value.data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPTYPENAME (pctxt);

}
EXTERN int asn1PD_e2ap_RICindicationHeader (OSCTXT* pctxt, e2ap_RICindicationHeader* pvalue){
   int stat = 0;
   RTXCTCXTPUSHTYPENAME (pctxt, "RICindicationHeader");
   stat = pd_DynOctetString(pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}
EXTERN int asn1PrtToStr_e2ap_RICindicationHeader (const char* name, e2ap_RICindicationHeader *pvalue, char* buffer, OSSIZE bufSize){
   if(rtPrintToStringIndent(buffer, bufSize) < 0) return -1;
   if(rtPrintToStringHexStr(name, pvalue->numocts, pvalue->data, buffer, bufSize) < 0) return -1;
   return 0;
}
EXTERN int asn1PrtToStrm_e2ap_RICindicationHeader (OSCTXT* pctxt, const char* name, const e2ap_RICindicationHeader* pvalue){
   int stat =0;
   stat = rtPrintToStreamIndent(pctxt);
   if(stat !=0) return LOG_RTERR(pctxt, stat);
   stat = rtPrintToStreamHexStr(pctxt, name, pvalue->numocts, pvalue->data);
   if(stat !=0) return LOG_RTERR(pctxt, stat);
   return stat;
}
//EXTERN int asn1Copy_e2ap_RICindicationHeader (OSCTXT* pctxt, const e2ap_RICindicationHeader* pSrcValue, e2ap_RICindicationHeader* pDstValue);
 int asn1Init_e2ap_RICindicationHeader (e2ap_RICindicationHeader* pvalue){
   if (pvalue == 0) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   pvalue->data = 0;
   return 0;
}
 void asn1Free_e2ap_RICindicationHeader (OSCTXT* pctxt, e2ap_RICindicationHeader* pvalue){
   if (pvalue == 0) return;
   if(pvalue->numocts>0){
       rtxMemFreePtr(pctxt, (void*)pvalue->data);
       pvalue->data = 0;
       pvalue->numocts = 0;
   }
}
int asn1Init_e2ap_RICindicationHeader (e2ap_RICindicationHeader* pvalue){
   if (pvalue == 0) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   pvalue->data = 0;
   return 0;
}
/*****************************************/
/*           RICindicationMessage                */
/*****************************************/
//9 mau octet string
//type 9  mau la octet string no size mau la pdusessioncommonnetworkinstance

EXTERN int asn1PE_e2ap_RICindicationMessage (OSCTXT* pctxt, e2ap_RICindicationMessage value){
   int stat = 0
   RTXCTCXTPUSHTYPENAME (pctxt, "RICindicationMessage");
   stat = pe_OctetString(pctxt, value.numocts, value.data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPTYPENAME (pctxt);

}
EXTERN int asn1PD_e2ap_RICindicationMessage (OSCTXT* pctxt, e2ap_RICindicationMessage* pvalue){
   int stat = 0;
   RTXCTCXTPUSHTYPENAME (pctxt, "RICindicationMessage");
   stat = pd_DynOctetString(pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}
EXTERN int asn1PrtToStr_e2ap_RICindicationMessage (const char* name, e2ap_RICindicationMessage *pvalue, char* buffer, OSSIZE bufSize){
   if(rtPrintToStringIndent(buffer, bufSize) < 0) return -1;
   if(rtPrintToStringHexStr(name, pvalue->numocts, pvalue->data, buffer, bufSize) < 0) return -1;
   return 0;
}
EXTERN int asn1PrtToStrm_e2ap_RICindicationMessage (OSCTXT* pctxt, const char* name, const e2ap_RICindicationMessage* pvalue){
   int stat =0;
   stat = rtPrintToStreamIndent(pctxt);
   if(stat !=0) return LOG_RTERR(pctxt, stat);
   stat = rtPrintToStreamHexStr(pctxt, name, pvalue->numocts, pvalue->data);
   if(stat !=0) return LOG_RTERR(pctxt, stat);
   return stat;
}
//EXTERN int asn1Copy_e2ap_RICindicationMessage (OSCTXT* pctxt, const e2ap_RICindicationMessage* pSrcValue, e2ap_RICindicationMessage* pDstValue);
 int asn1Init_e2ap_RICindicationMessage (e2ap_RICindicationMessage* pvalue){
   if (pvalue == 0) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   pvalue->data = 0;
   return 0;
}
 void asn1Free_e2ap_RICindicationMessage (OSCTXT* pctxt, e2ap_RICindicationMessage* pvalue){
   if (pvalue == 0) return;
   if(pvalue->numocts>0){
       rtxMemFreePtr(pctxt, (void*)pvalue->data);
       pvalue->data = 0;
       pvalue->numocts = 0;
   }
}
int asn1Init_e2ap_RICindicationMessage (e2ap_RICindicationMessage* pvalue){
   if (pvalue == 0) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   pvalue->data = 0;
   return 0;
}
/*****************************************/
/*           RICindication_IEs                */
/*****************************************/
/* ie.c.j2 */
 /* d là con của msg */
EXTERN int asn1PE_e2ap_RICindication_protocolIEs_element (OSCTXT* pctxt, e2ap_RICindication_protocolIEs_element* pvalue)
{
    int stat =0;

    /*encode id*/

    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PE_e2ap_ProtocolIE_ID(pctxt, pvalue->id);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PE_e2ap_Criticality(pctxt, pvalue->criticality);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
    {
        OSCTXT lctxt;
        OSOCTET *pDynamicEncodeBuffer;
        ASN1OpenType openType;
        OSBOOL encoded = TRUE;

        openType.numocts = 0;
        openType.data =0;

        rtxCopyContext(&lctxt, pctxt);
        pctxt->pStream =0;

        stat = rtxInitContextBuffer(pctxt, 0, 0);
        if(stat!=0) return LOG_RTERR(pctxt, stat);

        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_RICindication_IEs_id_RICrequestID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICrequestID");
                    stat = asn1PE_e2ap_RICrequestID (pctxt, pvalue->value.u._e2ap_RICindication_IEs_id_RICrequestID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICindication_IEs_id_RANfunctionID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RANfunctionID");
                    stat = asn1PE_e2ap_RANfunctionID (pctxt, pvalue->value.u._e2ap_RICindication_IEs_id_RANfunctionID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICindication_IEs_id_RICactionID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICactionID");
                    stat = asn1PE_e2ap_RICactionID (pctxt, pvalue->value.u._e2ap_RICindication_IEs_id_RICactionID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICindication_IEs_id_RICindicationSN:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICindicationSN");
                    stat = asn1PE_e2ap_RICindicationSN (pctxt, pvalue->value.u._e2ap_RICindication_IEs_id_RICindicationSN);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICindication_IEs_id_RICindicationType:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICindicationType");
                    stat = asn1PE_e2ap_RICindicationType (pctxt, pvalue->value.u._e2ap_RICindication_IEs_id_RICindicationType);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICindication_IEs_id_RICindicationHeader:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICindicationHeader");
                    stat = asn1PE_e2ap_RICindicationHeader (pctxt, pvalue->value.u._e2ap_RICindication_IEs_id_RICindicationHeader);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICindication_IEs_id_RICindicationMessage:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICindicationMessage");
                    stat = asn1PE_e2ap_RICindicationMessage (pctxt, pvalue->value.u._e2ap_RICindication_IEs_id_RICindicationMessage);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICindication_IEs_id_RICcallProcessID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICcallProcessID");
                    stat = asn1PE_e2ap_RICcallProcessID (pctxt, pvalue->value.u._e2ap_RICindication_IEs_id_RICcallProcessID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_RICindication_IEs_UNDEF_:
            {
                if(0!=pvalue->value.u.extElem1){
                    openType.numocts = pvalue->value.u.extElem1->numocts;
                    openType.data = pvalue->value.u.extElem1->data;
                } else {
                    /* No extension element to encode */
                }
                encoded = FALSE;
                break;
            }

            default:
                encoded = FALSE;
                stat = RTERR_INVOPT;
                break;
        } 

        if(encoded){
            openType.numocts = (OSUINT32)pe_GetMsgLen(pctxt);
            openType.data = pDynamicEncodeBuffer = pctxt -> buffer.data;
        }
        rtxCopyContext(pctxt, &lctxt);

        if(stat == 0) {
            stat = pe_OpenType (pctxt, openType.numocts, openType.data);
        }
    #if 1
        if(encoded){//dungnm23 check lai nhe
            rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
        }
    #endif

    }

    if(stat!=0) return LOG_RTERR(pctxt, stat);  
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}

EXTERN int  asn1PD_e2ap_RICindication_protocolIEs_element (OSCTXT* pctxt, e2ap_RICindication_protocolIEs_element* pvalue){
    int stat =0;

    /*decode id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PD_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PD_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");

    {
        OSUINT32 openTypeLen;
        size_t bitStartOffset, bitLength;

        stat = pd_UnconsLength(pctxt, &openTypeLen);
        if(stat<0) return LOG_RTERR(pctxt, stat);
        else if(stat == RT_OK_FRAG){
            rtxErrAddStrParm(pctxt, "open type with fragment length");
            return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
        }
        bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
        bitLength = openTypeLen * 8;

        switch(pvalue->id){//dungnm23 check case lai nhe
        
            case ASN1V_e2ap_id_RICrequestID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICindication_IEs_id_RICrequestID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICrequestID");
                pvalue->value.u._e2ap_RICindication_IEs_id_RICrequestID 
                    = rtxMemAllocType(pctxt, e2ap_RICrequestID);

                asn1Init_e2ap_RICrequestID(pvalue->value.u._e2ap_RICindication_IEs_id_RICrequestID);

                stat = asn1PD_e2ap_RICrequestID (pctxt,
                        (e2ap_RICrequestID*)pvalue->value.
                        u._e2ap_RICindication_IEs_id_RICrequestID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RANfunctionID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICindication_IEs_id_RANfunctionID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RANfunctionID");
                pvalue->value.u._e2ap_RICindication_IEs_id_RANfunctionID 
                    = rtxMemAllocType(pctxt, e2ap_RANfunctionID);

                asn1Init_e2ap_RANfunctionID(pvalue->value.u._e2ap_RICindication_IEs_id_RANfunctionID);

                stat = asn1PD_e2ap_RANfunctionID (pctxt,
                        (e2ap_RANfunctionID*)pvalue->value.
                        u._e2ap_RICindication_IEs_id_RANfunctionID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RICactionID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICindication_IEs_id_RICactionID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICactionID");
                pvalue->value.u._e2ap_RICindication_IEs_id_RICactionID 
                    = rtxMemAllocType(pctxt, e2ap_RICactionID);

                asn1Init_e2ap_RICactionID(pvalue->value.u._e2ap_RICindication_IEs_id_RICactionID);

                stat = asn1PD_e2ap_RICactionID (pctxt,
                        (e2ap_RICactionID*)pvalue->value.
                        u._e2ap_RICindication_IEs_id_RICactionID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RICindicationSN:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICindication_IEs_id_RICindicationSN;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICindicationSN");
                pvalue->value.u._e2ap_RICindication_IEs_id_RICindicationSN 
                    = rtxMemAllocType(pctxt, e2ap_RICindicationSN);

                asn1Init_e2ap_RICindicationSN(pvalue->value.u._e2ap_RICindication_IEs_id_RICindicationSN);

                stat = asn1PD_e2ap_RICindicationSN (pctxt,
                        (e2ap_RICindicationSN*)pvalue->value.
                        u._e2ap_RICindication_IEs_id_RICindicationSN);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RICindicationType:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICindication_IEs_id_RICindicationType;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICindicationType");
                pvalue->value.u._e2ap_RICindication_IEs_id_RICindicationType 
                    = rtxMemAllocType(pctxt, e2ap_RICindicationType);

                asn1Init_e2ap_RICindicationType(pvalue->value.u._e2ap_RICindication_IEs_id_RICindicationType);

                stat = asn1PD_e2ap_RICindicationType (pctxt,
                        (e2ap_RICindicationType*)pvalue->value.
                        u._e2ap_RICindication_IEs_id_RICindicationType);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RICindicationHeader:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICindication_IEs_id_RICindicationHeader;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICindicationHeader");
                pvalue->value.u._e2ap_RICindication_IEs_id_RICindicationHeader 
                    = rtxMemAllocType(pctxt, e2ap_RICindicationHeader);

                asn1Init_e2ap_RICindicationHeader(pvalue->value.u._e2ap_RICindication_IEs_id_RICindicationHeader);

                stat = asn1PD_e2ap_RICindicationHeader (pctxt,
                        (e2ap_RICindicationHeader*)pvalue->value.
                        u._e2ap_RICindication_IEs_id_RICindicationHeader);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RICindicationMessage:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICindication_IEs_id_RICindicationMessage;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICindicationMessage");
                pvalue->value.u._e2ap_RICindication_IEs_id_RICindicationMessage 
                    = rtxMemAllocType(pctxt, e2ap_RICindicationMessage);

                asn1Init_e2ap_RICindicationMessage(pvalue->value.u._e2ap_RICindication_IEs_id_RICindicationMessage);

                stat = asn1PD_e2ap_RICindicationMessage (pctxt,
                        (e2ap_RICindicationMessage*)pvalue->value.
                        u._e2ap_RICindication_IEs_id_RICindicationMessage);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RICcallProcessID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICindication_IEs_id_RICcallProcessID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICcallProcessID");
                pvalue->value.u._e2ap_RICindication_IEs_id_RICcallProcessID 
                    = rtxMemAllocType(pctxt, e2ap_RICcallProcessID);

                asn1Init_e2ap_RICcallProcessID(pvalue->value.u._e2ap_RICindication_IEs_id_RICcallProcessID);

                stat = asn1PD_e2ap_RICcallProcessID (pctxt,
                        (e2ap_RICcallProcessID*)pvalue->value.
                        u._e2ap_RICindication_IEs_id_RICcallProcessID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICindication_IEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*) rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
    }
    {
    size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
    size_t bitsConsumed = bitEndOffset-bitStartOffset;
    if(bitsConsumed<bitLength){
        stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
    }
    else stat =(bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
    }}
    if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}


int asn1Init_e2ap_RICindication_protocolIEs_element(e2ap_RICindication_protocolIEs_element* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    OSCRTLMEMSET (&pvalue->value, 0, sizeof(pvalue->value));
    return 0;
}


//-----> chuaw có template rtxFreeASN1OpenType

#if 0
void asn1Free_e2ap_RICindication_protocolIEs_element(OSCTXT* pctxt, e2ap_RICindication_protocolIEs_element* pvalue)
{
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICindication_IEs_id_id_RICrequestID:
            // rtxFreeE2ap_RICrequestID(pvalue->value.u._e2ap_RICindication_IEs_id_id_RICrequestID);

            if(pvalue->value.i._e2ap_RICindication_id_RICrequestID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICrequestID(pctxt, pvalue->value.u._e2ap_RICindication_IEs_id_id_RICrequestID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICindication_IEs_id_id_RICrequestID);
           // pvalue->value.u._e2ap_RICindication_IEs_id_id_RICrequestID = NULL;
           pvalue->value.u._e2ap_RICindication_IEs_id_RICrequestID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICindication_IEs_id_id_RANfunctionID:
            // rtxFreeE2ap_RANfunctionID(pvalue->value.u._e2ap_RICindication_IEs_id_id_RANfunctionID);

            if(pvalue->value.i._e2ap_RICindication_id_RANfunctionID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RANfunctionID(pctxt, pvalue->value.u._e2ap_RICindication_IEs_id_id_RANfunctionID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICindication_IEs_id_id_RANfunctionID);
           // pvalue->value.u._e2ap_RICindication_IEs_id_id_RANfunctionID = NULL;
           pvalue->value.u._e2ap_RICindication_IEs_id_RANfunctionID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICindication_IEs_id_id_RICactionID:
            // rtxFreeE2ap_RICactionID(pvalue->value.u._e2ap_RICindication_IEs_id_id_RICactionID);

            if(pvalue->value.i._e2ap_RICindication_id_RICactionID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICactionID(pctxt, pvalue->value.u._e2ap_RICindication_IEs_id_id_RICactionID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICindication_IEs_id_id_RICactionID);
           // pvalue->value.u._e2ap_RICindication_IEs_id_id_RICactionID = NULL;
           pvalue->value.u._e2ap_RICindication_IEs_id_RICactionID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICindication_IEs_id_id_RICindicationSN:
            // rtxFreeE2ap_RICindicationSN(pvalue->value.u._e2ap_RICindication_IEs_id_id_RICindicationSN);

            if(pvalue->value.i._e2ap_RICindication_id_RICindicationSN!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICindicationSN(pctxt, pvalue->value.u._e2ap_RICindication_IEs_id_id_RICindicationSN);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICindication_IEs_id_id_RICindicationSN);
           // pvalue->value.u._e2ap_RICindication_IEs_id_id_RICindicationSN = NULL;
           pvalue->value.u._e2ap_RICindication_IEs_id_RICindicationSN = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICindication_IEs_id_id_RICindicationType:
            // rtxFreeE2ap_RICindicationType(pvalue->value.u._e2ap_RICindication_IEs_id_id_RICindicationType);

            if(pvalue->value.i._e2ap_RICindication_id_RICindicationType!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICindicationType(pctxt, pvalue->value.u._e2ap_RICindication_IEs_id_id_RICindicationType);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICindication_IEs_id_id_RICindicationType);
           // pvalue->value.u._e2ap_RICindication_IEs_id_id_RICindicationType = NULL;
           pvalue->value.u._e2ap_RICindication_IEs_id_RICindicationType = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICindication_IEs_id_id_RICindicationHeader:
            // rtxFreeE2ap_RICindicationHeader(pvalue->value.u._e2ap_RICindication_IEs_id_id_RICindicationHeader);

            if(pvalue->value.i._e2ap_RICindication_id_RICindicationHeader!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICindicationHeader(pctxt, pvalue->value.u._e2ap_RICindication_IEs_id_id_RICindicationHeader);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICindication_IEs_id_id_RICindicationHeader);
           // pvalue->value.u._e2ap_RICindication_IEs_id_id_RICindicationHeader = NULL;
           pvalue->value.u._e2ap_RICindication_IEs_id_RICindicationHeader = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICindication_IEs_id_id_RICindicationMessage:
            // rtxFreeE2ap_RICindicationMessage(pvalue->value.u._e2ap_RICindication_IEs_id_id_RICindicationMessage);

            if(pvalue->value.i._e2ap_RICindication_id_RICindicationMessage!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICindicationMessage(pctxt, pvalue->value.u._e2ap_RICindication_IEs_id_id_RICindicationMessage);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICindication_IEs_id_id_RICindicationMessage);
           // pvalue->value.u._e2ap_RICindication_IEs_id_id_RICindicationMessage = NULL;
           pvalue->value.u._e2ap_RICindication_IEs_id_RICindicationMessage = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICindication_IEs_id_id_RICcallProcessID:
            // rtxFreeE2ap_RICcallProcessID(pvalue->value.u._e2ap_RICindication_IEs_id_id_RICcallProcessID);

            if(pvalue->value.i._e2ap_RICindication_id_RICcallProcessID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICcallProcessID(pctxt, pvalue->value.u._e2ap_RICindication_IEs_id_id_RICcallProcessID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICindication_IEs_id_id_RICcallProcessID);
           // pvalue->value.u._e2ap_RICindication_IEs_id_id_RICcallProcessID = NULL;
           pvalue->value.u._e2ap_RICindication_IEs_id_RICcallProcessID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICindication_IEs_UNDEF_:
            rtxFreeASN1OpenType(pvalue->value.u.extElem1);
            break;
        default:
            break;
    }
}

int asn1PrtToStr_e2ap_RICindication_protocolIEs_element(OSCTXT* pctxt, e2ap_RICindication_protocolIEs_element* pvalue)
{
    int stat =0;
    RTXCTXTPUSHELEMNAME(pctxt, "e2ap_RICindication_protocolIEs_element");

    /*print id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PrtToStr_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PrtToStr_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_RICindication_IEs_id_id_RICrequestID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICrequestID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICrequestID (pctxt, pvalue->value.u._e2ap_RICindication_IEs_id_id_RICrequestID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICindication_IEs_id_id_RANfunctionID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RANfunctionID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RANfunctionID (pctxt, pvalue->value.u._e2ap_RICindication_IEs_id_id_RANfunctionID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICindication_IEs_id_id_RICactionID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICactionID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICactionID (pctxt, pvalue->value.u._e2ap_RICindication_IEs_id_id_RICactionID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICindication_IEs_id_id_RICindicationSN:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICindicationSN");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICindicationSN (pctxt, pvalue->value.u._e2ap_RICindication_IEs_id_id_RICindicationSN);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICindication_IEs_id_id_RICindicationType:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICindicationType");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICindicationType (pctxt, pvalue->value.u._e2ap_RICindication_IEs_id_id_RICindicationType);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICindication_IEs_id_id_RICindicationHeader:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICindicationHeader");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICindicationHeader (pctxt, pvalue->value.u._e2ap_RICindication_IEs_id_id_RICindicationHeader);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICindication_IEs_id_id_RICindicationMessage:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICindicationMessage");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICindicationMessage (pctxt, pvalue->value.u._e2ap_RICindication_IEs_id_id_RICindicationMessage);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICindication_IEs_id_id_RICcallProcessID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICcallProcessID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICcallProcessID (pctxt, pvalue->value.u._e2ap_RICindication_IEs_id_id_RICcallProcessID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_RICindication_IEs_UNDEF_:
            {
                rtxPLogMsg(pctxt, "Extension element present - raw data not printed.\n");
                break;
            }

            default:
                stat = RTERR_INVOPT;
                return LOG_RTERR(pctxt, stat);
        }
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);
}
#endif


int asn1PrtToStr_e2ap_RICindication_protocolIEs_element (const char * name,
 e2ap_RICindication_protocolIEs_element* pvalue, 
 char * buffer, OSSIZE bufSize){
    if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
        return -1;
    if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
        return -1;

    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICindication_IEs_id_RICrequestID:
            if(asn1PrtToStr_e2ap_RICrequestID("RICrequestID", 
                    pvalue->value.u._e2ap_RICindication_IEs_id_RICrequestID, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICindication_IEs_id_RANfunctionID:
            if(asn1PrtToStr_e2ap_RANfunctionID("RANfunctionID", 
                    pvalue->value.u._e2ap_RICindication_IEs_id_RANfunctionID, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICindication_IEs_id_RICactionID:
            if(asn1PrtToStr_e2ap_RICactionID("RICactionID", 
                    pvalue->value.u._e2ap_RICindication_IEs_id_RICactionID, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICindication_IEs_id_RICindicationSN:
            if(asn1PrtToStr_e2ap_RICindicationSN("RICindicationSN", 
                    pvalue->value.u._e2ap_RICindication_IEs_id_RICindicationSN, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICindication_IEs_id_RICindicationType:
            if(asn1PrtToStr_e2ap_RICindicationType("RICindicationType", 
                    pvalue->value.u._e2ap_RICindication_IEs_id_RICindicationType, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICindication_IEs_id_RICindicationHeader:
            if(asn1PrtToStr_e2ap_RICindicationHeader("RICindicationHeader", 
                    pvalue->value.u._e2ap_RICindication_IEs_id_RICindicationHeader, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICindication_IEs_id_RICindicationMessage:
            if(asn1PrtToStr_e2ap_RICindicationMessage("RICindicationMessage", 
                    pvalue->value.u._e2ap_RICindication_IEs_id_RICindicationMessage, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICindication_IEs_id_RICcallProcessID:
            if(asn1PrtToStr_e2ap_RICcallProcessID("RICcallProcessID", 
                    pvalue->value.u._e2ap_RICindication_IEs_id_RICcallProcessID, buffer, bufSize)<0)
                return -1;
            break;    
        default:
        if(0!=pvalue -> value.u.extElem1){
            rtPrintToStringIndent(buffer, bufSize);
            rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

        }
        }
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

    return 0;

 }

 void asn1Free_e2ap_RICindication_protocolIEs_element(OSCTXT* pctxt, e2ap_RICindication_protocolIEs_element* pvalue){
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICindication_IEs_id_RICrequestID:
            if(pvalue->value.u._e2ap_RICindication_IEs_id_RICrequestID!=NULL){
            asn1Free_e2ap_RICrequestID(pctxt, pvalue->value.u._e2ap_RICindication_IEs_id_RICrequestID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICindication_IEs_id_RICrequestID);
            pvalue->value.u._e2ap_RICindication_IEs_id_RICrequestID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICindication_IEs_id_RANfunctionID:
            if(pvalue->value.u._e2ap_RICindication_IEs_id_RANfunctionID!=NULL){
            asn1Free_e2ap_RANfunctionID(pctxt, pvalue->value.u._e2ap_RICindication_IEs_id_RANfunctionID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICindication_IEs_id_RANfunctionID);
            pvalue->value.u._e2ap_RICindication_IEs_id_RANfunctionID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICindication_IEs_id_RICactionID:
            if(pvalue->value.u._e2ap_RICindication_IEs_id_RICactionID!=NULL){
            asn1Free_e2ap_RICactionID(pctxt, pvalue->value.u._e2ap_RICindication_IEs_id_RICactionID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICindication_IEs_id_RICactionID);
            pvalue->value.u._e2ap_RICindication_IEs_id_RICactionID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICindication_IEs_id_RICindicationSN:
            if(pvalue->value.u._e2ap_RICindication_IEs_id_RICindicationSN!=NULL){
            asn1Free_e2ap_RICindicationSN(pctxt, pvalue->value.u._e2ap_RICindication_IEs_id_RICindicationSN);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICindication_IEs_id_RICindicationSN);
            pvalue->value.u._e2ap_RICindication_IEs_id_RICindicationSN = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICindication_IEs_id_RICindicationType:
            if(pvalue->value.u._e2ap_RICindication_IEs_id_RICindicationType!=NULL){
            asn1Free_e2ap_RICindicationType(pctxt, pvalue->value.u._e2ap_RICindication_IEs_id_RICindicationType);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICindication_IEs_id_RICindicationType);
            pvalue->value.u._e2ap_RICindication_IEs_id_RICindicationType = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICindication_IEs_id_RICindicationHeader:
            if(pvalue->value.u._e2ap_RICindication_IEs_id_RICindicationHeader!=NULL){
            asn1Free_e2ap_RICindicationHeader(pctxt, pvalue->value.u._e2ap_RICindication_IEs_id_RICindicationHeader);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICindication_IEs_id_RICindicationHeader);
            pvalue->value.u._e2ap_RICindication_IEs_id_RICindicationHeader = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICindication_IEs_id_RICindicationMessage:
            if(pvalue->value.u._e2ap_RICindication_IEs_id_RICindicationMessage!=NULL){
            asn1Free_e2ap_RICindicationMessage(pctxt, pvalue->value.u._e2ap_RICindication_IEs_id_RICindicationMessage);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICindication_IEs_id_RICindicationMessage);
            pvalue->value.u._e2ap_RICindication_IEs_id_RICindicationMessage = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICindication_IEs_id_RICcallProcessID:
            if(pvalue->value.u._e2ap_RICindication_IEs_id_RICcallProcessID!=NULL){
            asn1Free_e2ap_RICcallProcessID(pctxt, pvalue->value.u._e2ap_RICindication_IEs_id_RICcallProcessID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICindication_IEs_id_RICcallProcessID);
            pvalue->value.u._e2ap_RICindication_IEs_id_RICcallProcessID = NULL;
            }
            break;
        default:
            break;


    }
 }

 

/*****************************************/
/*           RICindication                */
/*****************************************/
//2_container.c
/* 1. xxx_ProtocolIE -> mẫu cũ ở ie_big_msg */
EXTERN int asn1PE_e2ap_RICindication_protocolIEs (OSCTXT* pctxt, e2ap_RICindication_protocolIEs* pvalue)
{
    int stat =0;
    OSRTDListNode* pnode;
    OSUINT32 xx1;

    /*encode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pe_Length(pctxt, pvalue->count);
    if(stat<0) return LOG_RTERR(pctxt, stat);

    /*encode each element*/
    xx1 =0;
    for(pnode = pvalue->head; pnode != 0 && xx1<pvalue->count; pnode = pnode->next){
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE", xx1);
        stat = asn1PE_e2ap_RICindication_protocolIEs_element (pctxt, ((e2ap_RICindication_protocolIEs_element*)pnode->data));
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        xx1++;
        RTXCTXTPOPARRAYELEMNAME(pctxt);
    }

    return (stat);
}

EXTERN int  asn1PD_e2ap_RICindication_protocolIEs(OSCTXT* pctxt, e2ap_RICindication_protocolIEs* pvalue)
{
     int stat =0;
     OSRTDListNode* pnode;
     OSSIZE count =0;
     OSSIZE xx1=0;


     /*decode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pd_Length64(pctxt, &count); //tai sao lai 64
    if(stat!=0) return LOG_RTERR(pctxt, stat);

    /*decode each element*/
    rtxDListInit(pvalue);

    for(xx1=0; xx1 < count; xx1++){
        e2ap_RICindication_protocolIEs_element* pdata;
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE",xx1);

        if(pnode == NULL) return LOG_RTERR(pctxt, RTERR_NOMEM);

        asn1Init_e2ap_RICindication_protocolIEs_element(pdata);
        rtxDListAppendNode(pvalue, pnode);
        stat = asn1PD_e2ap_RICindication_protocolIEs_element (pctxt, pdata);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        RTXCTXTPOPARRAYELEMNAME(pctxt);

    }
    return (stat);
}


int asn1Init_e2ap_RICindication_protocolIEs(e2ap_RICindication_protocolIEs* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    rtxDListFastInit (pvalue);
    return 0;
}
#if 1 //ao that day
void asn1Free_e2ap_RICindication_protocolIEs(OSCTXT* pctxt, e2ap_RICindication_protocolIEs* pvalue)
{
    if(0==pvalue) return;   
    e2ap_RICindication_protocolIEs_element* pdata;
    OSRTDListNode* pnode=pvalue->head;
    while(0!=pnode){
        pdata = (e2ap_RICindication_protocolIEs_element*)pnode->data;
       // asn1Free_e2ap_RICindication_protocolIEs_element(pctxt, pdata);
        pnode = pnode->next;
    }
    rtxDListFreeAll(pctxt, pvalue);
}
#endif


EXTERN int asn1PrtToStr_e2ap_RICindication_protocolIEs(const char* name, e2ap_RICindication_protocolIEs* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_RICindication_protocolIEs_element* pdata0;
    OSRTDListNode* pnode0;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode0 = pvalue->head;  xx1 < pvalue->count && pnode0 != 0; pnode0 = pnode0->next, xx1++){
        pdata0 = (e2ap_RICindication_protocolIEs_element*)pnode0->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 0
        if(asn1PrtToStr_e2ap_RICindication_protocolIEs_element(nameBuf, pdata0, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}


/*2 . RICindication -> mẫu cũ ở seq_normal*/

int asn1PE_e2ap_RICindication (OSCTXT* pctxt, e2ap_RICindication* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RICindication");
   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field protocolIEs - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
   stat = asn1PE_e2ap_RICindication_protocolIEs (pctxt, &pvalue->protocolIEs);
   if(stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RICindication (OSCTXT* pctxt, e2ap_RICindication* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME(pctxt, "RICindication");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field protocolIEs */
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
      stat = asn1PD_e2ap_RICindication_protocolIEs (pctxt, &pvalue->protocolIEs);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RICindication (e2ap_RICindication* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RICindication_protocolIEs(&pvalue->protocolIEs);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RICindication (OSCTXT* pctxt, e2ap_RICindication* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_RICindication_protocolIEs(pctxt, &pvalue->protocolIEs);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RICindication (const char* name, e2ap_RICindication* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }

   if(asn1PrtToStr_e2ap_RICindication_protocolIEs("protocolIEs", &pvalue->protocolIEs, buffer, bufSize) <0){
      return -1;
   }

   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           LoadMeasurementID                */
/*****************************************/
//5 mau integer
//mau 5 integer size(a .. b..) mau la nrfreqencyband
EXTERN int asn1PE_e2ap_LoadMeasurementID (OSCTXT* pctxt, e2ap_LoadMeasurementID value){
    int stat =0;
    OSBOOL extbit = FALSE;
    RTXCTCXTPUSHTYPENAME (pctxt, "LoadMeasurementID");
    if(value>1 && value<=4095){
        extbit = 0;
    }
    else extbit =1;
    stat = rtxEncBit (pctxt, extbit);
    if (stat != 0) return LOG_RTERR (pctxt, stat);
    if(extbit){
        stat = pe_UnconsUnsigned (pctxt, value);
        if(stat != 0) return LOG_RTERR (pctxt, stat);
    }
    else{
        stat = pe_ConsUnsigned (pctxt, value, 1, 4095);
        if (stat != 0) return LOG_RTERR (pctxt, stat);
    }
    RTXCTXTPOPTYPENAME (pctxt);
    return stat;
}
EXTERN int asn1PD_e2ap_LoadMeasurementID (OSCTXT* pctxt, e2ap_LoadMeasurementID* pvalue){
    int stat =0;
    OSBOOL extbit = FALSE;
    RTXCTCXTPUSHTYPENAME (pctxt, "LoadMeasurementID");
    /*extensiobit*/
    stat = DECBIT (pctxt, &extbit);
    if (stat != 0) return LOG_RTERR (pctxt, stat);
    if(extbit==0){
        stat = pd_ConsUnsigned (pctxt, pvalue, 1, 4095);
        if (stat != 0) return LOG_RTERR (pctxt, stat);
    }else{
        stat = pd_UnconsUnsigned (pctxt, pvalue);
        if (stat != 0) return LOG_RTERR (pctxt, stat);
    }
    RTXCTXTPOPTYPENAME (pctxt);
    return stat;
}
//EXTERN int asn1Print_e2ap_LoadMeasurementID (const char* name, const e2ap_LoadMeasurementID* pvalue);
//EXTERN int asn1PrtToStr_e2ap_LoadMeasurementID (const char* name, e2ap_LoadMeasurementID* pvalue, char* buffer, OSSIZE bufSize);
//EXTERN int asn1PrtToStrm_e2ap_LoadMeasurementID (OSCTXT* pctxt, const char* name, const e2ap_LoadMeasurementID* pvalue);
EXTERN int asn1Init_e2ap_LoadMeasurementID (e2ap_LoadMeasurementID* pvalue){
    //if (pvalue == 0) return RTERR_NULLPTR;
    //*pvalue = 0;
    return 0;
}
EXTERN int asn1Free_e2ap_LoadMeasurementID (OSCTXT* pctxt, e2ap_LoadMeasurementID* pvalue){
    // No dynamic memory to free for integer
    return 0;
}
/******************************************************/
/*                                                    */
/*    RegistrationRequest                          */
/*                                                    */
/******************************************************/
//enumerated


const OSEnumItem e2ap_RegistrationRequest_ENUMTAB[] = {
    { OSUTF8("start"), 0, 5, 0 },
    { OSUTF8("stop"), 1, 4, 1 },
    { OSUTF8("add"), 2, 3, 2 }
};


const OSUTF8CHAR* e2ap_RegistrationRequest_ToString (OSUINT32 value){
   OSINT32 idx = value;
   if(idx >=0 && idx < e2ap_RegistrationRequest_ENUMTABSIZE){
      return e2ap_RegistrationRequest_ENUMTAB[e2ap_RegistrationRequest_ENUMTAB[idx].transidx].name;
   }else{
      return OSUTF8("_UNKNOWN_");
   }
}


int e2ap_RegistrationRequest_ToEnum (OSCTXT* pctxt, const OSUTF8CHAR* value,e2ap_RegistrationRequest* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes(value);
   return e2ap_RegistrationRequest_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int e2ap_RegistrationRequest_ToEnum2 (OSCTXT* pctxt, const OSUTF8CHAR* value, OSSIZE valueLen,e2ap_RegistrationRequest* pvalue)
{
   OSINT32 idx = rtxLookupEnum(value, valueLen,
      e2ap_RegistrationRequest_ENUMTAB, e2ap_RegistrationRequest_ENUMTABSIZE);
   if (idx >= 0) {
      *pvalue = (e2ap_RegistrationRequest)e2ap_RegistrationRequest_ENUMTAB[idx].value;
      return 0;
   } else {
      rtxErrAddIntParm (pctxt, (const char*)value);//dungnm23 check xem là Str hay Int
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_e2ap_RegistrationRequest (OSCTXT* pctxt, e2ap_RegistrationRequest value)
{
   int stat = 0;
   RTXCTXTPUSHTYPENAME (pctxt, "RegistrationRequest");
   if (value >= 3) {
      rtxErrAddIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(2));
   if(stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}

EXTERN int asn1PD_e2ap_RegistrationRequest (OSCTXT* pctxt, e2ap_RegistrationRequest* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RegistrationRequest");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(2));
   if(stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return stat;
}

EXTERN int asn1PrtToStr_e2ap_RegistrationRequest (const char* name, e2ap_RegistrationRequest* pvalue, char* buffer, OSSIZE bufSize)
{
   int stat;

   if(rtPrintToStringIndent(buffer, bufSize) < 0) return -1;
   if(rtPrintToString(name, buffer, bufSize) < 0) return -1;

   switch(*pvalue) {
      case 0:
         stat = rtPrintToString(" = start \n", buffer, bufSize);
         break;
      case 1:
         stat = rtPrintToString(" = stop \n", buffer, bufSize);
         break;
      case 2:
         stat = rtPrintToString(" = add \n", buffer, bufSize);
         break;
      default:
         stat = rtPrintToString(" = ???\n", buffer, bufSize);
   }

   if (stat < 0) return -1;
   return 0;

}

/*Init*/
EXTERN int asn1Init_e2ap_RegistrationRequest (e2ap_RegistrationRequest* pvalue){
      //if (pvalue == 0) return RTERR_NULLPTR;
      //*pvalue = 0;
      return 0;
}/******************************************************/
/*                                                    */
/*    RICloadRequest                          */
/*                                                    */
/******************************************************/
//enumerated


const OSEnumItem e2ap_RICloadRequest_ENUMTAB[] = {
    { OSUTF8("true"), 0, 4, 0 }
};


const OSUTF8CHAR* e2ap_RICloadRequest_ToString (OSUINT32 value){
   OSINT32 idx = value;
   if(idx >=0 && idx < e2ap_RICloadRequest_ENUMTABSIZE){
      return e2ap_RICloadRequest_ENUMTAB[e2ap_RICloadRequest_ENUMTAB[idx].transidx].name;
   }else{
      return OSUTF8("_UNKNOWN_");
   }
}


int e2ap_RICloadRequest_ToEnum (OSCTXT* pctxt, const OSUTF8CHAR* value,e2ap_RICloadRequest* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes(value);
   return e2ap_RICloadRequest_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int e2ap_RICloadRequest_ToEnum2 (OSCTXT* pctxt, const OSUTF8CHAR* value, OSSIZE valueLen,e2ap_RICloadRequest* pvalue)
{
   OSINT32 idx = rtxLookupEnum(value, valueLen,
      e2ap_RICloadRequest_ENUMTAB, e2ap_RICloadRequest_ENUMTABSIZE);
   if (idx >= 0) {
      *pvalue = (e2ap_RICloadRequest)e2ap_RICloadRequest_ENUMTAB[idx].value;
      return 0;
   } else {
      rtxErrAddIntParm (pctxt, (const char*)value);//dungnm23 check xem là Str hay Int
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_e2ap_RICloadRequest (OSCTXT* pctxt, e2ap_RICloadRequest value)
{
   int stat = 0;
   RTXCTXTPUSHTYPENAME (pctxt, "RICloadRequest");
   if (value >= 1) {
      rtxErrAddIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(0));
   if(stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}

EXTERN int asn1PD_e2ap_RICloadRequest (OSCTXT* pctxt, e2ap_RICloadRequest* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RICloadRequest");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(0));
   if(stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return stat;
}

EXTERN int asn1PrtToStr_e2ap_RICloadRequest (const char* name, e2ap_RICloadRequest* pvalue, char* buffer, OSSIZE bufSize)
{
   int stat;

   if(rtPrintToStringIndent(buffer, bufSize) < 0) return -1;
   if(rtPrintToString(name, buffer, bufSize) < 0) return -1;

   switch(*pvalue) {
      case 0:
         stat = rtPrintToString(" = true \n", buffer, bufSize);
         break;
      default:
         stat = rtPrintToString(" = ???\n", buffer, bufSize);
   }

   if (stat < 0) return -1;
   return 0;

}

/*Init*/
EXTERN int asn1Init_e2ap_RICloadRequest (e2ap_RICloadRequest* pvalue){
      //if (pvalue == 0) return RTERR_NULLPTR;
      //*pvalue = 0;
      return 0;
}
/*****************************************/
/*           RICserviceLoadRequest                */
/*****************************************/
//sequence normal
// Các nội dung cần thiết cho template seq_normal.c.j2

// Các phần còn lại của template seq_normal.c.j2
//contain extensition bit -> theo mau cua GlobalgNB-ID
int asn1PE_e2ap_RICserviceLoadRequest (OSCTXT* pctxt, e2ap_RICserviceLoadRequest* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RICserviceLoadRequest");

   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);

   /*optional bit for field ricServiceReportLoadRequest*/
   stat = rtxEncBit (pctxt, pvalue->m_ricServiceReportLoadRequestPresent);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   /*optional bit for field ricServiceInsertLoadRequest*/
   stat = rtxEncBit (pctxt, pvalue->m_ricServiceInsertLoadRequestPresent);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   /*optional bit for field ricServiceControlLoadRequest*/
   stat = rtxEncBit (pctxt, pvalue->m_ricServiceControlLoadRequestPresent);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   /*optional bit for field ricServicePolicyLoadRequest*/
   stat = rtxEncBit (pctxt, pvalue->m_ricServicePolicyLoadRequestPresent);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   /*optional bit for field ricServiceQueryLoadRequest*/
   stat = rtxEncBit (pctxt, pvalue->m_ricServiceQueryLoadRequestPresent);
   if (stat != 0) return LOG_RTERR(pctxt, stat);

   /*encode root elements*/   
   /* encode field ricServiceReportLoadRequest - id = -1*/  
   if (pvalue->m_ricServiceReportLoadRequestPresent) {//OPTIONAL FIELD
   RTXCTXTPUSHELEMNAME(pctxt, "ricServiceReportLoadRequest");
   stat = asn1PE_e2ap_RICloadRequest (pctxt, pvalue->ricServiceReportLoadRequest);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   }

   /* encode field ricServiceInsertLoadRequest - id = -1*/  
   if (pvalue->m_ricServiceInsertLoadRequestPresent) {//OPTIONAL FIELD
   RTXCTXTPUSHELEMNAME(pctxt, "ricServiceInsertLoadRequest");
   stat = asn1PE_e2ap_RICloadRequest (pctxt, pvalue->ricServiceInsertLoadRequest);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   }

   /* encode field ricServiceControlLoadRequest - id = -1*/  
   if (pvalue->m_ricServiceControlLoadRequestPresent) {//OPTIONAL FIELD
   RTXCTXTPUSHELEMNAME(pctxt, "ricServiceControlLoadRequest");
   stat = asn1PE_e2ap_RICloadRequest (pctxt, pvalue->ricServiceControlLoadRequest);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   }

   /* encode field ricServicePolicyLoadRequest - id = -1*/  
   if (pvalue->m_ricServicePolicyLoadRequestPresent) {//OPTIONAL FIELD
   RTXCTXTPUSHELEMNAME(pctxt, "ricServicePolicyLoadRequest");
   stat = asn1PE_e2ap_RICloadRequest (pctxt, pvalue->ricServicePolicyLoadRequest);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   }

   /* encode field ricServiceQueryLoadRequest - id = -1*/  
   if (pvalue->m_ricServiceQueryLoadRequestPresent) {//OPTIONAL FIELD
   RTXCTXTPUSHELEMNAME(pctxt, "ricServiceQueryLoadRequest");
   stat = asn1PE_e2ap_RICloadRequest (pctxt, pvalue->ricServiceQueryLoadRequest);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   }


   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RICserviceLoadRequest (OSCTXT* pctxt, e2ap_RICserviceLoadRequest* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[5];

   RTXCTXTPUSHTYPENAME(pctxt, "RICserviceLoadRequest");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 5; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field ricServiceReportLoadRequest */
   RTXCTXTPUSHELEMNAME(pctxt, "ricServiceReportLoadRequest");
   if (optbits[0]) {
      pvalue->m_ricServiceReportLoadRequestPresent = TRUE;
      stat = asn1PD_e2ap_RICloadRequest (pctxt, &pvalue->ricServiceReportLoadRequest);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   } else {
      pvalue->m_ricServiceReportLoadRequestPresent = FALSE;
   }
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field ricServiceInsertLoadRequest */
   RTXCTXTPUSHELEMNAME(pctxt, "ricServiceInsertLoadRequest");
   if (optbits[0]) {
      pvalue->m_ricServiceInsertLoadRequestPresent = TRUE;
      stat = asn1PD_e2ap_RICloadRequest (pctxt, &pvalue->ricServiceInsertLoadRequest);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   } else {
      pvalue->m_ricServiceInsertLoadRequestPresent = FALSE;
   }
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field ricServiceControlLoadRequest */
   RTXCTXTPUSHELEMNAME(pctxt, "ricServiceControlLoadRequest");
   if (optbits[0]) {
      pvalue->m_ricServiceControlLoadRequestPresent = TRUE;
      stat = asn1PD_e2ap_RICloadRequest (pctxt, &pvalue->ricServiceControlLoadRequest);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   } else {
      pvalue->m_ricServiceControlLoadRequestPresent = FALSE;
   }
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field ricServicePolicyLoadRequest */
   RTXCTXTPUSHELEMNAME(pctxt, "ricServicePolicyLoadRequest");
   if (optbits[0]) {
      pvalue->m_ricServicePolicyLoadRequestPresent = TRUE;
      stat = asn1PD_e2ap_RICloadRequest (pctxt, &pvalue->ricServicePolicyLoadRequest);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   } else {
      pvalue->m_ricServicePolicyLoadRequestPresent = FALSE;
   }
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field ricServiceQueryLoadRequest */
   RTXCTXTPUSHELEMNAME(pctxt, "ricServiceQueryLoadRequest");
   if (optbits[0]) {
      pvalue->m_ricServiceQueryLoadRequestPresent = TRUE;
      stat = asn1PD_e2ap_RICloadRequest (pctxt, &pvalue->ricServiceQueryLoadRequest);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   } else {
      pvalue->m_ricServiceQueryLoadRequestPresent = FALSE;
   }
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RICserviceLoadRequest (e2ap_RICserviceLoadRequest* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RICloadRequest (&pvalue->ricServiceReportLoadRequest);
   asn1Init_e2ap_RICloadRequest (&pvalue->ricServiceInsertLoadRequest);
   asn1Init_e2ap_RICloadRequest (&pvalue->ricServiceControlLoadRequest);
   asn1Init_e2ap_RICloadRequest (&pvalue->ricServicePolicyLoadRequest);
   asn1Init_e2ap_RICloadRequest (&pvalue->ricServiceQueryLoadRequest);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RICserviceLoadRequest (OSCTXT* pctxt, e2ap_RICserviceLoadRequest* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_RICloadRequest (pctxt, &pvalue->ricServiceReportLoadRequest);
   asn1Free_e2ap_RICloadRequest (pctxt, &pvalue->ricServiceInsertLoadRequest);
   asn1Free_e2ap_RICloadRequest (pctxt, &pvalue->ricServiceControlLoadRequest);
   asn1Free_e2ap_RICloadRequest (pctxt, &pvalue->ricServicePolicyLoadRequest);
   asn1Free_e2ap_RICloadRequest (pctxt, &pvalue->ricServiceQueryLoadRequest);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RICserviceLoadRequest (const char* name, e2ap_RICserviceLoadRequest* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }
   if(asn1PrtToStr_e2ap_RICloadRequest ("ricServiceReportLoadRequest", &pvalue->ricServiceReportLoadRequest, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_RICloadRequest ("ricServiceInsertLoadRequest", &pvalue->ricServiceInsertLoadRequest, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_RICloadRequest ("ricServiceControlLoadRequest", &pvalue->ricServiceControlLoadRequest, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_RICloadRequest ("ricServicePolicyLoadRequest", &pvalue->ricServicePolicyLoadRequest, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_RICloadRequest ("ricServiceQueryLoadRequest", &pvalue->ricServiceQueryLoadRequest, buffer, bufSize) < 0)
   {
      return -1;
   }



   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}
/*****************************************/
/*           RICactionLoadRequest-Item                */
/*****************************************/
//sequence normal
// Các nội dung cần thiết cho template seq_normal.c.j2

// Các phần còn lại của template seq_normal.c.j2
//contain extensition bit -> theo mau cua GlobalgNB-ID
int asn1PE_e2ap_RICactionLoadRequest_Item (OSCTXT* pctxt, e2ap_RICactionLoadRequest_Item* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RICactionLoadRequest-Item");

   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field ricActionID - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "ricActionID");
   stat = asn1PE_e2ap_RICactionID (pctxt, pvalue->ricActionID);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /* encode field ricActionLoadRequest - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "ricActionLoadRequest");
   stat = asn1PE_e2ap_RICloadRequest (pctxt, pvalue->ricActionLoadRequest);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);



   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RICactionLoadRequest_Item (OSCTXT* pctxt, e2ap_RICactionLoadRequest_Item* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME(pctxt, "RICactionLoadRequest-Item");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field ricActionID */
   RTXCTXTPUSHELEMNAME(pctxt, "ricActionID");
      stat = asn1PD_e2ap_RICactionID (pctxt, &pvalue->ricActionID);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field ricActionLoadRequest */
   RTXCTXTPUSHELEMNAME(pctxt, "ricActionLoadRequest");
      stat = asn1PD_e2ap_RICloadRequest (pctxt, &pvalue->ricActionLoadRequest);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RICactionLoadRequest_Item (e2ap_RICactionLoadRequest_Item* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RICactionID (&pvalue->ricActionID);
   asn1Init_e2ap_RICloadRequest (&pvalue->ricActionLoadRequest);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RICactionLoadRequest_Item (OSCTXT* pctxt, e2ap_RICactionLoadRequest_Item* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_RICactionID (pctxt, &pvalue->ricActionID);
   asn1Free_e2ap_RICloadRequest (pctxt, &pvalue->ricActionLoadRequest);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RICactionLoadRequest_Item (const char* name, e2ap_RICactionLoadRequest_Item* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }
   if(asn1PrtToStr_e2ap_RICactionID ("ricActionID", &pvalue->ricActionID, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_RICloadRequest ("ricActionLoadRequest", &pvalue->ricActionLoadRequest, buffer, bufSize) < 0)
   {
      return -1;
   }



   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           RICactionLoadRequest_ItemIEs                */
/*****************************************/
/* ie.c.j2 */
/*ie thường*/
int asn1PE_e2ap_RICactionLoadRequest_ItemIEs (OSCTXT* pctxt, e2ap_RICactionLoadRequest_ItemIEs* pvalue)
{
   int stat = 0;
   //RTXCTXTPUSHTYPENAME (pctxt, "RICactionLoadRequest-ItemIEs");

   /* encode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");
   stat = asn1PE_e2ap_ProtocolIE_ID (pctxt, pvalue->id);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");
   stat = asn1PE_e2ap_Criticality (pctxt, pvalue->criticality);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   {
      OSCTXT ictxt;
      OSOCTET* pDynamicEncodeBuffer;
      ASN1OpenType openType;
      OSBOOL  encoded = TRUE;

      openType.numocts = 0;
      openType.data = 0;

      rtxCopyContext (&ictxt, pctxt);
      pctxt->pStream = 0;

      stat = rtxInitContextBuffer (pctxt, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_RICactionLoadRequest_ItemIEs_id_RICactionLoadRequest_Item:
         
        // RTXCTXTPUSHELEMNAME (pctxt, "RICactionLoadRequest_ItemIEs_id_RICactionLoadRequest_Item");
         RTXCTXTPUSHELEMNAME (pctxt, "RICactionLoadRequest-Item");
         stat = asn1PE_e2ap_RICactionLoadRequest_Item (pctxt, pvalue->value.u._e2apRICactionLoadRequest_ItemIEs_id_RICactionLoadRequest_Item);
         RTXCTXTPOPELEMNAME (pctxt);
      
         break;

      case T_E2AP_PDU_Contents_e2ap_RICactionLoadRequest_ItemIEs_UNDEF_:
      {
          if(0!=pvalue->value.u.extElem1){
              openType.numocts = pvalue->value.u.extElem1->numocts;
              openType.data = pvalue->value.u.extElem1->data;
          } else {
              /* No extension element to encode */
          }
          encoded = FALSE;
          break;
      }
      default:
         encoded = FALSE;
         stat = RTERR_INVOPT;
      }

      if (encoded) {
         openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
         openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
      }
      rtxCopyContext (pctxt, &ictxt);
      if(stat ==0) stat = pe_OpenType(pctxt, openType.numocts, openType.data);
      /*free dynamic encode buffer*/
      if(encoded){
          rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
      }
   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);
   //RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

int asn1PD_e2ap_RICactionLoadRequest_ItemIEs (OSCTXT* pctxt, e2ap_RICactionLoadRequest_ItemIEs* pvalue)
{
   int stat =0;
   /*deode root element id*/
   RTXCTXTPUSHELEMNAME(pctxt, "id");
   stat = asn1PD_e2ap_ProtocolIE_ID (pctxt, &pvalue->id);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*decode root element criticality*/
   RTXCTXTPUSHELEMNAME(pctxt, "criticality");
   stat = asn1PD_e2ap_Criticality (pctxt, &pvalue->criticality);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   /*decode root element value*/
   RTXCTXTPUSHELEMNAME(pctxt, "value");
   {
      OSUINT32 openTypeLen;
      size_t bitStartOffset, bitLength;
      stat = pd_UnconsLength(pctxt, &openTypeLen);
      if(stat <0) return LOG_RTERR(pctxt, stat);
      else if(stat == RT_OK_FRAG){
         rtxErrAddStrParm(pctxt, "open type with fragmented length use - perindef");
         return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
      }
      bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
      bitLength = openTypeLen * 8;
      switch (pvalue->id){
         case T_E2AP_PDU_Contents_e2ap_RICactionLoadRequest_ItemIEs_id_RICactionLoadRequest_Item:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICactionLoadRequest_ItemIEs_id_RICactionLoadRequest_Item;
            RTXCTXTPUSHELEMNAME(pctxt, "RICactionLoadRequest-Item");
            //pvalue->value.u._e2ap_RICactionLoadRequest_ItemIEs_id_id_RICactionLoadRequest_Item 
             pvalue->value.u._e2apRICactionLoadRequest_ItemIEs_id_RICactionLoadRequest_Item 
                    = rtxMemAllocType(pctxt, e2ap_RICactionLoadRequest_Item);
            //asn1Init_e2ap_RICactionLoadRequest_Item(pvalue->value.u._e2ap_RICactionLoadRequest_ItemIEs_id_id_RICactionLoadRequest_Item);
            asn1Init_e2ap_RICactionLoadRequest_Item(pvalue->value.u._e2apRICactionLoadRequest_ItemIEs_id_RICactionLoadRequest_Item);
            stat = asn1PD_e2ap_RICactionLoadRequest_Item (pctxt,
                    (e2ap_RICactionLoadRequest_Item*)pvalue->value.
                    u._e2apRICactionLoadRequest_ItemIEs_id_RICactionLoadRequest_Item);
            if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICactionLoadRequest_ItemIEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*)rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
      }
      {
      size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
      size_t bitsConsumed = bitEndOffset - bitStartOffset;
      if(bitsConsumed < bitLength){
         stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
      } else {
         stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
      }
      }
   }
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   return stat;
}

void asn1Init_e2ap_RICactionLoadRequest_ItemIEs (e2ap_RICactionLoadRequest_ItemIEs* pvalue)
{
   if (!pvalue) return;
   OSCRTLMEMSET (pvalue, 0, sizeof(e2ap_RICactionLoadRequest_ItemIEs));
}

#if 0
void asn1Free_e2ap_RICactionLoadRequest_ItemIEs (OSCTXT* pctxt, e2ap_RICactionLoadRequest_ItemIEs* pvalue)
{
   if (!pvalue) return;
   if (pvalue->extElem1) {
      rtxMemFreeArray (pctxt, pvalue->extElem1);
      pvalue->extElem1 = 0;
      pvalue->extElem1_n = 0;
   }
}
#endif
void asn1Free_e2ap_RICactionLoadRequest_ItemIEs (OSCTXT* pctxt, e2ap_RICactionLoadRequest_ItemIEs* pvalue)
{
   if(0==pvalue) return;
   switch(pvalue->value.t){
      case T_E2AP_PDU_Contents_e2ap_RICactionLoadRequest_ItemIEs_id_RICactionLoadRequest_Item:
         asn1Free_e2ap_RICactionLoadRequest_Item (pctxt, pvalue->value.u._e2apRICactionLoadRequest_ItemIEs_id_RICactionLoadRequest_Item);
         rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2apRICactionLoadRequest_ItemIEs_id_RICactionLoadRequest_Item);
         pvalue->value.u._e2apRICactionLoadRequest_ItemIEs_id_RICactionLoadRequest_Item = 0;
         break;
      case T_E2AP_PDU_Contents_e2ap_RICactionLoadRequest_ItemIEs_UNDEF_:
         if(0!=pvalue->value.u.extElem1){
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1->data);
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
             pvalue->value.u.extElem1 =0;
         }
         break;
         default:;
   }
}

int  asn1PrtToStr_e2ap_RICactionLoadRequest_ItemIEs (const char * name, e2ap_RICactionLoadRequest_ItemIEs* pvalue, char * buffer, OSSIZE bufSize){
   if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
       return -1;

      if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
         return -1;

      if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
         return -1;
      if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
         return -1;
      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_RICactionLoadRequest_ItemIEs_id_RICactionLoadRequest_Item:
         if(asn1PrtToStr_e2ap_RICactionLoadRequest_Item("RICactionLoadRequest-Item",
                pvalue->value.u._e2apRICactionLoadRequest_ItemIEs_id_RICactionLoadRequest_Item, buffer, bufSize)<0)// dungnm23 check lai nhe xem la
            return -1;
         break;
      default:
         if(0!=pvalue -> value.u.extElem1){
             rtPrintToStringIndent(buffer, bufSize);
             rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

         }
      }
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

      return 0;

}
 

/*****************************************/
/*           RICactionLoadRequest_List                */
/*****************************************/
//seq_of_single_container


int asn1PE_e2ap_RICactionLoadRequest_List (OSCTXT* pctxt, e2ap_RICactionLoadRequest_List* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_RICactionLoadRequest_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "RICactionLoadRequest-List");

   /* encode length determinant */
   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;
   for (xx1 = 0; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next, xx1++) {
      pdata = (e2ap_RICactionLoadRequest_ItemIEs*) pnode->data;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_e2ap_RICactionLoadRequest_ItemIEs (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      //xx1++;
      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}

int asn1PD_e2ap_RICactionLoadRequest_List (OSCTXT* pctxt, e2ap_RICactionLoadRequest_List* ppvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_RICactionLoadRequest_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "RICactionLoadRequest-List");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (ppvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      pdata = rtxMemAllocType (pctxt, e2ap_RICactionLoadRequest_ItemIEs);
      if (!pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);
      asn1Init_e2ap_RICactionLoadRequest_ItemIEs (pdata);
      stat = asn1PD_e2ap_RICactionLoadRequest_ItemIEs (pctxt, pdata);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         return LOG_RTERR (pctxt, stat);
      }

      rtxDListAppendNode (ppvalue, pdata);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

void asn1Init_e2ap_RICactionLoadRequest_List (e2ap_RICactionLoadRequest_List* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
}

void asn1Free_e2ap_RICactionLoadRequest_List (OSCTXT* pctxt, e2ap_RICactionLoadRequest_List* pvalue)
{
   if(pvalue==0) return;
   OSRTDListNode* pnode = pvalue->head;
   while (pnode) {
      e2ap_RICactionLoadRequest_ItemIEs* pdata = (e2ap_RICactionLoadRequest_ItemIEs*) pnode->data;
      if (pdata) {
         asn1Free_e2ap_RICactionLoadRequest_ItemIEs (pctxt, pdata);
         rtxMemFreePtr (pctxt, pdata);
      }
      pnode = pnode->next;
   }
      rtxDListFreeAll(pctxt, pvalue);
}

#if 0
void asn1Free_e2ap_RICactionLoadRequest_List (OSCTXT* pctxt, e2ap_RICactionLoadRequest_List* pvalue){
   if(0==pvalue ) return;
   {
      e2ap_RICactionLoadRequest_ItemIEs * pdata;
      OSRTDListNode *pnode = pvalue->head;
      while(0!=pnode){
         pdata = (e2ap_RICactionLoadRequest_ItemIEs*)pnode->data;
         asn1Free_e2ap_RICactionLoadRequest_ItemIEs(pctxt, pdata);
         pnode = pnode->next;
      }
      rtxDListFreeAll(pctxt, pvalue);
   }
}
#endif


int asn1PrtToStr_e2ap_RICactionLoadRequest_List(const char* name, e2ap_RICactionLoadRequest_List* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_RICactionLoadRequest_ItemIEs* pdata;
    OSRTDListNode* pnode;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode = pvalue->head;  xx1 < pvalue->count && pnode != 0; pnode = pnode->next, xx1++){
        pdata = (e2ap_RICactionLoadRequest_ItemIEs*)pnode->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 1
        if(asn1PrtToStr_e2ap_RICactionLoadRequest_ItemIEs(nameBuf, pdata, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}
/*****************************************/
/*           RICsubscriptionLoadRequest-ItemIE                */
/*****************************************/
//sequence normal
// Các nội dung cần thiết cho template seq_normal.c.j2

// Các phần còn lại của template seq_normal.c.j2
//contain extensition bit -> theo mau cua GlobalgNB-ID
int asn1PE_e2ap_RICsubscriptionLoadRequest_ItemIE (OSCTXT* pctxt, e2ap_RICsubscriptionLoadRequest_ItemIE* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RICsubscriptionLoadRequest-ItemIE");

   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);

   /*optional bit for field ricSubscriptionLoadRequest*/
   stat = rtxEncBit (pctxt, pvalue->m_ricSubscriptionLoadRequestPresent);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   /*optional bit for field ricActionLoadRequest_list*/
   stat = rtxEncBit (pctxt, pvalue->m_ricActionLoadRequest_listPresent);
   if (stat != 0) return LOG_RTERR(pctxt, stat);

   /*encode root elements*/   
   /* encode field ricRequestID - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "ricRequestID");
   stat = asn1PE_e2ap_RICrequestID (pctxt, pvalue->ricRequestID);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /* encode field ricSubscriptionLoadRequest - id = -1*/  
   if (pvalue->m_ricSubscriptionLoadRequestPresent) {//OPTIONAL FIELD
   RTXCTXTPUSHELEMNAME(pctxt, "ricSubscriptionLoadRequest");
   stat = asn1PE_e2ap_RICloadRequest (pctxt, pvalue->ricSubscriptionLoadRequest);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   }

   /* encode field ricActionLoadRequest_list - id = -1*/  
   if (pvalue->m_ricActionLoadRequest_listPresent) {//OPTIONAL FIELD
   RTXCTXTPUSHELEMNAME(pctxt, "ricActionLoadRequest-list");
   stat = asn1PE_e2ap_RICactionLoadRequest_List (pctxt, pvalue->ricActionLoadRequest_list);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   }


   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RICsubscriptionLoadRequest_ItemIE (OSCTXT* pctxt, e2ap_RICsubscriptionLoadRequest_ItemIE* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[3];

   RTXCTXTPUSHTYPENAME(pctxt, "RICsubscriptionLoadRequest-ItemIE");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field ricRequestID */
   RTXCTXTPUSHELEMNAME(pctxt, "ricRequestID");
      stat = asn1PD_e2ap_RICrequestID (pctxt, &pvalue->ricRequestID);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field ricSubscriptionLoadRequest */
   RTXCTXTPUSHELEMNAME(pctxt, "ricSubscriptionLoadRequest");
   if (optbits[0]) {
      pvalue->m_ricSubscriptionLoadRequestPresent = TRUE;
      stat = asn1PD_e2ap_RICloadRequest (pctxt, &pvalue->ricSubscriptionLoadRequest);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   } else {
      pvalue->m_ricSubscriptionLoadRequestPresent = FALSE;
   }
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field ricActionLoadRequest_list */
   RTXCTXTPUSHELEMNAME(pctxt, "ricActionLoadRequest-list");
   if (optbits[0]) {
      pvalue->m_ricActionLoadRequest_listPresent = TRUE;
      stat = asn1PD_e2ap_RICactionLoadRequest_List (pctxt, &pvalue->ricActionLoadRequest_list);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   } else {
      pvalue->m_ricActionLoadRequest_listPresent = FALSE;
   }
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RICsubscriptionLoadRequest_ItemIE (e2ap_RICsubscriptionLoadRequest_ItemIE* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RICrequestID (&pvalue->ricRequestID);
   asn1Init_e2ap_RICloadRequest (&pvalue->ricSubscriptionLoadRequest);
   asn1Init_e2ap_RICactionLoadRequest_List (&pvalue->ricActionLoadRequest_list);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RICsubscriptionLoadRequest_ItemIE (OSCTXT* pctxt, e2ap_RICsubscriptionLoadRequest_ItemIE* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_RICrequestID (pctxt, &pvalue->ricRequestID);
   asn1Free_e2ap_RICloadRequest (pctxt, &pvalue->ricSubscriptionLoadRequest);
   asn1Free_e2ap_RICactionLoadRequest_List (pctxt, &pvalue->ricActionLoadRequest_list);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RICsubscriptionLoadRequest_ItemIE (const char* name, e2ap_RICsubscriptionLoadRequest_ItemIE* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }
   if(asn1PrtToStr_e2ap_RICrequestID ("ricRequestID", &pvalue->ricRequestID, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_RICloadRequest ("ricSubscriptionLoadRequest", &pvalue->ricSubscriptionLoadRequest, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_RICactionLoadRequest_List ("ricActionLoadRequest_list", &pvalue->ricActionLoadRequest_list, buffer, bufSize) < 0)
   {
      return -1;
   }



   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           RICsubscriptionLoadRequest_ItemIEs                */
/*****************************************/
/* ie.c.j2 */
/*ie thường*/
int asn1PE_e2ap_RICsubscriptionLoadRequest_ItemIEs (OSCTXT* pctxt, e2ap_RICsubscriptionLoadRequest_ItemIEs* pvalue)
{
   int stat = 0;
   //RTXCTXTPUSHTYPENAME (pctxt, "RICsubscriptionLoadRequest-ItemIEs");

   /* encode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");
   stat = asn1PE_e2ap_ProtocolIE_ID (pctxt, pvalue->id);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");
   stat = asn1PE_e2ap_Criticality (pctxt, pvalue->criticality);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   {
      OSCTXT ictxt;
      OSOCTET* pDynamicEncodeBuffer;
      ASN1OpenType openType;
      OSBOOL  encoded = TRUE;

      openType.numocts = 0;
      openType.data = 0;

      rtxCopyContext (&ictxt, pctxt);
      pctxt->pStream = 0;

      stat = rtxInitContextBuffer (pctxt, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_RICsubscriptionLoadRequest_ItemIEs_id_RICsubscriptionLoadRequest_Item:
         
        // RTXCTXTPUSHELEMNAME (pctxt, "RICsubscriptionLoadRequest_ItemIEs_id_RICsubscriptionLoadRequest_ItemIE");
         RTXCTXTPUSHELEMNAME (pctxt, "RICsubscriptionLoadRequest-ItemIE");
         stat = asn1PE_e2ap_RICsubscriptionLoadRequest_ItemIE (pctxt, pvalue->value.u._e2apRICsubscriptionLoadRequest_ItemIEs_id_RICsubscriptionLoadRequest_Item);
         RTXCTXTPOPELEMNAME (pctxt);
      
         break;

      case T_E2AP_PDU_Contents_e2ap_RICsubscriptionLoadRequest_ItemIEs_UNDEF_:
      {
          if(0!=pvalue->value.u.extElem1){
              openType.numocts = pvalue->value.u.extElem1->numocts;
              openType.data = pvalue->value.u.extElem1->data;
          } else {
              /* No extension element to encode */
          }
          encoded = FALSE;
          break;
      }
      default:
         encoded = FALSE;
         stat = RTERR_INVOPT;
      }

      if (encoded) {
         openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
         openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
      }
      rtxCopyContext (pctxt, &ictxt);
      if(stat ==0) stat = pe_OpenType(pctxt, openType.numocts, openType.data);
      /*free dynamic encode buffer*/
      if(encoded){
          rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
      }
   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);
   //RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

int asn1PD_e2ap_RICsubscriptionLoadRequest_ItemIEs (OSCTXT* pctxt, e2ap_RICsubscriptionLoadRequest_ItemIEs* pvalue)
{
   int stat =0;
   /*deode root element id*/
   RTXCTXTPUSHELEMNAME(pctxt, "id");
   stat = asn1PD_e2ap_ProtocolIE_ID (pctxt, &pvalue->id);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*decode root element criticality*/
   RTXCTXTPUSHELEMNAME(pctxt, "criticality");
   stat = asn1PD_e2ap_Criticality (pctxt, &pvalue->criticality);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   /*decode root element value*/
   RTXCTXTPUSHELEMNAME(pctxt, "value");
   {
      OSUINT32 openTypeLen;
      size_t bitStartOffset, bitLength;
      stat = pd_UnconsLength(pctxt, &openTypeLen);
      if(stat <0) return LOG_RTERR(pctxt, stat);
      else if(stat == RT_OK_FRAG){
         rtxErrAddStrParm(pctxt, "open type with fragmented length use - perindef");
         return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
      }
      bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
      bitLength = openTypeLen * 8;
      switch (pvalue->id){
         case T_E2AP_PDU_Contents_e2ap_RICsubscriptionLoadRequest_ItemIEs_id_RICsubscriptionLoadRequest_Item:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionLoadRequest_ItemIEs_id_RICsubscriptionLoadRequest_Item;
            RTXCTXTPUSHELEMNAME(pctxt, "RICsubscriptionLoadRequest-ItemIE");
            //pvalue->value.u._e2ap_RICsubscriptionLoadRequest_ItemIEs_id_id_RICsubscriptionLoadRequest_Item 
             pvalue->value.u._e2apRICsubscriptionLoadRequest_ItemIEs_id_RICsubscriptionLoadRequest_Item 
                    = rtxMemAllocType(pctxt, e2ap_RICsubscriptionLoadRequest_ItemIE);
            //asn1Init_e2ap_RICsubscriptionLoadRequest_ItemIE(pvalue->value.u._e2ap_RICsubscriptionLoadRequest_ItemIEs_id_id_RICsubscriptionLoadRequest_Item);
            asn1Init_e2ap_RICsubscriptionLoadRequest_ItemIE(pvalue->value.u._e2apRICsubscriptionLoadRequest_ItemIEs_id_RICsubscriptionLoadRequest_Item);
            stat = asn1PD_e2ap_RICsubscriptionLoadRequest_ItemIE (pctxt,
                    (e2ap_RICsubscriptionLoadRequest_ItemIE*)pvalue->value.
                    u._e2apRICsubscriptionLoadRequest_ItemIEs_id_RICsubscriptionLoadRequest_Item);
            if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionLoadRequest_ItemIEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*)rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
      }
      {
      size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
      size_t bitsConsumed = bitEndOffset - bitStartOffset;
      if(bitsConsumed < bitLength){
         stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
      } else {
         stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
      }
      }
   }
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   return stat;
}

void asn1Init_e2ap_RICsubscriptionLoadRequest_ItemIEs (e2ap_RICsubscriptionLoadRequest_ItemIEs* pvalue)
{
   if (!pvalue) return;
   OSCRTLMEMSET (pvalue, 0, sizeof(e2ap_RICsubscriptionLoadRequest_ItemIEs));
}

#if 0
void asn1Free_e2ap_RICsubscriptionLoadRequest_ItemIEs (OSCTXT* pctxt, e2ap_RICsubscriptionLoadRequest_ItemIEs* pvalue)
{
   if (!pvalue) return;
   if (pvalue->extElem1) {
      rtxMemFreeArray (pctxt, pvalue->extElem1);
      pvalue->extElem1 = 0;
      pvalue->extElem1_n = 0;
   }
}
#endif
void asn1Free_e2ap_RICsubscriptionLoadRequest_ItemIEs (OSCTXT* pctxt, e2ap_RICsubscriptionLoadRequest_ItemIEs* pvalue)
{
   if(0==pvalue) return;
   switch(pvalue->value.t){
      case T_E2AP_PDU_Contents_e2ap_RICsubscriptionLoadRequest_ItemIEs_id_RICsubscriptionLoadRequest_Item:
         asn1Free_e2ap_RICsubscriptionLoadRequest_ItemIE (pctxt, pvalue->value.u._e2apRICsubscriptionLoadRequest_ItemIEs_id_RICsubscriptionLoadRequest_Item);
         rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2apRICsubscriptionLoadRequest_ItemIEs_id_RICsubscriptionLoadRequest_Item);
         pvalue->value.u._e2apRICsubscriptionLoadRequest_ItemIEs_id_RICsubscriptionLoadRequest_Item = 0;
         break;
      case T_E2AP_PDU_Contents_e2ap_RICsubscriptionLoadRequest_ItemIEs_UNDEF_:
         if(0!=pvalue->value.u.extElem1){
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1->data);
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
             pvalue->value.u.extElem1 =0;
         }
         break;
         default:;
   }
}

int  asn1PrtToStr_e2ap_RICsubscriptionLoadRequest_ItemIEs (const char * name, e2ap_RICsubscriptionLoadRequest_ItemIEs* pvalue, char * buffer, OSSIZE bufSize){
   if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
       return -1;

      if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
         return -1;

      if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
         return -1;
      if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
         return -1;
      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_RICsubscriptionLoadRequest_ItemIEs_id_RICsubscriptionLoadRequest_Item:
         if(asn1PrtToStr_e2ap_RICsubscriptionLoadRequest_ItemIE("RICsubscriptionLoadRequest-ItemIE",
                pvalue->value.u._e2apRICsubscriptionLoadRequest_ItemIEs_id_RICsubscriptionLoadRequest_Item, buffer, bufSize)<0)// dungnm23 check lai nhe xem la
            return -1;
         break;
      default:
         if(0!=pvalue -> value.u.extElem1){
             rtPrintToStringIndent(buffer, bufSize);
             rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

         }
      }
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

      return 0;

}
 

/*****************************************/
/*           RICsubscriptionLoadRequest_List                */
/*****************************************/
//seq_of_single_container


int asn1PE_e2ap_RICsubscriptionLoadRequest_List (OSCTXT* pctxt, e2ap_RICsubscriptionLoadRequest_List* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_RICsubscriptionLoadRequest_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "RICsubscriptionLoadRequest-List");

   /* encode length determinant */
   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1024), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;
   for (xx1 = 0; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next, xx1++) {
      pdata = (e2ap_RICsubscriptionLoadRequest_ItemIEs*) pnode->data;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_e2ap_RICsubscriptionLoadRequest_ItemIEs (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      //xx1++;
      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}

int asn1PD_e2ap_RICsubscriptionLoadRequest_List (OSCTXT* pctxt, e2ap_RICsubscriptionLoadRequest_List* ppvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_RICsubscriptionLoadRequest_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "RICsubscriptionLoadRequest-List");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1024), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (ppvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      pdata = rtxMemAllocType (pctxt, e2ap_RICsubscriptionLoadRequest_ItemIEs);
      if (!pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);
      asn1Init_e2ap_RICsubscriptionLoadRequest_ItemIEs (pdata);
      stat = asn1PD_e2ap_RICsubscriptionLoadRequest_ItemIEs (pctxt, pdata);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         return LOG_RTERR (pctxt, stat);
      }

      rtxDListAppendNode (ppvalue, pdata);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

void asn1Init_e2ap_RICsubscriptionLoadRequest_List (e2ap_RICsubscriptionLoadRequest_List* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
}

void asn1Free_e2ap_RICsubscriptionLoadRequest_List (OSCTXT* pctxt, e2ap_RICsubscriptionLoadRequest_List* pvalue)
{
   if(pvalue==0) return;
   OSRTDListNode* pnode = pvalue->head;
   while (pnode) {
      e2ap_RICsubscriptionLoadRequest_ItemIEs* pdata = (e2ap_RICsubscriptionLoadRequest_ItemIEs*) pnode->data;
      if (pdata) {
         asn1Free_e2ap_RICsubscriptionLoadRequest_ItemIEs (pctxt, pdata);
         rtxMemFreePtr (pctxt, pdata);
      }
      pnode = pnode->next;
   }
      rtxDListFreeAll(pctxt, pvalue);
}

#if 0
void asn1Free_e2ap_RICsubscriptionLoadRequest_List (OSCTXT* pctxt, e2ap_RICsubscriptionLoadRequest_List* pvalue){
   if(0==pvalue ) return;
   {
      e2ap_RICsubscriptionLoadRequest_ItemIEs * pdata;
      OSRTDListNode *pnode = pvalue->head;
      while(0!=pnode){
         pdata = (e2ap_RICsubscriptionLoadRequest_ItemIEs*)pnode->data;
         asn1Free_e2ap_RICsubscriptionLoadRequest_ItemIEs(pctxt, pdata);
         pnode = pnode->next;
      }
      rtxDListFreeAll(pctxt, pvalue);
   }
}
#endif


int asn1PrtToStr_e2ap_RICsubscriptionLoadRequest_List(const char* name, e2ap_RICsubscriptionLoadRequest_List* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_RICsubscriptionLoadRequest_ItemIEs* pdata;
    OSRTDListNode* pnode;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode = pvalue->head;  xx1 < pvalue->count && pnode != 0; pnode = pnode->next, xx1++){
        pdata = (e2ap_RICsubscriptionLoadRequest_ItemIEs*)pnode->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 1
        if(asn1PrtToStr_e2ap_RICsubscriptionLoadRequest_ItemIEs(nameBuf, pdata, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}
/*****************************************/
/*           RANfunctionLoadRequest-Item                */
/*****************************************/
//sequence normal
// Các nội dung cần thiết cho template seq_normal.c.j2

// Các phần còn lại của template seq_normal.c.j2
//contain extensition bit -> theo mau cua GlobalgNB-ID
int asn1PE_e2ap_RANfunctionLoadRequest_Item (OSCTXT* pctxt, e2ap_RANfunctionLoadRequest_Item* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RANfunctionLoadRequest-Item");

   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);

   /*optional bit for field ranFunctionLoadRequest*/
   stat = rtxEncBit (pctxt, pvalue->m_ranFunctionLoadRequestPresent);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   /*optional bit for field ricServiceLoadRequest*/
   stat = rtxEncBit (pctxt, pvalue->m_ricServiceLoadRequestPresent);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   /*optional bit for field ricSubscriptionLoadRequest_list*/
   stat = rtxEncBit (pctxt, pvalue->m_ricSubscriptionLoadRequest_listPresent);
   if (stat != 0) return LOG_RTERR(pctxt, stat);

   /*encode root elements*/   
   /* encode field ranFunctionID - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "ranFunctionID");
   stat = asn1PE_e2ap_RANfunctionID (pctxt, pvalue->ranFunctionID);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /* encode field ranFunctionLoadRequest - id = -1*/  
   if (pvalue->m_ranFunctionLoadRequestPresent) {//OPTIONAL FIELD
   RTXCTXTPUSHELEMNAME(pctxt, "ranFunctionLoadRequest");
   stat = asn1PE_e2ap_RICloadRequest (pctxt, pvalue->ranFunctionLoadRequest);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   }

   /* encode field ricServiceLoadRequest - id = -1*/  
   if (pvalue->m_ricServiceLoadRequestPresent) {//OPTIONAL FIELD
   RTXCTXTPUSHELEMNAME(pctxt, "ricServiceLoadRequest");
   stat = asn1PE_e2ap_RICserviceLoadRequest (pctxt, pvalue->ricServiceLoadRequest);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   }

   /* encode field ricSubscriptionLoadRequest_list - id = -1*/  
   if (pvalue->m_ricSubscriptionLoadRequest_listPresent) {//OPTIONAL FIELD
   RTXCTXTPUSHELEMNAME(pctxt, "ricSubscriptionLoadRequest-list");
   stat = asn1PE_e2ap_RICsubscriptionLoadRequest_List (pctxt, pvalue->ricSubscriptionLoadRequest_list);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   }


   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RANfunctionLoadRequest_Item (OSCTXT* pctxt, e2ap_RANfunctionLoadRequest_Item* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[4];

   RTXCTXTPUSHTYPENAME(pctxt, "RANfunctionLoadRequest-Item");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 4; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field ranFunctionID */
   RTXCTXTPUSHELEMNAME(pctxt, "ranFunctionID");
      stat = asn1PD_e2ap_RANfunctionID (pctxt, &pvalue->ranFunctionID);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field ranFunctionLoadRequest */
   RTXCTXTPUSHELEMNAME(pctxt, "ranFunctionLoadRequest");
   if (optbits[0]) {
      pvalue->m_ranFunctionLoadRequestPresent = TRUE;
      stat = asn1PD_e2ap_RICloadRequest (pctxt, &pvalue->ranFunctionLoadRequest);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   } else {
      pvalue->m_ranFunctionLoadRequestPresent = FALSE;
   }
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field ricServiceLoadRequest */
   RTXCTXTPUSHELEMNAME(pctxt, "ricServiceLoadRequest");
   if (optbits[0]) {
      pvalue->m_ricServiceLoadRequestPresent = TRUE;
      stat = asn1PD_e2ap_RICserviceLoadRequest (pctxt, &pvalue->ricServiceLoadRequest);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   } else {
      pvalue->m_ricServiceLoadRequestPresent = FALSE;
   }
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field ricSubscriptionLoadRequest_list */
   RTXCTXTPUSHELEMNAME(pctxt, "ricSubscriptionLoadRequest-list");
   if (optbits[0]) {
      pvalue->m_ricSubscriptionLoadRequest_listPresent = TRUE;
      stat = asn1PD_e2ap_RICsubscriptionLoadRequest_List (pctxt, &pvalue->ricSubscriptionLoadRequest_list);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   } else {
      pvalue->m_ricSubscriptionLoadRequest_listPresent = FALSE;
   }
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RANfunctionLoadRequest_Item (e2ap_RANfunctionLoadRequest_Item* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RANfunctionID (&pvalue->ranFunctionID);
   asn1Init_e2ap_RICloadRequest (&pvalue->ranFunctionLoadRequest);
   asn1Init_e2ap_RICserviceLoadRequest (&pvalue->ricServiceLoadRequest);
   asn1Init_e2ap_RICsubscriptionLoadRequest_List (&pvalue->ricSubscriptionLoadRequest_list);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RANfunctionLoadRequest_Item (OSCTXT* pctxt, e2ap_RANfunctionLoadRequest_Item* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_RANfunctionID (pctxt, &pvalue->ranFunctionID);
   asn1Free_e2ap_RICloadRequest (pctxt, &pvalue->ranFunctionLoadRequest);
   asn1Free_e2ap_RICserviceLoadRequest (pctxt, &pvalue->ricServiceLoadRequest);
   asn1Free_e2ap_RICsubscriptionLoadRequest_List (pctxt, &pvalue->ricSubscriptionLoadRequest_list);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RANfunctionLoadRequest_Item (const char* name, e2ap_RANfunctionLoadRequest_Item* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }
   if(asn1PrtToStr_e2ap_RANfunctionID ("ranFunctionID", &pvalue->ranFunctionID, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_RICloadRequest ("ranFunctionLoadRequest", &pvalue->ranFunctionLoadRequest, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_RICserviceLoadRequest ("ricServiceLoadRequest", &pvalue->ricServiceLoadRequest, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_RICsubscriptionLoadRequest_List ("ricSubscriptionLoadRequest_list", &pvalue->ricSubscriptionLoadRequest_list, buffer, bufSize) < 0)
   {
      return -1;
   }



   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           RANfunctionLoadRequest_ItemIEs                */
/*****************************************/
/* ie.c.j2 */
/*ie thường*/
int asn1PE_e2ap_RANfunctionLoadRequest_ItemIEs (OSCTXT* pctxt, e2ap_RANfunctionLoadRequest_ItemIEs* pvalue)
{
   int stat = 0;
   //RTXCTXTPUSHTYPENAME (pctxt, "RANfunctionLoadRequest-ItemIEs");

   /* encode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");
   stat = asn1PE_e2ap_ProtocolIE_ID (pctxt, pvalue->id);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");
   stat = asn1PE_e2ap_Criticality (pctxt, pvalue->criticality);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   {
      OSCTXT ictxt;
      OSOCTET* pDynamicEncodeBuffer;
      ASN1OpenType openType;
      OSBOOL  encoded = TRUE;

      openType.numocts = 0;
      openType.data = 0;

      rtxCopyContext (&ictxt, pctxt);
      pctxt->pStream = 0;

      stat = rtxInitContextBuffer (pctxt, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_RANfunctionLoadRequest_ItemIEs_id_RANfunctionLoadRequest_Item:
         
        // RTXCTXTPUSHELEMNAME (pctxt, "RANfunctionLoadRequest_ItemIEs_id_RANfunctionLoadRequest_Item");
         RTXCTXTPUSHELEMNAME (pctxt, "RANfunctionLoadRequest-Item");
         stat = asn1PE_e2ap_RANfunctionLoadRequest_Item (pctxt, pvalue->value.u._e2apRANfunctionLoadRequest_ItemIEs_id_RANfunctionLoadRequest_Item);
         RTXCTXTPOPELEMNAME (pctxt);
      
         break;

      case T_E2AP_PDU_Contents_e2ap_RANfunctionLoadRequest_ItemIEs_UNDEF_:
      {
          if(0!=pvalue->value.u.extElem1){
              openType.numocts = pvalue->value.u.extElem1->numocts;
              openType.data = pvalue->value.u.extElem1->data;
          } else {
              /* No extension element to encode */
          }
          encoded = FALSE;
          break;
      }
      default:
         encoded = FALSE;
         stat = RTERR_INVOPT;
      }

      if (encoded) {
         openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
         openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
      }
      rtxCopyContext (pctxt, &ictxt);
      if(stat ==0) stat = pe_OpenType(pctxt, openType.numocts, openType.data);
      /*free dynamic encode buffer*/
      if(encoded){
          rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
      }
   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);
   //RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

int asn1PD_e2ap_RANfunctionLoadRequest_ItemIEs (OSCTXT* pctxt, e2ap_RANfunctionLoadRequest_ItemIEs* pvalue)
{
   int stat =0;
   /*deode root element id*/
   RTXCTXTPUSHELEMNAME(pctxt, "id");
   stat = asn1PD_e2ap_ProtocolIE_ID (pctxt, &pvalue->id);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*decode root element criticality*/
   RTXCTXTPUSHELEMNAME(pctxt, "criticality");
   stat = asn1PD_e2ap_Criticality (pctxt, &pvalue->criticality);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   /*decode root element value*/
   RTXCTXTPUSHELEMNAME(pctxt, "value");
   {
      OSUINT32 openTypeLen;
      size_t bitStartOffset, bitLength;
      stat = pd_UnconsLength(pctxt, &openTypeLen);
      if(stat <0) return LOG_RTERR(pctxt, stat);
      else if(stat == RT_OK_FRAG){
         rtxErrAddStrParm(pctxt, "open type with fragmented length use - perindef");
         return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
      }
      bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
      bitLength = openTypeLen * 8;
      switch (pvalue->id){
         case T_E2AP_PDU_Contents_e2ap_RANfunctionLoadRequest_ItemIEs_id_RANfunctionLoadRequest_Item:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RANfunctionLoadRequest_ItemIEs_id_RANfunctionLoadRequest_Item;
            RTXCTXTPUSHELEMNAME(pctxt, "RANfunctionLoadRequest-Item");
            //pvalue->value.u._e2ap_RANfunctionLoadRequest_ItemIEs_id_id_RANfunctionLoadRequest_Item 
             pvalue->value.u._e2apRANfunctionLoadRequest_ItemIEs_id_RANfunctionLoadRequest_Item 
                    = rtxMemAllocType(pctxt, e2ap_RANfunctionLoadRequest_Item);
            //asn1Init_e2ap_RANfunctionLoadRequest_Item(pvalue->value.u._e2ap_RANfunctionLoadRequest_ItemIEs_id_id_RANfunctionLoadRequest_Item);
            asn1Init_e2ap_RANfunctionLoadRequest_Item(pvalue->value.u._e2apRANfunctionLoadRequest_ItemIEs_id_RANfunctionLoadRequest_Item);
            stat = asn1PD_e2ap_RANfunctionLoadRequest_Item (pctxt,
                    (e2ap_RANfunctionLoadRequest_Item*)pvalue->value.
                    u._e2apRANfunctionLoadRequest_ItemIEs_id_RANfunctionLoadRequest_Item);
            if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RANfunctionLoadRequest_ItemIEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*)rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
      }
      {
      size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
      size_t bitsConsumed = bitEndOffset - bitStartOffset;
      if(bitsConsumed < bitLength){
         stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
      } else {
         stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
      }
      }
   }
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   return stat;
}

void asn1Init_e2ap_RANfunctionLoadRequest_ItemIEs (e2ap_RANfunctionLoadRequest_ItemIEs* pvalue)
{
   if (!pvalue) return;
   OSCRTLMEMSET (pvalue, 0, sizeof(e2ap_RANfunctionLoadRequest_ItemIEs));
}

#if 0
void asn1Free_e2ap_RANfunctionLoadRequest_ItemIEs (OSCTXT* pctxt, e2ap_RANfunctionLoadRequest_ItemIEs* pvalue)
{
   if (!pvalue) return;
   if (pvalue->extElem1) {
      rtxMemFreeArray (pctxt, pvalue->extElem1);
      pvalue->extElem1 = 0;
      pvalue->extElem1_n = 0;
   }
}
#endif
void asn1Free_e2ap_RANfunctionLoadRequest_ItemIEs (OSCTXT* pctxt, e2ap_RANfunctionLoadRequest_ItemIEs* pvalue)
{
   if(0==pvalue) return;
   switch(pvalue->value.t){
      case T_E2AP_PDU_Contents_e2ap_RANfunctionLoadRequest_ItemIEs_id_RANfunctionLoadRequest_Item:
         asn1Free_e2ap_RANfunctionLoadRequest_Item (pctxt, pvalue->value.u._e2apRANfunctionLoadRequest_ItemIEs_id_RANfunctionLoadRequest_Item);
         rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2apRANfunctionLoadRequest_ItemIEs_id_RANfunctionLoadRequest_Item);
         pvalue->value.u._e2apRANfunctionLoadRequest_ItemIEs_id_RANfunctionLoadRequest_Item = 0;
         break;
      case T_E2AP_PDU_Contents_e2ap_RANfunctionLoadRequest_ItemIEs_UNDEF_:
         if(0!=pvalue->value.u.extElem1){
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1->data);
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
             pvalue->value.u.extElem1 =0;
         }
         break;
         default:;
   }
}

int  asn1PrtToStr_e2ap_RANfunctionLoadRequest_ItemIEs (const char * name, e2ap_RANfunctionLoadRequest_ItemIEs* pvalue, char * buffer, OSSIZE bufSize){
   if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
       return -1;

      if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
         return -1;

      if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
         return -1;
      if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
         return -1;
      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_RANfunctionLoadRequest_ItemIEs_id_RANfunctionLoadRequest_Item:
         if(asn1PrtToStr_e2ap_RANfunctionLoadRequest_Item("RANfunctionLoadRequest-Item",
                pvalue->value.u._e2apRANfunctionLoadRequest_ItemIEs_id_RANfunctionLoadRequest_Item, buffer, bufSize)<0)// dungnm23 check lai nhe xem la
            return -1;
         break;
      default:
         if(0!=pvalue -> value.u.extElem1){
             rtPrintToStringIndent(buffer, bufSize);
             rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

         }
      }
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

      return 0;

}
 

/*****************************************/
/*           RANfunctionLoadRequest_List                */
/*****************************************/
//seq_of_single_container


int asn1PE_e2ap_RANfunctionLoadRequest_List (OSCTXT* pctxt, e2ap_RANfunctionLoadRequest_List* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_RANfunctionLoadRequest_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "RANfunctionLoadRequest-List");

   /* encode length determinant */
   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(256), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;
   for (xx1 = 0; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next, xx1++) {
      pdata = (e2ap_RANfunctionLoadRequest_ItemIEs*) pnode->data;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_e2ap_RANfunctionLoadRequest_ItemIEs (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      //xx1++;
      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}

int asn1PD_e2ap_RANfunctionLoadRequest_List (OSCTXT* pctxt, e2ap_RANfunctionLoadRequest_List* ppvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_RANfunctionLoadRequest_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "RANfunctionLoadRequest-List");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(256), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (ppvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      pdata = rtxMemAllocType (pctxt, e2ap_RANfunctionLoadRequest_ItemIEs);
      if (!pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);
      asn1Init_e2ap_RANfunctionLoadRequest_ItemIEs (pdata);
      stat = asn1PD_e2ap_RANfunctionLoadRequest_ItemIEs (pctxt, pdata);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         return LOG_RTERR (pctxt, stat);
      }

      rtxDListAppendNode (ppvalue, pdata);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

void asn1Init_e2ap_RANfunctionLoadRequest_List (e2ap_RANfunctionLoadRequest_List* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
}

void asn1Free_e2ap_RANfunctionLoadRequest_List (OSCTXT* pctxt, e2ap_RANfunctionLoadRequest_List* pvalue)
{
   if(pvalue==0) return;
   OSRTDListNode* pnode = pvalue->head;
   while (pnode) {
      e2ap_RANfunctionLoadRequest_ItemIEs* pdata = (e2ap_RANfunctionLoadRequest_ItemIEs*) pnode->data;
      if (pdata) {
         asn1Free_e2ap_RANfunctionLoadRequest_ItemIEs (pctxt, pdata);
         rtxMemFreePtr (pctxt, pdata);
      }
      pnode = pnode->next;
   }
      rtxDListFreeAll(pctxt, pvalue);
}

#if 0
void asn1Free_e2ap_RANfunctionLoadRequest_List (OSCTXT* pctxt, e2ap_RANfunctionLoadRequest_List* pvalue){
   if(0==pvalue ) return;
   {
      e2ap_RANfunctionLoadRequest_ItemIEs * pdata;
      OSRTDListNode *pnode = pvalue->head;
      while(0!=pnode){
         pdata = (e2ap_RANfunctionLoadRequest_ItemIEs*)pnode->data;
         asn1Free_e2ap_RANfunctionLoadRequest_ItemIEs(pctxt, pdata);
         pnode = pnode->next;
      }
      rtxDListFreeAll(pctxt, pvalue);
   }
}
#endif


int asn1PrtToStr_e2ap_RANfunctionLoadRequest_List(const char* name, e2ap_RANfunctionLoadRequest_List* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_RANfunctionLoadRequest_ItemIEs* pdata;
    OSRTDListNode* pnode;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode = pvalue->head;  xx1 < pvalue->count && pnode != 0; pnode = pnode->next, xx1++){
        pdata = (e2ap_RANfunctionLoadRequest_ItemIEs*)pnode->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 1
        if(asn1PrtToStr_e2ap_RANfunctionLoadRequest_ItemIEs(nameBuf, pdata, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}/******************************************************/
/*                                                    */
/*    ReportingPeriodicity                          */
/*                                                    */
/******************************************************/
//enumerated


const OSEnumItem e2ap_ReportingPeriodicity_ENUMTAB[] = {
    { OSUTF8("ms500"), 0, 5, 0 },
    { OSUTF8("ms1000"), 1, 6, 1 },
    { OSUTF8("ms2000"), 2, 6, 2 },
    { OSUTF8("ms5000"), 3, 6, 3 },
    { OSUTF8("ms10000"), 4, 7, 4 }
};


const OSUTF8CHAR* e2ap_ReportingPeriodicity_ToString (OSUINT32 value){
   OSINT32 idx = value;
   if(idx >=0 && idx < e2ap_ReportingPeriodicity_ENUMTABSIZE){
      return e2ap_ReportingPeriodicity_ENUMTAB[e2ap_ReportingPeriodicity_ENUMTAB[idx].transidx].name;
   }else{
      return OSUTF8("_UNKNOWN_");
   }
}


int e2ap_ReportingPeriodicity_ToEnum (OSCTXT* pctxt, const OSUTF8CHAR* value,e2ap_ReportingPeriodicity* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes(value);
   return e2ap_ReportingPeriodicity_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int e2ap_ReportingPeriodicity_ToEnum2 (OSCTXT* pctxt, const OSUTF8CHAR* value, OSSIZE valueLen,e2ap_ReportingPeriodicity* pvalue)
{
   OSINT32 idx = rtxLookupEnum(value, valueLen,
      e2ap_ReportingPeriodicity_ENUMTAB, e2ap_ReportingPeriodicity_ENUMTABSIZE);
   if (idx >= 0) {
      *pvalue = (e2ap_ReportingPeriodicity)e2ap_ReportingPeriodicity_ENUMTAB[idx].value;
      return 0;
   } else {
      rtxErrAddIntParm (pctxt, (const char*)value);//dungnm23 check xem là Str hay Int
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_e2ap_ReportingPeriodicity (OSCTXT* pctxt, e2ap_ReportingPeriodicity value)
{
   int stat = 0;
   RTXCTXTPUSHTYPENAME (pctxt, "ReportingPeriodicity");
   if (value >= 5) {
      rtxErrAddIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(4));
   if(stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}

EXTERN int asn1PD_e2ap_ReportingPeriodicity (OSCTXT* pctxt, e2ap_ReportingPeriodicity* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ReportingPeriodicity");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(4));
   if(stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return stat;
}

EXTERN int asn1PrtToStr_e2ap_ReportingPeriodicity (const char* name, e2ap_ReportingPeriodicity* pvalue, char* buffer, OSSIZE bufSize)
{
   int stat;

   if(rtPrintToStringIndent(buffer, bufSize) < 0) return -1;
   if(rtPrintToString(name, buffer, bufSize) < 0) return -1;

   switch(*pvalue) {
      case 0:
         stat = rtPrintToString(" = ms500 \n", buffer, bufSize);
         break;
      case 1:
         stat = rtPrintToString(" = ms1000 \n", buffer, bufSize);
         break;
      case 2:
         stat = rtPrintToString(" = ms2000 \n", buffer, bufSize);
         break;
      case 3:
         stat = rtPrintToString(" = ms5000 \n", buffer, bufSize);
         break;
      case 4:
         stat = rtPrintToString(" = ms10000 \n", buffer, bufSize);
         break;
      default:
         stat = rtPrintToString(" = ???\n", buffer, bufSize);
   }

   if (stat < 0) return -1;
   return 0;

}

/*Init*/
EXTERN int asn1Init_e2ap_ReportingPeriodicity (e2ap_ReportingPeriodicity* pvalue){
      //if (pvalue == 0) return RTERR_NULLPTR;
      //*pvalue = 0;
      return 0;
}/*****************************************/
/*           RICserviceLoadStatusRequest_IEs                */
/*****************************************/
/* ie.c.j2 */
 /* d là con của msg */
EXTERN int asn1PE_e2ap_RICserviceLoadStatusRequest_protocolIEs_element (OSCTXT* pctxt, e2ap_RICserviceLoadStatusRequest_protocolIEs_element* pvalue)
{
    int stat =0;

    /*encode id*/

    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PE_e2ap_ProtocolIE_ID(pctxt, pvalue->id);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PE_e2ap_Criticality(pctxt, pvalue->criticality);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
    {
        OSCTXT lctxt;
        OSOCTET *pDynamicEncodeBuffer;
        ASN1OpenType openType;
        OSBOOL encoded = TRUE;

        openType.numocts = 0;
        openType.data =0;

        rtxCopyContext(&lctxt, pctxt);
        pctxt->pStream =0;

        stat = rtxInitContextBuffer(pctxt, 0, 0);
        if(stat!=0) return LOG_RTERR(pctxt, stat);

        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusRequest_IEs_id_RICloadMeasurementID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICloadMeasurementID");
                    stat = asn1PE_e2ap_LoadMeasurementID (pctxt, pvalue->value.u._e2ap_RICserviceLoadStatusRequest_IEs_id_RICloadMeasurementID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusRequest_IEs_id_E2nodeLoadMeasurementID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-E2nodeLoadMeasurementID");
                    stat = asn1PE_e2ap_LoadMeasurementID (pctxt, pvalue->value.u._e2ap_RICserviceLoadStatusRequest_IEs_id_E2nodeLoadMeasurementID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusRequest_IEs_id_RegistrationRequest:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RegistrationRequest");
                    stat = asn1PE_e2ap_RegistrationRequest (pctxt, pvalue->value.u._e2ap_RICserviceLoadStatusRequest_IEs_id_RegistrationRequest);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusRequest_IEs_id_RANfunctionLoadRequest_List:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RANfunctionLoadRequest-List");
                    stat = asn1PE_e2ap_RANfunctionLoadRequest_List (pctxt, pvalue->value.u._e2ap_RICserviceLoadStatusRequest_IEs_id_RANfunctionLoadRequest_List);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusRequest_IEs_id_ReportingPeriodicity:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-ReportingPeriodicity");
                    stat = asn1PE_e2ap_ReportingPeriodicity (pctxt, pvalue->value.u._e2ap_RICserviceLoadStatusRequest_IEs_id_ReportingPeriodicity);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusRequest_IEs_UNDEF_:
            {
                if(0!=pvalue->value.u.extElem1){
                    openType.numocts = pvalue->value.u.extElem1->numocts;
                    openType.data = pvalue->value.u.extElem1->data;
                } else {
                    /* No extension element to encode */
                }
                encoded = FALSE;
                break;
            }

            default:
                encoded = FALSE;
                stat = RTERR_INVOPT;
                break;
        } 

        if(encoded){
            openType.numocts = (OSUINT32)pe_GetMsgLen(pctxt);
            openType.data = pDynamicEncodeBuffer = pctxt -> buffer.data;
        }
        rtxCopyContext(pctxt, &lctxt);

        if(stat == 0) {
            stat = pe_OpenType (pctxt, openType.numocts, openType.data);
        }
    #if 1
        if(encoded){//dungnm23 check lai nhe
            rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
        }
    #endif

    }

    if(stat!=0) return LOG_RTERR(pctxt, stat);  
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}

EXTERN int  asn1PD_e2ap_RICserviceLoadStatusRequest_protocolIEs_element (OSCTXT* pctxt, e2ap_RICserviceLoadStatusRequest_protocolIEs_element* pvalue){
    int stat =0;

    /*decode id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PD_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PD_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");

    {
        OSUINT32 openTypeLen;
        size_t bitStartOffset, bitLength;

        stat = pd_UnconsLength(pctxt, &openTypeLen);
        if(stat<0) return LOG_RTERR(pctxt, stat);
        else if(stat == RT_OK_FRAG){
            rtxErrAddStrParm(pctxt, "open type with fragment length");
            return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
        }
        bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
        bitLength = openTypeLen * 8;

        switch(pvalue->id){//dungnm23 check case lai nhe
        
            case ASN1V_e2ap_id_RICloadMeasurementID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusRequest_IEs_id_RICloadMeasurementID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICloadMeasurementID");
                pvalue->value.u._e2ap_RICserviceLoadStatusRequest_IEs_id_RICloadMeasurementID 
                    = rtxMemAllocType(pctxt, e2ap_LoadMeasurementID);

                asn1Init_e2ap_LoadMeasurementID(pvalue->value.u._e2ap_RICserviceLoadStatusRequest_IEs_id_RICloadMeasurementID);

                stat = asn1PD_e2ap_LoadMeasurementID (pctxt,
                        (e2ap_LoadMeasurementID*)pvalue->value.
                        u._e2ap_RICserviceLoadStatusRequest_IEs_id_RICloadMeasurementID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_E2nodeLoadMeasurementID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusRequest_IEs_id_E2nodeLoadMeasurementID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-E2nodeLoadMeasurementID");
                pvalue->value.u._e2ap_RICserviceLoadStatusRequest_IEs_id_E2nodeLoadMeasurementID 
                    = rtxMemAllocType(pctxt, e2ap_LoadMeasurementID);

                asn1Init_e2ap_LoadMeasurementID(pvalue->value.u._e2ap_RICserviceLoadStatusRequest_IEs_id_E2nodeLoadMeasurementID);

                stat = asn1PD_e2ap_LoadMeasurementID (pctxt,
                        (e2ap_LoadMeasurementID*)pvalue->value.
                        u._e2ap_RICserviceLoadStatusRequest_IEs_id_E2nodeLoadMeasurementID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RegistrationRequest:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusRequest_IEs_id_RegistrationRequest;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RegistrationRequest");
                pvalue->value.u._e2ap_RICserviceLoadStatusRequest_IEs_id_RegistrationRequest 
                    = rtxMemAllocType(pctxt, e2ap_RegistrationRequest);

                asn1Init_e2ap_RegistrationRequest(pvalue->value.u._e2ap_RICserviceLoadStatusRequest_IEs_id_RegistrationRequest);

                stat = asn1PD_e2ap_RegistrationRequest (pctxt,
                        (e2ap_RegistrationRequest*)pvalue->value.
                        u._e2ap_RICserviceLoadStatusRequest_IEs_id_RegistrationRequest);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RANfunctionLoadRequest_List:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusRequest_IEs_id_RANfunctionLoadRequest_List;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RANfunctionLoadRequest-List");
                pvalue->value.u._e2ap_RICserviceLoadStatusRequest_IEs_id_RANfunctionLoadRequest_List 
                    = rtxMemAllocType(pctxt, e2ap_RANfunctionLoadRequest_List);

                asn1Init_e2ap_RANfunctionLoadRequest_List(pvalue->value.u._e2ap_RICserviceLoadStatusRequest_IEs_id_RANfunctionLoadRequest_List);

                stat = asn1PD_e2ap_RANfunctionLoadRequest_List (pctxt,
                        (e2ap_RANfunctionLoadRequest_List*)pvalue->value.
                        u._e2ap_RICserviceLoadStatusRequest_IEs_id_RANfunctionLoadRequest_List);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_ReportingPeriodicity:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusRequest_IEs_id_ReportingPeriodicity;
            RTXCTXTPUSHELEMNAME(pctxt, "id-ReportingPeriodicity");
                pvalue->value.u._e2ap_RICserviceLoadStatusRequest_IEs_id_ReportingPeriodicity 
                    = rtxMemAllocType(pctxt, e2ap_ReportingPeriodicity);

                asn1Init_e2ap_ReportingPeriodicity(pvalue->value.u._e2ap_RICserviceLoadStatusRequest_IEs_id_ReportingPeriodicity);

                stat = asn1PD_e2ap_ReportingPeriodicity (pctxt,
                        (e2ap_ReportingPeriodicity*)pvalue->value.
                        u._e2ap_RICserviceLoadStatusRequest_IEs_id_ReportingPeriodicity);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusRequest_IEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*) rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
    }
    {
    size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
    size_t bitsConsumed = bitEndOffset-bitStartOffset;
    if(bitsConsumed<bitLength){
        stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
    }
    else stat =(bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
    }}
    if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}


int asn1Init_e2ap_RICserviceLoadStatusRequest_protocolIEs_element(e2ap_RICserviceLoadStatusRequest_protocolIEs_element* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    OSCRTLMEMSET (&pvalue->value, 0, sizeof(pvalue->value));
    return 0;
}


//-----> chuaw có template rtxFreeASN1OpenType

#if 0
void asn1Free_e2ap_RICserviceLoadStatusRequest_protocolIEs_element(OSCTXT* pctxt, e2ap_RICserviceLoadStatusRequest_protocolIEs_element* pvalue)
{
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusRequest_IEs_id_id_RICloadMeasurementID:
            // rtxFreeE2ap_LoadMeasurementID(pvalue->value.u._e2ap_RICserviceLoadStatusRequest_IEs_id_id_RICloadMeasurementID);

            if(pvalue->value.i._e2ap_RICserviceLoadStatusRequest_id_LoadMeasurementID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_LoadMeasurementID(pctxt, pvalue->value.u._e2ap_RICserviceLoadStatusRequest_IEs_id_id_RICloadMeasurementID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICserviceLoadStatusRequest_IEs_id_id_RICloadMeasurementID);
           // pvalue->value.u._e2ap_RICserviceLoadStatusRequest_IEs_id_id_RICloadMeasurementID = NULL;
           pvalue->value.u._e2ap_RICserviceLoadStatusRequest_IEs_id_RICloadMeasurementID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusRequest_IEs_id_id_E2nodeLoadMeasurementID:
            // rtxFreeE2ap_LoadMeasurementID(pvalue->value.u._e2ap_RICserviceLoadStatusRequest_IEs_id_id_E2nodeLoadMeasurementID);

            if(pvalue->value.i._e2ap_RICserviceLoadStatusRequest_id_LoadMeasurementID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_LoadMeasurementID(pctxt, pvalue->value.u._e2ap_RICserviceLoadStatusRequest_IEs_id_id_E2nodeLoadMeasurementID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICserviceLoadStatusRequest_IEs_id_id_E2nodeLoadMeasurementID);
           // pvalue->value.u._e2ap_RICserviceLoadStatusRequest_IEs_id_id_E2nodeLoadMeasurementID = NULL;
           pvalue->value.u._e2ap_RICserviceLoadStatusRequest_IEs_id_E2nodeLoadMeasurementID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusRequest_IEs_id_id_RegistrationRequest:
            // rtxFreeE2ap_RegistrationRequest(pvalue->value.u._e2ap_RICserviceLoadStatusRequest_IEs_id_id_RegistrationRequest);

            if(pvalue->value.i._e2ap_RICserviceLoadStatusRequest_id_RegistrationRequest!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RegistrationRequest(pctxt, pvalue->value.u._e2ap_RICserviceLoadStatusRequest_IEs_id_id_RegistrationRequest);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICserviceLoadStatusRequest_IEs_id_id_RegistrationRequest);
           // pvalue->value.u._e2ap_RICserviceLoadStatusRequest_IEs_id_id_RegistrationRequest = NULL;
           pvalue->value.u._e2ap_RICserviceLoadStatusRequest_IEs_id_RegistrationRequest = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusRequest_IEs_id_id_RANfunctionLoadRequest_List:
            // rtxFreeE2ap_RANfunctionLoadRequest_List(pvalue->value.u._e2ap_RICserviceLoadStatusRequest_IEs_id_id_RANfunctionLoadRequest_List);

            if(pvalue->value.i._e2ap_RICserviceLoadStatusRequest_id_RANfunctionLoadRequest_List!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RANfunctionLoadRequest_List(pctxt, pvalue->value.u._e2ap_RICserviceLoadStatusRequest_IEs_id_id_RANfunctionLoadRequest_List);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICserviceLoadStatusRequest_IEs_id_id_RANfunctionLoadRequest_List);
           // pvalue->value.u._e2ap_RICserviceLoadStatusRequest_IEs_id_id_RANfunctionLoadRequest_List = NULL;
           pvalue->value.u._e2ap_RICserviceLoadStatusRequest_IEs_id_RANfunctionLoadRequest_List = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusRequest_IEs_id_id_ReportingPeriodicity:
            // rtxFreeE2ap_ReportingPeriodicity(pvalue->value.u._e2ap_RICserviceLoadStatusRequest_IEs_id_id_ReportingPeriodicity);

            if(pvalue->value.i._e2ap_RICserviceLoadStatusRequest_id_ReportingPeriodicity!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_ReportingPeriodicity(pctxt, pvalue->value.u._e2ap_RICserviceLoadStatusRequest_IEs_id_id_ReportingPeriodicity);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICserviceLoadStatusRequest_IEs_id_id_ReportingPeriodicity);
           // pvalue->value.u._e2ap_RICserviceLoadStatusRequest_IEs_id_id_ReportingPeriodicity = NULL;
           pvalue->value.u._e2ap_RICserviceLoadStatusRequest_IEs_id_ReportingPeriodicity = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusRequest_IEs_UNDEF_:
            rtxFreeASN1OpenType(pvalue->value.u.extElem1);
            break;
        default:
            break;
    }
}

int asn1PrtToStr_e2ap_RICserviceLoadStatusRequest_protocolIEs_element(OSCTXT* pctxt, e2ap_RICserviceLoadStatusRequest_protocolIEs_element* pvalue)
{
    int stat =0;
    RTXCTXTPUSHELEMNAME(pctxt, "e2ap_RICserviceLoadStatusRequest_protocolIEs_element");

    /*print id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PrtToStr_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PrtToStr_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusRequest_IEs_id_id_RICloadMeasurementID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "LoadMeasurementID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_LoadMeasurementID (pctxt, pvalue->value.u._e2ap_RICserviceLoadStatusRequest_IEs_id_id_RICloadMeasurementID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusRequest_IEs_id_id_E2nodeLoadMeasurementID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "LoadMeasurementID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_LoadMeasurementID (pctxt, pvalue->value.u._e2ap_RICserviceLoadStatusRequest_IEs_id_id_E2nodeLoadMeasurementID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusRequest_IEs_id_id_RegistrationRequest:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RegistrationRequest");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RegistrationRequest (pctxt, pvalue->value.u._e2ap_RICserviceLoadStatusRequest_IEs_id_id_RegistrationRequest);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusRequest_IEs_id_id_RANfunctionLoadRequest_List:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RANfunctionLoadRequest-List");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RANfunctionLoadRequest_List (pctxt, pvalue->value.u._e2ap_RICserviceLoadStatusRequest_IEs_id_id_RANfunctionLoadRequest_List);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusRequest_IEs_id_id_ReportingPeriodicity:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "ReportingPeriodicity");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_ReportingPeriodicity (pctxt, pvalue->value.u._e2ap_RICserviceLoadStatusRequest_IEs_id_id_ReportingPeriodicity);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusRequest_IEs_UNDEF_:
            {
                rtxPLogMsg(pctxt, "Extension element present - raw data not printed.\n");
                break;
            }

            default:
                stat = RTERR_INVOPT;
                return LOG_RTERR(pctxt, stat);
        }
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);
}
#endif


int asn1PrtToStr_e2ap_RICserviceLoadStatusRequest_protocolIEs_element (const char * name,
 e2ap_RICserviceLoadStatusRequest_protocolIEs_element* pvalue, 
 char * buffer, OSSIZE bufSize){
    if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
        return -1;
    if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
        return -1;

    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusRequest_IEs_id_RICloadMeasurementID:
            if(asn1PrtToStr_e2ap_LoadMeasurementID("LoadMeasurementID", 
                    pvalue->value.u._e2ap_RICserviceLoadStatusRequest_IEs_id_RICloadMeasurementID, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusRequest_IEs_id_E2nodeLoadMeasurementID:
            if(asn1PrtToStr_e2ap_LoadMeasurementID("LoadMeasurementID", 
                    pvalue->value.u._e2ap_RICserviceLoadStatusRequest_IEs_id_E2nodeLoadMeasurementID, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusRequest_IEs_id_RegistrationRequest:
            if(asn1PrtToStr_e2ap_RegistrationRequest("RegistrationRequest", 
                    pvalue->value.u._e2ap_RICserviceLoadStatusRequest_IEs_id_RegistrationRequest, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusRequest_IEs_id_RANfunctionLoadRequest_List:
            if(asn1PrtToStr_e2ap_RANfunctionLoadRequest_List("RANfunctionLoadRequest-List", 
                    pvalue->value.u._e2ap_RICserviceLoadStatusRequest_IEs_id_RANfunctionLoadRequest_List, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusRequest_IEs_id_ReportingPeriodicity:
            if(asn1PrtToStr_e2ap_ReportingPeriodicity("ReportingPeriodicity", 
                    pvalue->value.u._e2ap_RICserviceLoadStatusRequest_IEs_id_ReportingPeriodicity, buffer, bufSize)<0)
                return -1;
            break;    
        default:
        if(0!=pvalue -> value.u.extElem1){
            rtPrintToStringIndent(buffer, bufSize);
            rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

        }
        }
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

    return 0;

 }

 void asn1Free_e2ap_RICserviceLoadStatusRequest_protocolIEs_element(OSCTXT* pctxt, e2ap_RICserviceLoadStatusRequest_protocolIEs_element* pvalue){
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusRequest_IEs_id_RICloadMeasurementID:
            if(pvalue->value.u._e2ap_RICserviceLoadStatusRequest_IEs_id_RICloadMeasurementID!=NULL){
            asn1Free_e2ap_LoadMeasurementID(pctxt, pvalue->value.u._e2ap_RICserviceLoadStatusRequest_IEs_id_RICloadMeasurementID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICserviceLoadStatusRequest_IEs_id_RICloadMeasurementID);
            pvalue->value.u._e2ap_RICserviceLoadStatusRequest_IEs_id_RICloadMeasurementID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusRequest_IEs_id_E2nodeLoadMeasurementID:
            if(pvalue->value.u._e2ap_RICserviceLoadStatusRequest_IEs_id_E2nodeLoadMeasurementID!=NULL){
            asn1Free_e2ap_LoadMeasurementID(pctxt, pvalue->value.u._e2ap_RICserviceLoadStatusRequest_IEs_id_E2nodeLoadMeasurementID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICserviceLoadStatusRequest_IEs_id_E2nodeLoadMeasurementID);
            pvalue->value.u._e2ap_RICserviceLoadStatusRequest_IEs_id_E2nodeLoadMeasurementID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusRequest_IEs_id_RegistrationRequest:
            if(pvalue->value.u._e2ap_RICserviceLoadStatusRequest_IEs_id_RegistrationRequest!=NULL){
            asn1Free_e2ap_RegistrationRequest(pctxt, pvalue->value.u._e2ap_RICserviceLoadStatusRequest_IEs_id_RegistrationRequest);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICserviceLoadStatusRequest_IEs_id_RegistrationRequest);
            pvalue->value.u._e2ap_RICserviceLoadStatusRequest_IEs_id_RegistrationRequest = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusRequest_IEs_id_RANfunctionLoadRequest_List:
            if(pvalue->value.u._e2ap_RICserviceLoadStatusRequest_IEs_id_RANfunctionLoadRequest_List!=NULL){
            asn1Free_e2ap_RANfunctionLoadRequest_List(pctxt, pvalue->value.u._e2ap_RICserviceLoadStatusRequest_IEs_id_RANfunctionLoadRequest_List);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICserviceLoadStatusRequest_IEs_id_RANfunctionLoadRequest_List);
            pvalue->value.u._e2ap_RICserviceLoadStatusRequest_IEs_id_RANfunctionLoadRequest_List = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusRequest_IEs_id_ReportingPeriodicity:
            if(pvalue->value.u._e2ap_RICserviceLoadStatusRequest_IEs_id_ReportingPeriodicity!=NULL){
            asn1Free_e2ap_ReportingPeriodicity(pctxt, pvalue->value.u._e2ap_RICserviceLoadStatusRequest_IEs_id_ReportingPeriodicity);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICserviceLoadStatusRequest_IEs_id_ReportingPeriodicity);
            pvalue->value.u._e2ap_RICserviceLoadStatusRequest_IEs_id_ReportingPeriodicity = NULL;
            }
            break;
        default:
            break;


    }
 }

 

/*****************************************/
/*           RICserviceLoadStatusRequest                */
/*****************************************/
//2_container.c
/* 1. xxx_ProtocolIE -> mẫu cũ ở ie_big_msg */
EXTERN int asn1PE_e2ap_RICserviceLoadStatusRequest_protocolIEs (OSCTXT* pctxt, e2ap_RICserviceLoadStatusRequest_protocolIEs* pvalue)
{
    int stat =0;
    OSRTDListNode* pnode;
    OSUINT32 xx1;

    /*encode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pe_Length(pctxt, pvalue->count);
    if(stat<0) return LOG_RTERR(pctxt, stat);

    /*encode each element*/
    xx1 =0;
    for(pnode = pvalue->head; pnode != 0 && xx1<pvalue->count; pnode = pnode->next){
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE", xx1);
        stat = asn1PE_e2ap_RICserviceLoadStatusRequest_protocolIEs_element (pctxt, ((e2ap_RICserviceLoadStatusRequest_protocolIEs_element*)pnode->data));
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        xx1++;
        RTXCTXTPOPARRAYELEMNAME(pctxt);
    }

    return (stat);
}

EXTERN int  asn1PD_e2ap_RICserviceLoadStatusRequest_protocolIEs(OSCTXT* pctxt, e2ap_RICserviceLoadStatusRequest_protocolIEs* pvalue)
{
     int stat =0;
     OSRTDListNode* pnode;
     OSSIZE count =0;
     OSSIZE xx1=0;


     /*decode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pd_Length64(pctxt, &count); //tai sao lai 64
    if(stat!=0) return LOG_RTERR(pctxt, stat);

    /*decode each element*/
    rtxDListInit(pvalue);

    for(xx1=0; xx1 < count; xx1++){
        e2ap_RICserviceLoadStatusRequest_protocolIEs_element* pdata;
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE",xx1);

        if(pnode == NULL) return LOG_RTERR(pctxt, RTERR_NOMEM);

        asn1Init_e2ap_RICserviceLoadStatusRequest_protocolIEs_element(pdata);
        rtxDListAppendNode(pvalue, pnode);
        stat = asn1PD_e2ap_RICserviceLoadStatusRequest_protocolIEs_element (pctxt, pdata);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        RTXCTXTPOPARRAYELEMNAME(pctxt);

    }
    return (stat);
}


int asn1Init_e2ap_RICserviceLoadStatusRequest_protocolIEs(e2ap_RICserviceLoadStatusRequest_protocolIEs* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    rtxDListFastInit (pvalue);
    return 0;
}
#if 1 //ao that day
void asn1Free_e2ap_RICserviceLoadStatusRequest_protocolIEs(OSCTXT* pctxt, e2ap_RICserviceLoadStatusRequest_protocolIEs* pvalue)
{
    if(0==pvalue) return;   
    e2ap_RICserviceLoadStatusRequest_protocolIEs_element* pdata;
    OSRTDListNode* pnode=pvalue->head;
    while(0!=pnode){
        pdata = (e2ap_RICserviceLoadStatusRequest_protocolIEs_element*)pnode->data;
       // asn1Free_e2ap_RICserviceLoadStatusRequest_protocolIEs_element(pctxt, pdata);
        pnode = pnode->next;
    }
    rtxDListFreeAll(pctxt, pvalue);
}
#endif


EXTERN int asn1PrtToStr_e2ap_RICserviceLoadStatusRequest_protocolIEs(const char* name, e2ap_RICserviceLoadStatusRequest_protocolIEs* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_RICserviceLoadStatusRequest_protocolIEs_element* pdata0;
    OSRTDListNode* pnode0;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode0 = pvalue->head;  xx1 < pvalue->count && pnode0 != 0; pnode0 = pnode0->next, xx1++){
        pdata0 = (e2ap_RICserviceLoadStatusRequest_protocolIEs_element*)pnode0->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 0
        if(asn1PrtToStr_e2ap_RICserviceLoadStatusRequest_protocolIEs_element(nameBuf, pdata0, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}


/*2 . RICserviceLoadStatusRequest -> mẫu cũ ở seq_normal*/

int asn1PE_e2ap_RICserviceLoadStatusRequest (OSCTXT* pctxt, e2ap_RICserviceLoadStatusRequest* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RICserviceLoadStatusRequest");
   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field protocolIEs - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
   stat = asn1PE_e2ap_RICserviceLoadStatusRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if(stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RICserviceLoadStatusRequest (OSCTXT* pctxt, e2ap_RICserviceLoadStatusRequest* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME(pctxt, "RICserviceLoadStatusRequest");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field protocolIEs */
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
      stat = asn1PD_e2ap_RICserviceLoadStatusRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RICserviceLoadStatusRequest (e2ap_RICserviceLoadStatusRequest* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RICserviceLoadStatusRequest_protocolIEs(&pvalue->protocolIEs);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RICserviceLoadStatusRequest (OSCTXT* pctxt, e2ap_RICserviceLoadStatusRequest* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_RICserviceLoadStatusRequest_protocolIEs(pctxt, &pvalue->protocolIEs);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RICserviceLoadStatusRequest (const char* name, e2ap_RICserviceLoadStatusRequest* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }

   if(asn1PrtToStr_e2ap_RICserviceLoadStatusRequest_protocolIEs("protocolIEs", &pvalue->protocolIEs, buffer, bufSize) <0){
      return -1;
   }

   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/******************************************************/
/*                                                    */
/*    RICloadConfirm                          */
/*                                                    */
/******************************************************/
//enumerated


const OSEnumItem e2ap_RICloadConfirm_ENUMTAB[] = {
    { OSUTF8("true"), 0, 4, 0 }
};


const OSUTF8CHAR* e2ap_RICloadConfirm_ToString (OSUINT32 value){
   OSINT32 idx = value;
   if(idx >=0 && idx < e2ap_RICloadConfirm_ENUMTABSIZE){
      return e2ap_RICloadConfirm_ENUMTAB[e2ap_RICloadConfirm_ENUMTAB[idx].transidx].name;
   }else{
      return OSUTF8("_UNKNOWN_");
   }
}


int e2ap_RICloadConfirm_ToEnum (OSCTXT* pctxt, const OSUTF8CHAR* value,e2ap_RICloadConfirm* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes(value);
   return e2ap_RICloadConfirm_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int e2ap_RICloadConfirm_ToEnum2 (OSCTXT* pctxt, const OSUTF8CHAR* value, OSSIZE valueLen,e2ap_RICloadConfirm* pvalue)
{
   OSINT32 idx = rtxLookupEnum(value, valueLen,
      e2ap_RICloadConfirm_ENUMTAB, e2ap_RICloadConfirm_ENUMTABSIZE);
   if (idx >= 0) {
      *pvalue = (e2ap_RICloadConfirm)e2ap_RICloadConfirm_ENUMTAB[idx].value;
      return 0;
   } else {
      rtxErrAddIntParm (pctxt, (const char*)value);//dungnm23 check xem là Str hay Int
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_e2ap_RICloadConfirm (OSCTXT* pctxt, e2ap_RICloadConfirm value)
{
   int stat = 0;
   RTXCTXTPUSHTYPENAME (pctxt, "RICloadConfirm");
   if (value >= 1) {
      rtxErrAddIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(0));
   if(stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}

EXTERN int asn1PD_e2ap_RICloadConfirm (OSCTXT* pctxt, e2ap_RICloadConfirm* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RICloadConfirm");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(0));
   if(stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return stat;
}

EXTERN int asn1PrtToStr_e2ap_RICloadConfirm (const char* name, e2ap_RICloadConfirm* pvalue, char* buffer, OSSIZE bufSize)
{
   int stat;

   if(rtPrintToStringIndent(buffer, bufSize) < 0) return -1;
   if(rtPrintToString(name, buffer, bufSize) < 0) return -1;

   switch(*pvalue) {
      case 0:
         stat = rtPrintToString(" = true \n", buffer, bufSize);
         break;
      default:
         stat = rtPrintToString(" = ???\n", buffer, bufSize);
   }

   if (stat < 0) return -1;
   return 0;

}

/*Init*/
EXTERN int asn1Init_e2ap_RICloadConfirm (e2ap_RICloadConfirm* pvalue){
      //if (pvalue == 0) return RTERR_NULLPTR;
      //*pvalue = 0;
      return 0;
}
/*****************************************/
/*           RICserviceLoadConfirm                */
/*****************************************/
//sequence normal
// Các nội dung cần thiết cho template seq_normal.c.j2

// Các phần còn lại của template seq_normal.c.j2
//contain extensition bit -> theo mau cua GlobalgNB-ID
int asn1PE_e2ap_RICserviceLoadConfirm (OSCTXT* pctxt, e2ap_RICserviceLoadConfirm* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RICserviceLoadConfirm");

   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);

   /*optional bit for field ricServiceReportLoadConfirm*/
   stat = rtxEncBit (pctxt, pvalue->m_ricServiceReportLoadConfirmPresent);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   /*optional bit for field ricServiceInsertLoadConfirm*/
   stat = rtxEncBit (pctxt, pvalue->m_ricServiceInsertLoadConfirmPresent);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   /*optional bit for field ricServiceControlLoadConfirm*/
   stat = rtxEncBit (pctxt, pvalue->m_ricServiceControlLoadConfirmPresent);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   /*optional bit for field ricServicePolicyLoadConfirm*/
   stat = rtxEncBit (pctxt, pvalue->m_ricServicePolicyLoadConfirmPresent);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   /*optional bit for field ricServiceQueryLoadConfirm*/
   stat = rtxEncBit (pctxt, pvalue->m_ricServiceQueryLoadConfirmPresent);
   if (stat != 0) return LOG_RTERR(pctxt, stat);

   /*encode root elements*/   
   /* encode field ricServiceReportLoadConfirm - id = -1*/  
   if (pvalue->m_ricServiceReportLoadConfirmPresent) {//OPTIONAL FIELD
   RTXCTXTPUSHELEMNAME(pctxt, "ricServiceReportLoadConfirm");
   stat = asn1PE_e2ap_RICloadConfirm (pctxt, pvalue->ricServiceReportLoadConfirm);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   }

   /* encode field ricServiceInsertLoadConfirm - id = -1*/  
   if (pvalue->m_ricServiceInsertLoadConfirmPresent) {//OPTIONAL FIELD
   RTXCTXTPUSHELEMNAME(pctxt, "ricServiceInsertLoadConfirm");
   stat = asn1PE_e2ap_RICloadConfirm (pctxt, pvalue->ricServiceInsertLoadConfirm);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   }

   /* encode field ricServiceControlLoadConfirm - id = -1*/  
   if (pvalue->m_ricServiceControlLoadConfirmPresent) {//OPTIONAL FIELD
   RTXCTXTPUSHELEMNAME(pctxt, "ricServiceControlLoadConfirm");
   stat = asn1PE_e2ap_RICloadConfirm (pctxt, pvalue->ricServiceControlLoadConfirm);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   }

   /* encode field ricServicePolicyLoadConfirm - id = -1*/  
   if (pvalue->m_ricServicePolicyLoadConfirmPresent) {//OPTIONAL FIELD
   RTXCTXTPUSHELEMNAME(pctxt, "ricServicePolicyLoadConfirm");
   stat = asn1PE_e2ap_RICloadConfirm (pctxt, pvalue->ricServicePolicyLoadConfirm);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   }

   /* encode field ricServiceQueryLoadConfirm - id = -1*/  
   if (pvalue->m_ricServiceQueryLoadConfirmPresent) {//OPTIONAL FIELD
   RTXCTXTPUSHELEMNAME(pctxt, "ricServiceQueryLoadConfirm");
   stat = asn1PE_e2ap_RICloadConfirm (pctxt, pvalue->ricServiceQueryLoadConfirm);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   }


   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RICserviceLoadConfirm (OSCTXT* pctxt, e2ap_RICserviceLoadConfirm* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[5];

   RTXCTXTPUSHTYPENAME(pctxt, "RICserviceLoadConfirm");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 5; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field ricServiceReportLoadConfirm */
   RTXCTXTPUSHELEMNAME(pctxt, "ricServiceReportLoadConfirm");
   if (optbits[0]) {
      pvalue->m_ricServiceReportLoadConfirmPresent = TRUE;
      stat = asn1PD_e2ap_RICloadConfirm (pctxt, &pvalue->ricServiceReportLoadConfirm);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   } else {
      pvalue->m_ricServiceReportLoadConfirmPresent = FALSE;
   }
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field ricServiceInsertLoadConfirm */
   RTXCTXTPUSHELEMNAME(pctxt, "ricServiceInsertLoadConfirm");
   if (optbits[0]) {
      pvalue->m_ricServiceInsertLoadConfirmPresent = TRUE;
      stat = asn1PD_e2ap_RICloadConfirm (pctxt, &pvalue->ricServiceInsertLoadConfirm);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   } else {
      pvalue->m_ricServiceInsertLoadConfirmPresent = FALSE;
   }
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field ricServiceControlLoadConfirm */
   RTXCTXTPUSHELEMNAME(pctxt, "ricServiceControlLoadConfirm");
   if (optbits[0]) {
      pvalue->m_ricServiceControlLoadConfirmPresent = TRUE;
      stat = asn1PD_e2ap_RICloadConfirm (pctxt, &pvalue->ricServiceControlLoadConfirm);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   } else {
      pvalue->m_ricServiceControlLoadConfirmPresent = FALSE;
   }
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field ricServicePolicyLoadConfirm */
   RTXCTXTPUSHELEMNAME(pctxt, "ricServicePolicyLoadConfirm");
   if (optbits[0]) {
      pvalue->m_ricServicePolicyLoadConfirmPresent = TRUE;
      stat = asn1PD_e2ap_RICloadConfirm (pctxt, &pvalue->ricServicePolicyLoadConfirm);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   } else {
      pvalue->m_ricServicePolicyLoadConfirmPresent = FALSE;
   }
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field ricServiceQueryLoadConfirm */
   RTXCTXTPUSHELEMNAME(pctxt, "ricServiceQueryLoadConfirm");
   if (optbits[0]) {
      pvalue->m_ricServiceQueryLoadConfirmPresent = TRUE;
      stat = asn1PD_e2ap_RICloadConfirm (pctxt, &pvalue->ricServiceQueryLoadConfirm);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   } else {
      pvalue->m_ricServiceQueryLoadConfirmPresent = FALSE;
   }
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RICserviceLoadConfirm (e2ap_RICserviceLoadConfirm* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RICloadConfirm (&pvalue->ricServiceReportLoadConfirm);
   asn1Init_e2ap_RICloadConfirm (&pvalue->ricServiceInsertLoadConfirm);
   asn1Init_e2ap_RICloadConfirm (&pvalue->ricServiceControlLoadConfirm);
   asn1Init_e2ap_RICloadConfirm (&pvalue->ricServicePolicyLoadConfirm);
   asn1Init_e2ap_RICloadConfirm (&pvalue->ricServiceQueryLoadConfirm);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RICserviceLoadConfirm (OSCTXT* pctxt, e2ap_RICserviceLoadConfirm* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_RICloadConfirm (pctxt, &pvalue->ricServiceReportLoadConfirm);
   asn1Free_e2ap_RICloadConfirm (pctxt, &pvalue->ricServiceInsertLoadConfirm);
   asn1Free_e2ap_RICloadConfirm (pctxt, &pvalue->ricServiceControlLoadConfirm);
   asn1Free_e2ap_RICloadConfirm (pctxt, &pvalue->ricServicePolicyLoadConfirm);
   asn1Free_e2ap_RICloadConfirm (pctxt, &pvalue->ricServiceQueryLoadConfirm);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RICserviceLoadConfirm (const char* name, e2ap_RICserviceLoadConfirm* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }
   if(asn1PrtToStr_e2ap_RICloadConfirm ("ricServiceReportLoadConfirm", &pvalue->ricServiceReportLoadConfirm, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_RICloadConfirm ("ricServiceInsertLoadConfirm", &pvalue->ricServiceInsertLoadConfirm, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_RICloadConfirm ("ricServiceControlLoadConfirm", &pvalue->ricServiceControlLoadConfirm, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_RICloadConfirm ("ricServicePolicyLoadConfirm", &pvalue->ricServicePolicyLoadConfirm, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_RICloadConfirm ("ricServiceQueryLoadConfirm", &pvalue->ricServiceQueryLoadConfirm, buffer, bufSize) < 0)
   {
      return -1;
   }



   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}
/*****************************************/
/*           RICactionLoadConfirm-Item                */
/*****************************************/
//sequence normal
// Các nội dung cần thiết cho template seq_normal.c.j2

// Các phần còn lại của template seq_normal.c.j2
//contain extensition bit -> theo mau cua GlobalgNB-ID
int asn1PE_e2ap_RICactionLoadConfirm_Item (OSCTXT* pctxt, e2ap_RICactionLoadConfirm_Item* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RICactionLoadConfirm-Item");

   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field ricActionID - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "ricActionID");
   stat = asn1PE_e2ap_RICactionID (pctxt, pvalue->ricActionID);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /* encode field ricActionLoadConfirm - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "ricActionLoadConfirm");
   stat = asn1PE_e2ap_RICloadConfirm (pctxt, pvalue->ricActionLoadConfirm);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);



   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RICactionLoadConfirm_Item (OSCTXT* pctxt, e2ap_RICactionLoadConfirm_Item* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME(pctxt, "RICactionLoadConfirm-Item");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field ricActionID */
   RTXCTXTPUSHELEMNAME(pctxt, "ricActionID");
      stat = asn1PD_e2ap_RICactionID (pctxt, &pvalue->ricActionID);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field ricActionLoadConfirm */
   RTXCTXTPUSHELEMNAME(pctxt, "ricActionLoadConfirm");
      stat = asn1PD_e2ap_RICloadConfirm (pctxt, &pvalue->ricActionLoadConfirm);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RICactionLoadConfirm_Item (e2ap_RICactionLoadConfirm_Item* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RICactionID (&pvalue->ricActionID);
   asn1Init_e2ap_RICloadConfirm (&pvalue->ricActionLoadConfirm);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RICactionLoadConfirm_Item (OSCTXT* pctxt, e2ap_RICactionLoadConfirm_Item* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_RICactionID (pctxt, &pvalue->ricActionID);
   asn1Free_e2ap_RICloadConfirm (pctxt, &pvalue->ricActionLoadConfirm);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RICactionLoadConfirm_Item (const char* name, e2ap_RICactionLoadConfirm_Item* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }
   if(asn1PrtToStr_e2ap_RICactionID ("ricActionID", &pvalue->ricActionID, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_RICloadConfirm ("ricActionLoadConfirm", &pvalue->ricActionLoadConfirm, buffer, bufSize) < 0)
   {
      return -1;
   }



   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           RICactionLoadConfirm_ItemIEs                */
/*****************************************/
/* ie.c.j2 */
/*ie thường*/
int asn1PE_e2ap_RICactionLoadConfirm_ItemIEs (OSCTXT* pctxt, e2ap_RICactionLoadConfirm_ItemIEs* pvalue)
{
   int stat = 0;
   //RTXCTXTPUSHTYPENAME (pctxt, "RICactionLoadConfirm-ItemIEs");

   /* encode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");
   stat = asn1PE_e2ap_ProtocolIE_ID (pctxt, pvalue->id);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");
   stat = asn1PE_e2ap_Criticality (pctxt, pvalue->criticality);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   {
      OSCTXT ictxt;
      OSOCTET* pDynamicEncodeBuffer;
      ASN1OpenType openType;
      OSBOOL  encoded = TRUE;

      openType.numocts = 0;
      openType.data = 0;

      rtxCopyContext (&ictxt, pctxt);
      pctxt->pStream = 0;

      stat = rtxInitContextBuffer (pctxt, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_RICactionLoadConfirm_ItemIEs_id_RICactionLoadConfirm_Item:
         
        // RTXCTXTPUSHELEMNAME (pctxt, "RICactionLoadConfirm_ItemIEs_id_RICactionLoadConfirm_Item");
         RTXCTXTPUSHELEMNAME (pctxt, "RICactionLoadConfirm-Item");
         stat = asn1PE_e2ap_RICactionLoadConfirm_Item (pctxt, pvalue->value.u._e2apRICactionLoadConfirm_ItemIEs_id_RICactionLoadConfirm_Item);
         RTXCTXTPOPELEMNAME (pctxt);
      
         break;

      case T_E2AP_PDU_Contents_e2ap_RICactionLoadConfirm_ItemIEs_UNDEF_:
      {
          if(0!=pvalue->value.u.extElem1){
              openType.numocts = pvalue->value.u.extElem1->numocts;
              openType.data = pvalue->value.u.extElem1->data;
          } else {
              /* No extension element to encode */
          }
          encoded = FALSE;
          break;
      }
      default:
         encoded = FALSE;
         stat = RTERR_INVOPT;
      }

      if (encoded) {
         openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
         openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
      }
      rtxCopyContext (pctxt, &ictxt);
      if(stat ==0) stat = pe_OpenType(pctxt, openType.numocts, openType.data);
      /*free dynamic encode buffer*/
      if(encoded){
          rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
      }
   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);
   //RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

int asn1PD_e2ap_RICactionLoadConfirm_ItemIEs (OSCTXT* pctxt, e2ap_RICactionLoadConfirm_ItemIEs* pvalue)
{
   int stat =0;
   /*deode root element id*/
   RTXCTXTPUSHELEMNAME(pctxt, "id");
   stat = asn1PD_e2ap_ProtocolIE_ID (pctxt, &pvalue->id);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*decode root element criticality*/
   RTXCTXTPUSHELEMNAME(pctxt, "criticality");
   stat = asn1PD_e2ap_Criticality (pctxt, &pvalue->criticality);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   /*decode root element value*/
   RTXCTXTPUSHELEMNAME(pctxt, "value");
   {
      OSUINT32 openTypeLen;
      size_t bitStartOffset, bitLength;
      stat = pd_UnconsLength(pctxt, &openTypeLen);
      if(stat <0) return LOG_RTERR(pctxt, stat);
      else if(stat == RT_OK_FRAG){
         rtxErrAddStrParm(pctxt, "open type with fragmented length use - perindef");
         return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
      }
      bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
      bitLength = openTypeLen * 8;
      switch (pvalue->id){
         case T_E2AP_PDU_Contents_e2ap_RICactionLoadConfirm_ItemIEs_id_RICactionLoadConfirm_Item:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICactionLoadConfirm_ItemIEs_id_RICactionLoadConfirm_Item;
            RTXCTXTPUSHELEMNAME(pctxt, "RICactionLoadConfirm-Item");
            //pvalue->value.u._e2ap_RICactionLoadConfirm_ItemIEs_id_id_RICactionLoadConfirm_Item 
             pvalue->value.u._e2apRICactionLoadConfirm_ItemIEs_id_RICactionLoadConfirm_Item 
                    = rtxMemAllocType(pctxt, e2ap_RICactionLoadConfirm_Item);
            //asn1Init_e2ap_RICactionLoadConfirm_Item(pvalue->value.u._e2ap_RICactionLoadConfirm_ItemIEs_id_id_RICactionLoadConfirm_Item);
            asn1Init_e2ap_RICactionLoadConfirm_Item(pvalue->value.u._e2apRICactionLoadConfirm_ItemIEs_id_RICactionLoadConfirm_Item);
            stat = asn1PD_e2ap_RICactionLoadConfirm_Item (pctxt,
                    (e2ap_RICactionLoadConfirm_Item*)pvalue->value.
                    u._e2apRICactionLoadConfirm_ItemIEs_id_RICactionLoadConfirm_Item);
            if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICactionLoadConfirm_ItemIEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*)rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
      }
      {
      size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
      size_t bitsConsumed = bitEndOffset - bitStartOffset;
      if(bitsConsumed < bitLength){
         stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
      } else {
         stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
      }
      }
   }
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   return stat;
}

void asn1Init_e2ap_RICactionLoadConfirm_ItemIEs (e2ap_RICactionLoadConfirm_ItemIEs* pvalue)
{
   if (!pvalue) return;
   OSCRTLMEMSET (pvalue, 0, sizeof(e2ap_RICactionLoadConfirm_ItemIEs));
}

#if 0
void asn1Free_e2ap_RICactionLoadConfirm_ItemIEs (OSCTXT* pctxt, e2ap_RICactionLoadConfirm_ItemIEs* pvalue)
{
   if (!pvalue) return;
   if (pvalue->extElem1) {
      rtxMemFreeArray (pctxt, pvalue->extElem1);
      pvalue->extElem1 = 0;
      pvalue->extElem1_n = 0;
   }
}
#endif
void asn1Free_e2ap_RICactionLoadConfirm_ItemIEs (OSCTXT* pctxt, e2ap_RICactionLoadConfirm_ItemIEs* pvalue)
{
   if(0==pvalue) return;
   switch(pvalue->value.t){
      case T_E2AP_PDU_Contents_e2ap_RICactionLoadConfirm_ItemIEs_id_RICactionLoadConfirm_Item:
         asn1Free_e2ap_RICactionLoadConfirm_Item (pctxt, pvalue->value.u._e2apRICactionLoadConfirm_ItemIEs_id_RICactionLoadConfirm_Item);
         rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2apRICactionLoadConfirm_ItemIEs_id_RICactionLoadConfirm_Item);
         pvalue->value.u._e2apRICactionLoadConfirm_ItemIEs_id_RICactionLoadConfirm_Item = 0;
         break;
      case T_E2AP_PDU_Contents_e2ap_RICactionLoadConfirm_ItemIEs_UNDEF_:
         if(0!=pvalue->value.u.extElem1){
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1->data);
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
             pvalue->value.u.extElem1 =0;
         }
         break;
         default:;
   }
}

int  asn1PrtToStr_e2ap_RICactionLoadConfirm_ItemIEs (const char * name, e2ap_RICactionLoadConfirm_ItemIEs* pvalue, char * buffer, OSSIZE bufSize){
   if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
       return -1;

      if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
         return -1;

      if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
         return -1;
      if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
         return -1;
      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_RICactionLoadConfirm_ItemIEs_id_RICactionLoadConfirm_Item:
         if(asn1PrtToStr_e2ap_RICactionLoadConfirm_Item("RICactionLoadConfirm-Item",
                pvalue->value.u._e2apRICactionLoadConfirm_ItemIEs_id_RICactionLoadConfirm_Item, buffer, bufSize)<0)// dungnm23 check lai nhe xem la
            return -1;
         break;
      default:
         if(0!=pvalue -> value.u.extElem1){
             rtPrintToStringIndent(buffer, bufSize);
             rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

         }
      }
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

      return 0;

}
 

/*****************************************/
/*           RICactionLoadConfirm_List                */
/*****************************************/
//seq_of_single_container


int asn1PE_e2ap_RICactionLoadConfirm_List (OSCTXT* pctxt, e2ap_RICactionLoadConfirm_List* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_RICactionLoadConfirm_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "RICactionLoadConfirm-List");

   /* encode length determinant */
   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;
   for (xx1 = 0; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next, xx1++) {
      pdata = (e2ap_RICactionLoadConfirm_ItemIEs*) pnode->data;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_e2ap_RICactionLoadConfirm_ItemIEs (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      //xx1++;
      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}

int asn1PD_e2ap_RICactionLoadConfirm_List (OSCTXT* pctxt, e2ap_RICactionLoadConfirm_List* ppvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_RICactionLoadConfirm_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "RICactionLoadConfirm-List");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (ppvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      pdata = rtxMemAllocType (pctxt, e2ap_RICactionLoadConfirm_ItemIEs);
      if (!pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);
      asn1Init_e2ap_RICactionLoadConfirm_ItemIEs (pdata);
      stat = asn1PD_e2ap_RICactionLoadConfirm_ItemIEs (pctxt, pdata);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         return LOG_RTERR (pctxt, stat);
      }

      rtxDListAppendNode (ppvalue, pdata);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

void asn1Init_e2ap_RICactionLoadConfirm_List (e2ap_RICactionLoadConfirm_List* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
}

void asn1Free_e2ap_RICactionLoadConfirm_List (OSCTXT* pctxt, e2ap_RICactionLoadConfirm_List* pvalue)
{
   if(pvalue==0) return;
   OSRTDListNode* pnode = pvalue->head;
   while (pnode) {
      e2ap_RICactionLoadConfirm_ItemIEs* pdata = (e2ap_RICactionLoadConfirm_ItemIEs*) pnode->data;
      if (pdata) {
         asn1Free_e2ap_RICactionLoadConfirm_ItemIEs (pctxt, pdata);
         rtxMemFreePtr (pctxt, pdata);
      }
      pnode = pnode->next;
   }
      rtxDListFreeAll(pctxt, pvalue);
}

#if 0
void asn1Free_e2ap_RICactionLoadConfirm_List (OSCTXT* pctxt, e2ap_RICactionLoadConfirm_List* pvalue){
   if(0==pvalue ) return;
   {
      e2ap_RICactionLoadConfirm_ItemIEs * pdata;
      OSRTDListNode *pnode = pvalue->head;
      while(0!=pnode){
         pdata = (e2ap_RICactionLoadConfirm_ItemIEs*)pnode->data;
         asn1Free_e2ap_RICactionLoadConfirm_ItemIEs(pctxt, pdata);
         pnode = pnode->next;
      }
      rtxDListFreeAll(pctxt, pvalue);
   }
}
#endif


int asn1PrtToStr_e2ap_RICactionLoadConfirm_List(const char* name, e2ap_RICactionLoadConfirm_List* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_RICactionLoadConfirm_ItemIEs* pdata;
    OSRTDListNode* pnode;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode = pvalue->head;  xx1 < pvalue->count && pnode != 0; pnode = pnode->next, xx1++){
        pdata = (e2ap_RICactionLoadConfirm_ItemIEs*)pnode->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 1
        if(asn1PrtToStr_e2ap_RICactionLoadConfirm_ItemIEs(nameBuf, pdata, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}
/*****************************************/
/*           RICsubscriptionLoadConfirm-ItemIE                */
/*****************************************/
//sequence normal
// Các nội dung cần thiết cho template seq_normal.c.j2

// Các phần còn lại của template seq_normal.c.j2
//contain extensition bit -> theo mau cua GlobalgNB-ID
int asn1PE_e2ap_RICsubscriptionLoadConfirm_ItemIE (OSCTXT* pctxt, e2ap_RICsubscriptionLoadConfirm_ItemIE* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RICsubscriptionLoadConfirm-ItemIE");

   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);

   /*optional bit for field ricSubscriptionLoadConfirm*/
   stat = rtxEncBit (pctxt, pvalue->m_ricSubscriptionLoadConfirmPresent);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   /*optional bit for field ricActionLoadConfirm_list*/
   stat = rtxEncBit (pctxt, pvalue->m_ricActionLoadConfirm_listPresent);
   if (stat != 0) return LOG_RTERR(pctxt, stat);

   /*encode root elements*/   
   /* encode field ricRequestID - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "ricRequestID");
   stat = asn1PE_e2ap_RICrequestID (pctxt, pvalue->ricRequestID);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /* encode field ricSubscriptionLoadConfirm - id = -1*/  
   if (pvalue->m_ricSubscriptionLoadConfirmPresent) {//OPTIONAL FIELD
   RTXCTXTPUSHELEMNAME(pctxt, "ricSubscriptionLoadConfirm");
   stat = asn1PE_e2ap_RICloadConfirm (pctxt, pvalue->ricSubscriptionLoadConfirm);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   }

   /* encode field ricActionLoadConfirm_list - id = -1*/  
   if (pvalue->m_ricActionLoadConfirm_listPresent) {//OPTIONAL FIELD
   RTXCTXTPUSHELEMNAME(pctxt, "ricActionLoadConfirm-list");
   stat = asn1PE_e2ap_RICactionLoadConfirm_List (pctxt, pvalue->ricActionLoadConfirm_list);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   }


   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RICsubscriptionLoadConfirm_ItemIE (OSCTXT* pctxt, e2ap_RICsubscriptionLoadConfirm_ItemIE* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[3];

   RTXCTXTPUSHTYPENAME(pctxt, "RICsubscriptionLoadConfirm-ItemIE");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field ricRequestID */
   RTXCTXTPUSHELEMNAME(pctxt, "ricRequestID");
      stat = asn1PD_e2ap_RICrequestID (pctxt, &pvalue->ricRequestID);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field ricSubscriptionLoadConfirm */
   RTXCTXTPUSHELEMNAME(pctxt, "ricSubscriptionLoadConfirm");
   if (optbits[0]) {
      pvalue->m_ricSubscriptionLoadConfirmPresent = TRUE;
      stat = asn1PD_e2ap_RICloadConfirm (pctxt, &pvalue->ricSubscriptionLoadConfirm);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   } else {
      pvalue->m_ricSubscriptionLoadConfirmPresent = FALSE;
   }
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field ricActionLoadConfirm_list */
   RTXCTXTPUSHELEMNAME(pctxt, "ricActionLoadConfirm-list");
   if (optbits[0]) {
      pvalue->m_ricActionLoadConfirm_listPresent = TRUE;
      stat = asn1PD_e2ap_RICactionLoadConfirm_List (pctxt, &pvalue->ricActionLoadConfirm_list);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   } else {
      pvalue->m_ricActionLoadConfirm_listPresent = FALSE;
   }
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RICsubscriptionLoadConfirm_ItemIE (e2ap_RICsubscriptionLoadConfirm_ItemIE* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RICrequestID (&pvalue->ricRequestID);
   asn1Init_e2ap_RICloadConfirm (&pvalue->ricSubscriptionLoadConfirm);
   asn1Init_e2ap_RICactionLoadConfirm_List (&pvalue->ricActionLoadConfirm_list);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RICsubscriptionLoadConfirm_ItemIE (OSCTXT* pctxt, e2ap_RICsubscriptionLoadConfirm_ItemIE* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_RICrequestID (pctxt, &pvalue->ricRequestID);
   asn1Free_e2ap_RICloadConfirm (pctxt, &pvalue->ricSubscriptionLoadConfirm);
   asn1Free_e2ap_RICactionLoadConfirm_List (pctxt, &pvalue->ricActionLoadConfirm_list);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RICsubscriptionLoadConfirm_ItemIE (const char* name, e2ap_RICsubscriptionLoadConfirm_ItemIE* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }
   if(asn1PrtToStr_e2ap_RICrequestID ("ricRequestID", &pvalue->ricRequestID, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_RICloadConfirm ("ricSubscriptionLoadConfirm", &pvalue->ricSubscriptionLoadConfirm, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_RICactionLoadConfirm_List ("ricActionLoadConfirm_list", &pvalue->ricActionLoadConfirm_list, buffer, bufSize) < 0)
   {
      return -1;
   }



   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           RICsubscriptionLoadConfirm_ItemIEs                */
/*****************************************/
/* ie.c.j2 */
/*ie thường*/
int asn1PE_e2ap_RICsubscriptionLoadConfirm_ItemIEs (OSCTXT* pctxt, e2ap_RICsubscriptionLoadConfirm_ItemIEs* pvalue)
{
   int stat = 0;
   //RTXCTXTPUSHTYPENAME (pctxt, "RICsubscriptionLoadConfirm-ItemIEs");

   /* encode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");
   stat = asn1PE_e2ap_ProtocolIE_ID (pctxt, pvalue->id);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");
   stat = asn1PE_e2ap_Criticality (pctxt, pvalue->criticality);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   {
      OSCTXT ictxt;
      OSOCTET* pDynamicEncodeBuffer;
      ASN1OpenType openType;
      OSBOOL  encoded = TRUE;

      openType.numocts = 0;
      openType.data = 0;

      rtxCopyContext (&ictxt, pctxt);
      pctxt->pStream = 0;

      stat = rtxInitContextBuffer (pctxt, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_RICsubscriptionLoadConfirm_ItemIEs_id_RICsubscriptionLoadConfirm_Item:
         
        // RTXCTXTPUSHELEMNAME (pctxt, "RICsubscriptionLoadConfirm_ItemIEs_id_RICsubscriptionLoadConfirm_ItemIE");
         RTXCTXTPUSHELEMNAME (pctxt, "RICsubscriptionLoadConfirm-ItemIE");
         stat = asn1PE_e2ap_RICsubscriptionLoadConfirm_ItemIE (pctxt, pvalue->value.u._e2apRICsubscriptionLoadConfirm_ItemIEs_id_RICsubscriptionLoadConfirm_Item);
         RTXCTXTPOPELEMNAME (pctxt);
      
         break;

      case T_E2AP_PDU_Contents_e2ap_RICsubscriptionLoadConfirm_ItemIEs_UNDEF_:
      {
          if(0!=pvalue->value.u.extElem1){
              openType.numocts = pvalue->value.u.extElem1->numocts;
              openType.data = pvalue->value.u.extElem1->data;
          } else {
              /* No extension element to encode */
          }
          encoded = FALSE;
          break;
      }
      default:
         encoded = FALSE;
         stat = RTERR_INVOPT;
      }

      if (encoded) {
         openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
         openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
      }
      rtxCopyContext (pctxt, &ictxt);
      if(stat ==0) stat = pe_OpenType(pctxt, openType.numocts, openType.data);
      /*free dynamic encode buffer*/
      if(encoded){
          rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
      }
   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);
   //RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

int asn1PD_e2ap_RICsubscriptionLoadConfirm_ItemIEs (OSCTXT* pctxt, e2ap_RICsubscriptionLoadConfirm_ItemIEs* pvalue)
{
   int stat =0;
   /*deode root element id*/
   RTXCTXTPUSHELEMNAME(pctxt, "id");
   stat = asn1PD_e2ap_ProtocolIE_ID (pctxt, &pvalue->id);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*decode root element criticality*/
   RTXCTXTPUSHELEMNAME(pctxt, "criticality");
   stat = asn1PD_e2ap_Criticality (pctxt, &pvalue->criticality);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   /*decode root element value*/
   RTXCTXTPUSHELEMNAME(pctxt, "value");
   {
      OSUINT32 openTypeLen;
      size_t bitStartOffset, bitLength;
      stat = pd_UnconsLength(pctxt, &openTypeLen);
      if(stat <0) return LOG_RTERR(pctxt, stat);
      else if(stat == RT_OK_FRAG){
         rtxErrAddStrParm(pctxt, "open type with fragmented length use - perindef");
         return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
      }
      bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
      bitLength = openTypeLen * 8;
      switch (pvalue->id){
         case T_E2AP_PDU_Contents_e2ap_RICsubscriptionLoadConfirm_ItemIEs_id_RICsubscriptionLoadConfirm_Item:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionLoadConfirm_ItemIEs_id_RICsubscriptionLoadConfirm_Item;
            RTXCTXTPUSHELEMNAME(pctxt, "RICsubscriptionLoadConfirm-ItemIE");
            //pvalue->value.u._e2ap_RICsubscriptionLoadConfirm_ItemIEs_id_id_RICsubscriptionLoadConfirm_Item 
             pvalue->value.u._e2apRICsubscriptionLoadConfirm_ItemIEs_id_RICsubscriptionLoadConfirm_Item 
                    = rtxMemAllocType(pctxt, e2ap_RICsubscriptionLoadConfirm_ItemIE);
            //asn1Init_e2ap_RICsubscriptionLoadConfirm_ItemIE(pvalue->value.u._e2ap_RICsubscriptionLoadConfirm_ItemIEs_id_id_RICsubscriptionLoadConfirm_Item);
            asn1Init_e2ap_RICsubscriptionLoadConfirm_ItemIE(pvalue->value.u._e2apRICsubscriptionLoadConfirm_ItemIEs_id_RICsubscriptionLoadConfirm_Item);
            stat = asn1PD_e2ap_RICsubscriptionLoadConfirm_ItemIE (pctxt,
                    (e2ap_RICsubscriptionLoadConfirm_ItemIE*)pvalue->value.
                    u._e2apRICsubscriptionLoadConfirm_ItemIEs_id_RICsubscriptionLoadConfirm_Item);
            if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionLoadConfirm_ItemIEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*)rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
      }
      {
      size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
      size_t bitsConsumed = bitEndOffset - bitStartOffset;
      if(bitsConsumed < bitLength){
         stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
      } else {
         stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
      }
      }
   }
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   return stat;
}

void asn1Init_e2ap_RICsubscriptionLoadConfirm_ItemIEs (e2ap_RICsubscriptionLoadConfirm_ItemIEs* pvalue)
{
   if (!pvalue) return;
   OSCRTLMEMSET (pvalue, 0, sizeof(e2ap_RICsubscriptionLoadConfirm_ItemIEs));
}

#if 0
void asn1Free_e2ap_RICsubscriptionLoadConfirm_ItemIEs (OSCTXT* pctxt, e2ap_RICsubscriptionLoadConfirm_ItemIEs* pvalue)
{
   if (!pvalue) return;
   if (pvalue->extElem1) {
      rtxMemFreeArray (pctxt, pvalue->extElem1);
      pvalue->extElem1 = 0;
      pvalue->extElem1_n = 0;
   }
}
#endif
void asn1Free_e2ap_RICsubscriptionLoadConfirm_ItemIEs (OSCTXT* pctxt, e2ap_RICsubscriptionLoadConfirm_ItemIEs* pvalue)
{
   if(0==pvalue) return;
   switch(pvalue->value.t){
      case T_E2AP_PDU_Contents_e2ap_RICsubscriptionLoadConfirm_ItemIEs_id_RICsubscriptionLoadConfirm_Item:
         asn1Free_e2ap_RICsubscriptionLoadConfirm_ItemIE (pctxt, pvalue->value.u._e2apRICsubscriptionLoadConfirm_ItemIEs_id_RICsubscriptionLoadConfirm_Item);
         rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2apRICsubscriptionLoadConfirm_ItemIEs_id_RICsubscriptionLoadConfirm_Item);
         pvalue->value.u._e2apRICsubscriptionLoadConfirm_ItemIEs_id_RICsubscriptionLoadConfirm_Item = 0;
         break;
      case T_E2AP_PDU_Contents_e2ap_RICsubscriptionLoadConfirm_ItemIEs_UNDEF_:
         if(0!=pvalue->value.u.extElem1){
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1->data);
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
             pvalue->value.u.extElem1 =0;
         }
         break;
         default:;
   }
}

int  asn1PrtToStr_e2ap_RICsubscriptionLoadConfirm_ItemIEs (const char * name, e2ap_RICsubscriptionLoadConfirm_ItemIEs* pvalue, char * buffer, OSSIZE bufSize){
   if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
       return -1;

      if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
         return -1;

      if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
         return -1;
      if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
         return -1;
      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_RICsubscriptionLoadConfirm_ItemIEs_id_RICsubscriptionLoadConfirm_Item:
         if(asn1PrtToStr_e2ap_RICsubscriptionLoadConfirm_ItemIE("RICsubscriptionLoadConfirm-ItemIE",
                pvalue->value.u._e2apRICsubscriptionLoadConfirm_ItemIEs_id_RICsubscriptionLoadConfirm_Item, buffer, bufSize)<0)// dungnm23 check lai nhe xem la
            return -1;
         break;
      default:
         if(0!=pvalue -> value.u.extElem1){
             rtPrintToStringIndent(buffer, bufSize);
             rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

         }
      }
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

      return 0;

}
 

/*****************************************/
/*           RICsubscriptionLoadConfirm_List                */
/*****************************************/
//seq_of_single_container


int asn1PE_e2ap_RICsubscriptionLoadConfirm_List (OSCTXT* pctxt, e2ap_RICsubscriptionLoadConfirm_List* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_RICsubscriptionLoadConfirm_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "RICsubscriptionLoadConfirm-List");

   /* encode length determinant */
   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1024), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;
   for (xx1 = 0; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next, xx1++) {
      pdata = (e2ap_RICsubscriptionLoadConfirm_ItemIEs*) pnode->data;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_e2ap_RICsubscriptionLoadConfirm_ItemIEs (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      //xx1++;
      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}

int asn1PD_e2ap_RICsubscriptionLoadConfirm_List (OSCTXT* pctxt, e2ap_RICsubscriptionLoadConfirm_List* ppvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_RICsubscriptionLoadConfirm_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "RICsubscriptionLoadConfirm-List");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1024), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (ppvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      pdata = rtxMemAllocType (pctxt, e2ap_RICsubscriptionLoadConfirm_ItemIEs);
      if (!pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);
      asn1Init_e2ap_RICsubscriptionLoadConfirm_ItemIEs (pdata);
      stat = asn1PD_e2ap_RICsubscriptionLoadConfirm_ItemIEs (pctxt, pdata);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         return LOG_RTERR (pctxt, stat);
      }

      rtxDListAppendNode (ppvalue, pdata);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

void asn1Init_e2ap_RICsubscriptionLoadConfirm_List (e2ap_RICsubscriptionLoadConfirm_List* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
}

void asn1Free_e2ap_RICsubscriptionLoadConfirm_List (OSCTXT* pctxt, e2ap_RICsubscriptionLoadConfirm_List* pvalue)
{
   if(pvalue==0) return;
   OSRTDListNode* pnode = pvalue->head;
   while (pnode) {
      e2ap_RICsubscriptionLoadConfirm_ItemIEs* pdata = (e2ap_RICsubscriptionLoadConfirm_ItemIEs*) pnode->data;
      if (pdata) {
         asn1Free_e2ap_RICsubscriptionLoadConfirm_ItemIEs (pctxt, pdata);
         rtxMemFreePtr (pctxt, pdata);
      }
      pnode = pnode->next;
   }
      rtxDListFreeAll(pctxt, pvalue);
}

#if 0
void asn1Free_e2ap_RICsubscriptionLoadConfirm_List (OSCTXT* pctxt, e2ap_RICsubscriptionLoadConfirm_List* pvalue){
   if(0==pvalue ) return;
   {
      e2ap_RICsubscriptionLoadConfirm_ItemIEs * pdata;
      OSRTDListNode *pnode = pvalue->head;
      while(0!=pnode){
         pdata = (e2ap_RICsubscriptionLoadConfirm_ItemIEs*)pnode->data;
         asn1Free_e2ap_RICsubscriptionLoadConfirm_ItemIEs(pctxt, pdata);
         pnode = pnode->next;
      }
      rtxDListFreeAll(pctxt, pvalue);
   }
}
#endif


int asn1PrtToStr_e2ap_RICsubscriptionLoadConfirm_List(const char* name, e2ap_RICsubscriptionLoadConfirm_List* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_RICsubscriptionLoadConfirm_ItemIEs* pdata;
    OSRTDListNode* pnode;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode = pvalue->head;  xx1 < pvalue->count && pnode != 0; pnode = pnode->next, xx1++){
        pdata = (e2ap_RICsubscriptionLoadConfirm_ItemIEs*)pnode->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 1
        if(asn1PrtToStr_e2ap_RICsubscriptionLoadConfirm_ItemIEs(nameBuf, pdata, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}
/*****************************************/
/*           RANfunctionLoadConfirm-Item                */
/*****************************************/
//sequence normal
// Các nội dung cần thiết cho template seq_normal.c.j2

// Các phần còn lại của template seq_normal.c.j2
//contain extensition bit -> theo mau cua GlobalgNB-ID
int asn1PE_e2ap_RANfunctionLoadConfirm_Item (OSCTXT* pctxt, e2ap_RANfunctionLoadConfirm_Item* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RANfunctionLoadConfirm-Item");

   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);

   /*optional bit for field ranFunctionLoadConfirm*/
   stat = rtxEncBit (pctxt, pvalue->m_ranFunctionLoadConfirmPresent);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   /*optional bit for field ricServiceLoadConfirm*/
   stat = rtxEncBit (pctxt, pvalue->m_ricServiceLoadConfirmPresent);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   /*optional bit for field ricSubscriptionLoadConfirm_list*/
   stat = rtxEncBit (pctxt, pvalue->m_ricSubscriptionLoadConfirm_listPresent);
   if (stat != 0) return LOG_RTERR(pctxt, stat);

   /*encode root elements*/   
   /* encode field ranFunctionID - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "ranFunctionID");
   stat = asn1PE_e2ap_RANfunctionID (pctxt, pvalue->ranFunctionID);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /* encode field ranFunctionLoadConfirm - id = -1*/  
   if (pvalue->m_ranFunctionLoadConfirmPresent) {//OPTIONAL FIELD
   RTXCTXTPUSHELEMNAME(pctxt, "ranFunctionLoadConfirm");
   stat = asn1PE_e2ap_RICloadConfirm (pctxt, pvalue->ranFunctionLoadConfirm);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   }

   /* encode field ricServiceLoadConfirm - id = -1*/  
   if (pvalue->m_ricServiceLoadConfirmPresent) {//OPTIONAL FIELD
   RTXCTXTPUSHELEMNAME(pctxt, "ricServiceLoadConfirm");
   stat = asn1PE_e2ap_RICserviceLoadConfirm (pctxt, pvalue->ricServiceLoadConfirm);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   }

   /* encode field ricSubscriptionLoadConfirm_list - id = -1*/  
   if (pvalue->m_ricSubscriptionLoadConfirm_listPresent) {//OPTIONAL FIELD
   RTXCTXTPUSHELEMNAME(pctxt, "ricSubscriptionLoadConfirm-list");
   stat = asn1PE_e2ap_RICsubscriptionLoadConfirm_List (pctxt, pvalue->ricSubscriptionLoadConfirm_list);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   }


   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RANfunctionLoadConfirm_Item (OSCTXT* pctxt, e2ap_RANfunctionLoadConfirm_Item* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[4];

   RTXCTXTPUSHTYPENAME(pctxt, "RANfunctionLoadConfirm-Item");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 4; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field ranFunctionID */
   RTXCTXTPUSHELEMNAME(pctxt, "ranFunctionID");
      stat = asn1PD_e2ap_RANfunctionID (pctxt, &pvalue->ranFunctionID);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field ranFunctionLoadConfirm */
   RTXCTXTPUSHELEMNAME(pctxt, "ranFunctionLoadConfirm");
   if (optbits[0]) {
      pvalue->m_ranFunctionLoadConfirmPresent = TRUE;
      stat = asn1PD_e2ap_RICloadConfirm (pctxt, &pvalue->ranFunctionLoadConfirm);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   } else {
      pvalue->m_ranFunctionLoadConfirmPresent = FALSE;
   }
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field ricServiceLoadConfirm */
   RTXCTXTPUSHELEMNAME(pctxt, "ricServiceLoadConfirm");
   if (optbits[0]) {
      pvalue->m_ricServiceLoadConfirmPresent = TRUE;
      stat = asn1PD_e2ap_RICserviceLoadConfirm (pctxt, &pvalue->ricServiceLoadConfirm);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   } else {
      pvalue->m_ricServiceLoadConfirmPresent = FALSE;
   }
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field ricSubscriptionLoadConfirm_list */
   RTXCTXTPUSHELEMNAME(pctxt, "ricSubscriptionLoadConfirm-list");
   if (optbits[0]) {
      pvalue->m_ricSubscriptionLoadConfirm_listPresent = TRUE;
      stat = asn1PD_e2ap_RICsubscriptionLoadConfirm_List (pctxt, &pvalue->ricSubscriptionLoadConfirm_list);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   } else {
      pvalue->m_ricSubscriptionLoadConfirm_listPresent = FALSE;
   }
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RANfunctionLoadConfirm_Item (e2ap_RANfunctionLoadConfirm_Item* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RANfunctionID (&pvalue->ranFunctionID);
   asn1Init_e2ap_RICloadConfirm (&pvalue->ranFunctionLoadConfirm);
   asn1Init_e2ap_RICserviceLoadConfirm (&pvalue->ricServiceLoadConfirm);
   asn1Init_e2ap_RICsubscriptionLoadConfirm_List (&pvalue->ricSubscriptionLoadConfirm_list);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RANfunctionLoadConfirm_Item (OSCTXT* pctxt, e2ap_RANfunctionLoadConfirm_Item* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_RANfunctionID (pctxt, &pvalue->ranFunctionID);
   asn1Free_e2ap_RICloadConfirm (pctxt, &pvalue->ranFunctionLoadConfirm);
   asn1Free_e2ap_RICserviceLoadConfirm (pctxt, &pvalue->ricServiceLoadConfirm);
   asn1Free_e2ap_RICsubscriptionLoadConfirm_List (pctxt, &pvalue->ricSubscriptionLoadConfirm_list);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RANfunctionLoadConfirm_Item (const char* name, e2ap_RANfunctionLoadConfirm_Item* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }
   if(asn1PrtToStr_e2ap_RANfunctionID ("ranFunctionID", &pvalue->ranFunctionID, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_RICloadConfirm ("ranFunctionLoadConfirm", &pvalue->ranFunctionLoadConfirm, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_RICserviceLoadConfirm ("ricServiceLoadConfirm", &pvalue->ricServiceLoadConfirm, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_RICsubscriptionLoadConfirm_List ("ricSubscriptionLoadConfirm_list", &pvalue->ricSubscriptionLoadConfirm_list, buffer, bufSize) < 0)
   {
      return -1;
   }



   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           RANfunctionLoadConfirm_ItemIEs                */
/*****************************************/
/* ie.c.j2 */
/*ie thường*/
int asn1PE_e2ap_RANfunctionLoadConfirm_ItemIEs (OSCTXT* pctxt, e2ap_RANfunctionLoadConfirm_ItemIEs* pvalue)
{
   int stat = 0;
   //RTXCTXTPUSHTYPENAME (pctxt, "RANfunctionLoadConfirm-ItemIEs");

   /* encode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");
   stat = asn1PE_e2ap_ProtocolIE_ID (pctxt, pvalue->id);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");
   stat = asn1PE_e2ap_Criticality (pctxt, pvalue->criticality);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   {
      OSCTXT ictxt;
      OSOCTET* pDynamicEncodeBuffer;
      ASN1OpenType openType;
      OSBOOL  encoded = TRUE;

      openType.numocts = 0;
      openType.data = 0;

      rtxCopyContext (&ictxt, pctxt);
      pctxt->pStream = 0;

      stat = rtxInitContextBuffer (pctxt, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_RANfunctionLoadConfirm_ItemIEs_id_RANfunctionLoadConfirm_Item:
         
        // RTXCTXTPUSHELEMNAME (pctxt, "RANfunctionLoadConfirm_ItemIEs_id_RANfunctionLoadConfirm_Item");
         RTXCTXTPUSHELEMNAME (pctxt, "RANfunctionLoadConfirm-Item");
         stat = asn1PE_e2ap_RANfunctionLoadConfirm_Item (pctxt, pvalue->value.u._e2apRANfunctionLoadConfirm_ItemIEs_id_RANfunctionLoadConfirm_Item);
         RTXCTXTPOPELEMNAME (pctxt);
      
         break;

      case T_E2AP_PDU_Contents_e2ap_RANfunctionLoadConfirm_ItemIEs_UNDEF_:
      {
          if(0!=pvalue->value.u.extElem1){
              openType.numocts = pvalue->value.u.extElem1->numocts;
              openType.data = pvalue->value.u.extElem1->data;
          } else {
              /* No extension element to encode */
          }
          encoded = FALSE;
          break;
      }
      default:
         encoded = FALSE;
         stat = RTERR_INVOPT;
      }

      if (encoded) {
         openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
         openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
      }
      rtxCopyContext (pctxt, &ictxt);
      if(stat ==0) stat = pe_OpenType(pctxt, openType.numocts, openType.data);
      /*free dynamic encode buffer*/
      if(encoded){
          rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
      }
   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);
   //RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

int asn1PD_e2ap_RANfunctionLoadConfirm_ItemIEs (OSCTXT* pctxt, e2ap_RANfunctionLoadConfirm_ItemIEs* pvalue)
{
   int stat =0;
   /*deode root element id*/
   RTXCTXTPUSHELEMNAME(pctxt, "id");
   stat = asn1PD_e2ap_ProtocolIE_ID (pctxt, &pvalue->id);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*decode root element criticality*/
   RTXCTXTPUSHELEMNAME(pctxt, "criticality");
   stat = asn1PD_e2ap_Criticality (pctxt, &pvalue->criticality);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   /*decode root element value*/
   RTXCTXTPUSHELEMNAME(pctxt, "value");
   {
      OSUINT32 openTypeLen;
      size_t bitStartOffset, bitLength;
      stat = pd_UnconsLength(pctxt, &openTypeLen);
      if(stat <0) return LOG_RTERR(pctxt, stat);
      else if(stat == RT_OK_FRAG){
         rtxErrAddStrParm(pctxt, "open type with fragmented length use - perindef");
         return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
      }
      bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
      bitLength = openTypeLen * 8;
      switch (pvalue->id){
         case T_E2AP_PDU_Contents_e2ap_RANfunctionLoadConfirm_ItemIEs_id_RANfunctionLoadConfirm_Item:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RANfunctionLoadConfirm_ItemIEs_id_RANfunctionLoadConfirm_Item;
            RTXCTXTPUSHELEMNAME(pctxt, "RANfunctionLoadConfirm-Item");
            //pvalue->value.u._e2ap_RANfunctionLoadConfirm_ItemIEs_id_id_RANfunctionLoadConfirm_Item 
             pvalue->value.u._e2apRANfunctionLoadConfirm_ItemIEs_id_RANfunctionLoadConfirm_Item 
                    = rtxMemAllocType(pctxt, e2ap_RANfunctionLoadConfirm_Item);
            //asn1Init_e2ap_RANfunctionLoadConfirm_Item(pvalue->value.u._e2ap_RANfunctionLoadConfirm_ItemIEs_id_id_RANfunctionLoadConfirm_Item);
            asn1Init_e2ap_RANfunctionLoadConfirm_Item(pvalue->value.u._e2apRANfunctionLoadConfirm_ItemIEs_id_RANfunctionLoadConfirm_Item);
            stat = asn1PD_e2ap_RANfunctionLoadConfirm_Item (pctxt,
                    (e2ap_RANfunctionLoadConfirm_Item*)pvalue->value.
                    u._e2apRANfunctionLoadConfirm_ItemIEs_id_RANfunctionLoadConfirm_Item);
            if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RANfunctionLoadConfirm_ItemIEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*)rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
      }
      {
      size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
      size_t bitsConsumed = bitEndOffset - bitStartOffset;
      if(bitsConsumed < bitLength){
         stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
      } else {
         stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
      }
      }
   }
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   return stat;
}

void asn1Init_e2ap_RANfunctionLoadConfirm_ItemIEs (e2ap_RANfunctionLoadConfirm_ItemIEs* pvalue)
{
   if (!pvalue) return;
   OSCRTLMEMSET (pvalue, 0, sizeof(e2ap_RANfunctionLoadConfirm_ItemIEs));
}

#if 0
void asn1Free_e2ap_RANfunctionLoadConfirm_ItemIEs (OSCTXT* pctxt, e2ap_RANfunctionLoadConfirm_ItemIEs* pvalue)
{
   if (!pvalue) return;
   if (pvalue->extElem1) {
      rtxMemFreeArray (pctxt, pvalue->extElem1);
      pvalue->extElem1 = 0;
      pvalue->extElem1_n = 0;
   }
}
#endif
void asn1Free_e2ap_RANfunctionLoadConfirm_ItemIEs (OSCTXT* pctxt, e2ap_RANfunctionLoadConfirm_ItemIEs* pvalue)
{
   if(0==pvalue) return;
   switch(pvalue->value.t){
      case T_E2AP_PDU_Contents_e2ap_RANfunctionLoadConfirm_ItemIEs_id_RANfunctionLoadConfirm_Item:
         asn1Free_e2ap_RANfunctionLoadConfirm_Item (pctxt, pvalue->value.u._e2apRANfunctionLoadConfirm_ItemIEs_id_RANfunctionLoadConfirm_Item);
         rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2apRANfunctionLoadConfirm_ItemIEs_id_RANfunctionLoadConfirm_Item);
         pvalue->value.u._e2apRANfunctionLoadConfirm_ItemIEs_id_RANfunctionLoadConfirm_Item = 0;
         break;
      case T_E2AP_PDU_Contents_e2ap_RANfunctionLoadConfirm_ItemIEs_UNDEF_:
         if(0!=pvalue->value.u.extElem1){
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1->data);
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
             pvalue->value.u.extElem1 =0;
         }
         break;
         default:;
   }
}

int  asn1PrtToStr_e2ap_RANfunctionLoadConfirm_ItemIEs (const char * name, e2ap_RANfunctionLoadConfirm_ItemIEs* pvalue, char * buffer, OSSIZE bufSize){
   if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
       return -1;

      if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
         return -1;

      if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
         return -1;
      if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
         return -1;
      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_RANfunctionLoadConfirm_ItemIEs_id_RANfunctionLoadConfirm_Item:
         if(asn1PrtToStr_e2ap_RANfunctionLoadConfirm_Item("RANfunctionLoadConfirm-Item",
                pvalue->value.u._e2apRANfunctionLoadConfirm_ItemIEs_id_RANfunctionLoadConfirm_Item, buffer, bufSize)<0)// dungnm23 check lai nhe xem la
            return -1;
         break;
      default:
         if(0!=pvalue -> value.u.extElem1){
             rtPrintToStringIndent(buffer, bufSize);
             rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

         }
      }
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

      return 0;

}
 

/*****************************************/
/*           RANfunctionLoadConfirm_List                */
/*****************************************/
//seq_of_single_container


int asn1PE_e2ap_RANfunctionLoadConfirm_List (OSCTXT* pctxt, e2ap_RANfunctionLoadConfirm_List* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_RANfunctionLoadConfirm_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "RANfunctionLoadConfirm-List");

   /* encode length determinant */
   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(256), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;
   for (xx1 = 0; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next, xx1++) {
      pdata = (e2ap_RANfunctionLoadConfirm_ItemIEs*) pnode->data;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_e2ap_RANfunctionLoadConfirm_ItemIEs (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      //xx1++;
      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}

int asn1PD_e2ap_RANfunctionLoadConfirm_List (OSCTXT* pctxt, e2ap_RANfunctionLoadConfirm_List* ppvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_RANfunctionLoadConfirm_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "RANfunctionLoadConfirm-List");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(256), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (ppvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      pdata = rtxMemAllocType (pctxt, e2ap_RANfunctionLoadConfirm_ItemIEs);
      if (!pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);
      asn1Init_e2ap_RANfunctionLoadConfirm_ItemIEs (pdata);
      stat = asn1PD_e2ap_RANfunctionLoadConfirm_ItemIEs (pctxt, pdata);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         return LOG_RTERR (pctxt, stat);
      }

      rtxDListAppendNode (ppvalue, pdata);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

void asn1Init_e2ap_RANfunctionLoadConfirm_List (e2ap_RANfunctionLoadConfirm_List* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
}

void asn1Free_e2ap_RANfunctionLoadConfirm_List (OSCTXT* pctxt, e2ap_RANfunctionLoadConfirm_List* pvalue)
{
   if(pvalue==0) return;
   OSRTDListNode* pnode = pvalue->head;
   while (pnode) {
      e2ap_RANfunctionLoadConfirm_ItemIEs* pdata = (e2ap_RANfunctionLoadConfirm_ItemIEs*) pnode->data;
      if (pdata) {
         asn1Free_e2ap_RANfunctionLoadConfirm_ItemIEs (pctxt, pdata);
         rtxMemFreePtr (pctxt, pdata);
      }
      pnode = pnode->next;
   }
      rtxDListFreeAll(pctxt, pvalue);
}

#if 0
void asn1Free_e2ap_RANfunctionLoadConfirm_List (OSCTXT* pctxt, e2ap_RANfunctionLoadConfirm_List* pvalue){
   if(0==pvalue ) return;
   {
      e2ap_RANfunctionLoadConfirm_ItemIEs * pdata;
      OSRTDListNode *pnode = pvalue->head;
      while(0!=pnode){
         pdata = (e2ap_RANfunctionLoadConfirm_ItemIEs*)pnode->data;
         asn1Free_e2ap_RANfunctionLoadConfirm_ItemIEs(pctxt, pdata);
         pnode = pnode->next;
      }
      rtxDListFreeAll(pctxt, pvalue);
   }
}
#endif


int asn1PrtToStr_e2ap_RANfunctionLoadConfirm_List(const char* name, e2ap_RANfunctionLoadConfirm_List* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_RANfunctionLoadConfirm_ItemIEs* pdata;
    OSRTDListNode* pnode;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode = pvalue->head;  xx1 < pvalue->count && pnode != 0; pnode = pnode->next, xx1++){
        pdata = (e2ap_RANfunctionLoadConfirm_ItemIEs*)pnode->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 1
        if(asn1PrtToStr_e2ap_RANfunctionLoadConfirm_ItemIEs(nameBuf, pdata, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}/*****************************************/
/*           RICserviceLoadStatusResponse_IEs                */
/*****************************************/
/* ie.c.j2 */
 /* d là con của msg */
EXTERN int asn1PE_e2ap_RICserviceLoadStatusResponse_protocolIEs_element (OSCTXT* pctxt, e2ap_RICserviceLoadStatusResponse_protocolIEs_element* pvalue)
{
    int stat =0;

    /*encode id*/

    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PE_e2ap_ProtocolIE_ID(pctxt, pvalue->id);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PE_e2ap_Criticality(pctxt, pvalue->criticality);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
    {
        OSCTXT lctxt;
        OSOCTET *pDynamicEncodeBuffer;
        ASN1OpenType openType;
        OSBOOL encoded = TRUE;

        openType.numocts = 0;
        openType.data =0;

        rtxCopyContext(&lctxt, pctxt);
        pctxt->pStream =0;

        stat = rtxInitContextBuffer(pctxt, 0, 0);
        if(stat!=0) return LOG_RTERR(pctxt, stat);

        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusResponse_IEs_id_RICloadMeasurementID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICloadMeasurementID");
                    stat = asn1PE_e2ap_LoadMeasurementID (pctxt, pvalue->value.u._e2ap_RICserviceLoadStatusResponse_IEs_id_RICloadMeasurementID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusResponse_IEs_id_E2nodeLoadMeasurementID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-E2nodeLoadMeasurementID");
                    stat = asn1PE_e2ap_LoadMeasurementID (pctxt, pvalue->value.u._e2ap_RICserviceLoadStatusResponse_IEs_id_E2nodeLoadMeasurementID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusResponse_IEs_id_RANfunctionLoadConfirm_List:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RANfunctionLoadConfirm-List");
                    stat = asn1PE_e2ap_RANfunctionLoadConfirm_List (pctxt, pvalue->value.u._e2ap_RICserviceLoadStatusResponse_IEs_id_RANfunctionLoadConfirm_List);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusResponse_IEs_UNDEF_:
            {
                if(0!=pvalue->value.u.extElem1){
                    openType.numocts = pvalue->value.u.extElem1->numocts;
                    openType.data = pvalue->value.u.extElem1->data;
                } else {
                    /* No extension element to encode */
                }
                encoded = FALSE;
                break;
            }

            default:
                encoded = FALSE;
                stat = RTERR_INVOPT;
                break;
        } 

        if(encoded){
            openType.numocts = (OSUINT32)pe_GetMsgLen(pctxt);
            openType.data = pDynamicEncodeBuffer = pctxt -> buffer.data;
        }
        rtxCopyContext(pctxt, &lctxt);

        if(stat == 0) {
            stat = pe_OpenType (pctxt, openType.numocts, openType.data);
        }
    #if 1
        if(encoded){//dungnm23 check lai nhe
            rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
        }
    #endif

    }

    if(stat!=0) return LOG_RTERR(pctxt, stat);  
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}

EXTERN int  asn1PD_e2ap_RICserviceLoadStatusResponse_protocolIEs_element (OSCTXT* pctxt, e2ap_RICserviceLoadStatusResponse_protocolIEs_element* pvalue){
    int stat =0;

    /*decode id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PD_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PD_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");

    {
        OSUINT32 openTypeLen;
        size_t bitStartOffset, bitLength;

        stat = pd_UnconsLength(pctxt, &openTypeLen);
        if(stat<0) return LOG_RTERR(pctxt, stat);
        else if(stat == RT_OK_FRAG){
            rtxErrAddStrParm(pctxt, "open type with fragment length");
            return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
        }
        bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
        bitLength = openTypeLen * 8;

        switch(pvalue->id){//dungnm23 check case lai nhe
        
            case ASN1V_e2ap_id_RICloadMeasurementID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusResponse_IEs_id_RICloadMeasurementID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICloadMeasurementID");
                pvalue->value.u._e2ap_RICserviceLoadStatusResponse_IEs_id_RICloadMeasurementID 
                    = rtxMemAllocType(pctxt, e2ap_LoadMeasurementID);

                asn1Init_e2ap_LoadMeasurementID(pvalue->value.u._e2ap_RICserviceLoadStatusResponse_IEs_id_RICloadMeasurementID);

                stat = asn1PD_e2ap_LoadMeasurementID (pctxt,
                        (e2ap_LoadMeasurementID*)pvalue->value.
                        u._e2ap_RICserviceLoadStatusResponse_IEs_id_RICloadMeasurementID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_E2nodeLoadMeasurementID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusResponse_IEs_id_E2nodeLoadMeasurementID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-E2nodeLoadMeasurementID");
                pvalue->value.u._e2ap_RICserviceLoadStatusResponse_IEs_id_E2nodeLoadMeasurementID 
                    = rtxMemAllocType(pctxt, e2ap_LoadMeasurementID);

                asn1Init_e2ap_LoadMeasurementID(pvalue->value.u._e2ap_RICserviceLoadStatusResponse_IEs_id_E2nodeLoadMeasurementID);

                stat = asn1PD_e2ap_LoadMeasurementID (pctxt,
                        (e2ap_LoadMeasurementID*)pvalue->value.
                        u._e2ap_RICserviceLoadStatusResponse_IEs_id_E2nodeLoadMeasurementID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RANfunctionLoadConfirm_List:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusResponse_IEs_id_RANfunctionLoadConfirm_List;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RANfunctionLoadConfirm-List");
                pvalue->value.u._e2ap_RICserviceLoadStatusResponse_IEs_id_RANfunctionLoadConfirm_List 
                    = rtxMemAllocType(pctxt, e2ap_RANfunctionLoadConfirm_List);

                asn1Init_e2ap_RANfunctionLoadConfirm_List(pvalue->value.u._e2ap_RICserviceLoadStatusResponse_IEs_id_RANfunctionLoadConfirm_List);

                stat = asn1PD_e2ap_RANfunctionLoadConfirm_List (pctxt,
                        (e2ap_RANfunctionLoadConfirm_List*)pvalue->value.
                        u._e2ap_RICserviceLoadStatusResponse_IEs_id_RANfunctionLoadConfirm_List);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusResponse_IEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*) rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
    }
    {
    size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
    size_t bitsConsumed = bitEndOffset-bitStartOffset;
    if(bitsConsumed<bitLength){
        stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
    }
    else stat =(bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
    }}
    if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}


int asn1Init_e2ap_RICserviceLoadStatusResponse_protocolIEs_element(e2ap_RICserviceLoadStatusResponse_protocolIEs_element* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    OSCRTLMEMSET (&pvalue->value, 0, sizeof(pvalue->value));
    return 0;
}


//-----> chuaw có template rtxFreeASN1OpenType

#if 0
void asn1Free_e2ap_RICserviceLoadStatusResponse_protocolIEs_element(OSCTXT* pctxt, e2ap_RICserviceLoadStatusResponse_protocolIEs_element* pvalue)
{
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusResponse_IEs_id_id_RICloadMeasurementID:
            // rtxFreeE2ap_LoadMeasurementID(pvalue->value.u._e2ap_RICserviceLoadStatusResponse_IEs_id_id_RICloadMeasurementID);

            if(pvalue->value.i._e2ap_RICserviceLoadStatusResponse_id_LoadMeasurementID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_LoadMeasurementID(pctxt, pvalue->value.u._e2ap_RICserviceLoadStatusResponse_IEs_id_id_RICloadMeasurementID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICserviceLoadStatusResponse_IEs_id_id_RICloadMeasurementID);
           // pvalue->value.u._e2ap_RICserviceLoadStatusResponse_IEs_id_id_RICloadMeasurementID = NULL;
           pvalue->value.u._e2ap_RICserviceLoadStatusResponse_IEs_id_RICloadMeasurementID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusResponse_IEs_id_id_E2nodeLoadMeasurementID:
            // rtxFreeE2ap_LoadMeasurementID(pvalue->value.u._e2ap_RICserviceLoadStatusResponse_IEs_id_id_E2nodeLoadMeasurementID);

            if(pvalue->value.i._e2ap_RICserviceLoadStatusResponse_id_LoadMeasurementID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_LoadMeasurementID(pctxt, pvalue->value.u._e2ap_RICserviceLoadStatusResponse_IEs_id_id_E2nodeLoadMeasurementID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICserviceLoadStatusResponse_IEs_id_id_E2nodeLoadMeasurementID);
           // pvalue->value.u._e2ap_RICserviceLoadStatusResponse_IEs_id_id_E2nodeLoadMeasurementID = NULL;
           pvalue->value.u._e2ap_RICserviceLoadStatusResponse_IEs_id_E2nodeLoadMeasurementID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusResponse_IEs_id_id_RANfunctionLoadConfirm_List:
            // rtxFreeE2ap_RANfunctionLoadConfirm_List(pvalue->value.u._e2ap_RICserviceLoadStatusResponse_IEs_id_id_RANfunctionLoadConfirm_List);

            if(pvalue->value.i._e2ap_RICserviceLoadStatusResponse_id_RANfunctionLoadConfirm_List!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RANfunctionLoadConfirm_List(pctxt, pvalue->value.u._e2ap_RICserviceLoadStatusResponse_IEs_id_id_RANfunctionLoadConfirm_List);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICserviceLoadStatusResponse_IEs_id_id_RANfunctionLoadConfirm_List);
           // pvalue->value.u._e2ap_RICserviceLoadStatusResponse_IEs_id_id_RANfunctionLoadConfirm_List = NULL;
           pvalue->value.u._e2ap_RICserviceLoadStatusResponse_IEs_id_RANfunctionLoadConfirm_List = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusResponse_IEs_UNDEF_:
            rtxFreeASN1OpenType(pvalue->value.u.extElem1);
            break;
        default:
            break;
    }
}

int asn1PrtToStr_e2ap_RICserviceLoadStatusResponse_protocolIEs_element(OSCTXT* pctxt, e2ap_RICserviceLoadStatusResponse_protocolIEs_element* pvalue)
{
    int stat =0;
    RTXCTXTPUSHELEMNAME(pctxt, "e2ap_RICserviceLoadStatusResponse_protocolIEs_element");

    /*print id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PrtToStr_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PrtToStr_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusResponse_IEs_id_id_RICloadMeasurementID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "LoadMeasurementID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_LoadMeasurementID (pctxt, pvalue->value.u._e2ap_RICserviceLoadStatusResponse_IEs_id_id_RICloadMeasurementID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusResponse_IEs_id_id_E2nodeLoadMeasurementID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "LoadMeasurementID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_LoadMeasurementID (pctxt, pvalue->value.u._e2ap_RICserviceLoadStatusResponse_IEs_id_id_E2nodeLoadMeasurementID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusResponse_IEs_id_id_RANfunctionLoadConfirm_List:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RANfunctionLoadConfirm-List");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RANfunctionLoadConfirm_List (pctxt, pvalue->value.u._e2ap_RICserviceLoadStatusResponse_IEs_id_id_RANfunctionLoadConfirm_List);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusResponse_IEs_UNDEF_:
            {
                rtxPLogMsg(pctxt, "Extension element present - raw data not printed.\n");
                break;
            }

            default:
                stat = RTERR_INVOPT;
                return LOG_RTERR(pctxt, stat);
        }
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);
}
#endif


int asn1PrtToStr_e2ap_RICserviceLoadStatusResponse_protocolIEs_element (const char * name,
 e2ap_RICserviceLoadStatusResponse_protocolIEs_element* pvalue, 
 char * buffer, OSSIZE bufSize){
    if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
        return -1;
    if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
        return -1;

    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusResponse_IEs_id_RICloadMeasurementID:
            if(asn1PrtToStr_e2ap_LoadMeasurementID("LoadMeasurementID", 
                    pvalue->value.u._e2ap_RICserviceLoadStatusResponse_IEs_id_RICloadMeasurementID, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusResponse_IEs_id_E2nodeLoadMeasurementID:
            if(asn1PrtToStr_e2ap_LoadMeasurementID("LoadMeasurementID", 
                    pvalue->value.u._e2ap_RICserviceLoadStatusResponse_IEs_id_E2nodeLoadMeasurementID, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusResponse_IEs_id_RANfunctionLoadConfirm_List:
            if(asn1PrtToStr_e2ap_RANfunctionLoadConfirm_List("RANfunctionLoadConfirm-List", 
                    pvalue->value.u._e2ap_RICserviceLoadStatusResponse_IEs_id_RANfunctionLoadConfirm_List, buffer, bufSize)<0)
                return -1;
            break;    
        default:
        if(0!=pvalue -> value.u.extElem1){
            rtPrintToStringIndent(buffer, bufSize);
            rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

        }
        }
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

    return 0;

 }

 void asn1Free_e2ap_RICserviceLoadStatusResponse_protocolIEs_element(OSCTXT* pctxt, e2ap_RICserviceLoadStatusResponse_protocolIEs_element* pvalue){
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusResponse_IEs_id_RICloadMeasurementID:
            if(pvalue->value.u._e2ap_RICserviceLoadStatusResponse_IEs_id_RICloadMeasurementID!=NULL){
            asn1Free_e2ap_LoadMeasurementID(pctxt, pvalue->value.u._e2ap_RICserviceLoadStatusResponse_IEs_id_RICloadMeasurementID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICserviceLoadStatusResponse_IEs_id_RICloadMeasurementID);
            pvalue->value.u._e2ap_RICserviceLoadStatusResponse_IEs_id_RICloadMeasurementID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusResponse_IEs_id_E2nodeLoadMeasurementID:
            if(pvalue->value.u._e2ap_RICserviceLoadStatusResponse_IEs_id_E2nodeLoadMeasurementID!=NULL){
            asn1Free_e2ap_LoadMeasurementID(pctxt, pvalue->value.u._e2ap_RICserviceLoadStatusResponse_IEs_id_E2nodeLoadMeasurementID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICserviceLoadStatusResponse_IEs_id_E2nodeLoadMeasurementID);
            pvalue->value.u._e2ap_RICserviceLoadStatusResponse_IEs_id_E2nodeLoadMeasurementID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusResponse_IEs_id_RANfunctionLoadConfirm_List:
            if(pvalue->value.u._e2ap_RICserviceLoadStatusResponse_IEs_id_RANfunctionLoadConfirm_List!=NULL){
            asn1Free_e2ap_RANfunctionLoadConfirm_List(pctxt, pvalue->value.u._e2ap_RICserviceLoadStatusResponse_IEs_id_RANfunctionLoadConfirm_List);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICserviceLoadStatusResponse_IEs_id_RANfunctionLoadConfirm_List);
            pvalue->value.u._e2ap_RICserviceLoadStatusResponse_IEs_id_RANfunctionLoadConfirm_List = NULL;
            }
            break;
        default:
            break;


    }
 }

 

/*****************************************/
/*           RICserviceLoadStatusResponse                */
/*****************************************/
//2_container.c
/* 1. xxx_ProtocolIE -> mẫu cũ ở ie_big_msg */
EXTERN int asn1PE_e2ap_RICserviceLoadStatusResponse_protocolIEs (OSCTXT* pctxt, e2ap_RICserviceLoadStatusResponse_protocolIEs* pvalue)
{
    int stat =0;
    OSRTDListNode* pnode;
    OSUINT32 xx1;

    /*encode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pe_Length(pctxt, pvalue->count);
    if(stat<0) return LOG_RTERR(pctxt, stat);

    /*encode each element*/
    xx1 =0;
    for(pnode = pvalue->head; pnode != 0 && xx1<pvalue->count; pnode = pnode->next){
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE", xx1);
        stat = asn1PE_e2ap_RICserviceLoadStatusResponse_protocolIEs_element (pctxt, ((e2ap_RICserviceLoadStatusResponse_protocolIEs_element*)pnode->data));
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        xx1++;
        RTXCTXTPOPARRAYELEMNAME(pctxt);
    }

    return (stat);
}

EXTERN int  asn1PD_e2ap_RICserviceLoadStatusResponse_protocolIEs(OSCTXT* pctxt, e2ap_RICserviceLoadStatusResponse_protocolIEs* pvalue)
{
     int stat =0;
     OSRTDListNode* pnode;
     OSSIZE count =0;
     OSSIZE xx1=0;


     /*decode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pd_Length64(pctxt, &count); //tai sao lai 64
    if(stat!=0) return LOG_RTERR(pctxt, stat);

    /*decode each element*/
    rtxDListInit(pvalue);

    for(xx1=0; xx1 < count; xx1++){
        e2ap_RICserviceLoadStatusResponse_protocolIEs_element* pdata;
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE",xx1);

        if(pnode == NULL) return LOG_RTERR(pctxt, RTERR_NOMEM);

        asn1Init_e2ap_RICserviceLoadStatusResponse_protocolIEs_element(pdata);
        rtxDListAppendNode(pvalue, pnode);
        stat = asn1PD_e2ap_RICserviceLoadStatusResponse_protocolIEs_element (pctxt, pdata);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        RTXCTXTPOPARRAYELEMNAME(pctxt);

    }
    return (stat);
}


int asn1Init_e2ap_RICserviceLoadStatusResponse_protocolIEs(e2ap_RICserviceLoadStatusResponse_protocolIEs* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    rtxDListFastInit (pvalue);
    return 0;
}
#if 1 //ao that day
void asn1Free_e2ap_RICserviceLoadStatusResponse_protocolIEs(OSCTXT* pctxt, e2ap_RICserviceLoadStatusResponse_protocolIEs* pvalue)
{
    if(0==pvalue) return;   
    e2ap_RICserviceLoadStatusResponse_protocolIEs_element* pdata;
    OSRTDListNode* pnode=pvalue->head;
    while(0!=pnode){
        pdata = (e2ap_RICserviceLoadStatusResponse_protocolIEs_element*)pnode->data;
       // asn1Free_e2ap_RICserviceLoadStatusResponse_protocolIEs_element(pctxt, pdata);
        pnode = pnode->next;
    }
    rtxDListFreeAll(pctxt, pvalue);
}
#endif


EXTERN int asn1PrtToStr_e2ap_RICserviceLoadStatusResponse_protocolIEs(const char* name, e2ap_RICserviceLoadStatusResponse_protocolIEs* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_RICserviceLoadStatusResponse_protocolIEs_element* pdata0;
    OSRTDListNode* pnode0;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode0 = pvalue->head;  xx1 < pvalue->count && pnode0 != 0; pnode0 = pnode0->next, xx1++){
        pdata0 = (e2ap_RICserviceLoadStatusResponse_protocolIEs_element*)pnode0->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 0
        if(asn1PrtToStr_e2ap_RICserviceLoadStatusResponse_protocolIEs_element(nameBuf, pdata0, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}


/*2 . RICserviceLoadStatusResponse -> mẫu cũ ở seq_normal*/

int asn1PE_e2ap_RICserviceLoadStatusResponse (OSCTXT* pctxt, e2ap_RICserviceLoadStatusResponse* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RICserviceLoadStatusResponse");
   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field protocolIEs - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
   stat = asn1PE_e2ap_RICserviceLoadStatusResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
   if(stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RICserviceLoadStatusResponse (OSCTXT* pctxt, e2ap_RICserviceLoadStatusResponse* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME(pctxt, "RICserviceLoadStatusResponse");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field protocolIEs */
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
      stat = asn1PD_e2ap_RICserviceLoadStatusResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RICserviceLoadStatusResponse (e2ap_RICserviceLoadStatusResponse* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RICserviceLoadStatusResponse_protocolIEs(&pvalue->protocolIEs);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RICserviceLoadStatusResponse (OSCTXT* pctxt, e2ap_RICserviceLoadStatusResponse* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_RICserviceLoadStatusResponse_protocolIEs(pctxt, &pvalue->protocolIEs);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RICserviceLoadStatusResponse (const char* name, e2ap_RICserviceLoadStatusResponse* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }

   if(asn1PrtToStr_e2ap_RICserviceLoadStatusResponse_protocolIEs("protocolIEs", &pvalue->protocolIEs, buffer, bufSize) <0){
      return -1;
   }

   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           RICserviceLoadStatusFailure_IEs                */
/*****************************************/
/* ie.c.j2 */
 /* d là con của msg */
EXTERN int asn1PE_e2ap_RICserviceLoadStatusFailure_protocolIEs_element (OSCTXT* pctxt, e2ap_RICserviceLoadStatusFailure_protocolIEs_element* pvalue)
{
    int stat =0;

    /*encode id*/

    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PE_e2ap_ProtocolIE_ID(pctxt, pvalue->id);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PE_e2ap_Criticality(pctxt, pvalue->criticality);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
    {
        OSCTXT lctxt;
        OSOCTET *pDynamicEncodeBuffer;
        ASN1OpenType openType;
        OSBOOL encoded = TRUE;

        openType.numocts = 0;
        openType.data =0;

        rtxCopyContext(&lctxt, pctxt);
        pctxt->pStream =0;

        stat = rtxInitContextBuffer(pctxt, 0, 0);
        if(stat!=0) return LOG_RTERR(pctxt, stat);

        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusFailure_IEs_id_RICloadMeasurementID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICloadMeasurementID");
                    stat = asn1PE_e2ap_LoadMeasurementID (pctxt, pvalue->value.u._e2ap_RICserviceLoadStatusFailure_IEs_id_RICloadMeasurementID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusFailure_IEs_id_E2nodeLoadMeasurementID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-E2nodeLoadMeasurementID");
                    stat = asn1PE_e2ap_LoadMeasurementID (pctxt, pvalue->value.u._e2ap_RICserviceLoadStatusFailure_IEs_id_E2nodeLoadMeasurementID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusFailure_IEs_id_Cause:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-Cause");
                    stat = asn1PE_e2ap_Cause (pctxt, pvalue->value.u._e2ap_RICserviceLoadStatusFailure_IEs_id_Cause);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusFailure_IEs_id_CriticalityDiagnostics:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-CriticalityDiagnostics");
                    stat = asn1PE_e2ap_CriticalityDiagnostics (pctxt, pvalue->value.u._e2ap_RICserviceLoadStatusFailure_IEs_id_CriticalityDiagnostics);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusFailure_IEs_UNDEF_:
            {
                if(0!=pvalue->value.u.extElem1){
                    openType.numocts = pvalue->value.u.extElem1->numocts;
                    openType.data = pvalue->value.u.extElem1->data;
                } else {
                    /* No extension element to encode */
                }
                encoded = FALSE;
                break;
            }

            default:
                encoded = FALSE;
                stat = RTERR_INVOPT;
                break;
        } 

        if(encoded){
            openType.numocts = (OSUINT32)pe_GetMsgLen(pctxt);
            openType.data = pDynamicEncodeBuffer = pctxt -> buffer.data;
        }
        rtxCopyContext(pctxt, &lctxt);

        if(stat == 0) {
            stat = pe_OpenType (pctxt, openType.numocts, openType.data);
        }
    #if 1
        if(encoded){//dungnm23 check lai nhe
            rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
        }
    #endif

    }

    if(stat!=0) return LOG_RTERR(pctxt, stat);  
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}

EXTERN int  asn1PD_e2ap_RICserviceLoadStatusFailure_protocolIEs_element (OSCTXT* pctxt, e2ap_RICserviceLoadStatusFailure_protocolIEs_element* pvalue){
    int stat =0;

    /*decode id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PD_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PD_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");

    {
        OSUINT32 openTypeLen;
        size_t bitStartOffset, bitLength;

        stat = pd_UnconsLength(pctxt, &openTypeLen);
        if(stat<0) return LOG_RTERR(pctxt, stat);
        else if(stat == RT_OK_FRAG){
            rtxErrAddStrParm(pctxt, "open type with fragment length");
            return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
        }
        bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
        bitLength = openTypeLen * 8;

        switch(pvalue->id){//dungnm23 check case lai nhe
        
            case ASN1V_e2ap_id_RICloadMeasurementID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusFailure_IEs_id_RICloadMeasurementID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICloadMeasurementID");
                pvalue->value.u._e2ap_RICserviceLoadStatusFailure_IEs_id_RICloadMeasurementID 
                    = rtxMemAllocType(pctxt, e2ap_LoadMeasurementID);

                asn1Init_e2ap_LoadMeasurementID(pvalue->value.u._e2ap_RICserviceLoadStatusFailure_IEs_id_RICloadMeasurementID);

                stat = asn1PD_e2ap_LoadMeasurementID (pctxt,
                        (e2ap_LoadMeasurementID*)pvalue->value.
                        u._e2ap_RICserviceLoadStatusFailure_IEs_id_RICloadMeasurementID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_E2nodeLoadMeasurementID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusFailure_IEs_id_E2nodeLoadMeasurementID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-E2nodeLoadMeasurementID");
                pvalue->value.u._e2ap_RICserviceLoadStatusFailure_IEs_id_E2nodeLoadMeasurementID 
                    = rtxMemAllocType(pctxt, e2ap_LoadMeasurementID);

                asn1Init_e2ap_LoadMeasurementID(pvalue->value.u._e2ap_RICserviceLoadStatusFailure_IEs_id_E2nodeLoadMeasurementID);

                stat = asn1PD_e2ap_LoadMeasurementID (pctxt,
                        (e2ap_LoadMeasurementID*)pvalue->value.
                        u._e2ap_RICserviceLoadStatusFailure_IEs_id_E2nodeLoadMeasurementID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_Cause:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusFailure_IEs_id_Cause;
            RTXCTXTPUSHELEMNAME(pctxt, "id-Cause");
                pvalue->value.u._e2ap_RICserviceLoadStatusFailure_IEs_id_Cause 
                    = rtxMemAllocType(pctxt, e2ap_Cause);

                asn1Init_e2ap_Cause(pvalue->value.u._e2ap_RICserviceLoadStatusFailure_IEs_id_Cause);

                stat = asn1PD_e2ap_Cause (pctxt,
                        (e2ap_Cause*)pvalue->value.
                        u._e2ap_RICserviceLoadStatusFailure_IEs_id_Cause);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_CriticalityDiagnostics:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusFailure_IEs_id_CriticalityDiagnostics;
            RTXCTXTPUSHELEMNAME(pctxt, "id-CriticalityDiagnostics");
                pvalue->value.u._e2ap_RICserviceLoadStatusFailure_IEs_id_CriticalityDiagnostics 
                    = rtxMemAllocType(pctxt, e2ap_CriticalityDiagnostics);

                asn1Init_e2ap_CriticalityDiagnostics(pvalue->value.u._e2ap_RICserviceLoadStatusFailure_IEs_id_CriticalityDiagnostics);

                stat = asn1PD_e2ap_CriticalityDiagnostics (pctxt,
                        (e2ap_CriticalityDiagnostics*)pvalue->value.
                        u._e2ap_RICserviceLoadStatusFailure_IEs_id_CriticalityDiagnostics);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusFailure_IEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*) rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
    }
    {
    size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
    size_t bitsConsumed = bitEndOffset-bitStartOffset;
    if(bitsConsumed<bitLength){
        stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
    }
    else stat =(bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
    }}
    if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}


int asn1Init_e2ap_RICserviceLoadStatusFailure_protocolIEs_element(e2ap_RICserviceLoadStatusFailure_protocolIEs_element* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    OSCRTLMEMSET (&pvalue->value, 0, sizeof(pvalue->value));
    return 0;
}


//-----> chuaw có template rtxFreeASN1OpenType

#if 0
void asn1Free_e2ap_RICserviceLoadStatusFailure_protocolIEs_element(OSCTXT* pctxt, e2ap_RICserviceLoadStatusFailure_protocolIEs_element* pvalue)
{
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusFailure_IEs_id_id_RICloadMeasurementID:
            // rtxFreeE2ap_LoadMeasurementID(pvalue->value.u._e2ap_RICserviceLoadStatusFailure_IEs_id_id_RICloadMeasurementID);

            if(pvalue->value.i._e2ap_RICserviceLoadStatusFailure_id_LoadMeasurementID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_LoadMeasurementID(pctxt, pvalue->value.u._e2ap_RICserviceLoadStatusFailure_IEs_id_id_RICloadMeasurementID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICserviceLoadStatusFailure_IEs_id_id_RICloadMeasurementID);
           // pvalue->value.u._e2ap_RICserviceLoadStatusFailure_IEs_id_id_RICloadMeasurementID = NULL;
           pvalue->value.u._e2ap_RICserviceLoadStatusFailure_IEs_id_RICloadMeasurementID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusFailure_IEs_id_id_E2nodeLoadMeasurementID:
            // rtxFreeE2ap_LoadMeasurementID(pvalue->value.u._e2ap_RICserviceLoadStatusFailure_IEs_id_id_E2nodeLoadMeasurementID);

            if(pvalue->value.i._e2ap_RICserviceLoadStatusFailure_id_LoadMeasurementID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_LoadMeasurementID(pctxt, pvalue->value.u._e2ap_RICserviceLoadStatusFailure_IEs_id_id_E2nodeLoadMeasurementID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICserviceLoadStatusFailure_IEs_id_id_E2nodeLoadMeasurementID);
           // pvalue->value.u._e2ap_RICserviceLoadStatusFailure_IEs_id_id_E2nodeLoadMeasurementID = NULL;
           pvalue->value.u._e2ap_RICserviceLoadStatusFailure_IEs_id_E2nodeLoadMeasurementID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusFailure_IEs_id_id_Cause:
            // rtxFreeE2ap_Cause(pvalue->value.u._e2ap_RICserviceLoadStatusFailure_IEs_id_id_Cause);

            if(pvalue->value.i._e2ap_RICserviceLoadStatusFailure_id_Cause!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_Cause(pctxt, pvalue->value.u._e2ap_RICserviceLoadStatusFailure_IEs_id_id_Cause);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICserviceLoadStatusFailure_IEs_id_id_Cause);
           // pvalue->value.u._e2ap_RICserviceLoadStatusFailure_IEs_id_id_Cause = NULL;
           pvalue->value.u._e2ap_RICserviceLoadStatusFailure_IEs_id_Cause = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusFailure_IEs_id_id_CriticalityDiagnostics:
            // rtxFreeE2ap_CriticalityDiagnostics(pvalue->value.u._e2ap_RICserviceLoadStatusFailure_IEs_id_id_CriticalityDiagnostics);

            if(pvalue->value.i._e2ap_RICserviceLoadStatusFailure_id_CriticalityDiagnostics!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_CriticalityDiagnostics(pctxt, pvalue->value.u._e2ap_RICserviceLoadStatusFailure_IEs_id_id_CriticalityDiagnostics);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICserviceLoadStatusFailure_IEs_id_id_CriticalityDiagnostics);
           // pvalue->value.u._e2ap_RICserviceLoadStatusFailure_IEs_id_id_CriticalityDiagnostics = NULL;
           pvalue->value.u._e2ap_RICserviceLoadStatusFailure_IEs_id_CriticalityDiagnostics = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusFailure_IEs_UNDEF_:
            rtxFreeASN1OpenType(pvalue->value.u.extElem1);
            break;
        default:
            break;
    }
}

int asn1PrtToStr_e2ap_RICserviceLoadStatusFailure_protocolIEs_element(OSCTXT* pctxt, e2ap_RICserviceLoadStatusFailure_protocolIEs_element* pvalue)
{
    int stat =0;
    RTXCTXTPUSHELEMNAME(pctxt, "e2ap_RICserviceLoadStatusFailure_protocolIEs_element");

    /*print id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PrtToStr_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PrtToStr_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusFailure_IEs_id_id_RICloadMeasurementID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "LoadMeasurementID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_LoadMeasurementID (pctxt, pvalue->value.u._e2ap_RICserviceLoadStatusFailure_IEs_id_id_RICloadMeasurementID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusFailure_IEs_id_id_E2nodeLoadMeasurementID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "LoadMeasurementID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_LoadMeasurementID (pctxt, pvalue->value.u._e2ap_RICserviceLoadStatusFailure_IEs_id_id_E2nodeLoadMeasurementID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusFailure_IEs_id_id_Cause:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "Cause");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_Cause (pctxt, pvalue->value.u._e2ap_RICserviceLoadStatusFailure_IEs_id_id_Cause);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusFailure_IEs_id_id_CriticalityDiagnostics:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "CriticalityDiagnostics");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_CriticalityDiagnostics (pctxt, pvalue->value.u._e2ap_RICserviceLoadStatusFailure_IEs_id_id_CriticalityDiagnostics);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusFailure_IEs_UNDEF_:
            {
                rtxPLogMsg(pctxt, "Extension element present - raw data not printed.\n");
                break;
            }

            default:
                stat = RTERR_INVOPT;
                return LOG_RTERR(pctxt, stat);
        }
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);
}
#endif


int asn1PrtToStr_e2ap_RICserviceLoadStatusFailure_protocolIEs_element (const char * name,
 e2ap_RICserviceLoadStatusFailure_protocolIEs_element* pvalue, 
 char * buffer, OSSIZE bufSize){
    if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
        return -1;
    if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
        return -1;

    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusFailure_IEs_id_RICloadMeasurementID:
            if(asn1PrtToStr_e2ap_LoadMeasurementID("LoadMeasurementID", 
                    pvalue->value.u._e2ap_RICserviceLoadStatusFailure_IEs_id_RICloadMeasurementID, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusFailure_IEs_id_E2nodeLoadMeasurementID:
            if(asn1PrtToStr_e2ap_LoadMeasurementID("LoadMeasurementID", 
                    pvalue->value.u._e2ap_RICserviceLoadStatusFailure_IEs_id_E2nodeLoadMeasurementID, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusFailure_IEs_id_Cause:
            if(asn1PrtToStr_e2ap_Cause("Cause", 
                    pvalue->value.u._e2ap_RICserviceLoadStatusFailure_IEs_id_Cause, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusFailure_IEs_id_CriticalityDiagnostics:
            if(asn1PrtToStr_e2ap_CriticalityDiagnostics("CriticalityDiagnostics", 
                    pvalue->value.u._e2ap_RICserviceLoadStatusFailure_IEs_id_CriticalityDiagnostics, buffer, bufSize)<0)
                return -1;
            break;    
        default:
        if(0!=pvalue -> value.u.extElem1){
            rtPrintToStringIndent(buffer, bufSize);
            rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

        }
        }
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

    return 0;

 }

 void asn1Free_e2ap_RICserviceLoadStatusFailure_protocolIEs_element(OSCTXT* pctxt, e2ap_RICserviceLoadStatusFailure_protocolIEs_element* pvalue){
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusFailure_IEs_id_RICloadMeasurementID:
            if(pvalue->value.u._e2ap_RICserviceLoadStatusFailure_IEs_id_RICloadMeasurementID!=NULL){
            asn1Free_e2ap_LoadMeasurementID(pctxt, pvalue->value.u._e2ap_RICserviceLoadStatusFailure_IEs_id_RICloadMeasurementID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICserviceLoadStatusFailure_IEs_id_RICloadMeasurementID);
            pvalue->value.u._e2ap_RICserviceLoadStatusFailure_IEs_id_RICloadMeasurementID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusFailure_IEs_id_E2nodeLoadMeasurementID:
            if(pvalue->value.u._e2ap_RICserviceLoadStatusFailure_IEs_id_E2nodeLoadMeasurementID!=NULL){
            asn1Free_e2ap_LoadMeasurementID(pctxt, pvalue->value.u._e2ap_RICserviceLoadStatusFailure_IEs_id_E2nodeLoadMeasurementID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICserviceLoadStatusFailure_IEs_id_E2nodeLoadMeasurementID);
            pvalue->value.u._e2ap_RICserviceLoadStatusFailure_IEs_id_E2nodeLoadMeasurementID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusFailure_IEs_id_Cause:
            if(pvalue->value.u._e2ap_RICserviceLoadStatusFailure_IEs_id_Cause!=NULL){
            asn1Free_e2ap_Cause(pctxt, pvalue->value.u._e2ap_RICserviceLoadStatusFailure_IEs_id_Cause);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICserviceLoadStatusFailure_IEs_id_Cause);
            pvalue->value.u._e2ap_RICserviceLoadStatusFailure_IEs_id_Cause = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICserviceLoadStatusFailure_IEs_id_CriticalityDiagnostics:
            if(pvalue->value.u._e2ap_RICserviceLoadStatusFailure_IEs_id_CriticalityDiagnostics!=NULL){
            asn1Free_e2ap_CriticalityDiagnostics(pctxt, pvalue->value.u._e2ap_RICserviceLoadStatusFailure_IEs_id_CriticalityDiagnostics);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICserviceLoadStatusFailure_IEs_id_CriticalityDiagnostics);
            pvalue->value.u._e2ap_RICserviceLoadStatusFailure_IEs_id_CriticalityDiagnostics = NULL;
            }
            break;
        default:
            break;


    }
 }

 

/*****************************************/
/*           RICserviceLoadStatusFailure                */
/*****************************************/
//2_container.c
/* 1. xxx_ProtocolIE -> mẫu cũ ở ie_big_msg */
EXTERN int asn1PE_e2ap_RICserviceLoadStatusFailure_protocolIEs (OSCTXT* pctxt, e2ap_RICserviceLoadStatusFailure_protocolIEs* pvalue)
{
    int stat =0;
    OSRTDListNode* pnode;
    OSUINT32 xx1;

    /*encode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pe_Length(pctxt, pvalue->count);
    if(stat<0) return LOG_RTERR(pctxt, stat);

    /*encode each element*/
    xx1 =0;
    for(pnode = pvalue->head; pnode != 0 && xx1<pvalue->count; pnode = pnode->next){
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE", xx1);
        stat = asn1PE_e2ap_RICserviceLoadStatusFailure_protocolIEs_element (pctxt, ((e2ap_RICserviceLoadStatusFailure_protocolIEs_element*)pnode->data));
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        xx1++;
        RTXCTXTPOPARRAYELEMNAME(pctxt);
    }

    return (stat);
}

EXTERN int  asn1PD_e2ap_RICserviceLoadStatusFailure_protocolIEs(OSCTXT* pctxt, e2ap_RICserviceLoadStatusFailure_protocolIEs* pvalue)
{
     int stat =0;
     OSRTDListNode* pnode;
     OSSIZE count =0;
     OSSIZE xx1=0;


     /*decode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pd_Length64(pctxt, &count); //tai sao lai 64
    if(stat!=0) return LOG_RTERR(pctxt, stat);

    /*decode each element*/
    rtxDListInit(pvalue);

    for(xx1=0; xx1 < count; xx1++){
        e2ap_RICserviceLoadStatusFailure_protocolIEs_element* pdata;
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE",xx1);

        if(pnode == NULL) return LOG_RTERR(pctxt, RTERR_NOMEM);

        asn1Init_e2ap_RICserviceLoadStatusFailure_protocolIEs_element(pdata);
        rtxDListAppendNode(pvalue, pnode);
        stat = asn1PD_e2ap_RICserviceLoadStatusFailure_protocolIEs_element (pctxt, pdata);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        RTXCTXTPOPARRAYELEMNAME(pctxt);

    }
    return (stat);
}


int asn1Init_e2ap_RICserviceLoadStatusFailure_protocolIEs(e2ap_RICserviceLoadStatusFailure_protocolIEs* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    rtxDListFastInit (pvalue);
    return 0;
}
#if 1 //ao that day
void asn1Free_e2ap_RICserviceLoadStatusFailure_protocolIEs(OSCTXT* pctxt, e2ap_RICserviceLoadStatusFailure_protocolIEs* pvalue)
{
    if(0==pvalue) return;   
    e2ap_RICserviceLoadStatusFailure_protocolIEs_element* pdata;
    OSRTDListNode* pnode=pvalue->head;
    while(0!=pnode){
        pdata = (e2ap_RICserviceLoadStatusFailure_protocolIEs_element*)pnode->data;
       // asn1Free_e2ap_RICserviceLoadStatusFailure_protocolIEs_element(pctxt, pdata);
        pnode = pnode->next;
    }
    rtxDListFreeAll(pctxt, pvalue);
}
#endif


EXTERN int asn1PrtToStr_e2ap_RICserviceLoadStatusFailure_protocolIEs(const char* name, e2ap_RICserviceLoadStatusFailure_protocolIEs* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_RICserviceLoadStatusFailure_protocolIEs_element* pdata0;
    OSRTDListNode* pnode0;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode0 = pvalue->head;  xx1 < pvalue->count && pnode0 != 0; pnode0 = pnode0->next, xx1++){
        pdata0 = (e2ap_RICserviceLoadStatusFailure_protocolIEs_element*)pnode0->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 0
        if(asn1PrtToStr_e2ap_RICserviceLoadStatusFailure_protocolIEs_element(nameBuf, pdata0, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}


/*2 . RICserviceLoadStatusFailure -> mẫu cũ ở seq_normal*/

int asn1PE_e2ap_RICserviceLoadStatusFailure (OSCTXT* pctxt, e2ap_RICserviceLoadStatusFailure* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RICserviceLoadStatusFailure");
   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field protocolIEs - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
   stat = asn1PE_e2ap_RICserviceLoadStatusFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
   if(stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RICserviceLoadStatusFailure (OSCTXT* pctxt, e2ap_RICserviceLoadStatusFailure* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME(pctxt, "RICserviceLoadStatusFailure");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field protocolIEs */
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
      stat = asn1PD_e2ap_RICserviceLoadStatusFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RICserviceLoadStatusFailure (e2ap_RICserviceLoadStatusFailure* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RICserviceLoadStatusFailure_protocolIEs(&pvalue->protocolIEs);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RICserviceLoadStatusFailure (OSCTXT* pctxt, e2ap_RICserviceLoadStatusFailure* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_RICserviceLoadStatusFailure_protocolIEs(pctxt, &pvalue->protocolIEs);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RICserviceLoadStatusFailure (const char* name, e2ap_RICserviceLoadStatusFailure* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }

   if(asn1PrtToStr_e2ap_RICserviceLoadStatusFailure_protocolIEs("protocolIEs", &pvalue->protocolIEs, buffer, bufSize) <0){
      return -1;
   }

   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}
/*****************************************/
/*           RICloadInformation                */
/*****************************************/
//sequence normal
// Các nội dung cần thiết cho template seq_normal.c.j2
    // Nội dung của file .c cho primitive ENUMERATED
    //enumerated intergrate
//metadata.parsed.primitive_id == 13

//mau tu dapsresponseinfo-item -> dapsressponseindicator
const OSEnumItem e2ap_RICloadInformation_loadStatus_ENUMTAB[] = {
    {OSUTF8("overload"), 0,8,0},
    {OSUTF8("notoverload"), 1,11,1}
};

/* Encode / Decode */
EXTERN int asn1PE_e2ap_RICloadInformation_loadStatus (OSCTXT* pctxt, e2ap_RICloadInformation_loadStatus value){
    int stat =0;
    if(value >= 2) {
       rtxErrAddIntParm (pctxt, value);
       return LOG_RTERR (pctxt, RTERR_INVENUM);
    }

    /*extention bit*/
    stat = rtxEncBit (pctxt, 0);
    if(stat != 0) return LOG_RTERR (pctxt, stat);
    stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
    if(stat != 0) return LOG_RTERR (pctxt, stat);
    return stat;
}
EXTERN int asn1PD_e2ap_RICloadInformation_loadStatus (OSCTXT* pctxt, e2ap_RICloadInformation_loadStatus* pvalue){
    int stat = 0;
    OSUINT32 ui;
    OSBOOL extbit = FALSE;
    stat = DEC_BIT(pctxt, &extbit);
    if (stat != 0) return LOG_RTERR (pctxt, stat);

    if(extbit){
        stat = pd_SmallNonNegWholeNumber(pctxt, &ui);
        if(stat != 0) return LOG_RTERR (pctxt, stat);
        *pvalue = ASN_K_EXTENUM;
    }else{
        stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
        if(stat != 0) return LOG_RTERR (pctxt, stat);
    }
    
    return stat;

}

/* Print helpers */
EXTERN void asn1Print_e2ap_RICloadInformation_loadStatus (const char* name, const e2ap_RICloadInformation_loadStatus* pvalue){
    rtxPrintIndent();
    printf("%s: ", name);
    switch(*pvalue) {
        case 0:
            printf("overload\n");
            break;
        case 1:
            printf("notoverload\n");
            break;
        default:
            printf("??? (%u)\n", *pvalue);
    }
}

/* Convert to stream (pretty print to stream) */
EXTERN int asn1PrtToStrm_e2ap_RICloadInformation_loadStatus (OSCTXT* pctxt, const char* name, const e2ap_RICloadInformation_loadStatus* pvalue){
    rtPrintToStringIndent(pctxt);
    rtPrintToStream(pctxt, name);
    switch(*pvalue) {
        case 0:
            rtPrintToStream(pctxt, " = overload \n");
            break;
        case 1:
            rtPrintToStream(pctxt, " = notoverload \n");
            break;
        default:
            rtPrintToStreamUnsigned(pctxt, " = ???\n", *pvalue);
    }
}

/* Convert to string (write into user buffer) */
EXTERN int asn1PrtToStr_e2ap_RICloadInformation_loadStatus (const char* name,e2ap_RICloadInformation_loadStatus* pvalue,  char* buffer,OSSIZE bufSize){
    int stat;
    
    if(rtPrintToStringIndent(buffer, bufSize) < 0) return -1;
    if(rtPrintToString(name, buffer, bufSize) < 0) return -1;
    
    switch(*pvalue) {
        case 0:
            stat = rtPrintToString(" = overload \n", buffer, bufSize);
            break;
        case 1:
            stat = rtPrintToString(" = notoverload \n", buffer, bufSize);
            break;
        default:
            stat = rtPrintToStringUnsigned(" = ???\n",*pvalue, buffer, bufSize);
    }
    
    if (stat < 0) return -1;
    return 0;   
}

/* Enum <-> String conversion */
EXTERN const OSUTF8CHAR* e2ap_RICloadInformation_loadStatus_ToString (OSUINT32 value){
    OSINT32 idx = value;
    if (idx >= 0 && idx < e2ap_RICloadInformation_loadStatus_ENUMTABSIZE) {
        return e2ap_RICloadInformation_loadStatus_ENUMTAB
        [e2ap_RICloadInformation_loadStatus_ENUMTAB[idx].transidx].name;
    } else {
        return OSUTF8("_UNKNOWN_");
    }
}
EXTERN int e2ap_RICloadInformation_loadStatus_ToEnum (OSCTXT* pctxt, const OSUTF8CHAR* value,e2ap_RICloadInformation_loadStatus* pvalue){
    OSSIZE valueLen = rtxUTF8LenBytes(value);
    return e2ap_RICloadInformation_loadStatus_ToEnum2 (pctxt, value, valueLen, pvalue);
}

EXTERN int e2ap_RICloadInformation_loadStatus_ToEnum2 (OSCTXT* pctxt, const OSUTF8CHAR* value, OSSIZE valueLen,e2ap_RICloadInformation_loadStatus* pvalue){
    OSINT32 idx = rtxLookupEnum(value, valueLen,
       e2ap_RICloadInformation_loadStatus_ENUMTAB, 
       e2ap_RICloadInformation_loadStatus_ENUMTABSIZE);
    if (idx >= 0) {
       *pvalue = (e2ap_RICloadInformation_loadStatus)e2ap_RICloadInformation_loadStatus_ENUMTAB[idx].value;
       return 0;
    } else {
       rtxErrAddStrParm (pctxt, (const char*)value);
       return LOG_RTERR (pctxt, RTERR_INVENUM);
    }
}

EXTERN int asn1Init_e2ap_RICloadInformation_loadStatus (e2ap_RICloadInformation_loadStatus* pvalue){
    //if (pvalue == 0) return RTERR_NULLPTR;
    //*pvalue = 0;
    return 0;
}
    // Nội dung của file .c cho primitive INTEGER (0..100)
    /*****************************************/
/*           loadEstimate                */
/*****************************************/
//interger intergrate
 //metadata.parsed.primitive_id == 6
// mau integer size(a...b) mau la timestayincell xn
//typedef OSUINT8 e2ap_RICloadInformation_loadEstimate;
EXTERN int asn1PE_e2ap_RICloadInformation_loadEstimate (OSCTXT* pctxt, e2ap_RICloadInformation_loadEstimate value){
    int stat =0;

    if(value<=100 && value>= 0){
        stat = pe_ConsUnsigned (pctxt, value, 0, 100);
        if(stat != 0) return LOG_RTERR (pctxt, stat);
    }else{
        rtxErrAddElemNameParm(pctxt);
        rtxErrAddUIntParm(pctxt, value);
        return LOG_RTERR(pctxt, RTERR_CONSVIO);
    }
    return stat;

}
EXTERN int asn1PD_e2ap_RICloadInformation_loadEstimate (OSCTXT* pctxt, e2ap_RICloadInformation_loadEstimate* pvalue){
    int stat =0;
    if(pctxt->buffer.aligned){
        int stat2 = PD_BYTE_ALIGN(pctxt);
        if(stat2 != 0) return LOG_RTERR (pctxt, stat2);
    }

    stat = rtxDecBitsToUInt16(pctxt, pvalue, pctxt->buffer.aligned ? 16:12);
    if(stat !=0) return LOG_RTERR (pctxt, stat);
    if(*pvalue > 100 || *pvalue < 0){
        rtxErrAddElemNameParm(pctxt);
        rtxErrAddUIntParm(pctxt, 100);
        return LOG_RTERR(pctxt, RTERR_CONSVIO);
    }
}
//EXTERN int asn1Print_e2ap_RICloadInformation_loadEstimate (const char* name, const e2ap_RICloadInformation_loadEstimate* pvalue);
EXTERN int asn1PrtToStr_e2ap_RICloadInformation_loadEstimate (const char* name, e2ap_RICloadInformation_loadEstimate* pvalue, char* buffer, OSSIZE bufSize){
    if(rtPrintToStringIndent(buffer, bufSize) < 0) return -1;
    if(rtPrintToStringUnsigned(name, *pvalue, buffer, bufSize) < 0) return -1;
    return 0;
}
//EXTERN int asn1PrtToStrm_e2ap_RICloadInformation_loadEstimate (OSCTXT* pctxt, const char* name, const e2ap_RICloadInformation_loadEstimate* pvalue);
EXTERN int asn1Init_e2ap_RICloadInformation_loadEstimate (e2ap_RICloadInformation_loadEstimate* pvalue){
    //if (pvalue == 0) return RTERR_NULLPTR;
    //*pvalue = 0;
    return 0;
}
EXTERN int asn1Free_e2ap_RICloadInformation_loadEstimate (OSCTXT* pctxt, e2ap_RICloadInformation_loadEstimate* pvalue){
    // No dynamic memory to free for integer
    return 0;
}




// Các phần còn lại của template seq_normal.c.j2
//contain extensition bit -> theo mau cua GlobalgNB-ID
int asn1PE_e2ap_RICloadInformation (OSCTXT* pctxt, e2ap_RICloadInformation* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RICloadInformation");

   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);

   /*optional bit for field loadStatus*/
   stat = rtxEncBit (pctxt, pvalue->m_loadStatusPresent);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   /*optional bit for field loadEstimate*/
   stat = rtxEncBit (pctxt, pvalue->m_loadEstimatePresent);
   if (stat != 0) return LOG_RTERR(pctxt, stat);

   /*encode root elements*/   
   /* encode field loadStatus - id = 13*/  
   if (pvalue->m_loadStatusPresent) {//OPTIONAL FIELD
   RTXCTXTPUSHELEMNAME(pctxt, "loadStatus");
   stat = asn1PE_e2ap_RICloadInformation_loadStatus(pctxt, &pvalue->loadStatus); //enum inter prim
  
  
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   }

   /* encode field loadEstimate - id = 6*/  
   if (pvalue->m_loadEstimatePresent) {//OPTIONAL FIELD
   RTXCTXTPUSHELEMNAME(pctxt, "loadEstimate");
   stat = asn1PE_e2ap_RICloadInformation_loadEstimate(pctxt, pvalue->loadEstimate); //intger mau 6 (a..b)
  
  
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   }


   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RICloadInformation (OSCTXT* pctxt, e2ap_RICloadInformation* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME(pctxt, "RICloadInformation");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field loadStatus */
   RTXCTXTPUSHELEMNAME(pctxt, "loadStatus");
   if (optbits[0]) {
      pvalue->m_loadStatusPresent = TRUE;
      stat = asn1PD_e2ap_RICloadInformation_loadStatus (pctxt, &pvalue->loadStatus); //primitive
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   } else {
      pvalue->m_loadStatusPresent = FALSE;
   }
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field loadEstimate */
   RTXCTXTPUSHELEMNAME(pctxt, "loadEstimate");
   if (optbits[0]) {
      pvalue->m_loadEstimatePresent = TRUE;
      stat = asn1PD_e2ap_RICloadInformation_loadEstimate (pctxt, &pvalue->loadEstimate); //primitive
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   } else {
      pvalue->m_loadEstimatePresent = FALSE;
   }
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RICloadInformation (e2ap_RICloadInformation* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RICloadInformation_loadStatus (&pvalue->loadStatus); //primitive delete &
   asn1Init_e2ap_RICloadInformation_loadEstimate (&pvalue->loadEstimate); //primitive delete &
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RICloadInformation (OSCTXT* pctxt, e2ap_RICloadInformation* pvalue)
{
   if(0==pvalue) return;
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RICloadInformation (const char* name, e2ap_RICloadInformation* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }

   if(asn1PrtToStr_e2ap_RICloadInformation_loadStatus ("loadStatus", &pvalue->loadStatus, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_RICloadInformation_loadEstimate ("loadEstimate", &pvalue->loadEstimate, buffer, bufSize) < 0)
   {
      return -1;
   }


   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}
/*****************************************/
/*           RICserviceLoadInformation                */
/*****************************************/
//sequence normal
// Các nội dung cần thiết cho template seq_normal.c.j2

// Các phần còn lại của template seq_normal.c.j2
//contain extensition bit -> theo mau cua GlobalgNB-ID
int asn1PE_e2ap_RICserviceLoadInformation (OSCTXT* pctxt, e2ap_RICserviceLoadInformation* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RICserviceLoadInformation");

   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);

   /*optional bit for field ricServiceReportLoadInformation*/
   stat = rtxEncBit (pctxt, pvalue->m_ricServiceReportLoadInformationPresent);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   /*optional bit for field ricServiceInsertLoadInformation*/
   stat = rtxEncBit (pctxt, pvalue->m_ricServiceInsertLoadInformationPresent);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   /*optional bit for field ricServiceControlLoadInformation*/
   stat = rtxEncBit (pctxt, pvalue->m_ricServiceControlLoadInformationPresent);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   /*optional bit for field ricServicePolicyLoadInformation*/
   stat = rtxEncBit (pctxt, pvalue->m_ricServicePolicyLoadInformationPresent);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   /*optional bit for field ricServiceQueryLoadInformation*/
   stat = rtxEncBit (pctxt, pvalue->m_ricServiceQueryLoadInformationPresent);
   if (stat != 0) return LOG_RTERR(pctxt, stat);

   /*encode root elements*/   
   /* encode field ricServiceReportLoadInformation - id = -1*/  
   if (pvalue->m_ricServiceReportLoadInformationPresent) {//OPTIONAL FIELD
   RTXCTXTPUSHELEMNAME(pctxt, "ricServiceReportLoadInformation");
   stat = asn1PE_e2ap_RICloadInformation (pctxt, pvalue->ricServiceReportLoadInformation);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   }

   /* encode field ricServiceInsertLoadInformation - id = -1*/  
   if (pvalue->m_ricServiceInsertLoadInformationPresent) {//OPTIONAL FIELD
   RTXCTXTPUSHELEMNAME(pctxt, "ricServiceInsertLoadInformation");
   stat = asn1PE_e2ap_RICloadInformation (pctxt, pvalue->ricServiceInsertLoadInformation);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   }

   /* encode field ricServiceControlLoadInformation - id = -1*/  
   if (pvalue->m_ricServiceControlLoadInformationPresent) {//OPTIONAL FIELD
   RTXCTXTPUSHELEMNAME(pctxt, "ricServiceControlLoadInformation");
   stat = asn1PE_e2ap_RICloadInformation (pctxt, pvalue->ricServiceControlLoadInformation);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   }

   /* encode field ricServicePolicyLoadInformation - id = -1*/  
   if (pvalue->m_ricServicePolicyLoadInformationPresent) {//OPTIONAL FIELD
   RTXCTXTPUSHELEMNAME(pctxt, "ricServicePolicyLoadInformation");
   stat = asn1PE_e2ap_RICloadInformation (pctxt, pvalue->ricServicePolicyLoadInformation);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   }

   /* encode field ricServiceQueryLoadInformation - id = -1*/  
   if (pvalue->m_ricServiceQueryLoadInformationPresent) {//OPTIONAL FIELD
   RTXCTXTPUSHELEMNAME(pctxt, "ricServiceQueryLoadInformation");
   stat = asn1PE_e2ap_RICloadInformation (pctxt, pvalue->ricServiceQueryLoadInformation);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   }


   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RICserviceLoadInformation (OSCTXT* pctxt, e2ap_RICserviceLoadInformation* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[5];

   RTXCTXTPUSHTYPENAME(pctxt, "RICserviceLoadInformation");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 5; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field ricServiceReportLoadInformation */
   RTXCTXTPUSHELEMNAME(pctxt, "ricServiceReportLoadInformation");
   if (optbits[0]) {
      pvalue->m_ricServiceReportLoadInformationPresent = TRUE;
      stat = asn1PD_e2ap_RICloadInformation (pctxt, &pvalue->ricServiceReportLoadInformation);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   } else {
      pvalue->m_ricServiceReportLoadInformationPresent = FALSE;
   }
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field ricServiceInsertLoadInformation */
   RTXCTXTPUSHELEMNAME(pctxt, "ricServiceInsertLoadInformation");
   if (optbits[0]) {
      pvalue->m_ricServiceInsertLoadInformationPresent = TRUE;
      stat = asn1PD_e2ap_RICloadInformation (pctxt, &pvalue->ricServiceInsertLoadInformation);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   } else {
      pvalue->m_ricServiceInsertLoadInformationPresent = FALSE;
   }
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field ricServiceControlLoadInformation */
   RTXCTXTPUSHELEMNAME(pctxt, "ricServiceControlLoadInformation");
   if (optbits[0]) {
      pvalue->m_ricServiceControlLoadInformationPresent = TRUE;
      stat = asn1PD_e2ap_RICloadInformation (pctxt, &pvalue->ricServiceControlLoadInformation);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   } else {
      pvalue->m_ricServiceControlLoadInformationPresent = FALSE;
   }
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field ricServicePolicyLoadInformation */
   RTXCTXTPUSHELEMNAME(pctxt, "ricServicePolicyLoadInformation");
   if (optbits[0]) {
      pvalue->m_ricServicePolicyLoadInformationPresent = TRUE;
      stat = asn1PD_e2ap_RICloadInformation (pctxt, &pvalue->ricServicePolicyLoadInformation);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   } else {
      pvalue->m_ricServicePolicyLoadInformationPresent = FALSE;
   }
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field ricServiceQueryLoadInformation */
   RTXCTXTPUSHELEMNAME(pctxt, "ricServiceQueryLoadInformation");
   if (optbits[0]) {
      pvalue->m_ricServiceQueryLoadInformationPresent = TRUE;
      stat = asn1PD_e2ap_RICloadInformation (pctxt, &pvalue->ricServiceQueryLoadInformation);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   } else {
      pvalue->m_ricServiceQueryLoadInformationPresent = FALSE;
   }
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RICserviceLoadInformation (e2ap_RICserviceLoadInformation* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RICloadInformation (&pvalue->ricServiceReportLoadInformation);
   asn1Init_e2ap_RICloadInformation (&pvalue->ricServiceInsertLoadInformation);
   asn1Init_e2ap_RICloadInformation (&pvalue->ricServiceControlLoadInformation);
   asn1Init_e2ap_RICloadInformation (&pvalue->ricServicePolicyLoadInformation);
   asn1Init_e2ap_RICloadInformation (&pvalue->ricServiceQueryLoadInformation);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RICserviceLoadInformation (OSCTXT* pctxt, e2ap_RICserviceLoadInformation* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_RICloadInformation (pctxt, &pvalue->ricServiceReportLoadInformation);
   asn1Free_e2ap_RICloadInformation (pctxt, &pvalue->ricServiceInsertLoadInformation);
   asn1Free_e2ap_RICloadInformation (pctxt, &pvalue->ricServiceControlLoadInformation);
   asn1Free_e2ap_RICloadInformation (pctxt, &pvalue->ricServicePolicyLoadInformation);
   asn1Free_e2ap_RICloadInformation (pctxt, &pvalue->ricServiceQueryLoadInformation);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RICserviceLoadInformation (const char* name, e2ap_RICserviceLoadInformation* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }
   if(asn1PrtToStr_e2ap_RICloadInformation ("ricServiceReportLoadInformation", &pvalue->ricServiceReportLoadInformation, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_RICloadInformation ("ricServiceInsertLoadInformation", &pvalue->ricServiceInsertLoadInformation, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_RICloadInformation ("ricServiceControlLoadInformation", &pvalue->ricServiceControlLoadInformation, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_RICloadInformation ("ricServicePolicyLoadInformation", &pvalue->ricServicePolicyLoadInformation, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_RICloadInformation ("ricServiceQueryLoadInformation", &pvalue->ricServiceQueryLoadInformation, buffer, bufSize) < 0)
   {
      return -1;
   }



   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}
/*****************************************/
/*           RICactionLoad-Item                */
/*****************************************/
//sequence normal
// Các nội dung cần thiết cho template seq_normal.c.j2

// Các phần còn lại của template seq_normal.c.j2
//contain extensition bit -> theo mau cua GlobalgNB-ID
int asn1PE_e2ap_RICactionLoad_Item (OSCTXT* pctxt, e2ap_RICactionLoad_Item* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RICactionLoad-Item");

   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field ricActionID - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "ricActionID");
   stat = asn1PE_e2ap_RICactionID (pctxt, pvalue->ricActionID);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /* encode field ricActionLoadInformation - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "ricActionLoadInformation");
   stat = asn1PE_e2ap_RICloadInformation (pctxt, pvalue->ricActionLoadInformation);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);



   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RICactionLoad_Item (OSCTXT* pctxt, e2ap_RICactionLoad_Item* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME(pctxt, "RICactionLoad-Item");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field ricActionID */
   RTXCTXTPUSHELEMNAME(pctxt, "ricActionID");
      stat = asn1PD_e2ap_RICactionID (pctxt, &pvalue->ricActionID);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field ricActionLoadInformation */
   RTXCTXTPUSHELEMNAME(pctxt, "ricActionLoadInformation");
      stat = asn1PD_e2ap_RICloadInformation (pctxt, &pvalue->ricActionLoadInformation);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RICactionLoad_Item (e2ap_RICactionLoad_Item* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RICactionID (&pvalue->ricActionID);
   asn1Init_e2ap_RICloadInformation (&pvalue->ricActionLoadInformation);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RICactionLoad_Item (OSCTXT* pctxt, e2ap_RICactionLoad_Item* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_RICactionID (pctxt, &pvalue->ricActionID);
   asn1Free_e2ap_RICloadInformation (pctxt, &pvalue->ricActionLoadInformation);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RICactionLoad_Item (const char* name, e2ap_RICactionLoad_Item* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }
   if(asn1PrtToStr_e2ap_RICactionID ("ricActionID", &pvalue->ricActionID, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_RICloadInformation ("ricActionLoadInformation", &pvalue->ricActionLoadInformation, buffer, bufSize) < 0)
   {
      return -1;
   }



   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           RICactionLoad_ItemIEs                */
/*****************************************/
/* ie.c.j2 */
/*ie thường*/
int asn1PE_e2ap_RICactionLoad_ItemIEs (OSCTXT* pctxt, e2ap_RICactionLoad_ItemIEs* pvalue)
{
   int stat = 0;
   //RTXCTXTPUSHTYPENAME (pctxt, "RICactionLoad-ItemIEs");

   /* encode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");
   stat = asn1PE_e2ap_ProtocolIE_ID (pctxt, pvalue->id);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");
   stat = asn1PE_e2ap_Criticality (pctxt, pvalue->criticality);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   {
      OSCTXT ictxt;
      OSOCTET* pDynamicEncodeBuffer;
      ASN1OpenType openType;
      OSBOOL  encoded = TRUE;

      openType.numocts = 0;
      openType.data = 0;

      rtxCopyContext (&ictxt, pctxt);
      pctxt->pStream = 0;

      stat = rtxInitContextBuffer (pctxt, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_RICactionLoad_ItemIEs_id_RICactionLoad_Item:
         
        // RTXCTXTPUSHELEMNAME (pctxt, "RICactionLoad_ItemIEs_id_RICactionLoad_Item");
         RTXCTXTPUSHELEMNAME (pctxt, "RICactionLoad-Item");
         stat = asn1PE_e2ap_RICactionLoad_Item (pctxt, pvalue->value.u._e2apRICactionLoad_ItemIEs_id_RICactionLoad_Item);
         RTXCTXTPOPELEMNAME (pctxt);
      
         break;

      case T_E2AP_PDU_Contents_e2ap_RICactionLoad_ItemIEs_UNDEF_:
      {
          if(0!=pvalue->value.u.extElem1){
              openType.numocts = pvalue->value.u.extElem1->numocts;
              openType.data = pvalue->value.u.extElem1->data;
          } else {
              /* No extension element to encode */
          }
          encoded = FALSE;
          break;
      }
      default:
         encoded = FALSE;
         stat = RTERR_INVOPT;
      }

      if (encoded) {
         openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
         openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
      }
      rtxCopyContext (pctxt, &ictxt);
      if(stat ==0) stat = pe_OpenType(pctxt, openType.numocts, openType.data);
      /*free dynamic encode buffer*/
      if(encoded){
          rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
      }
   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);
   //RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

int asn1PD_e2ap_RICactionLoad_ItemIEs (OSCTXT* pctxt, e2ap_RICactionLoad_ItemIEs* pvalue)
{
   int stat =0;
   /*deode root element id*/
   RTXCTXTPUSHELEMNAME(pctxt, "id");
   stat = asn1PD_e2ap_ProtocolIE_ID (pctxt, &pvalue->id);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*decode root element criticality*/
   RTXCTXTPUSHELEMNAME(pctxt, "criticality");
   stat = asn1PD_e2ap_Criticality (pctxt, &pvalue->criticality);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   /*decode root element value*/
   RTXCTXTPUSHELEMNAME(pctxt, "value");
   {
      OSUINT32 openTypeLen;
      size_t bitStartOffset, bitLength;
      stat = pd_UnconsLength(pctxt, &openTypeLen);
      if(stat <0) return LOG_RTERR(pctxt, stat);
      else if(stat == RT_OK_FRAG){
         rtxErrAddStrParm(pctxt, "open type with fragmented length use - perindef");
         return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
      }
      bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
      bitLength = openTypeLen * 8;
      switch (pvalue->id){
         case T_E2AP_PDU_Contents_e2ap_RICactionLoad_ItemIEs_id_RICactionLoad_Item:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICactionLoad_ItemIEs_id_RICactionLoad_Item;
            RTXCTXTPUSHELEMNAME(pctxt, "RICactionLoad-Item");
            //pvalue->value.u._e2ap_RICactionLoad_ItemIEs_id_id_RICactionLoad_Item 
             pvalue->value.u._e2apRICactionLoad_ItemIEs_id_RICactionLoad_Item 
                    = rtxMemAllocType(pctxt, e2ap_RICactionLoad_Item);
            //asn1Init_e2ap_RICactionLoad_Item(pvalue->value.u._e2ap_RICactionLoad_ItemIEs_id_id_RICactionLoad_Item);
            asn1Init_e2ap_RICactionLoad_Item(pvalue->value.u._e2apRICactionLoad_ItemIEs_id_RICactionLoad_Item);
            stat = asn1PD_e2ap_RICactionLoad_Item (pctxt,
                    (e2ap_RICactionLoad_Item*)pvalue->value.
                    u._e2apRICactionLoad_ItemIEs_id_RICactionLoad_Item);
            if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICactionLoad_ItemIEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*)rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
      }
      {
      size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
      size_t bitsConsumed = bitEndOffset - bitStartOffset;
      if(bitsConsumed < bitLength){
         stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
      } else {
         stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
      }
      }
   }
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   return stat;
}

void asn1Init_e2ap_RICactionLoad_ItemIEs (e2ap_RICactionLoad_ItemIEs* pvalue)
{
   if (!pvalue) return;
   OSCRTLMEMSET (pvalue, 0, sizeof(e2ap_RICactionLoad_ItemIEs));
}

#if 0
void asn1Free_e2ap_RICactionLoad_ItemIEs (OSCTXT* pctxt, e2ap_RICactionLoad_ItemIEs* pvalue)
{
   if (!pvalue) return;
   if (pvalue->extElem1) {
      rtxMemFreeArray (pctxt, pvalue->extElem1);
      pvalue->extElem1 = 0;
      pvalue->extElem1_n = 0;
   }
}
#endif
void asn1Free_e2ap_RICactionLoad_ItemIEs (OSCTXT* pctxt, e2ap_RICactionLoad_ItemIEs* pvalue)
{
   if(0==pvalue) return;
   switch(pvalue->value.t){
      case T_E2AP_PDU_Contents_e2ap_RICactionLoad_ItemIEs_id_RICactionLoad_Item:
         asn1Free_e2ap_RICactionLoad_Item (pctxt, pvalue->value.u._e2apRICactionLoad_ItemIEs_id_RICactionLoad_Item);
         rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2apRICactionLoad_ItemIEs_id_RICactionLoad_Item);
         pvalue->value.u._e2apRICactionLoad_ItemIEs_id_RICactionLoad_Item = 0;
         break;
      case T_E2AP_PDU_Contents_e2ap_RICactionLoad_ItemIEs_UNDEF_:
         if(0!=pvalue->value.u.extElem1){
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1->data);
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
             pvalue->value.u.extElem1 =0;
         }
         break;
         default:;
   }
}

int  asn1PrtToStr_e2ap_RICactionLoad_ItemIEs (const char * name, e2ap_RICactionLoad_ItemIEs* pvalue, char * buffer, OSSIZE bufSize){
   if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
       return -1;

      if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
         return -1;

      if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
         return -1;
      if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
         return -1;
      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_RICactionLoad_ItemIEs_id_RICactionLoad_Item:
         if(asn1PrtToStr_e2ap_RICactionLoad_Item("RICactionLoad-Item",
                pvalue->value.u._e2apRICactionLoad_ItemIEs_id_RICactionLoad_Item, buffer, bufSize)<0)// dungnm23 check lai nhe xem la
            return -1;
         break;
      default:
         if(0!=pvalue -> value.u.extElem1){
             rtPrintToStringIndent(buffer, bufSize);
             rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

         }
      }
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

      return 0;

}
 

/*****************************************/
/*           RICactionLoad_List                */
/*****************************************/
//seq_of_single_container


int asn1PE_e2ap_RICactionLoad_List (OSCTXT* pctxt, e2ap_RICactionLoad_List* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_RICactionLoad_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "RICactionLoad-List");

   /* encode length determinant */
   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;
   for (xx1 = 0; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next, xx1++) {
      pdata = (e2ap_RICactionLoad_ItemIEs*) pnode->data;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_e2ap_RICactionLoad_ItemIEs (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      //xx1++;
      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}

int asn1PD_e2ap_RICactionLoad_List (OSCTXT* pctxt, e2ap_RICactionLoad_List* ppvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_RICactionLoad_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "RICactionLoad-List");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (ppvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      pdata = rtxMemAllocType (pctxt, e2ap_RICactionLoad_ItemIEs);
      if (!pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);
      asn1Init_e2ap_RICactionLoad_ItemIEs (pdata);
      stat = asn1PD_e2ap_RICactionLoad_ItemIEs (pctxt, pdata);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         return LOG_RTERR (pctxt, stat);
      }

      rtxDListAppendNode (ppvalue, pdata);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

void asn1Init_e2ap_RICactionLoad_List (e2ap_RICactionLoad_List* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
}

void asn1Free_e2ap_RICactionLoad_List (OSCTXT* pctxt, e2ap_RICactionLoad_List* pvalue)
{
   if(pvalue==0) return;
   OSRTDListNode* pnode = pvalue->head;
   while (pnode) {
      e2ap_RICactionLoad_ItemIEs* pdata = (e2ap_RICactionLoad_ItemIEs*) pnode->data;
      if (pdata) {
         asn1Free_e2ap_RICactionLoad_ItemIEs (pctxt, pdata);
         rtxMemFreePtr (pctxt, pdata);
      }
      pnode = pnode->next;
   }
      rtxDListFreeAll(pctxt, pvalue);
}

#if 0
void asn1Free_e2ap_RICactionLoad_List (OSCTXT* pctxt, e2ap_RICactionLoad_List* pvalue){
   if(0==pvalue ) return;
   {
      e2ap_RICactionLoad_ItemIEs * pdata;
      OSRTDListNode *pnode = pvalue->head;
      while(0!=pnode){
         pdata = (e2ap_RICactionLoad_ItemIEs*)pnode->data;
         asn1Free_e2ap_RICactionLoad_ItemIEs(pctxt, pdata);
         pnode = pnode->next;
      }
      rtxDListFreeAll(pctxt, pvalue);
   }
}
#endif


int asn1PrtToStr_e2ap_RICactionLoad_List(const char* name, e2ap_RICactionLoad_List* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_RICactionLoad_ItemIEs* pdata;
    OSRTDListNode* pnode;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode = pvalue->head;  xx1 < pvalue->count && pnode != 0; pnode = pnode->next, xx1++){
        pdata = (e2ap_RICactionLoad_ItemIEs*)pnode->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 1
        if(asn1PrtToStr_e2ap_RICactionLoad_ItemIEs(nameBuf, pdata, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}
/*****************************************/
/*           RICsubscriptionLoad-ItemIE                */
/*****************************************/
//sequence normal
// Các nội dung cần thiết cho template seq_normal.c.j2

// Các phần còn lại của template seq_normal.c.j2
//contain extensition bit -> theo mau cua GlobalgNB-ID
int asn1PE_e2ap_RICsubscriptionLoad_ItemIE (OSCTXT* pctxt, e2ap_RICsubscriptionLoad_ItemIE* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RICsubscriptionLoad-ItemIE");

   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);

   /*optional bit for field ricSubscriptionLoadInformation*/
   stat = rtxEncBit (pctxt, pvalue->m_ricSubscriptionLoadInformationPresent);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   /*optional bit for field ricActionLoad_list*/
   stat = rtxEncBit (pctxt, pvalue->m_ricActionLoad_listPresent);
   if (stat != 0) return LOG_RTERR(pctxt, stat);

   /*encode root elements*/   
   /* encode field ricRequestID - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "ricRequestID");
   stat = asn1PE_e2ap_RICrequestID (pctxt, pvalue->ricRequestID);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /* encode field ricSubscriptionLoadInformation - id = -1*/  
   if (pvalue->m_ricSubscriptionLoadInformationPresent) {//OPTIONAL FIELD
   RTXCTXTPUSHELEMNAME(pctxt, "ricSubscriptionLoadInformation");
   stat = asn1PE_e2ap_RICloadInformation (pctxt, pvalue->ricSubscriptionLoadInformation);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   }

   /* encode field ricActionLoad_list - id = -1*/  
   if (pvalue->m_ricActionLoad_listPresent) {//OPTIONAL FIELD
   RTXCTXTPUSHELEMNAME(pctxt, "ricActionLoad-list");
   stat = asn1PE_e2ap_RICactionLoad_List (pctxt, pvalue->ricActionLoad_list);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   }


   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RICsubscriptionLoad_ItemIE (OSCTXT* pctxt, e2ap_RICsubscriptionLoad_ItemIE* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[3];

   RTXCTXTPUSHTYPENAME(pctxt, "RICsubscriptionLoad-ItemIE");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field ricRequestID */
   RTXCTXTPUSHELEMNAME(pctxt, "ricRequestID");
      stat = asn1PD_e2ap_RICrequestID (pctxt, &pvalue->ricRequestID);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field ricSubscriptionLoadInformation */
   RTXCTXTPUSHELEMNAME(pctxt, "ricSubscriptionLoadInformation");
   if (optbits[0]) {
      pvalue->m_ricSubscriptionLoadInformationPresent = TRUE;
      stat = asn1PD_e2ap_RICloadInformation (pctxt, &pvalue->ricSubscriptionLoadInformation);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   } else {
      pvalue->m_ricSubscriptionLoadInformationPresent = FALSE;
   }
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field ricActionLoad_list */
   RTXCTXTPUSHELEMNAME(pctxt, "ricActionLoad-list");
   if (optbits[0]) {
      pvalue->m_ricActionLoad_listPresent = TRUE;
      stat = asn1PD_e2ap_RICactionLoad_List (pctxt, &pvalue->ricActionLoad_list);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   } else {
      pvalue->m_ricActionLoad_listPresent = FALSE;
   }
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RICsubscriptionLoad_ItemIE (e2ap_RICsubscriptionLoad_ItemIE* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RICrequestID (&pvalue->ricRequestID);
   asn1Init_e2ap_RICloadInformation (&pvalue->ricSubscriptionLoadInformation);
   asn1Init_e2ap_RICactionLoad_List (&pvalue->ricActionLoad_list);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RICsubscriptionLoad_ItemIE (OSCTXT* pctxt, e2ap_RICsubscriptionLoad_ItemIE* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_RICrequestID (pctxt, &pvalue->ricRequestID);
   asn1Free_e2ap_RICloadInformation (pctxt, &pvalue->ricSubscriptionLoadInformation);
   asn1Free_e2ap_RICactionLoad_List (pctxt, &pvalue->ricActionLoad_list);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RICsubscriptionLoad_ItemIE (const char* name, e2ap_RICsubscriptionLoad_ItemIE* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }
   if(asn1PrtToStr_e2ap_RICrequestID ("ricRequestID", &pvalue->ricRequestID, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_RICloadInformation ("ricSubscriptionLoadInformation", &pvalue->ricSubscriptionLoadInformation, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_RICactionLoad_List ("ricActionLoad_list", &pvalue->ricActionLoad_list, buffer, bufSize) < 0)
   {
      return -1;
   }



   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           RICsubscriptionLoad_ItemIEs                */
/*****************************************/
/* ie.c.j2 */
/*ie thường*/
int asn1PE_e2ap_RICsubscriptionLoad_ItemIEs (OSCTXT* pctxt, e2ap_RICsubscriptionLoad_ItemIEs* pvalue)
{
   int stat = 0;
   //RTXCTXTPUSHTYPENAME (pctxt, "RICsubscriptionLoad-ItemIEs");

   /* encode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");
   stat = asn1PE_e2ap_ProtocolIE_ID (pctxt, pvalue->id);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");
   stat = asn1PE_e2ap_Criticality (pctxt, pvalue->criticality);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   {
      OSCTXT ictxt;
      OSOCTET* pDynamicEncodeBuffer;
      ASN1OpenType openType;
      OSBOOL  encoded = TRUE;

      openType.numocts = 0;
      openType.data = 0;

      rtxCopyContext (&ictxt, pctxt);
      pctxt->pStream = 0;

      stat = rtxInitContextBuffer (pctxt, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_RICsubscriptionLoad_ItemIEs_id_RICsubscriptionLoad_Item:
         
        // RTXCTXTPUSHELEMNAME (pctxt, "RICsubscriptionLoad_ItemIEs_id_RICsubscriptionLoad_ItemIE");
         RTXCTXTPUSHELEMNAME (pctxt, "RICsubscriptionLoad-ItemIE");
         stat = asn1PE_e2ap_RICsubscriptionLoad_ItemIE (pctxt, pvalue->value.u._e2apRICsubscriptionLoad_ItemIEs_id_RICsubscriptionLoad_Item);
         RTXCTXTPOPELEMNAME (pctxt);
      
         break;

      case T_E2AP_PDU_Contents_e2ap_RICsubscriptionLoad_ItemIEs_UNDEF_:
      {
          if(0!=pvalue->value.u.extElem1){
              openType.numocts = pvalue->value.u.extElem1->numocts;
              openType.data = pvalue->value.u.extElem1->data;
          } else {
              /* No extension element to encode */
          }
          encoded = FALSE;
          break;
      }
      default:
         encoded = FALSE;
         stat = RTERR_INVOPT;
      }

      if (encoded) {
         openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
         openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
      }
      rtxCopyContext (pctxt, &ictxt);
      if(stat ==0) stat = pe_OpenType(pctxt, openType.numocts, openType.data);
      /*free dynamic encode buffer*/
      if(encoded){
          rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
      }
   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);
   //RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

int asn1PD_e2ap_RICsubscriptionLoad_ItemIEs (OSCTXT* pctxt, e2ap_RICsubscriptionLoad_ItemIEs* pvalue)
{
   int stat =0;
   /*deode root element id*/
   RTXCTXTPUSHELEMNAME(pctxt, "id");
   stat = asn1PD_e2ap_ProtocolIE_ID (pctxt, &pvalue->id);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*decode root element criticality*/
   RTXCTXTPUSHELEMNAME(pctxt, "criticality");
   stat = asn1PD_e2ap_Criticality (pctxt, &pvalue->criticality);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   /*decode root element value*/
   RTXCTXTPUSHELEMNAME(pctxt, "value");
   {
      OSUINT32 openTypeLen;
      size_t bitStartOffset, bitLength;
      stat = pd_UnconsLength(pctxt, &openTypeLen);
      if(stat <0) return LOG_RTERR(pctxt, stat);
      else if(stat == RT_OK_FRAG){
         rtxErrAddStrParm(pctxt, "open type with fragmented length use - perindef");
         return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
      }
      bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
      bitLength = openTypeLen * 8;
      switch (pvalue->id){
         case T_E2AP_PDU_Contents_e2ap_RICsubscriptionLoad_ItemIEs_id_RICsubscriptionLoad_Item:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionLoad_ItemIEs_id_RICsubscriptionLoad_Item;
            RTXCTXTPUSHELEMNAME(pctxt, "RICsubscriptionLoad-ItemIE");
            //pvalue->value.u._e2ap_RICsubscriptionLoad_ItemIEs_id_id_RICsubscriptionLoad_Item 
             pvalue->value.u._e2apRICsubscriptionLoad_ItemIEs_id_RICsubscriptionLoad_Item 
                    = rtxMemAllocType(pctxt, e2ap_RICsubscriptionLoad_ItemIE);
            //asn1Init_e2ap_RICsubscriptionLoad_ItemIE(pvalue->value.u._e2ap_RICsubscriptionLoad_ItemIEs_id_id_RICsubscriptionLoad_Item);
            asn1Init_e2ap_RICsubscriptionLoad_ItemIE(pvalue->value.u._e2apRICsubscriptionLoad_ItemIEs_id_RICsubscriptionLoad_Item);
            stat = asn1PD_e2ap_RICsubscriptionLoad_ItemIE (pctxt,
                    (e2ap_RICsubscriptionLoad_ItemIE*)pvalue->value.
                    u._e2apRICsubscriptionLoad_ItemIEs_id_RICsubscriptionLoad_Item);
            if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionLoad_ItemIEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*)rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
      }
      {
      size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
      size_t bitsConsumed = bitEndOffset - bitStartOffset;
      if(bitsConsumed < bitLength){
         stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
      } else {
         stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
      }
      }
   }
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   return stat;
}

void asn1Init_e2ap_RICsubscriptionLoad_ItemIEs (e2ap_RICsubscriptionLoad_ItemIEs* pvalue)
{
   if (!pvalue) return;
   OSCRTLMEMSET (pvalue, 0, sizeof(e2ap_RICsubscriptionLoad_ItemIEs));
}

#if 0
void asn1Free_e2ap_RICsubscriptionLoad_ItemIEs (OSCTXT* pctxt, e2ap_RICsubscriptionLoad_ItemIEs* pvalue)
{
   if (!pvalue) return;
   if (pvalue->extElem1) {
      rtxMemFreeArray (pctxt, pvalue->extElem1);
      pvalue->extElem1 = 0;
      pvalue->extElem1_n = 0;
   }
}
#endif
void asn1Free_e2ap_RICsubscriptionLoad_ItemIEs (OSCTXT* pctxt, e2ap_RICsubscriptionLoad_ItemIEs* pvalue)
{
   if(0==pvalue) return;
   switch(pvalue->value.t){
      case T_E2AP_PDU_Contents_e2ap_RICsubscriptionLoad_ItemIEs_id_RICsubscriptionLoad_Item:
         asn1Free_e2ap_RICsubscriptionLoad_ItemIE (pctxt, pvalue->value.u._e2apRICsubscriptionLoad_ItemIEs_id_RICsubscriptionLoad_Item);
         rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2apRICsubscriptionLoad_ItemIEs_id_RICsubscriptionLoad_Item);
         pvalue->value.u._e2apRICsubscriptionLoad_ItemIEs_id_RICsubscriptionLoad_Item = 0;
         break;
      case T_E2AP_PDU_Contents_e2ap_RICsubscriptionLoad_ItemIEs_UNDEF_:
         if(0!=pvalue->value.u.extElem1){
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1->data);
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
             pvalue->value.u.extElem1 =0;
         }
         break;
         default:;
   }
}

int  asn1PrtToStr_e2ap_RICsubscriptionLoad_ItemIEs (const char * name, e2ap_RICsubscriptionLoad_ItemIEs* pvalue, char * buffer, OSSIZE bufSize){
   if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
       return -1;

      if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
         return -1;

      if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
         return -1;
      if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
         return -1;
      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_RICsubscriptionLoad_ItemIEs_id_RICsubscriptionLoad_Item:
         if(asn1PrtToStr_e2ap_RICsubscriptionLoad_ItemIE("RICsubscriptionLoad-ItemIE",
                pvalue->value.u._e2apRICsubscriptionLoad_ItemIEs_id_RICsubscriptionLoad_Item, buffer, bufSize)<0)// dungnm23 check lai nhe xem la
            return -1;
         break;
      default:
         if(0!=pvalue -> value.u.extElem1){
             rtPrintToStringIndent(buffer, bufSize);
             rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

         }
      }
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

      return 0;

}
 

/*****************************************/
/*           RICsubscriptionLoad_List                */
/*****************************************/
//seq_of_single_container


int asn1PE_e2ap_RICsubscriptionLoad_List (OSCTXT* pctxt, e2ap_RICsubscriptionLoad_List* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_RICsubscriptionLoad_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "RICsubscriptionLoad-List");

   /* encode length determinant */
   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1024), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;
   for (xx1 = 0; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next, xx1++) {
      pdata = (e2ap_RICsubscriptionLoad_ItemIEs*) pnode->data;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_e2ap_RICsubscriptionLoad_ItemIEs (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      //xx1++;
      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}

int asn1PD_e2ap_RICsubscriptionLoad_List (OSCTXT* pctxt, e2ap_RICsubscriptionLoad_List* ppvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_RICsubscriptionLoad_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "RICsubscriptionLoad-List");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1024), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (ppvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      pdata = rtxMemAllocType (pctxt, e2ap_RICsubscriptionLoad_ItemIEs);
      if (!pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);
      asn1Init_e2ap_RICsubscriptionLoad_ItemIEs (pdata);
      stat = asn1PD_e2ap_RICsubscriptionLoad_ItemIEs (pctxt, pdata);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         return LOG_RTERR (pctxt, stat);
      }

      rtxDListAppendNode (ppvalue, pdata);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

void asn1Init_e2ap_RICsubscriptionLoad_List (e2ap_RICsubscriptionLoad_List* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
}

void asn1Free_e2ap_RICsubscriptionLoad_List (OSCTXT* pctxt, e2ap_RICsubscriptionLoad_List* pvalue)
{
   if(pvalue==0) return;
   OSRTDListNode* pnode = pvalue->head;
   while (pnode) {
      e2ap_RICsubscriptionLoad_ItemIEs* pdata = (e2ap_RICsubscriptionLoad_ItemIEs*) pnode->data;
      if (pdata) {
         asn1Free_e2ap_RICsubscriptionLoad_ItemIEs (pctxt, pdata);
         rtxMemFreePtr (pctxt, pdata);
      }
      pnode = pnode->next;
   }
      rtxDListFreeAll(pctxt, pvalue);
}

#if 0
void asn1Free_e2ap_RICsubscriptionLoad_List (OSCTXT* pctxt, e2ap_RICsubscriptionLoad_List* pvalue){
   if(0==pvalue ) return;
   {
      e2ap_RICsubscriptionLoad_ItemIEs * pdata;
      OSRTDListNode *pnode = pvalue->head;
      while(0!=pnode){
         pdata = (e2ap_RICsubscriptionLoad_ItemIEs*)pnode->data;
         asn1Free_e2ap_RICsubscriptionLoad_ItemIEs(pctxt, pdata);
         pnode = pnode->next;
      }
      rtxDListFreeAll(pctxt, pvalue);
   }
}
#endif


int asn1PrtToStr_e2ap_RICsubscriptionLoad_List(const char* name, e2ap_RICsubscriptionLoad_List* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_RICsubscriptionLoad_ItemIEs* pdata;
    OSRTDListNode* pnode;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode = pvalue->head;  xx1 < pvalue->count && pnode != 0; pnode = pnode->next, xx1++){
        pdata = (e2ap_RICsubscriptionLoad_ItemIEs*)pnode->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 1
        if(asn1PrtToStr_e2ap_RICsubscriptionLoad_ItemIEs(nameBuf, pdata, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}
/*****************************************/
/*           RANfunctionLoad-Item                */
/*****************************************/
//sequence normal
// Các nội dung cần thiết cho template seq_normal.c.j2

// Các phần còn lại của template seq_normal.c.j2
//contain extensition bit -> theo mau cua GlobalgNB-ID
int asn1PE_e2ap_RANfunctionLoad_Item (OSCTXT* pctxt, e2ap_RANfunctionLoad_Item* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RANfunctionLoad-Item");

   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);

   /*optional bit for field ranFunctionLoadInformation*/
   stat = rtxEncBit (pctxt, pvalue->m_ranFunctionLoadInformationPresent);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   /*optional bit for field ricServiceLoadInformation*/
   stat = rtxEncBit (pctxt, pvalue->m_ricServiceLoadInformationPresent);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   /*optional bit for field ricSubscriptionLoad_list*/
   stat = rtxEncBit (pctxt, pvalue->m_ricSubscriptionLoad_listPresent);
   if (stat != 0) return LOG_RTERR(pctxt, stat);

   /*encode root elements*/   
   /* encode field ranFunctionID - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "ranFunctionID");
   stat = asn1PE_e2ap_RANfunctionID (pctxt, pvalue->ranFunctionID);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /* encode field ranFunctionLoadInformation - id = -1*/  
   if (pvalue->m_ranFunctionLoadInformationPresent) {//OPTIONAL FIELD
   RTXCTXTPUSHELEMNAME(pctxt, "ranFunctionLoadInformation");
   stat = asn1PE_e2ap_RICloadInformation (pctxt, pvalue->ranFunctionLoadInformation);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   }

   /* encode field ricServiceLoadInformation - id = -1*/  
   if (pvalue->m_ricServiceLoadInformationPresent) {//OPTIONAL FIELD
   RTXCTXTPUSHELEMNAME(pctxt, "ricServiceLoadInformation");
   stat = asn1PE_e2ap_RICserviceLoadInformation (pctxt, pvalue->ricServiceLoadInformation);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   }

   /* encode field ricSubscriptionLoad_list - id = -1*/  
   if (pvalue->m_ricSubscriptionLoad_listPresent) {//OPTIONAL FIELD
   RTXCTXTPUSHELEMNAME(pctxt, "ricSubscriptionLoad-list");
   stat = asn1PE_e2ap_RICsubscriptionLoad_List (pctxt, pvalue->ricSubscriptionLoad_list);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   }


   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RANfunctionLoad_Item (OSCTXT* pctxt, e2ap_RANfunctionLoad_Item* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[4];

   RTXCTXTPUSHTYPENAME(pctxt, "RANfunctionLoad-Item");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 4; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field ranFunctionID */
   RTXCTXTPUSHELEMNAME(pctxt, "ranFunctionID");
      stat = asn1PD_e2ap_RANfunctionID (pctxt, &pvalue->ranFunctionID);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field ranFunctionLoadInformation */
   RTXCTXTPUSHELEMNAME(pctxt, "ranFunctionLoadInformation");
   if (optbits[0]) {
      pvalue->m_ranFunctionLoadInformationPresent = TRUE;
      stat = asn1PD_e2ap_RICloadInformation (pctxt, &pvalue->ranFunctionLoadInformation);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   } else {
      pvalue->m_ranFunctionLoadInformationPresent = FALSE;
   }
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field ricServiceLoadInformation */
   RTXCTXTPUSHELEMNAME(pctxt, "ricServiceLoadInformation");
   if (optbits[0]) {
      pvalue->m_ricServiceLoadInformationPresent = TRUE;
      stat = asn1PD_e2ap_RICserviceLoadInformation (pctxt, &pvalue->ricServiceLoadInformation);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   } else {
      pvalue->m_ricServiceLoadInformationPresent = FALSE;
   }
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field ricSubscriptionLoad_list */
   RTXCTXTPUSHELEMNAME(pctxt, "ricSubscriptionLoad-list");
   if (optbits[0]) {
      pvalue->m_ricSubscriptionLoad_listPresent = TRUE;
      stat = asn1PD_e2ap_RICsubscriptionLoad_List (pctxt, &pvalue->ricSubscriptionLoad_list);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   } else {
      pvalue->m_ricSubscriptionLoad_listPresent = FALSE;
   }
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RANfunctionLoad_Item (e2ap_RANfunctionLoad_Item* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RANfunctionID (&pvalue->ranFunctionID);
   asn1Init_e2ap_RICloadInformation (&pvalue->ranFunctionLoadInformation);
   asn1Init_e2ap_RICserviceLoadInformation (&pvalue->ricServiceLoadInformation);
   asn1Init_e2ap_RICsubscriptionLoad_List (&pvalue->ricSubscriptionLoad_list);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RANfunctionLoad_Item (OSCTXT* pctxt, e2ap_RANfunctionLoad_Item* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_RANfunctionID (pctxt, &pvalue->ranFunctionID);
   asn1Free_e2ap_RICloadInformation (pctxt, &pvalue->ranFunctionLoadInformation);
   asn1Free_e2ap_RICserviceLoadInformation (pctxt, &pvalue->ricServiceLoadInformation);
   asn1Free_e2ap_RICsubscriptionLoad_List (pctxt, &pvalue->ricSubscriptionLoad_list);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RANfunctionLoad_Item (const char* name, e2ap_RANfunctionLoad_Item* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }
   if(asn1PrtToStr_e2ap_RANfunctionID ("ranFunctionID", &pvalue->ranFunctionID, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_RICloadInformation ("ranFunctionLoadInformation", &pvalue->ranFunctionLoadInformation, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_RICserviceLoadInformation ("ricServiceLoadInformation", &pvalue->ricServiceLoadInformation, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_RICsubscriptionLoad_List ("ricSubscriptionLoad_list", &pvalue->ricSubscriptionLoad_list, buffer, bufSize) < 0)
   {
      return -1;
   }



   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           RANfunctionLoad_ItemIEs                */
/*****************************************/
/* ie.c.j2 */
/*ie thường*/
int asn1PE_e2ap_RANfunctionLoad_ItemIEs (OSCTXT* pctxt, e2ap_RANfunctionLoad_ItemIEs* pvalue)
{
   int stat = 0;
   //RTXCTXTPUSHTYPENAME (pctxt, "RANfunctionLoad-ItemIEs");

   /* encode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");
   stat = asn1PE_e2ap_ProtocolIE_ID (pctxt, pvalue->id);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");
   stat = asn1PE_e2ap_Criticality (pctxt, pvalue->criticality);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   {
      OSCTXT ictxt;
      OSOCTET* pDynamicEncodeBuffer;
      ASN1OpenType openType;
      OSBOOL  encoded = TRUE;

      openType.numocts = 0;
      openType.data = 0;

      rtxCopyContext (&ictxt, pctxt);
      pctxt->pStream = 0;

      stat = rtxInitContextBuffer (pctxt, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_RANfunctionLoad_ItemIEs_id_RANfunctionLoad_Item:
         
        // RTXCTXTPUSHELEMNAME (pctxt, "RANfunctionLoad_ItemIEs_id_RANfunctionLoad_Item");
         RTXCTXTPUSHELEMNAME (pctxt, "RANfunctionLoad-Item");
         stat = asn1PE_e2ap_RANfunctionLoad_Item (pctxt, pvalue->value.u._e2apRANfunctionLoad_ItemIEs_id_RANfunctionLoad_Item);
         RTXCTXTPOPELEMNAME (pctxt);
      
         break;

      case T_E2AP_PDU_Contents_e2ap_RANfunctionLoad_ItemIEs_UNDEF_:
      {
          if(0!=pvalue->value.u.extElem1){
              openType.numocts = pvalue->value.u.extElem1->numocts;
              openType.data = pvalue->value.u.extElem1->data;
          } else {
              /* No extension element to encode */
          }
          encoded = FALSE;
          break;
      }
      default:
         encoded = FALSE;
         stat = RTERR_INVOPT;
      }

      if (encoded) {
         openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
         openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
      }
      rtxCopyContext (pctxt, &ictxt);
      if(stat ==0) stat = pe_OpenType(pctxt, openType.numocts, openType.data);
      /*free dynamic encode buffer*/
      if(encoded){
          rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
      }
   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);
   //RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

int asn1PD_e2ap_RANfunctionLoad_ItemIEs (OSCTXT* pctxt, e2ap_RANfunctionLoad_ItemIEs* pvalue)
{
   int stat =0;
   /*deode root element id*/
   RTXCTXTPUSHELEMNAME(pctxt, "id");
   stat = asn1PD_e2ap_ProtocolIE_ID (pctxt, &pvalue->id);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*decode root element criticality*/
   RTXCTXTPUSHELEMNAME(pctxt, "criticality");
   stat = asn1PD_e2ap_Criticality (pctxt, &pvalue->criticality);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   /*decode root element value*/
   RTXCTXTPUSHELEMNAME(pctxt, "value");
   {
      OSUINT32 openTypeLen;
      size_t bitStartOffset, bitLength;
      stat = pd_UnconsLength(pctxt, &openTypeLen);
      if(stat <0) return LOG_RTERR(pctxt, stat);
      else if(stat == RT_OK_FRAG){
         rtxErrAddStrParm(pctxt, "open type with fragmented length use - perindef");
         return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
      }
      bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
      bitLength = openTypeLen * 8;
      switch (pvalue->id){
         case T_E2AP_PDU_Contents_e2ap_RANfunctionLoad_ItemIEs_id_RANfunctionLoad_Item:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RANfunctionLoad_ItemIEs_id_RANfunctionLoad_Item;
            RTXCTXTPUSHELEMNAME(pctxt, "RANfunctionLoad-Item");
            //pvalue->value.u._e2ap_RANfunctionLoad_ItemIEs_id_id_RANfunctionLoad_Item 
             pvalue->value.u._e2apRANfunctionLoad_ItemIEs_id_RANfunctionLoad_Item 
                    = rtxMemAllocType(pctxt, e2ap_RANfunctionLoad_Item);
            //asn1Init_e2ap_RANfunctionLoad_Item(pvalue->value.u._e2ap_RANfunctionLoad_ItemIEs_id_id_RANfunctionLoad_Item);
            asn1Init_e2ap_RANfunctionLoad_Item(pvalue->value.u._e2apRANfunctionLoad_ItemIEs_id_RANfunctionLoad_Item);
            stat = asn1PD_e2ap_RANfunctionLoad_Item (pctxt,
                    (e2ap_RANfunctionLoad_Item*)pvalue->value.
                    u._e2apRANfunctionLoad_ItemIEs_id_RANfunctionLoad_Item);
            if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RANfunctionLoad_ItemIEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*)rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
      }
      {
      size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
      size_t bitsConsumed = bitEndOffset - bitStartOffset;
      if(bitsConsumed < bitLength){
         stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
      } else {
         stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
      }
      }
   }
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   return stat;
}

void asn1Init_e2ap_RANfunctionLoad_ItemIEs (e2ap_RANfunctionLoad_ItemIEs* pvalue)
{
   if (!pvalue) return;
   OSCRTLMEMSET (pvalue, 0, sizeof(e2ap_RANfunctionLoad_ItemIEs));
}

#if 0
void asn1Free_e2ap_RANfunctionLoad_ItemIEs (OSCTXT* pctxt, e2ap_RANfunctionLoad_ItemIEs* pvalue)
{
   if (!pvalue) return;
   if (pvalue->extElem1) {
      rtxMemFreeArray (pctxt, pvalue->extElem1);
      pvalue->extElem1 = 0;
      pvalue->extElem1_n = 0;
   }
}
#endif
void asn1Free_e2ap_RANfunctionLoad_ItemIEs (OSCTXT* pctxt, e2ap_RANfunctionLoad_ItemIEs* pvalue)
{
   if(0==pvalue) return;
   switch(pvalue->value.t){
      case T_E2AP_PDU_Contents_e2ap_RANfunctionLoad_ItemIEs_id_RANfunctionLoad_Item:
         asn1Free_e2ap_RANfunctionLoad_Item (pctxt, pvalue->value.u._e2apRANfunctionLoad_ItemIEs_id_RANfunctionLoad_Item);
         rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2apRANfunctionLoad_ItemIEs_id_RANfunctionLoad_Item);
         pvalue->value.u._e2apRANfunctionLoad_ItemIEs_id_RANfunctionLoad_Item = 0;
         break;
      case T_E2AP_PDU_Contents_e2ap_RANfunctionLoad_ItemIEs_UNDEF_:
         if(0!=pvalue->value.u.extElem1){
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1->data);
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
             pvalue->value.u.extElem1 =0;
         }
         break;
         default:;
   }
}

int  asn1PrtToStr_e2ap_RANfunctionLoad_ItemIEs (const char * name, e2ap_RANfunctionLoad_ItemIEs* pvalue, char * buffer, OSSIZE bufSize){
   if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
       return -1;

      if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
         return -1;

      if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
         return -1;
      if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
         return -1;
      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_RANfunctionLoad_ItemIEs_id_RANfunctionLoad_Item:
         if(asn1PrtToStr_e2ap_RANfunctionLoad_Item("RANfunctionLoad-Item",
                pvalue->value.u._e2apRANfunctionLoad_ItemIEs_id_RANfunctionLoad_Item, buffer, bufSize)<0)// dungnm23 check lai nhe xem la
            return -1;
         break;
      default:
         if(0!=pvalue -> value.u.extElem1){
             rtPrintToStringIndent(buffer, bufSize);
             rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

         }
      }
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

      return 0;

}
 

/*****************************************/
/*           RANfunctionLoad_List                */
/*****************************************/
//seq_of_single_container


int asn1PE_e2ap_RANfunctionLoad_List (OSCTXT* pctxt, e2ap_RANfunctionLoad_List* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_RANfunctionLoad_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "RANfunctionLoad-List");

   /* encode length determinant */
   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(256), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;
   for (xx1 = 0; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next, xx1++) {
      pdata = (e2ap_RANfunctionLoad_ItemIEs*) pnode->data;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_e2ap_RANfunctionLoad_ItemIEs (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      //xx1++;
      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}

int asn1PD_e2ap_RANfunctionLoad_List (OSCTXT* pctxt, e2ap_RANfunctionLoad_List* ppvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_RANfunctionLoad_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "RANfunctionLoad-List");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(256), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (ppvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      pdata = rtxMemAllocType (pctxt, e2ap_RANfunctionLoad_ItemIEs);
      if (!pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);
      asn1Init_e2ap_RANfunctionLoad_ItemIEs (pdata);
      stat = asn1PD_e2ap_RANfunctionLoad_ItemIEs (pctxt, pdata);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         return LOG_RTERR (pctxt, stat);
      }

      rtxDListAppendNode (ppvalue, pdata);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

void asn1Init_e2ap_RANfunctionLoad_List (e2ap_RANfunctionLoad_List* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
}

void asn1Free_e2ap_RANfunctionLoad_List (OSCTXT* pctxt, e2ap_RANfunctionLoad_List* pvalue)
{
   if(pvalue==0) return;
   OSRTDListNode* pnode = pvalue->head;
   while (pnode) {
      e2ap_RANfunctionLoad_ItemIEs* pdata = (e2ap_RANfunctionLoad_ItemIEs*) pnode->data;
      if (pdata) {
         asn1Free_e2ap_RANfunctionLoad_ItemIEs (pctxt, pdata);
         rtxMemFreePtr (pctxt, pdata);
      }
      pnode = pnode->next;
   }
      rtxDListFreeAll(pctxt, pvalue);
}

#if 0
void asn1Free_e2ap_RANfunctionLoad_List (OSCTXT* pctxt, e2ap_RANfunctionLoad_List* pvalue){
   if(0==pvalue ) return;
   {
      e2ap_RANfunctionLoad_ItemIEs * pdata;
      OSRTDListNode *pnode = pvalue->head;
      while(0!=pnode){
         pdata = (e2ap_RANfunctionLoad_ItemIEs*)pnode->data;
         asn1Free_e2ap_RANfunctionLoad_ItemIEs(pctxt, pdata);
         pnode = pnode->next;
      }
      rtxDListFreeAll(pctxt, pvalue);
   }
}
#endif


int asn1PrtToStr_e2ap_RANfunctionLoad_List(const char* name, e2ap_RANfunctionLoad_List* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_RANfunctionLoad_ItemIEs* pdata;
    OSRTDListNode* pnode;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode = pvalue->head;  xx1 < pvalue->count && pnode != 0; pnode = pnode->next, xx1++){
        pdata = (e2ap_RANfunctionLoad_ItemIEs*)pnode->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 1
        if(asn1PrtToStr_e2ap_RANfunctionLoad_ItemIEs(nameBuf, pdata, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}/*****************************************/
/*           RICserviceLoadUpdate_IEs                */
/*****************************************/
/* ie.c.j2 */
 /* d là con của msg */
EXTERN int asn1PE_e2ap_RICserviceLoadUpdate_protocolIEs_element (OSCTXT* pctxt, e2ap_RICserviceLoadUpdate_protocolIEs_element* pvalue)
{
    int stat =0;

    /*encode id*/

    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PE_e2ap_ProtocolIE_ID(pctxt, pvalue->id);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PE_e2ap_Criticality(pctxt, pvalue->criticality);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
    {
        OSCTXT lctxt;
        OSOCTET *pDynamicEncodeBuffer;
        ASN1OpenType openType;
        OSBOOL encoded = TRUE;

        openType.numocts = 0;
        openType.data =0;

        rtxCopyContext(&lctxt, pctxt);
        pctxt->pStream =0;

        stat = rtxInitContextBuffer(pctxt, 0, 0);
        if(stat!=0) return LOG_RTERR(pctxt, stat);

        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_RICserviceLoadUpdate_IEs_id_RICloadMeasurementID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICloadMeasurementID");
                    stat = asn1PE_e2ap_LoadMeasurementID (pctxt, pvalue->value.u._e2ap_RICserviceLoadUpdate_IEs_id_RICloadMeasurementID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICserviceLoadUpdate_IEs_id_E2nodeLoadMeasurementID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-E2nodeLoadMeasurementID");
                    stat = asn1PE_e2ap_LoadMeasurementID (pctxt, pvalue->value.u._e2ap_RICserviceLoadUpdate_IEs_id_E2nodeLoadMeasurementID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICserviceLoadUpdate_IEs_id_RANfunctionLoad_List:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RANfunctionLoad-List");
                    stat = asn1PE_e2ap_RANfunctionLoad_List (pctxt, pvalue->value.u._e2ap_RICserviceLoadUpdate_IEs_id_RANfunctionLoad_List);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_RICserviceLoadUpdate_IEs_UNDEF_:
            {
                if(0!=pvalue->value.u.extElem1){
                    openType.numocts = pvalue->value.u.extElem1->numocts;
                    openType.data = pvalue->value.u.extElem1->data;
                } else {
                    /* No extension element to encode */
                }
                encoded = FALSE;
                break;
            }

            default:
                encoded = FALSE;
                stat = RTERR_INVOPT;
                break;
        } 

        if(encoded){
            openType.numocts = (OSUINT32)pe_GetMsgLen(pctxt);
            openType.data = pDynamicEncodeBuffer = pctxt -> buffer.data;
        }
        rtxCopyContext(pctxt, &lctxt);

        if(stat == 0) {
            stat = pe_OpenType (pctxt, openType.numocts, openType.data);
        }
    #if 1
        if(encoded){//dungnm23 check lai nhe
            rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
        }
    #endif

    }

    if(stat!=0) return LOG_RTERR(pctxt, stat);  
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}

EXTERN int  asn1PD_e2ap_RICserviceLoadUpdate_protocolIEs_element (OSCTXT* pctxt, e2ap_RICserviceLoadUpdate_protocolIEs_element* pvalue){
    int stat =0;

    /*decode id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PD_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PD_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");

    {
        OSUINT32 openTypeLen;
        size_t bitStartOffset, bitLength;

        stat = pd_UnconsLength(pctxt, &openTypeLen);
        if(stat<0) return LOG_RTERR(pctxt, stat);
        else if(stat == RT_OK_FRAG){
            rtxErrAddStrParm(pctxt, "open type with fragment length");
            return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
        }
        bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
        bitLength = openTypeLen * 8;

        switch(pvalue->id){//dungnm23 check case lai nhe
        
            case ASN1V_e2ap_id_RICloadMeasurementID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICserviceLoadUpdate_IEs_id_RICloadMeasurementID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICloadMeasurementID");
                pvalue->value.u._e2ap_RICserviceLoadUpdate_IEs_id_RICloadMeasurementID 
                    = rtxMemAllocType(pctxt, e2ap_LoadMeasurementID);

                asn1Init_e2ap_LoadMeasurementID(pvalue->value.u._e2ap_RICserviceLoadUpdate_IEs_id_RICloadMeasurementID);

                stat = asn1PD_e2ap_LoadMeasurementID (pctxt,
                        (e2ap_LoadMeasurementID*)pvalue->value.
                        u._e2ap_RICserviceLoadUpdate_IEs_id_RICloadMeasurementID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_E2nodeLoadMeasurementID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICserviceLoadUpdate_IEs_id_E2nodeLoadMeasurementID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-E2nodeLoadMeasurementID");
                pvalue->value.u._e2ap_RICserviceLoadUpdate_IEs_id_E2nodeLoadMeasurementID 
                    = rtxMemAllocType(pctxt, e2ap_LoadMeasurementID);

                asn1Init_e2ap_LoadMeasurementID(pvalue->value.u._e2ap_RICserviceLoadUpdate_IEs_id_E2nodeLoadMeasurementID);

                stat = asn1PD_e2ap_LoadMeasurementID (pctxt,
                        (e2ap_LoadMeasurementID*)pvalue->value.
                        u._e2ap_RICserviceLoadUpdate_IEs_id_E2nodeLoadMeasurementID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RANfunctionLoad_List:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICserviceLoadUpdate_IEs_id_RANfunctionLoad_List;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RANfunctionLoad-List");
                pvalue->value.u._e2ap_RICserviceLoadUpdate_IEs_id_RANfunctionLoad_List 
                    = rtxMemAllocType(pctxt, e2ap_RANfunctionLoad_List);

                asn1Init_e2ap_RANfunctionLoad_List(pvalue->value.u._e2ap_RICserviceLoadUpdate_IEs_id_RANfunctionLoad_List);

                stat = asn1PD_e2ap_RANfunctionLoad_List (pctxt,
                        (e2ap_RANfunctionLoad_List*)pvalue->value.
                        u._e2ap_RICserviceLoadUpdate_IEs_id_RANfunctionLoad_List);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICserviceLoadUpdate_IEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*) rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
    }
    {
    size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
    size_t bitsConsumed = bitEndOffset-bitStartOffset;
    if(bitsConsumed<bitLength){
        stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
    }
    else stat =(bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
    }}
    if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}


int asn1Init_e2ap_RICserviceLoadUpdate_protocolIEs_element(e2ap_RICserviceLoadUpdate_protocolIEs_element* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    OSCRTLMEMSET (&pvalue->value, 0, sizeof(pvalue->value));
    return 0;
}


//-----> chuaw có template rtxFreeASN1OpenType

#if 0
void asn1Free_e2ap_RICserviceLoadUpdate_protocolIEs_element(OSCTXT* pctxt, e2ap_RICserviceLoadUpdate_protocolIEs_element* pvalue)
{
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICserviceLoadUpdate_IEs_id_id_RICloadMeasurementID:
            // rtxFreeE2ap_LoadMeasurementID(pvalue->value.u._e2ap_RICserviceLoadUpdate_IEs_id_id_RICloadMeasurementID);

            if(pvalue->value.i._e2ap_RICserviceLoadUpdate_id_LoadMeasurementID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_LoadMeasurementID(pctxt, pvalue->value.u._e2ap_RICserviceLoadUpdate_IEs_id_id_RICloadMeasurementID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICserviceLoadUpdate_IEs_id_id_RICloadMeasurementID);
           // pvalue->value.u._e2ap_RICserviceLoadUpdate_IEs_id_id_RICloadMeasurementID = NULL;
           pvalue->value.u._e2ap_RICserviceLoadUpdate_IEs_id_RICloadMeasurementID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICserviceLoadUpdate_IEs_id_id_E2nodeLoadMeasurementID:
            // rtxFreeE2ap_LoadMeasurementID(pvalue->value.u._e2ap_RICserviceLoadUpdate_IEs_id_id_E2nodeLoadMeasurementID);

            if(pvalue->value.i._e2ap_RICserviceLoadUpdate_id_LoadMeasurementID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_LoadMeasurementID(pctxt, pvalue->value.u._e2ap_RICserviceLoadUpdate_IEs_id_id_E2nodeLoadMeasurementID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICserviceLoadUpdate_IEs_id_id_E2nodeLoadMeasurementID);
           // pvalue->value.u._e2ap_RICserviceLoadUpdate_IEs_id_id_E2nodeLoadMeasurementID = NULL;
           pvalue->value.u._e2ap_RICserviceLoadUpdate_IEs_id_E2nodeLoadMeasurementID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICserviceLoadUpdate_IEs_id_id_RANfunctionLoad_List:
            // rtxFreeE2ap_RANfunctionLoad_List(pvalue->value.u._e2ap_RICserviceLoadUpdate_IEs_id_id_RANfunctionLoad_List);

            if(pvalue->value.i._e2ap_RICserviceLoadUpdate_id_RANfunctionLoad_List!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RANfunctionLoad_List(pctxt, pvalue->value.u._e2ap_RICserviceLoadUpdate_IEs_id_id_RANfunctionLoad_List);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICserviceLoadUpdate_IEs_id_id_RANfunctionLoad_List);
           // pvalue->value.u._e2ap_RICserviceLoadUpdate_IEs_id_id_RANfunctionLoad_List = NULL;
           pvalue->value.u._e2ap_RICserviceLoadUpdate_IEs_id_RANfunctionLoad_List = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICserviceLoadUpdate_IEs_UNDEF_:
            rtxFreeASN1OpenType(pvalue->value.u.extElem1);
            break;
        default:
            break;
    }
}

int asn1PrtToStr_e2ap_RICserviceLoadUpdate_protocolIEs_element(OSCTXT* pctxt, e2ap_RICserviceLoadUpdate_protocolIEs_element* pvalue)
{
    int stat =0;
    RTXCTXTPUSHELEMNAME(pctxt, "e2ap_RICserviceLoadUpdate_protocolIEs_element");

    /*print id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PrtToStr_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PrtToStr_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_RICserviceLoadUpdate_IEs_id_id_RICloadMeasurementID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "LoadMeasurementID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_LoadMeasurementID (pctxt, pvalue->value.u._e2ap_RICserviceLoadUpdate_IEs_id_id_RICloadMeasurementID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICserviceLoadUpdate_IEs_id_id_E2nodeLoadMeasurementID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "LoadMeasurementID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_LoadMeasurementID (pctxt, pvalue->value.u._e2ap_RICserviceLoadUpdate_IEs_id_id_E2nodeLoadMeasurementID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICserviceLoadUpdate_IEs_id_id_RANfunctionLoad_List:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RANfunctionLoad-List");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RANfunctionLoad_List (pctxt, pvalue->value.u._e2ap_RICserviceLoadUpdate_IEs_id_id_RANfunctionLoad_List);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_RICserviceLoadUpdate_IEs_UNDEF_:
            {
                rtxPLogMsg(pctxt, "Extension element present - raw data not printed.\n");
                break;
            }

            default:
                stat = RTERR_INVOPT;
                return LOG_RTERR(pctxt, stat);
        }
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);
}
#endif


int asn1PrtToStr_e2ap_RICserviceLoadUpdate_protocolIEs_element (const char * name,
 e2ap_RICserviceLoadUpdate_protocolIEs_element* pvalue, 
 char * buffer, OSSIZE bufSize){
    if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
        return -1;
    if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
        return -1;

    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICserviceLoadUpdate_IEs_id_RICloadMeasurementID:
            if(asn1PrtToStr_e2ap_LoadMeasurementID("LoadMeasurementID", 
                    pvalue->value.u._e2ap_RICserviceLoadUpdate_IEs_id_RICloadMeasurementID, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICserviceLoadUpdate_IEs_id_E2nodeLoadMeasurementID:
            if(asn1PrtToStr_e2ap_LoadMeasurementID("LoadMeasurementID", 
                    pvalue->value.u._e2ap_RICserviceLoadUpdate_IEs_id_E2nodeLoadMeasurementID, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICserviceLoadUpdate_IEs_id_RANfunctionLoad_List:
            if(asn1PrtToStr_e2ap_RANfunctionLoad_List("RANfunctionLoad-List", 
                    pvalue->value.u._e2ap_RICserviceLoadUpdate_IEs_id_RANfunctionLoad_List, buffer, bufSize)<0)
                return -1;
            break;    
        default:
        if(0!=pvalue -> value.u.extElem1){
            rtPrintToStringIndent(buffer, bufSize);
            rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

        }
        }
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

    return 0;

 }

 void asn1Free_e2ap_RICserviceLoadUpdate_protocolIEs_element(OSCTXT* pctxt, e2ap_RICserviceLoadUpdate_protocolIEs_element* pvalue){
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICserviceLoadUpdate_IEs_id_RICloadMeasurementID:
            if(pvalue->value.u._e2ap_RICserviceLoadUpdate_IEs_id_RICloadMeasurementID!=NULL){
            asn1Free_e2ap_LoadMeasurementID(pctxt, pvalue->value.u._e2ap_RICserviceLoadUpdate_IEs_id_RICloadMeasurementID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICserviceLoadUpdate_IEs_id_RICloadMeasurementID);
            pvalue->value.u._e2ap_RICserviceLoadUpdate_IEs_id_RICloadMeasurementID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICserviceLoadUpdate_IEs_id_E2nodeLoadMeasurementID:
            if(pvalue->value.u._e2ap_RICserviceLoadUpdate_IEs_id_E2nodeLoadMeasurementID!=NULL){
            asn1Free_e2ap_LoadMeasurementID(pctxt, pvalue->value.u._e2ap_RICserviceLoadUpdate_IEs_id_E2nodeLoadMeasurementID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICserviceLoadUpdate_IEs_id_E2nodeLoadMeasurementID);
            pvalue->value.u._e2ap_RICserviceLoadUpdate_IEs_id_E2nodeLoadMeasurementID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICserviceLoadUpdate_IEs_id_RANfunctionLoad_List:
            if(pvalue->value.u._e2ap_RICserviceLoadUpdate_IEs_id_RANfunctionLoad_List!=NULL){
            asn1Free_e2ap_RANfunctionLoad_List(pctxt, pvalue->value.u._e2ap_RICserviceLoadUpdate_IEs_id_RANfunctionLoad_List);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICserviceLoadUpdate_IEs_id_RANfunctionLoad_List);
            pvalue->value.u._e2ap_RICserviceLoadUpdate_IEs_id_RANfunctionLoad_List = NULL;
            }
            break;
        default:
            break;


    }
 }

 

/*****************************************/
/*           RICserviceLoadUpdate                */
/*****************************************/
//2_container.c
/* 1. xxx_ProtocolIE -> mẫu cũ ở ie_big_msg */
EXTERN int asn1PE_e2ap_RICserviceLoadUpdate_protocolIEs (OSCTXT* pctxt, e2ap_RICserviceLoadUpdate_protocolIEs* pvalue)
{
    int stat =0;
    OSRTDListNode* pnode;
    OSUINT32 xx1;

    /*encode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pe_Length(pctxt, pvalue->count);
    if(stat<0) return LOG_RTERR(pctxt, stat);

    /*encode each element*/
    xx1 =0;
    for(pnode = pvalue->head; pnode != 0 && xx1<pvalue->count; pnode = pnode->next){
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE", xx1);
        stat = asn1PE_e2ap_RICserviceLoadUpdate_protocolIEs_element (pctxt, ((e2ap_RICserviceLoadUpdate_protocolIEs_element*)pnode->data));
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        xx1++;
        RTXCTXTPOPARRAYELEMNAME(pctxt);
    }

    return (stat);
}

EXTERN int  asn1PD_e2ap_RICserviceLoadUpdate_protocolIEs(OSCTXT* pctxt, e2ap_RICserviceLoadUpdate_protocolIEs* pvalue)
{
     int stat =0;
     OSRTDListNode* pnode;
     OSSIZE count =0;
     OSSIZE xx1=0;


     /*decode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pd_Length64(pctxt, &count); //tai sao lai 64
    if(stat!=0) return LOG_RTERR(pctxt, stat);

    /*decode each element*/
    rtxDListInit(pvalue);

    for(xx1=0; xx1 < count; xx1++){
        e2ap_RICserviceLoadUpdate_protocolIEs_element* pdata;
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE",xx1);

        if(pnode == NULL) return LOG_RTERR(pctxt, RTERR_NOMEM);

        asn1Init_e2ap_RICserviceLoadUpdate_protocolIEs_element(pdata);
        rtxDListAppendNode(pvalue, pnode);
        stat = asn1PD_e2ap_RICserviceLoadUpdate_protocolIEs_element (pctxt, pdata);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        RTXCTXTPOPARRAYELEMNAME(pctxt);

    }
    return (stat);
}


int asn1Init_e2ap_RICserviceLoadUpdate_protocolIEs(e2ap_RICserviceLoadUpdate_protocolIEs* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    rtxDListFastInit (pvalue);
    return 0;
}
#if 1 //ao that day
void asn1Free_e2ap_RICserviceLoadUpdate_protocolIEs(OSCTXT* pctxt, e2ap_RICserviceLoadUpdate_protocolIEs* pvalue)
{
    if(0==pvalue) return;   
    e2ap_RICserviceLoadUpdate_protocolIEs_element* pdata;
    OSRTDListNode* pnode=pvalue->head;
    while(0!=pnode){
        pdata = (e2ap_RICserviceLoadUpdate_protocolIEs_element*)pnode->data;
       // asn1Free_e2ap_RICserviceLoadUpdate_protocolIEs_element(pctxt, pdata);
        pnode = pnode->next;
    }
    rtxDListFreeAll(pctxt, pvalue);
}
#endif


EXTERN int asn1PrtToStr_e2ap_RICserviceLoadUpdate_protocolIEs(const char* name, e2ap_RICserviceLoadUpdate_protocolIEs* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_RICserviceLoadUpdate_protocolIEs_element* pdata0;
    OSRTDListNode* pnode0;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode0 = pvalue->head;  xx1 < pvalue->count && pnode0 != 0; pnode0 = pnode0->next, xx1++){
        pdata0 = (e2ap_RICserviceLoadUpdate_protocolIEs_element*)pnode0->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 0
        if(asn1PrtToStr_e2ap_RICserviceLoadUpdate_protocolIEs_element(nameBuf, pdata0, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}


/*2 . RICserviceLoadUpdate -> mẫu cũ ở seq_normal*/

int asn1PE_e2ap_RICserviceLoadUpdate (OSCTXT* pctxt, e2ap_RICserviceLoadUpdate* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RICserviceLoadUpdate");
   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field protocolIEs - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
   stat = asn1PE_e2ap_RICserviceLoadUpdate_protocolIEs (pctxt, &pvalue->protocolIEs);
   if(stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RICserviceLoadUpdate (OSCTXT* pctxt, e2ap_RICserviceLoadUpdate* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME(pctxt, "RICserviceLoadUpdate");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field protocolIEs */
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
      stat = asn1PD_e2ap_RICserviceLoadUpdate_protocolIEs (pctxt, &pvalue->protocolIEs);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RICserviceLoadUpdate (e2ap_RICserviceLoadUpdate* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RICserviceLoadUpdate_protocolIEs(&pvalue->protocolIEs);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RICserviceLoadUpdate (OSCTXT* pctxt, e2ap_RICserviceLoadUpdate* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_RICserviceLoadUpdate_protocolIEs(pctxt, &pvalue->protocolIEs);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RICserviceLoadUpdate (const char* name, e2ap_RICserviceLoadUpdate* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }

   if(asn1PrtToStr_e2ap_RICserviceLoadUpdate_protocolIEs("protocolIEs", &pvalue->protocolIEs, buffer, bufSize) <0){
      return -1;
   }

   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           RICserviceQuery_IEs                */
/*****************************************/
/* ie.c.j2 */
 /* d là con của msg */
EXTERN int asn1PE_e2ap_RICserviceQuery_protocolIEs_element (OSCTXT* pctxt, e2ap_RICserviceQuery_protocolIEs_element* pvalue)
{
    int stat =0;

    /*encode id*/

    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PE_e2ap_ProtocolIE_ID(pctxt, pvalue->id);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PE_e2ap_Criticality(pctxt, pvalue->criticality);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
    {
        OSCTXT lctxt;
        OSOCTET *pDynamicEncodeBuffer;
        ASN1OpenType openType;
        OSBOOL encoded = TRUE;

        openType.numocts = 0;
        openType.data =0;

        rtxCopyContext(&lctxt, pctxt);
        pctxt->pStream =0;

        stat = rtxInitContextBuffer(pctxt, 0, 0);
        if(stat!=0) return LOG_RTERR(pctxt, stat);

        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_RICserviceQuery_IEs_id_TransactionID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-TransactionID");
                    stat = asn1PE_e2ap_TransactionID (pctxt, pvalue->value.u._e2ap_RICserviceQuery_IEs_id_TransactionID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICserviceQuery_IEs_id_RANfunctionsAccepted:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RANfunctionsAccepted");
                    stat = asn1PE_e2ap_RANfunctionsID_List (pctxt, pvalue->value.u._e2ap_RICserviceQuery_IEs_id_RANfunctionsAccepted);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_RICserviceQuery_IEs_UNDEF_:
            {
                if(0!=pvalue->value.u.extElem1){
                    openType.numocts = pvalue->value.u.extElem1->numocts;
                    openType.data = pvalue->value.u.extElem1->data;
                } else {
                    /* No extension element to encode */
                }
                encoded = FALSE;
                break;
            }

            default:
                encoded = FALSE;
                stat = RTERR_INVOPT;
                break;
        } 

        if(encoded){
            openType.numocts = (OSUINT32)pe_GetMsgLen(pctxt);
            openType.data = pDynamicEncodeBuffer = pctxt -> buffer.data;
        }
        rtxCopyContext(pctxt, &lctxt);

        if(stat == 0) {
            stat = pe_OpenType (pctxt, openType.numocts, openType.data);
        }
    #if 1
        if(encoded){//dungnm23 check lai nhe
            rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
        }
    #endif

    }

    if(stat!=0) return LOG_RTERR(pctxt, stat);  
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}

EXTERN int  asn1PD_e2ap_RICserviceQuery_protocolIEs_element (OSCTXT* pctxt, e2ap_RICserviceQuery_protocolIEs_element* pvalue){
    int stat =0;

    /*decode id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PD_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PD_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");

    {
        OSUINT32 openTypeLen;
        size_t bitStartOffset, bitLength;

        stat = pd_UnconsLength(pctxt, &openTypeLen);
        if(stat<0) return LOG_RTERR(pctxt, stat);
        else if(stat == RT_OK_FRAG){
            rtxErrAddStrParm(pctxt, "open type with fragment length");
            return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
        }
        bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
        bitLength = openTypeLen * 8;

        switch(pvalue->id){//dungnm23 check case lai nhe
        
            case ASN1V_e2ap_id_TransactionID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICserviceQuery_IEs_id_TransactionID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-TransactionID");
                pvalue->value.u._e2ap_RICserviceQuery_IEs_id_TransactionID 
                    = rtxMemAllocType(pctxt, e2ap_TransactionID);

                asn1Init_e2ap_TransactionID(pvalue->value.u._e2ap_RICserviceQuery_IEs_id_TransactionID);

                stat = asn1PD_e2ap_TransactionID (pctxt,
                        (e2ap_TransactionID*)pvalue->value.
                        u._e2ap_RICserviceQuery_IEs_id_TransactionID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RANfunctionsAccepted:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICserviceQuery_IEs_id_RANfunctionsAccepted;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RANfunctionsAccepted");
                pvalue->value.u._e2ap_RICserviceQuery_IEs_id_RANfunctionsAccepted 
                    = rtxMemAllocType(pctxt, e2ap_RANfunctionsID_List);

                asn1Init_e2ap_RANfunctionsID_List(pvalue->value.u._e2ap_RICserviceQuery_IEs_id_RANfunctionsAccepted);

                stat = asn1PD_e2ap_RANfunctionsID_List (pctxt,
                        (e2ap_RANfunctionsID_List*)pvalue->value.
                        u._e2ap_RICserviceQuery_IEs_id_RANfunctionsAccepted);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICserviceQuery_IEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*) rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
    }
    {
    size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
    size_t bitsConsumed = bitEndOffset-bitStartOffset;
    if(bitsConsumed<bitLength){
        stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
    }
    else stat =(bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
    }}
    if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}


int asn1Init_e2ap_RICserviceQuery_protocolIEs_element(e2ap_RICserviceQuery_protocolIEs_element* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    OSCRTLMEMSET (&pvalue->value, 0, sizeof(pvalue->value));
    return 0;
}


//-----> chuaw có template rtxFreeASN1OpenType

#if 0
void asn1Free_e2ap_RICserviceQuery_protocolIEs_element(OSCTXT* pctxt, e2ap_RICserviceQuery_protocolIEs_element* pvalue)
{
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICserviceQuery_IEs_id_id_TransactionID:
            // rtxFreeE2ap_TransactionID(pvalue->value.u._e2ap_RICserviceQuery_IEs_id_id_TransactionID);

            if(pvalue->value.i._e2ap_RICserviceQuery_id_TransactionID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_TransactionID(pctxt, pvalue->value.u._e2ap_RICserviceQuery_IEs_id_id_TransactionID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICserviceQuery_IEs_id_id_TransactionID);
           // pvalue->value.u._e2ap_RICserviceQuery_IEs_id_id_TransactionID = NULL;
           pvalue->value.u._e2ap_RICserviceQuery_IEs_id_TransactionID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICserviceQuery_IEs_id_id_RANfunctionsAccepted:
            // rtxFreeE2ap_RANfunctionsID_List(pvalue->value.u._e2ap_RICserviceQuery_IEs_id_id_RANfunctionsAccepted);

            if(pvalue->value.i._e2ap_RICserviceQuery_id_RANfunctionsID_List!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RANfunctionsID_List(pctxt, pvalue->value.u._e2ap_RICserviceQuery_IEs_id_id_RANfunctionsAccepted);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICserviceQuery_IEs_id_id_RANfunctionsAccepted);
           // pvalue->value.u._e2ap_RICserviceQuery_IEs_id_id_RANfunctionsAccepted = NULL;
           pvalue->value.u._e2ap_RICserviceQuery_IEs_id_RANfunctionsAccepted = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICserviceQuery_IEs_UNDEF_:
            rtxFreeASN1OpenType(pvalue->value.u.extElem1);
            break;
        default:
            break;
    }
}

int asn1PrtToStr_e2ap_RICserviceQuery_protocolIEs_element(OSCTXT* pctxt, e2ap_RICserviceQuery_protocolIEs_element* pvalue)
{
    int stat =0;
    RTXCTXTPUSHELEMNAME(pctxt, "e2ap_RICserviceQuery_protocolIEs_element");

    /*print id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PrtToStr_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PrtToStr_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_RICserviceQuery_IEs_id_id_TransactionID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "TransactionID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_TransactionID (pctxt, pvalue->value.u._e2ap_RICserviceQuery_IEs_id_id_TransactionID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICserviceQuery_IEs_id_id_RANfunctionsAccepted:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RANfunctionsID-List");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RANfunctionsID_List (pctxt, pvalue->value.u._e2ap_RICserviceQuery_IEs_id_id_RANfunctionsAccepted);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_RICserviceQuery_IEs_UNDEF_:
            {
                rtxPLogMsg(pctxt, "Extension element present - raw data not printed.\n");
                break;
            }

            default:
                stat = RTERR_INVOPT;
                return LOG_RTERR(pctxt, stat);
        }
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);
}
#endif


int asn1PrtToStr_e2ap_RICserviceQuery_protocolIEs_element (const char * name,
 e2ap_RICserviceQuery_protocolIEs_element* pvalue, 
 char * buffer, OSSIZE bufSize){
    if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
        return -1;
    if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
        return -1;

    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICserviceQuery_IEs_id_TransactionID:
            if(asn1PrtToStr_e2ap_TransactionID("TransactionID", 
                    pvalue->value.u._e2ap_RICserviceQuery_IEs_id_TransactionID, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICserviceQuery_IEs_id_RANfunctionsAccepted:
            if(asn1PrtToStr_e2ap_RANfunctionsID_List("RANfunctionsID-List", 
                    pvalue->value.u._e2ap_RICserviceQuery_IEs_id_RANfunctionsAccepted, buffer, bufSize)<0)
                return -1;
            break;    
        default:
        if(0!=pvalue -> value.u.extElem1){
            rtPrintToStringIndent(buffer, bufSize);
            rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

        }
        }
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

    return 0;

 }

 void asn1Free_e2ap_RICserviceQuery_protocolIEs_element(OSCTXT* pctxt, e2ap_RICserviceQuery_protocolIEs_element* pvalue){
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICserviceQuery_IEs_id_TransactionID:
            if(pvalue->value.u._e2ap_RICserviceQuery_IEs_id_TransactionID!=NULL){
            asn1Free_e2ap_TransactionID(pctxt, pvalue->value.u._e2ap_RICserviceQuery_IEs_id_TransactionID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICserviceQuery_IEs_id_TransactionID);
            pvalue->value.u._e2ap_RICserviceQuery_IEs_id_TransactionID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICserviceQuery_IEs_id_RANfunctionsAccepted:
            if(pvalue->value.u._e2ap_RICserviceQuery_IEs_id_RANfunctionsAccepted!=NULL){
            asn1Free_e2ap_RANfunctionsID_List(pctxt, pvalue->value.u._e2ap_RICserviceQuery_IEs_id_RANfunctionsAccepted);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICserviceQuery_IEs_id_RANfunctionsAccepted);
            pvalue->value.u._e2ap_RICserviceQuery_IEs_id_RANfunctionsAccepted = NULL;
            }
            break;
        default:
            break;


    }
 }

 

/*****************************************/
/*           RICserviceQuery                */
/*****************************************/
//2_container.c
/* 1. xxx_ProtocolIE -> mẫu cũ ở ie_big_msg */
EXTERN int asn1PE_e2ap_RICserviceQuery_protocolIEs (OSCTXT* pctxt, e2ap_RICserviceQuery_protocolIEs* pvalue)
{
    int stat =0;
    OSRTDListNode* pnode;
    OSUINT32 xx1;

    /*encode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pe_Length(pctxt, pvalue->count);
    if(stat<0) return LOG_RTERR(pctxt, stat);

    /*encode each element*/
    xx1 =0;
    for(pnode = pvalue->head; pnode != 0 && xx1<pvalue->count; pnode = pnode->next){
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE", xx1);
        stat = asn1PE_e2ap_RICserviceQuery_protocolIEs_element (pctxt, ((e2ap_RICserviceQuery_protocolIEs_element*)pnode->data));
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        xx1++;
        RTXCTXTPOPARRAYELEMNAME(pctxt);
    }

    return (stat);
}

EXTERN int  asn1PD_e2ap_RICserviceQuery_protocolIEs(OSCTXT* pctxt, e2ap_RICserviceQuery_protocolIEs* pvalue)
{
     int stat =0;
     OSRTDListNode* pnode;
     OSSIZE count =0;
     OSSIZE xx1=0;


     /*decode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pd_Length64(pctxt, &count); //tai sao lai 64
    if(stat!=0) return LOG_RTERR(pctxt, stat);

    /*decode each element*/
    rtxDListInit(pvalue);

    for(xx1=0; xx1 < count; xx1++){
        e2ap_RICserviceQuery_protocolIEs_element* pdata;
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE",xx1);

        if(pnode == NULL) return LOG_RTERR(pctxt, RTERR_NOMEM);

        asn1Init_e2ap_RICserviceQuery_protocolIEs_element(pdata);
        rtxDListAppendNode(pvalue, pnode);
        stat = asn1PD_e2ap_RICserviceQuery_protocolIEs_element (pctxt, pdata);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        RTXCTXTPOPARRAYELEMNAME(pctxt);

    }
    return (stat);
}


int asn1Init_e2ap_RICserviceQuery_protocolIEs(e2ap_RICserviceQuery_protocolIEs* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    rtxDListFastInit (pvalue);
    return 0;
}
#if 1 //ao that day
void asn1Free_e2ap_RICserviceQuery_protocolIEs(OSCTXT* pctxt, e2ap_RICserviceQuery_protocolIEs* pvalue)
{
    if(0==pvalue) return;   
    e2ap_RICserviceQuery_protocolIEs_element* pdata;
    OSRTDListNode* pnode=pvalue->head;
    while(0!=pnode){
        pdata = (e2ap_RICserviceQuery_protocolIEs_element*)pnode->data;
       // asn1Free_e2ap_RICserviceQuery_protocolIEs_element(pctxt, pdata);
        pnode = pnode->next;
    }
    rtxDListFreeAll(pctxt, pvalue);
}
#endif


EXTERN int asn1PrtToStr_e2ap_RICserviceQuery_protocolIEs(const char* name, e2ap_RICserviceQuery_protocolIEs* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_RICserviceQuery_protocolIEs_element* pdata0;
    OSRTDListNode* pnode0;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode0 = pvalue->head;  xx1 < pvalue->count && pnode0 != 0; pnode0 = pnode0->next, xx1++){
        pdata0 = (e2ap_RICserviceQuery_protocolIEs_element*)pnode0->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 0
        if(asn1PrtToStr_e2ap_RICserviceQuery_protocolIEs_element(nameBuf, pdata0, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}


/*2 . RICserviceQuery -> mẫu cũ ở seq_normal*/

int asn1PE_e2ap_RICserviceQuery (OSCTXT* pctxt, e2ap_RICserviceQuery* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RICserviceQuery");
   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field protocolIEs - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
   stat = asn1PE_e2ap_RICserviceQuery_protocolIEs (pctxt, &pvalue->protocolIEs);
   if(stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RICserviceQuery (OSCTXT* pctxt, e2ap_RICserviceQuery* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME(pctxt, "RICserviceQuery");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field protocolIEs */
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
      stat = asn1PD_e2ap_RICserviceQuery_protocolIEs (pctxt, &pvalue->protocolIEs);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RICserviceQuery (e2ap_RICserviceQuery* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RICserviceQuery_protocolIEs(&pvalue->protocolIEs);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RICserviceQuery (OSCTXT* pctxt, e2ap_RICserviceQuery* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_RICserviceQuery_protocolIEs(pctxt, &pvalue->protocolIEs);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RICserviceQuery (const char* name, e2ap_RICserviceQuery* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }

   if(asn1PrtToStr_e2ap_RICserviceQuery_protocolIEs("protocolIEs", &pvalue->protocolIEs, buffer, bufSize) <0){
      return -1;
   }

   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           RICserviceUpdate_IEs                */
/*****************************************/
/* ie.c.j2 */
 /* d là con của msg */
EXTERN int asn1PE_e2ap_RICserviceUpdate_protocolIEs_element (OSCTXT* pctxt, e2ap_RICserviceUpdate_protocolIEs_element* pvalue)
{
    int stat =0;

    /*encode id*/

    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PE_e2ap_ProtocolIE_ID(pctxt, pvalue->id);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PE_e2ap_Criticality(pctxt, pvalue->criticality);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
    {
        OSCTXT lctxt;
        OSOCTET *pDynamicEncodeBuffer;
        ASN1OpenType openType;
        OSBOOL encoded = TRUE;

        openType.numocts = 0;
        openType.data =0;

        rtxCopyContext(&lctxt, pctxt);
        pctxt->pStream =0;

        stat = rtxInitContextBuffer(pctxt, 0, 0);
        if(stat!=0) return LOG_RTERR(pctxt, stat);

        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_RICserviceUpdate_IEs_id_TransactionID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-TransactionID");
                    stat = asn1PE_e2ap_TransactionID (pctxt, pvalue->value.u._e2ap_RICserviceUpdate_IEs_id_TransactionID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICserviceUpdate_IEs_id_RANfunctionsAdded:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RANfunctionsAdded");
                    stat = asn1PE_e2ap_RANfunctions_List (pctxt, pvalue->value.u._e2ap_RICserviceUpdate_IEs_id_RANfunctionsAdded);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICserviceUpdate_IEs_id_RANfunctionsModified:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RANfunctionsModified");
                    stat = asn1PE_e2ap_RANfunctions_List (pctxt, pvalue->value.u._e2ap_RICserviceUpdate_IEs_id_RANfunctionsModified);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICserviceUpdate_IEs_id_RANfunctionsDeleted:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RANfunctionsDeleted");
                    stat = asn1PE_e2ap_RANfunctionsID_List (pctxt, pvalue->value.u._e2ap_RICserviceUpdate_IEs_id_RANfunctionsDeleted);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_RICserviceUpdate_IEs_UNDEF_:
            {
                if(0!=pvalue->value.u.extElem1){
                    openType.numocts = pvalue->value.u.extElem1->numocts;
                    openType.data = pvalue->value.u.extElem1->data;
                } else {
                    /* No extension element to encode */
                }
                encoded = FALSE;
                break;
            }

            default:
                encoded = FALSE;
                stat = RTERR_INVOPT;
                break;
        } 

        if(encoded){
            openType.numocts = (OSUINT32)pe_GetMsgLen(pctxt);
            openType.data = pDynamicEncodeBuffer = pctxt -> buffer.data;
        }
        rtxCopyContext(pctxt, &lctxt);

        if(stat == 0) {
            stat = pe_OpenType (pctxt, openType.numocts, openType.data);
        }
    #if 1
        if(encoded){//dungnm23 check lai nhe
            rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
        }
    #endif

    }

    if(stat!=0) return LOG_RTERR(pctxt, stat);  
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}

EXTERN int  asn1PD_e2ap_RICserviceUpdate_protocolIEs_element (OSCTXT* pctxt, e2ap_RICserviceUpdate_protocolIEs_element* pvalue){
    int stat =0;

    /*decode id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PD_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PD_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");

    {
        OSUINT32 openTypeLen;
        size_t bitStartOffset, bitLength;

        stat = pd_UnconsLength(pctxt, &openTypeLen);
        if(stat<0) return LOG_RTERR(pctxt, stat);
        else if(stat == RT_OK_FRAG){
            rtxErrAddStrParm(pctxt, "open type with fragment length");
            return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
        }
        bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
        bitLength = openTypeLen * 8;

        switch(pvalue->id){//dungnm23 check case lai nhe
        
            case ASN1V_e2ap_id_TransactionID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICserviceUpdate_IEs_id_TransactionID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-TransactionID");
                pvalue->value.u._e2ap_RICserviceUpdate_IEs_id_TransactionID 
                    = rtxMemAllocType(pctxt, e2ap_TransactionID);

                asn1Init_e2ap_TransactionID(pvalue->value.u._e2ap_RICserviceUpdate_IEs_id_TransactionID);

                stat = asn1PD_e2ap_TransactionID (pctxt,
                        (e2ap_TransactionID*)pvalue->value.
                        u._e2ap_RICserviceUpdate_IEs_id_TransactionID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RANfunctionsAdded:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICserviceUpdate_IEs_id_RANfunctionsAdded;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RANfunctionsAdded");
                pvalue->value.u._e2ap_RICserviceUpdate_IEs_id_RANfunctionsAdded 
                    = rtxMemAllocType(pctxt, e2ap_RANfunctions_List);

                asn1Init_e2ap_RANfunctions_List(pvalue->value.u._e2ap_RICserviceUpdate_IEs_id_RANfunctionsAdded);

                stat = asn1PD_e2ap_RANfunctions_List (pctxt,
                        (e2ap_RANfunctions_List*)pvalue->value.
                        u._e2ap_RICserviceUpdate_IEs_id_RANfunctionsAdded);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RANfunctionsModified:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICserviceUpdate_IEs_id_RANfunctionsModified;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RANfunctionsModified");
                pvalue->value.u._e2ap_RICserviceUpdate_IEs_id_RANfunctionsModified 
                    = rtxMemAllocType(pctxt, e2ap_RANfunctions_List);

                asn1Init_e2ap_RANfunctions_List(pvalue->value.u._e2ap_RICserviceUpdate_IEs_id_RANfunctionsModified);

                stat = asn1PD_e2ap_RANfunctions_List (pctxt,
                        (e2ap_RANfunctions_List*)pvalue->value.
                        u._e2ap_RICserviceUpdate_IEs_id_RANfunctionsModified);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RANfunctionsDeleted:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICserviceUpdate_IEs_id_RANfunctionsDeleted;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RANfunctionsDeleted");
                pvalue->value.u._e2ap_RICserviceUpdate_IEs_id_RANfunctionsDeleted 
                    = rtxMemAllocType(pctxt, e2ap_RANfunctionsID_List);

                asn1Init_e2ap_RANfunctionsID_List(pvalue->value.u._e2ap_RICserviceUpdate_IEs_id_RANfunctionsDeleted);

                stat = asn1PD_e2ap_RANfunctionsID_List (pctxt,
                        (e2ap_RANfunctionsID_List*)pvalue->value.
                        u._e2ap_RICserviceUpdate_IEs_id_RANfunctionsDeleted);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICserviceUpdate_IEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*) rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
    }
    {
    size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
    size_t bitsConsumed = bitEndOffset-bitStartOffset;
    if(bitsConsumed<bitLength){
        stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
    }
    else stat =(bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
    }}
    if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}


int asn1Init_e2ap_RICserviceUpdate_protocolIEs_element(e2ap_RICserviceUpdate_protocolIEs_element* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    OSCRTLMEMSET (&pvalue->value, 0, sizeof(pvalue->value));
    return 0;
}


//-----> chuaw có template rtxFreeASN1OpenType

#if 0
void asn1Free_e2ap_RICserviceUpdate_protocolIEs_element(OSCTXT* pctxt, e2ap_RICserviceUpdate_protocolIEs_element* pvalue)
{
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICserviceUpdate_IEs_id_id_TransactionID:
            // rtxFreeE2ap_TransactionID(pvalue->value.u._e2ap_RICserviceUpdate_IEs_id_id_TransactionID);

            if(pvalue->value.i._e2ap_RICserviceUpdate_id_TransactionID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_TransactionID(pctxt, pvalue->value.u._e2ap_RICserviceUpdate_IEs_id_id_TransactionID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICserviceUpdate_IEs_id_id_TransactionID);
           // pvalue->value.u._e2ap_RICserviceUpdate_IEs_id_id_TransactionID = NULL;
           pvalue->value.u._e2ap_RICserviceUpdate_IEs_id_TransactionID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICserviceUpdate_IEs_id_id_RANfunctionsAdded:
            // rtxFreeE2ap_RANfunctions_List(pvalue->value.u._e2ap_RICserviceUpdate_IEs_id_id_RANfunctionsAdded);

            if(pvalue->value.i._e2ap_RICserviceUpdate_id_RANfunctions_List!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RANfunctions_List(pctxt, pvalue->value.u._e2ap_RICserviceUpdate_IEs_id_id_RANfunctionsAdded);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICserviceUpdate_IEs_id_id_RANfunctionsAdded);
           // pvalue->value.u._e2ap_RICserviceUpdate_IEs_id_id_RANfunctionsAdded = NULL;
           pvalue->value.u._e2ap_RICserviceUpdate_IEs_id_RANfunctionsAdded = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICserviceUpdate_IEs_id_id_RANfunctionsModified:
            // rtxFreeE2ap_RANfunctions_List(pvalue->value.u._e2ap_RICserviceUpdate_IEs_id_id_RANfunctionsModified);

            if(pvalue->value.i._e2ap_RICserviceUpdate_id_RANfunctions_List!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RANfunctions_List(pctxt, pvalue->value.u._e2ap_RICserviceUpdate_IEs_id_id_RANfunctionsModified);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICserviceUpdate_IEs_id_id_RANfunctionsModified);
           // pvalue->value.u._e2ap_RICserviceUpdate_IEs_id_id_RANfunctionsModified = NULL;
           pvalue->value.u._e2ap_RICserviceUpdate_IEs_id_RANfunctionsModified = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICserviceUpdate_IEs_id_id_RANfunctionsDeleted:
            // rtxFreeE2ap_RANfunctionsID_List(pvalue->value.u._e2ap_RICserviceUpdate_IEs_id_id_RANfunctionsDeleted);

            if(pvalue->value.i._e2ap_RICserviceUpdate_id_RANfunctionsID_List!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RANfunctionsID_List(pctxt, pvalue->value.u._e2ap_RICserviceUpdate_IEs_id_id_RANfunctionsDeleted);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICserviceUpdate_IEs_id_id_RANfunctionsDeleted);
           // pvalue->value.u._e2ap_RICserviceUpdate_IEs_id_id_RANfunctionsDeleted = NULL;
           pvalue->value.u._e2ap_RICserviceUpdate_IEs_id_RANfunctionsDeleted = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICserviceUpdate_IEs_UNDEF_:
            rtxFreeASN1OpenType(pvalue->value.u.extElem1);
            break;
        default:
            break;
    }
}

int asn1PrtToStr_e2ap_RICserviceUpdate_protocolIEs_element(OSCTXT* pctxt, e2ap_RICserviceUpdate_protocolIEs_element* pvalue)
{
    int stat =0;
    RTXCTXTPUSHELEMNAME(pctxt, "e2ap_RICserviceUpdate_protocolIEs_element");

    /*print id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PrtToStr_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PrtToStr_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_RICserviceUpdate_IEs_id_id_TransactionID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "TransactionID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_TransactionID (pctxt, pvalue->value.u._e2ap_RICserviceUpdate_IEs_id_id_TransactionID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICserviceUpdate_IEs_id_id_RANfunctionsAdded:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RANfunctions-List");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RANfunctions_List (pctxt, pvalue->value.u._e2ap_RICserviceUpdate_IEs_id_id_RANfunctionsAdded);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICserviceUpdate_IEs_id_id_RANfunctionsModified:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RANfunctions-List");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RANfunctions_List (pctxt, pvalue->value.u._e2ap_RICserviceUpdate_IEs_id_id_RANfunctionsModified);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICserviceUpdate_IEs_id_id_RANfunctionsDeleted:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RANfunctionsID-List");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RANfunctionsID_List (pctxt, pvalue->value.u._e2ap_RICserviceUpdate_IEs_id_id_RANfunctionsDeleted);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_RICserviceUpdate_IEs_UNDEF_:
            {
                rtxPLogMsg(pctxt, "Extension element present - raw data not printed.\n");
                break;
            }

            default:
                stat = RTERR_INVOPT;
                return LOG_RTERR(pctxt, stat);
        }
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);
}
#endif


int asn1PrtToStr_e2ap_RICserviceUpdate_protocolIEs_element (const char * name,
 e2ap_RICserviceUpdate_protocolIEs_element* pvalue, 
 char * buffer, OSSIZE bufSize){
    if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
        return -1;
    if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
        return -1;

    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICserviceUpdate_IEs_id_TransactionID:
            if(asn1PrtToStr_e2ap_TransactionID("TransactionID", 
                    pvalue->value.u._e2ap_RICserviceUpdate_IEs_id_TransactionID, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICserviceUpdate_IEs_id_RANfunctionsAdded:
            if(asn1PrtToStr_e2ap_RANfunctions_List("RANfunctions-List", 
                    pvalue->value.u._e2ap_RICserviceUpdate_IEs_id_RANfunctionsAdded, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICserviceUpdate_IEs_id_RANfunctionsModified:
            if(asn1PrtToStr_e2ap_RANfunctions_List("RANfunctions-List", 
                    pvalue->value.u._e2ap_RICserviceUpdate_IEs_id_RANfunctionsModified, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICserviceUpdate_IEs_id_RANfunctionsDeleted:
            if(asn1PrtToStr_e2ap_RANfunctionsID_List("RANfunctionsID-List", 
                    pvalue->value.u._e2ap_RICserviceUpdate_IEs_id_RANfunctionsDeleted, buffer, bufSize)<0)
                return -1;
            break;    
        default:
        if(0!=pvalue -> value.u.extElem1){
            rtPrintToStringIndent(buffer, bufSize);
            rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

        }
        }
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

    return 0;

 }

 void asn1Free_e2ap_RICserviceUpdate_protocolIEs_element(OSCTXT* pctxt, e2ap_RICserviceUpdate_protocolIEs_element* pvalue){
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICserviceUpdate_IEs_id_TransactionID:
            if(pvalue->value.u._e2ap_RICserviceUpdate_IEs_id_TransactionID!=NULL){
            asn1Free_e2ap_TransactionID(pctxt, pvalue->value.u._e2ap_RICserviceUpdate_IEs_id_TransactionID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICserviceUpdate_IEs_id_TransactionID);
            pvalue->value.u._e2ap_RICserviceUpdate_IEs_id_TransactionID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICserviceUpdate_IEs_id_RANfunctionsAdded:
            if(pvalue->value.u._e2ap_RICserviceUpdate_IEs_id_RANfunctionsAdded!=NULL){
            asn1Free_e2ap_RANfunctions_List(pctxt, pvalue->value.u._e2ap_RICserviceUpdate_IEs_id_RANfunctionsAdded);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICserviceUpdate_IEs_id_RANfunctionsAdded);
            pvalue->value.u._e2ap_RICserviceUpdate_IEs_id_RANfunctionsAdded = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICserviceUpdate_IEs_id_RANfunctionsModified:
            if(pvalue->value.u._e2ap_RICserviceUpdate_IEs_id_RANfunctionsModified!=NULL){
            asn1Free_e2ap_RANfunctions_List(pctxt, pvalue->value.u._e2ap_RICserviceUpdate_IEs_id_RANfunctionsModified);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICserviceUpdate_IEs_id_RANfunctionsModified);
            pvalue->value.u._e2ap_RICserviceUpdate_IEs_id_RANfunctionsModified = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICserviceUpdate_IEs_id_RANfunctionsDeleted:
            if(pvalue->value.u._e2ap_RICserviceUpdate_IEs_id_RANfunctionsDeleted!=NULL){
            asn1Free_e2ap_RANfunctionsID_List(pctxt, pvalue->value.u._e2ap_RICserviceUpdate_IEs_id_RANfunctionsDeleted);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICserviceUpdate_IEs_id_RANfunctionsDeleted);
            pvalue->value.u._e2ap_RICserviceUpdate_IEs_id_RANfunctionsDeleted = NULL;
            }
            break;
        default:
            break;


    }
 }

 

/*****************************************/
/*           RICserviceUpdate                */
/*****************************************/
//2_container.c
/* 1. xxx_ProtocolIE -> mẫu cũ ở ie_big_msg */
EXTERN int asn1PE_e2ap_RICserviceUpdate_protocolIEs (OSCTXT* pctxt, e2ap_RICserviceUpdate_protocolIEs* pvalue)
{
    int stat =0;
    OSRTDListNode* pnode;
    OSUINT32 xx1;

    /*encode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pe_Length(pctxt, pvalue->count);
    if(stat<0) return LOG_RTERR(pctxt, stat);

    /*encode each element*/
    xx1 =0;
    for(pnode = pvalue->head; pnode != 0 && xx1<pvalue->count; pnode = pnode->next){
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE", xx1);
        stat = asn1PE_e2ap_RICserviceUpdate_protocolIEs_element (pctxt, ((e2ap_RICserviceUpdate_protocolIEs_element*)pnode->data));
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        xx1++;
        RTXCTXTPOPARRAYELEMNAME(pctxt);
    }

    return (stat);
}

EXTERN int  asn1PD_e2ap_RICserviceUpdate_protocolIEs(OSCTXT* pctxt, e2ap_RICserviceUpdate_protocolIEs* pvalue)
{
     int stat =0;
     OSRTDListNode* pnode;
     OSSIZE count =0;
     OSSIZE xx1=0;


     /*decode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pd_Length64(pctxt, &count); //tai sao lai 64
    if(stat!=0) return LOG_RTERR(pctxt, stat);

    /*decode each element*/
    rtxDListInit(pvalue);

    for(xx1=0; xx1 < count; xx1++){
        e2ap_RICserviceUpdate_protocolIEs_element* pdata;
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE",xx1);

        if(pnode == NULL) return LOG_RTERR(pctxt, RTERR_NOMEM);

        asn1Init_e2ap_RICserviceUpdate_protocolIEs_element(pdata);
        rtxDListAppendNode(pvalue, pnode);
        stat = asn1PD_e2ap_RICserviceUpdate_protocolIEs_element (pctxt, pdata);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        RTXCTXTPOPARRAYELEMNAME(pctxt);

    }
    return (stat);
}


int asn1Init_e2ap_RICserviceUpdate_protocolIEs(e2ap_RICserviceUpdate_protocolIEs* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    rtxDListFastInit (pvalue);
    return 0;
}
#if 1 //ao that day
void asn1Free_e2ap_RICserviceUpdate_protocolIEs(OSCTXT* pctxt, e2ap_RICserviceUpdate_protocolIEs* pvalue)
{
    if(0==pvalue) return;   
    e2ap_RICserviceUpdate_protocolIEs_element* pdata;
    OSRTDListNode* pnode=pvalue->head;
    while(0!=pnode){
        pdata = (e2ap_RICserviceUpdate_protocolIEs_element*)pnode->data;
       // asn1Free_e2ap_RICserviceUpdate_protocolIEs_element(pctxt, pdata);
        pnode = pnode->next;
    }
    rtxDListFreeAll(pctxt, pvalue);
}
#endif


EXTERN int asn1PrtToStr_e2ap_RICserviceUpdate_protocolIEs(const char* name, e2ap_RICserviceUpdate_protocolIEs* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_RICserviceUpdate_protocolIEs_element* pdata0;
    OSRTDListNode* pnode0;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode0 = pvalue->head;  xx1 < pvalue->count && pnode0 != 0; pnode0 = pnode0->next, xx1++){
        pdata0 = (e2ap_RICserviceUpdate_protocolIEs_element*)pnode0->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 0
        if(asn1PrtToStr_e2ap_RICserviceUpdate_protocolIEs_element(nameBuf, pdata0, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}


/*2 . RICserviceUpdate -> mẫu cũ ở seq_normal*/

int asn1PE_e2ap_RICserviceUpdate (OSCTXT* pctxt, e2ap_RICserviceUpdate* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RICserviceUpdate");
   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field protocolIEs - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
   stat = asn1PE_e2ap_RICserviceUpdate_protocolIEs (pctxt, &pvalue->protocolIEs);
   if(stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RICserviceUpdate (OSCTXT* pctxt, e2ap_RICserviceUpdate* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME(pctxt, "RICserviceUpdate");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field protocolIEs */
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
      stat = asn1PD_e2ap_RICserviceUpdate_protocolIEs (pctxt, &pvalue->protocolIEs);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RICserviceUpdate (e2ap_RICserviceUpdate* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RICserviceUpdate_protocolIEs(&pvalue->protocolIEs);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RICserviceUpdate (OSCTXT* pctxt, e2ap_RICserviceUpdate* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_RICserviceUpdate_protocolIEs(pctxt, &pvalue->protocolIEs);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RICserviceUpdate (const char* name, e2ap_RICserviceUpdate* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }

   if(asn1PrtToStr_e2ap_RICserviceUpdate_protocolIEs("protocolIEs", &pvalue->protocolIEs, buffer, bufSize) <0){
      return -1;
   }

   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           RICserviceUpdateAcknowledge_IEs                */
/*****************************************/
/* ie.c.j2 */
 /* d là con của msg */
EXTERN int asn1PE_e2ap_RICserviceUpdateAcknowledge_protocolIEs_element (OSCTXT* pctxt, e2ap_RICserviceUpdateAcknowledge_protocolIEs_element* pvalue)
{
    int stat =0;

    /*encode id*/

    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PE_e2ap_ProtocolIE_ID(pctxt, pvalue->id);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PE_e2ap_Criticality(pctxt, pvalue->criticality);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
    {
        OSCTXT lctxt;
        OSOCTET *pDynamicEncodeBuffer;
        ASN1OpenType openType;
        OSBOOL encoded = TRUE;

        openType.numocts = 0;
        openType.data =0;

        rtxCopyContext(&lctxt, pctxt);
        pctxt->pStream =0;

        stat = rtxInitContextBuffer(pctxt, 0, 0);
        if(stat!=0) return LOG_RTERR(pctxt, stat);

        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_RICserviceUpdateAcknowledge_IEs_id_TransactionID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-TransactionID");
                    stat = asn1PE_e2ap_TransactionID (pctxt, pvalue->value.u._e2ap_RICserviceUpdateAcknowledge_IEs_id_TransactionID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICserviceUpdateAcknowledge_IEs_id_RANfunctionsAccepted:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RANfunctionsAccepted");
                    stat = asn1PE_e2ap_RANfunctionsID_List (pctxt, pvalue->value.u._e2ap_RICserviceUpdateAcknowledge_IEs_id_RANfunctionsAccepted);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICserviceUpdateAcknowledge_IEs_id_RANfunctionsRejected:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RANfunctionsRejected");
                    stat = asn1PE_e2ap_RANfunctionsIDcause_List (pctxt, pvalue->value.u._e2ap_RICserviceUpdateAcknowledge_IEs_id_RANfunctionsRejected);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_RICserviceUpdateAcknowledge_IEs_UNDEF_:
            {
                if(0!=pvalue->value.u.extElem1){
                    openType.numocts = pvalue->value.u.extElem1->numocts;
                    openType.data = pvalue->value.u.extElem1->data;
                } else {
                    /* No extension element to encode */
                }
                encoded = FALSE;
                break;
            }

            default:
                encoded = FALSE;
                stat = RTERR_INVOPT;
                break;
        } 

        if(encoded){
            openType.numocts = (OSUINT32)pe_GetMsgLen(pctxt);
            openType.data = pDynamicEncodeBuffer = pctxt -> buffer.data;
        }
        rtxCopyContext(pctxt, &lctxt);

        if(stat == 0) {
            stat = pe_OpenType (pctxt, openType.numocts, openType.data);
        }
    #if 1
        if(encoded){//dungnm23 check lai nhe
            rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
        }
    #endif

    }

    if(stat!=0) return LOG_RTERR(pctxt, stat);  
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}

EXTERN int  asn1PD_e2ap_RICserviceUpdateAcknowledge_protocolIEs_element (OSCTXT* pctxt, e2ap_RICserviceUpdateAcknowledge_protocolIEs_element* pvalue){
    int stat =0;

    /*decode id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PD_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PD_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");

    {
        OSUINT32 openTypeLen;
        size_t bitStartOffset, bitLength;

        stat = pd_UnconsLength(pctxt, &openTypeLen);
        if(stat<0) return LOG_RTERR(pctxt, stat);
        else if(stat == RT_OK_FRAG){
            rtxErrAddStrParm(pctxt, "open type with fragment length");
            return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
        }
        bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
        bitLength = openTypeLen * 8;

        switch(pvalue->id){//dungnm23 check case lai nhe
        
            case ASN1V_e2ap_id_TransactionID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICserviceUpdateAcknowledge_IEs_id_TransactionID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-TransactionID");
                pvalue->value.u._e2ap_RICserviceUpdateAcknowledge_IEs_id_TransactionID 
                    = rtxMemAllocType(pctxt, e2ap_TransactionID);

                asn1Init_e2ap_TransactionID(pvalue->value.u._e2ap_RICserviceUpdateAcknowledge_IEs_id_TransactionID);

                stat = asn1PD_e2ap_TransactionID (pctxt,
                        (e2ap_TransactionID*)pvalue->value.
                        u._e2ap_RICserviceUpdateAcknowledge_IEs_id_TransactionID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RANfunctionsAccepted:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICserviceUpdateAcknowledge_IEs_id_RANfunctionsAccepted;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RANfunctionsAccepted");
                pvalue->value.u._e2ap_RICserviceUpdateAcknowledge_IEs_id_RANfunctionsAccepted 
                    = rtxMemAllocType(pctxt, e2ap_RANfunctionsID_List);

                asn1Init_e2ap_RANfunctionsID_List(pvalue->value.u._e2ap_RICserviceUpdateAcknowledge_IEs_id_RANfunctionsAccepted);

                stat = asn1PD_e2ap_RANfunctionsID_List (pctxt,
                        (e2ap_RANfunctionsID_List*)pvalue->value.
                        u._e2ap_RICserviceUpdateAcknowledge_IEs_id_RANfunctionsAccepted);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RANfunctionsRejected:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICserviceUpdateAcknowledge_IEs_id_RANfunctionsRejected;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RANfunctionsRejected");
                pvalue->value.u._e2ap_RICserviceUpdateAcknowledge_IEs_id_RANfunctionsRejected 
                    = rtxMemAllocType(pctxt, e2ap_RANfunctionsIDcause_List);

                asn1Init_e2ap_RANfunctionsIDcause_List(pvalue->value.u._e2ap_RICserviceUpdateAcknowledge_IEs_id_RANfunctionsRejected);

                stat = asn1PD_e2ap_RANfunctionsIDcause_List (pctxt,
                        (e2ap_RANfunctionsIDcause_List*)pvalue->value.
                        u._e2ap_RICserviceUpdateAcknowledge_IEs_id_RANfunctionsRejected);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICserviceUpdateAcknowledge_IEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*) rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
    }
    {
    size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
    size_t bitsConsumed = bitEndOffset-bitStartOffset;
    if(bitsConsumed<bitLength){
        stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
    }
    else stat =(bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
    }}
    if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}


int asn1Init_e2ap_RICserviceUpdateAcknowledge_protocolIEs_element(e2ap_RICserviceUpdateAcknowledge_protocolIEs_element* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    OSCRTLMEMSET (&pvalue->value, 0, sizeof(pvalue->value));
    return 0;
}


//-----> chuaw có template rtxFreeASN1OpenType

#if 0
void asn1Free_e2ap_RICserviceUpdateAcknowledge_protocolIEs_element(OSCTXT* pctxt, e2ap_RICserviceUpdateAcknowledge_protocolIEs_element* pvalue)
{
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICserviceUpdateAcknowledge_IEs_id_id_TransactionID:
            // rtxFreeE2ap_TransactionID(pvalue->value.u._e2ap_RICserviceUpdateAcknowledge_IEs_id_id_TransactionID);

            if(pvalue->value.i._e2ap_RICserviceUpdateAcknowledge_id_TransactionID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_TransactionID(pctxt, pvalue->value.u._e2ap_RICserviceUpdateAcknowledge_IEs_id_id_TransactionID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICserviceUpdateAcknowledge_IEs_id_id_TransactionID);
           // pvalue->value.u._e2ap_RICserviceUpdateAcknowledge_IEs_id_id_TransactionID = NULL;
           pvalue->value.u._e2ap_RICserviceUpdateAcknowledge_IEs_id_TransactionID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICserviceUpdateAcknowledge_IEs_id_id_RANfunctionsAccepted:
            // rtxFreeE2ap_RANfunctionsID_List(pvalue->value.u._e2ap_RICserviceUpdateAcknowledge_IEs_id_id_RANfunctionsAccepted);

            if(pvalue->value.i._e2ap_RICserviceUpdateAcknowledge_id_RANfunctionsID_List!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RANfunctionsID_List(pctxt, pvalue->value.u._e2ap_RICserviceUpdateAcknowledge_IEs_id_id_RANfunctionsAccepted);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICserviceUpdateAcknowledge_IEs_id_id_RANfunctionsAccepted);
           // pvalue->value.u._e2ap_RICserviceUpdateAcknowledge_IEs_id_id_RANfunctionsAccepted = NULL;
           pvalue->value.u._e2ap_RICserviceUpdateAcknowledge_IEs_id_RANfunctionsAccepted = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICserviceUpdateAcknowledge_IEs_id_id_RANfunctionsRejected:
            // rtxFreeE2ap_RANfunctionsIDcause_List(pvalue->value.u._e2ap_RICserviceUpdateAcknowledge_IEs_id_id_RANfunctionsRejected);

            if(pvalue->value.i._e2ap_RICserviceUpdateAcknowledge_id_RANfunctionsIDcause_List!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RANfunctionsIDcause_List(pctxt, pvalue->value.u._e2ap_RICserviceUpdateAcknowledge_IEs_id_id_RANfunctionsRejected);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICserviceUpdateAcknowledge_IEs_id_id_RANfunctionsRejected);
           // pvalue->value.u._e2ap_RICserviceUpdateAcknowledge_IEs_id_id_RANfunctionsRejected = NULL;
           pvalue->value.u._e2ap_RICserviceUpdateAcknowledge_IEs_id_RANfunctionsRejected = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICserviceUpdateAcknowledge_IEs_UNDEF_:
            rtxFreeASN1OpenType(pvalue->value.u.extElem1);
            break;
        default:
            break;
    }
}

int asn1PrtToStr_e2ap_RICserviceUpdateAcknowledge_protocolIEs_element(OSCTXT* pctxt, e2ap_RICserviceUpdateAcknowledge_protocolIEs_element* pvalue)
{
    int stat =0;
    RTXCTXTPUSHELEMNAME(pctxt, "e2ap_RICserviceUpdateAcknowledge_protocolIEs_element");

    /*print id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PrtToStr_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PrtToStr_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_RICserviceUpdateAcknowledge_IEs_id_id_TransactionID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "TransactionID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_TransactionID (pctxt, pvalue->value.u._e2ap_RICserviceUpdateAcknowledge_IEs_id_id_TransactionID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICserviceUpdateAcknowledge_IEs_id_id_RANfunctionsAccepted:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RANfunctionsID-List");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RANfunctionsID_List (pctxt, pvalue->value.u._e2ap_RICserviceUpdateAcknowledge_IEs_id_id_RANfunctionsAccepted);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICserviceUpdateAcknowledge_IEs_id_id_RANfunctionsRejected:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RANfunctionsIDcause-List");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RANfunctionsIDcause_List (pctxt, pvalue->value.u._e2ap_RICserviceUpdateAcknowledge_IEs_id_id_RANfunctionsRejected);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_RICserviceUpdateAcknowledge_IEs_UNDEF_:
            {
                rtxPLogMsg(pctxt, "Extension element present - raw data not printed.\n");
                break;
            }

            default:
                stat = RTERR_INVOPT;
                return LOG_RTERR(pctxt, stat);
        }
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);
}
#endif


int asn1PrtToStr_e2ap_RICserviceUpdateAcknowledge_protocolIEs_element (const char * name,
 e2ap_RICserviceUpdateAcknowledge_protocolIEs_element* pvalue, 
 char * buffer, OSSIZE bufSize){
    if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
        return -1;
    if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
        return -1;

    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICserviceUpdateAcknowledge_IEs_id_TransactionID:
            if(asn1PrtToStr_e2ap_TransactionID("TransactionID", 
                    pvalue->value.u._e2ap_RICserviceUpdateAcknowledge_IEs_id_TransactionID, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICserviceUpdateAcknowledge_IEs_id_RANfunctionsAccepted:
            if(asn1PrtToStr_e2ap_RANfunctionsID_List("RANfunctionsID-List", 
                    pvalue->value.u._e2ap_RICserviceUpdateAcknowledge_IEs_id_RANfunctionsAccepted, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICserviceUpdateAcknowledge_IEs_id_RANfunctionsRejected:
            if(asn1PrtToStr_e2ap_RANfunctionsIDcause_List("RANfunctionsIDcause-List", 
                    pvalue->value.u._e2ap_RICserviceUpdateAcknowledge_IEs_id_RANfunctionsRejected, buffer, bufSize)<0)
                return -1;
            break;    
        default:
        if(0!=pvalue -> value.u.extElem1){
            rtPrintToStringIndent(buffer, bufSize);
            rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

        }
        }
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

    return 0;

 }

 void asn1Free_e2ap_RICserviceUpdateAcknowledge_protocolIEs_element(OSCTXT* pctxt, e2ap_RICserviceUpdateAcknowledge_protocolIEs_element* pvalue){
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICserviceUpdateAcknowledge_IEs_id_TransactionID:
            if(pvalue->value.u._e2ap_RICserviceUpdateAcknowledge_IEs_id_TransactionID!=NULL){
            asn1Free_e2ap_TransactionID(pctxt, pvalue->value.u._e2ap_RICserviceUpdateAcknowledge_IEs_id_TransactionID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICserviceUpdateAcknowledge_IEs_id_TransactionID);
            pvalue->value.u._e2ap_RICserviceUpdateAcknowledge_IEs_id_TransactionID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICserviceUpdateAcknowledge_IEs_id_RANfunctionsAccepted:
            if(pvalue->value.u._e2ap_RICserviceUpdateAcknowledge_IEs_id_RANfunctionsAccepted!=NULL){
            asn1Free_e2ap_RANfunctionsID_List(pctxt, pvalue->value.u._e2ap_RICserviceUpdateAcknowledge_IEs_id_RANfunctionsAccepted);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICserviceUpdateAcknowledge_IEs_id_RANfunctionsAccepted);
            pvalue->value.u._e2ap_RICserviceUpdateAcknowledge_IEs_id_RANfunctionsAccepted = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICserviceUpdateAcknowledge_IEs_id_RANfunctionsRejected:
            if(pvalue->value.u._e2ap_RICserviceUpdateAcknowledge_IEs_id_RANfunctionsRejected!=NULL){
            asn1Free_e2ap_RANfunctionsIDcause_List(pctxt, pvalue->value.u._e2ap_RICserviceUpdateAcknowledge_IEs_id_RANfunctionsRejected);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICserviceUpdateAcknowledge_IEs_id_RANfunctionsRejected);
            pvalue->value.u._e2ap_RICserviceUpdateAcknowledge_IEs_id_RANfunctionsRejected = NULL;
            }
            break;
        default:
            break;


    }
 }

 

/*****************************************/
/*           RICserviceUpdateAcknowledge                */
/*****************************************/
//2_container.c
/* 1. xxx_ProtocolIE -> mẫu cũ ở ie_big_msg */
EXTERN int asn1PE_e2ap_RICserviceUpdateAcknowledge_protocolIEs (OSCTXT* pctxt, e2ap_RICserviceUpdateAcknowledge_protocolIEs* pvalue)
{
    int stat =0;
    OSRTDListNode* pnode;
    OSUINT32 xx1;

    /*encode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pe_Length(pctxt, pvalue->count);
    if(stat<0) return LOG_RTERR(pctxt, stat);

    /*encode each element*/
    xx1 =0;
    for(pnode = pvalue->head; pnode != 0 && xx1<pvalue->count; pnode = pnode->next){
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE", xx1);
        stat = asn1PE_e2ap_RICserviceUpdateAcknowledge_protocolIEs_element (pctxt, ((e2ap_RICserviceUpdateAcknowledge_protocolIEs_element*)pnode->data));
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        xx1++;
        RTXCTXTPOPARRAYELEMNAME(pctxt);
    }

    return (stat);
}

EXTERN int  asn1PD_e2ap_RICserviceUpdateAcknowledge_protocolIEs(OSCTXT* pctxt, e2ap_RICserviceUpdateAcknowledge_protocolIEs* pvalue)
{
     int stat =0;
     OSRTDListNode* pnode;
     OSSIZE count =0;
     OSSIZE xx1=0;


     /*decode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pd_Length64(pctxt, &count); //tai sao lai 64
    if(stat!=0) return LOG_RTERR(pctxt, stat);

    /*decode each element*/
    rtxDListInit(pvalue);

    for(xx1=0; xx1 < count; xx1++){
        e2ap_RICserviceUpdateAcknowledge_protocolIEs_element* pdata;
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE",xx1);

        if(pnode == NULL) return LOG_RTERR(pctxt, RTERR_NOMEM);

        asn1Init_e2ap_RICserviceUpdateAcknowledge_protocolIEs_element(pdata);
        rtxDListAppendNode(pvalue, pnode);
        stat = asn1PD_e2ap_RICserviceUpdateAcknowledge_protocolIEs_element (pctxt, pdata);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        RTXCTXTPOPARRAYELEMNAME(pctxt);

    }
    return (stat);
}


int asn1Init_e2ap_RICserviceUpdateAcknowledge_protocolIEs(e2ap_RICserviceUpdateAcknowledge_protocolIEs* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    rtxDListFastInit (pvalue);
    return 0;
}
#if 1 //ao that day
void asn1Free_e2ap_RICserviceUpdateAcknowledge_protocolIEs(OSCTXT* pctxt, e2ap_RICserviceUpdateAcknowledge_protocolIEs* pvalue)
{
    if(0==pvalue) return;   
    e2ap_RICserviceUpdateAcknowledge_protocolIEs_element* pdata;
    OSRTDListNode* pnode=pvalue->head;
    while(0!=pnode){
        pdata = (e2ap_RICserviceUpdateAcknowledge_protocolIEs_element*)pnode->data;
       // asn1Free_e2ap_RICserviceUpdateAcknowledge_protocolIEs_element(pctxt, pdata);
        pnode = pnode->next;
    }
    rtxDListFreeAll(pctxt, pvalue);
}
#endif


EXTERN int asn1PrtToStr_e2ap_RICserviceUpdateAcknowledge_protocolIEs(const char* name, e2ap_RICserviceUpdateAcknowledge_protocolIEs* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_RICserviceUpdateAcknowledge_protocolIEs_element* pdata0;
    OSRTDListNode* pnode0;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode0 = pvalue->head;  xx1 < pvalue->count && pnode0 != 0; pnode0 = pnode0->next, xx1++){
        pdata0 = (e2ap_RICserviceUpdateAcknowledge_protocolIEs_element*)pnode0->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 0
        if(asn1PrtToStr_e2ap_RICserviceUpdateAcknowledge_protocolIEs_element(nameBuf, pdata0, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}


/*2 . RICserviceUpdateAcknowledge -> mẫu cũ ở seq_normal*/

int asn1PE_e2ap_RICserviceUpdateAcknowledge (OSCTXT* pctxt, e2ap_RICserviceUpdateAcknowledge* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RICserviceUpdateAcknowledge");
   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field protocolIEs - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
   stat = asn1PE_e2ap_RICserviceUpdateAcknowledge_protocolIEs (pctxt, &pvalue->protocolIEs);
   if(stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RICserviceUpdateAcknowledge (OSCTXT* pctxt, e2ap_RICserviceUpdateAcknowledge* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME(pctxt, "RICserviceUpdateAcknowledge");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field protocolIEs */
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
      stat = asn1PD_e2ap_RICserviceUpdateAcknowledge_protocolIEs (pctxt, &pvalue->protocolIEs);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RICserviceUpdateAcknowledge (e2ap_RICserviceUpdateAcknowledge* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RICserviceUpdateAcknowledge_protocolIEs(&pvalue->protocolIEs);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RICserviceUpdateAcknowledge (OSCTXT* pctxt, e2ap_RICserviceUpdateAcknowledge* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_RICserviceUpdateAcknowledge_protocolIEs(pctxt, &pvalue->protocolIEs);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RICserviceUpdateAcknowledge (const char* name, e2ap_RICserviceUpdateAcknowledge* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }

   if(asn1PrtToStr_e2ap_RICserviceUpdateAcknowledge_protocolIEs("protocolIEs", &pvalue->protocolIEs, buffer, bufSize) <0){
      return -1;
   }

   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           RICserviceUpdateFailure_IEs                */
/*****************************************/
/* ie.c.j2 */
 /* d là con của msg */
EXTERN int asn1PE_e2ap_RICserviceUpdateFailure_protocolIEs_element (OSCTXT* pctxt, e2ap_RICserviceUpdateFailure_protocolIEs_element* pvalue)
{
    int stat =0;

    /*encode id*/

    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PE_e2ap_ProtocolIE_ID(pctxt, pvalue->id);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PE_e2ap_Criticality(pctxt, pvalue->criticality);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
    {
        OSCTXT lctxt;
        OSOCTET *pDynamicEncodeBuffer;
        ASN1OpenType openType;
        OSBOOL encoded = TRUE;

        openType.numocts = 0;
        openType.data =0;

        rtxCopyContext(&lctxt, pctxt);
        pctxt->pStream =0;

        stat = rtxInitContextBuffer(pctxt, 0, 0);
        if(stat!=0) return LOG_RTERR(pctxt, stat);

        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_RICserviceUpdateFailure_IEs_id_TransactionID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-TransactionID");
                    stat = asn1PE_e2ap_TransactionID (pctxt, pvalue->value.u._e2ap_RICserviceUpdateFailure_IEs_id_TransactionID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICserviceUpdateFailure_IEs_id_Cause:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-Cause");
                    stat = asn1PE_e2ap_Cause (pctxt, pvalue->value.u._e2ap_RICserviceUpdateFailure_IEs_id_Cause);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICserviceUpdateFailure_IEs_id_TimeToWait:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-TimeToWait");
                    stat = asn1PE_e2ap_TimeToWait (pctxt, pvalue->value.u._e2ap_RICserviceUpdateFailure_IEs_id_TimeToWait);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICserviceUpdateFailure_IEs_id_CriticalityDiagnostics:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-CriticalityDiagnostics");
                    stat = asn1PE_e2ap_CriticalityDiagnostics (pctxt, pvalue->value.u._e2ap_RICserviceUpdateFailure_IEs_id_CriticalityDiagnostics);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_RICserviceUpdateFailure_IEs_UNDEF_:
            {
                if(0!=pvalue->value.u.extElem1){
                    openType.numocts = pvalue->value.u.extElem1->numocts;
                    openType.data = pvalue->value.u.extElem1->data;
                } else {
                    /* No extension element to encode */
                }
                encoded = FALSE;
                break;
            }

            default:
                encoded = FALSE;
                stat = RTERR_INVOPT;
                break;
        } 

        if(encoded){
            openType.numocts = (OSUINT32)pe_GetMsgLen(pctxt);
            openType.data = pDynamicEncodeBuffer = pctxt -> buffer.data;
        }
        rtxCopyContext(pctxt, &lctxt);

        if(stat == 0) {
            stat = pe_OpenType (pctxt, openType.numocts, openType.data);
        }
    #if 1
        if(encoded){//dungnm23 check lai nhe
            rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
        }
    #endif

    }

    if(stat!=0) return LOG_RTERR(pctxt, stat);  
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}

EXTERN int  asn1PD_e2ap_RICserviceUpdateFailure_protocolIEs_element (OSCTXT* pctxt, e2ap_RICserviceUpdateFailure_protocolIEs_element* pvalue){
    int stat =0;

    /*decode id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PD_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PD_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");

    {
        OSUINT32 openTypeLen;
        size_t bitStartOffset, bitLength;

        stat = pd_UnconsLength(pctxt, &openTypeLen);
        if(stat<0) return LOG_RTERR(pctxt, stat);
        else if(stat == RT_OK_FRAG){
            rtxErrAddStrParm(pctxt, "open type with fragment length");
            return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
        }
        bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
        bitLength = openTypeLen * 8;

        switch(pvalue->id){//dungnm23 check case lai nhe
        
            case ASN1V_e2ap_id_TransactionID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICserviceUpdateFailure_IEs_id_TransactionID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-TransactionID");
                pvalue->value.u._e2ap_RICserviceUpdateFailure_IEs_id_TransactionID 
                    = rtxMemAllocType(pctxt, e2ap_TransactionID);

                asn1Init_e2ap_TransactionID(pvalue->value.u._e2ap_RICserviceUpdateFailure_IEs_id_TransactionID);

                stat = asn1PD_e2ap_TransactionID (pctxt,
                        (e2ap_TransactionID*)pvalue->value.
                        u._e2ap_RICserviceUpdateFailure_IEs_id_TransactionID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_Cause:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICserviceUpdateFailure_IEs_id_Cause;
            RTXCTXTPUSHELEMNAME(pctxt, "id-Cause");
                pvalue->value.u._e2ap_RICserviceUpdateFailure_IEs_id_Cause 
                    = rtxMemAllocType(pctxt, e2ap_Cause);

                asn1Init_e2ap_Cause(pvalue->value.u._e2ap_RICserviceUpdateFailure_IEs_id_Cause);

                stat = asn1PD_e2ap_Cause (pctxt,
                        (e2ap_Cause*)pvalue->value.
                        u._e2ap_RICserviceUpdateFailure_IEs_id_Cause);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_TimeToWait:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICserviceUpdateFailure_IEs_id_TimeToWait;
            RTXCTXTPUSHELEMNAME(pctxt, "id-TimeToWait");
                pvalue->value.u._e2ap_RICserviceUpdateFailure_IEs_id_TimeToWait 
                    = rtxMemAllocType(pctxt, e2ap_TimeToWait);

                asn1Init_e2ap_TimeToWait(pvalue->value.u._e2ap_RICserviceUpdateFailure_IEs_id_TimeToWait);

                stat = asn1PD_e2ap_TimeToWait (pctxt,
                        (e2ap_TimeToWait*)pvalue->value.
                        u._e2ap_RICserviceUpdateFailure_IEs_id_TimeToWait);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_CriticalityDiagnostics:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICserviceUpdateFailure_IEs_id_CriticalityDiagnostics;
            RTXCTXTPUSHELEMNAME(pctxt, "id-CriticalityDiagnostics");
                pvalue->value.u._e2ap_RICserviceUpdateFailure_IEs_id_CriticalityDiagnostics 
                    = rtxMemAllocType(pctxt, e2ap_CriticalityDiagnostics);

                asn1Init_e2ap_CriticalityDiagnostics(pvalue->value.u._e2ap_RICserviceUpdateFailure_IEs_id_CriticalityDiagnostics);

                stat = asn1PD_e2ap_CriticalityDiagnostics (pctxt,
                        (e2ap_CriticalityDiagnostics*)pvalue->value.
                        u._e2ap_RICserviceUpdateFailure_IEs_id_CriticalityDiagnostics);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICserviceUpdateFailure_IEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*) rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
    }
    {
    size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
    size_t bitsConsumed = bitEndOffset-bitStartOffset;
    if(bitsConsumed<bitLength){
        stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
    }
    else stat =(bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
    }}
    if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}


int asn1Init_e2ap_RICserviceUpdateFailure_protocolIEs_element(e2ap_RICserviceUpdateFailure_protocolIEs_element* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    OSCRTLMEMSET (&pvalue->value, 0, sizeof(pvalue->value));
    return 0;
}


//-----> chuaw có template rtxFreeASN1OpenType

#if 0
void asn1Free_e2ap_RICserviceUpdateFailure_protocolIEs_element(OSCTXT* pctxt, e2ap_RICserviceUpdateFailure_protocolIEs_element* pvalue)
{
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICserviceUpdateFailure_IEs_id_id_TransactionID:
            // rtxFreeE2ap_TransactionID(pvalue->value.u._e2ap_RICserviceUpdateFailure_IEs_id_id_TransactionID);

            if(pvalue->value.i._e2ap_RICserviceUpdateFailure_id_TransactionID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_TransactionID(pctxt, pvalue->value.u._e2ap_RICserviceUpdateFailure_IEs_id_id_TransactionID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICserviceUpdateFailure_IEs_id_id_TransactionID);
           // pvalue->value.u._e2ap_RICserviceUpdateFailure_IEs_id_id_TransactionID = NULL;
           pvalue->value.u._e2ap_RICserviceUpdateFailure_IEs_id_TransactionID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICserviceUpdateFailure_IEs_id_id_Cause:
            // rtxFreeE2ap_Cause(pvalue->value.u._e2ap_RICserviceUpdateFailure_IEs_id_id_Cause);

            if(pvalue->value.i._e2ap_RICserviceUpdateFailure_id_Cause!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_Cause(pctxt, pvalue->value.u._e2ap_RICserviceUpdateFailure_IEs_id_id_Cause);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICserviceUpdateFailure_IEs_id_id_Cause);
           // pvalue->value.u._e2ap_RICserviceUpdateFailure_IEs_id_id_Cause = NULL;
           pvalue->value.u._e2ap_RICserviceUpdateFailure_IEs_id_Cause = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICserviceUpdateFailure_IEs_id_id_TimeToWait:
            // rtxFreeE2ap_TimeToWait(pvalue->value.u._e2ap_RICserviceUpdateFailure_IEs_id_id_TimeToWait);

            if(pvalue->value.i._e2ap_RICserviceUpdateFailure_id_TimeToWait!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_TimeToWait(pctxt, pvalue->value.u._e2ap_RICserviceUpdateFailure_IEs_id_id_TimeToWait);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICserviceUpdateFailure_IEs_id_id_TimeToWait);
           // pvalue->value.u._e2ap_RICserviceUpdateFailure_IEs_id_id_TimeToWait = NULL;
           pvalue->value.u._e2ap_RICserviceUpdateFailure_IEs_id_TimeToWait = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICserviceUpdateFailure_IEs_id_id_CriticalityDiagnostics:
            // rtxFreeE2ap_CriticalityDiagnostics(pvalue->value.u._e2ap_RICserviceUpdateFailure_IEs_id_id_CriticalityDiagnostics);

            if(pvalue->value.i._e2ap_RICserviceUpdateFailure_id_CriticalityDiagnostics!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_CriticalityDiagnostics(pctxt, pvalue->value.u._e2ap_RICserviceUpdateFailure_IEs_id_id_CriticalityDiagnostics);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICserviceUpdateFailure_IEs_id_id_CriticalityDiagnostics);
           // pvalue->value.u._e2ap_RICserviceUpdateFailure_IEs_id_id_CriticalityDiagnostics = NULL;
           pvalue->value.u._e2ap_RICserviceUpdateFailure_IEs_id_CriticalityDiagnostics = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICserviceUpdateFailure_IEs_UNDEF_:
            rtxFreeASN1OpenType(pvalue->value.u.extElem1);
            break;
        default:
            break;
    }
}

int asn1PrtToStr_e2ap_RICserviceUpdateFailure_protocolIEs_element(OSCTXT* pctxt, e2ap_RICserviceUpdateFailure_protocolIEs_element* pvalue)
{
    int stat =0;
    RTXCTXTPUSHELEMNAME(pctxt, "e2ap_RICserviceUpdateFailure_protocolIEs_element");

    /*print id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PrtToStr_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PrtToStr_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_RICserviceUpdateFailure_IEs_id_id_TransactionID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "TransactionID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_TransactionID (pctxt, pvalue->value.u._e2ap_RICserviceUpdateFailure_IEs_id_id_TransactionID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICserviceUpdateFailure_IEs_id_id_Cause:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "Cause");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_Cause (pctxt, pvalue->value.u._e2ap_RICserviceUpdateFailure_IEs_id_id_Cause);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICserviceUpdateFailure_IEs_id_id_TimeToWait:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "TimeToWait");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_TimeToWait (pctxt, pvalue->value.u._e2ap_RICserviceUpdateFailure_IEs_id_id_TimeToWait);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICserviceUpdateFailure_IEs_id_id_CriticalityDiagnostics:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "CriticalityDiagnostics");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_CriticalityDiagnostics (pctxt, pvalue->value.u._e2ap_RICserviceUpdateFailure_IEs_id_id_CriticalityDiagnostics);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_RICserviceUpdateFailure_IEs_UNDEF_:
            {
                rtxPLogMsg(pctxt, "Extension element present - raw data not printed.\n");
                break;
            }

            default:
                stat = RTERR_INVOPT;
                return LOG_RTERR(pctxt, stat);
        }
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);
}
#endif


int asn1PrtToStr_e2ap_RICserviceUpdateFailure_protocolIEs_element (const char * name,
 e2ap_RICserviceUpdateFailure_protocolIEs_element* pvalue, 
 char * buffer, OSSIZE bufSize){
    if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
        return -1;
    if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
        return -1;

    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICserviceUpdateFailure_IEs_id_TransactionID:
            if(asn1PrtToStr_e2ap_TransactionID("TransactionID", 
                    pvalue->value.u._e2ap_RICserviceUpdateFailure_IEs_id_TransactionID, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICserviceUpdateFailure_IEs_id_Cause:
            if(asn1PrtToStr_e2ap_Cause("Cause", 
                    pvalue->value.u._e2ap_RICserviceUpdateFailure_IEs_id_Cause, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICserviceUpdateFailure_IEs_id_TimeToWait:
            if(asn1PrtToStr_e2ap_TimeToWait("TimeToWait", 
                    pvalue->value.u._e2ap_RICserviceUpdateFailure_IEs_id_TimeToWait, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICserviceUpdateFailure_IEs_id_CriticalityDiagnostics:
            if(asn1PrtToStr_e2ap_CriticalityDiagnostics("CriticalityDiagnostics", 
                    pvalue->value.u._e2ap_RICserviceUpdateFailure_IEs_id_CriticalityDiagnostics, buffer, bufSize)<0)
                return -1;
            break;    
        default:
        if(0!=pvalue -> value.u.extElem1){
            rtPrintToStringIndent(buffer, bufSize);
            rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

        }
        }
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

    return 0;

 }

 void asn1Free_e2ap_RICserviceUpdateFailure_protocolIEs_element(OSCTXT* pctxt, e2ap_RICserviceUpdateFailure_protocolIEs_element* pvalue){
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICserviceUpdateFailure_IEs_id_TransactionID:
            if(pvalue->value.u._e2ap_RICserviceUpdateFailure_IEs_id_TransactionID!=NULL){
            asn1Free_e2ap_TransactionID(pctxt, pvalue->value.u._e2ap_RICserviceUpdateFailure_IEs_id_TransactionID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICserviceUpdateFailure_IEs_id_TransactionID);
            pvalue->value.u._e2ap_RICserviceUpdateFailure_IEs_id_TransactionID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICserviceUpdateFailure_IEs_id_Cause:
            if(pvalue->value.u._e2ap_RICserviceUpdateFailure_IEs_id_Cause!=NULL){
            asn1Free_e2ap_Cause(pctxt, pvalue->value.u._e2ap_RICserviceUpdateFailure_IEs_id_Cause);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICserviceUpdateFailure_IEs_id_Cause);
            pvalue->value.u._e2ap_RICserviceUpdateFailure_IEs_id_Cause = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICserviceUpdateFailure_IEs_id_TimeToWait:
            if(pvalue->value.u._e2ap_RICserviceUpdateFailure_IEs_id_TimeToWait!=NULL){
            asn1Free_e2ap_TimeToWait(pctxt, pvalue->value.u._e2ap_RICserviceUpdateFailure_IEs_id_TimeToWait);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICserviceUpdateFailure_IEs_id_TimeToWait);
            pvalue->value.u._e2ap_RICserviceUpdateFailure_IEs_id_TimeToWait = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICserviceUpdateFailure_IEs_id_CriticalityDiagnostics:
            if(pvalue->value.u._e2ap_RICserviceUpdateFailure_IEs_id_CriticalityDiagnostics!=NULL){
            asn1Free_e2ap_CriticalityDiagnostics(pctxt, pvalue->value.u._e2ap_RICserviceUpdateFailure_IEs_id_CriticalityDiagnostics);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICserviceUpdateFailure_IEs_id_CriticalityDiagnostics);
            pvalue->value.u._e2ap_RICserviceUpdateFailure_IEs_id_CriticalityDiagnostics = NULL;
            }
            break;
        default:
            break;


    }
 }

 

/*****************************************/
/*           RICserviceUpdateFailure                */
/*****************************************/
//2_container.c
/* 1. xxx_ProtocolIE -> mẫu cũ ở ie_big_msg */
EXTERN int asn1PE_e2ap_RICserviceUpdateFailure_protocolIEs (OSCTXT* pctxt, e2ap_RICserviceUpdateFailure_protocolIEs* pvalue)
{
    int stat =0;
    OSRTDListNode* pnode;
    OSUINT32 xx1;

    /*encode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pe_Length(pctxt, pvalue->count);
    if(stat<0) return LOG_RTERR(pctxt, stat);

    /*encode each element*/
    xx1 =0;
    for(pnode = pvalue->head; pnode != 0 && xx1<pvalue->count; pnode = pnode->next){
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE", xx1);
        stat = asn1PE_e2ap_RICserviceUpdateFailure_protocolIEs_element (pctxt, ((e2ap_RICserviceUpdateFailure_protocolIEs_element*)pnode->data));
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        xx1++;
        RTXCTXTPOPARRAYELEMNAME(pctxt);
    }

    return (stat);
}

EXTERN int  asn1PD_e2ap_RICserviceUpdateFailure_protocolIEs(OSCTXT* pctxt, e2ap_RICserviceUpdateFailure_protocolIEs* pvalue)
{
     int stat =0;
     OSRTDListNode* pnode;
     OSSIZE count =0;
     OSSIZE xx1=0;


     /*decode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pd_Length64(pctxt, &count); //tai sao lai 64
    if(stat!=0) return LOG_RTERR(pctxt, stat);

    /*decode each element*/
    rtxDListInit(pvalue);

    for(xx1=0; xx1 < count; xx1++){
        e2ap_RICserviceUpdateFailure_protocolIEs_element* pdata;
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE",xx1);

        if(pnode == NULL) return LOG_RTERR(pctxt, RTERR_NOMEM);

        asn1Init_e2ap_RICserviceUpdateFailure_protocolIEs_element(pdata);
        rtxDListAppendNode(pvalue, pnode);
        stat = asn1PD_e2ap_RICserviceUpdateFailure_protocolIEs_element (pctxt, pdata);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        RTXCTXTPOPARRAYELEMNAME(pctxt);

    }
    return (stat);
}


int asn1Init_e2ap_RICserviceUpdateFailure_protocolIEs(e2ap_RICserviceUpdateFailure_protocolIEs* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    rtxDListFastInit (pvalue);
    return 0;
}
#if 1 //ao that day
void asn1Free_e2ap_RICserviceUpdateFailure_protocolIEs(OSCTXT* pctxt, e2ap_RICserviceUpdateFailure_protocolIEs* pvalue)
{
    if(0==pvalue) return;   
    e2ap_RICserviceUpdateFailure_protocolIEs_element* pdata;
    OSRTDListNode* pnode=pvalue->head;
    while(0!=pnode){
        pdata = (e2ap_RICserviceUpdateFailure_protocolIEs_element*)pnode->data;
       // asn1Free_e2ap_RICserviceUpdateFailure_protocolIEs_element(pctxt, pdata);
        pnode = pnode->next;
    }
    rtxDListFreeAll(pctxt, pvalue);
}
#endif


EXTERN int asn1PrtToStr_e2ap_RICserviceUpdateFailure_protocolIEs(const char* name, e2ap_RICserviceUpdateFailure_protocolIEs* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_RICserviceUpdateFailure_protocolIEs_element* pdata0;
    OSRTDListNode* pnode0;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode0 = pvalue->head;  xx1 < pvalue->count && pnode0 != 0; pnode0 = pnode0->next, xx1++){
        pdata0 = (e2ap_RICserviceUpdateFailure_protocolIEs_element*)pnode0->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 0
        if(asn1PrtToStr_e2ap_RICserviceUpdateFailure_protocolIEs_element(nameBuf, pdata0, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}


/*2 . RICserviceUpdateFailure -> mẫu cũ ở seq_normal*/

int asn1PE_e2ap_RICserviceUpdateFailure (OSCTXT* pctxt, e2ap_RICserviceUpdateFailure* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RICserviceUpdateFailure");
   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field protocolIEs - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
   stat = asn1PE_e2ap_RICserviceUpdateFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
   if(stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RICserviceUpdateFailure (OSCTXT* pctxt, e2ap_RICserviceUpdateFailure* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME(pctxt, "RICserviceUpdateFailure");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field protocolIEs */
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
      stat = asn1PD_e2ap_RICserviceUpdateFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RICserviceUpdateFailure (e2ap_RICserviceUpdateFailure* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RICserviceUpdateFailure_protocolIEs(&pvalue->protocolIEs);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RICserviceUpdateFailure (OSCTXT* pctxt, e2ap_RICserviceUpdateFailure* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_RICserviceUpdateFailure_protocolIEs(pctxt, &pvalue->protocolIEs);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RICserviceUpdateFailure (const char* name, e2ap_RICserviceUpdateFailure* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }

   if(asn1PrtToStr_e2ap_RICserviceUpdateFailure_protocolIEs("protocolIEs", &pvalue->protocolIEs, buffer, bufSize) <0){
      return -1;
   }

   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           RICsubscriptionFailure_IEs                */
/*****************************************/
/* ie.c.j2 */
 /* d là con của msg */
EXTERN int asn1PE_e2ap_RICsubscriptionFailure_protocolIEs_element (OSCTXT* pctxt, e2ap_RICsubscriptionFailure_protocolIEs_element* pvalue)
{
    int stat =0;

    /*encode id*/

    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PE_e2ap_ProtocolIE_ID(pctxt, pvalue->id);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PE_e2ap_Criticality(pctxt, pvalue->criticality);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
    {
        OSCTXT lctxt;
        OSOCTET *pDynamicEncodeBuffer;
        ASN1OpenType openType;
        OSBOOL encoded = TRUE;

        openType.numocts = 0;
        openType.data =0;

        rtxCopyContext(&lctxt, pctxt);
        pctxt->pStream =0;

        stat = rtxInitContextBuffer(pctxt, 0, 0);
        if(stat!=0) return LOG_RTERR(pctxt, stat);

        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionFailure_IEs_id_RICrequestID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICrequestID");
                    stat = asn1PE_e2ap_RICrequestID (pctxt, pvalue->value.u._e2ap_RICsubscriptionFailure_IEs_id_RICrequestID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionFailure_IEs_id_RANfunctionID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RANfunctionID");
                    stat = asn1PE_e2ap_RANfunctionID (pctxt, pvalue->value.u._e2ap_RICsubscriptionFailure_IEs_id_RANfunctionID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionFailure_IEs_id_Cause:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-Cause");
                    stat = asn1PE_e2ap_Cause (pctxt, pvalue->value.u._e2ap_RICsubscriptionFailure_IEs_id_Cause);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionFailure_IEs_id_CriticalityDiagnostics:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-CriticalityDiagnostics");
                    stat = asn1PE_e2ap_CriticalityDiagnostics (pctxt, pvalue->value.u._e2ap_RICsubscriptionFailure_IEs_id_CriticalityDiagnostics);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionFailure_IEs_UNDEF_:
            {
                if(0!=pvalue->value.u.extElem1){
                    openType.numocts = pvalue->value.u.extElem1->numocts;
                    openType.data = pvalue->value.u.extElem1->data;
                } else {
                    /* No extension element to encode */
                }
                encoded = FALSE;
                break;
            }

            default:
                encoded = FALSE;
                stat = RTERR_INVOPT;
                break;
        } 

        if(encoded){
            openType.numocts = (OSUINT32)pe_GetMsgLen(pctxt);
            openType.data = pDynamicEncodeBuffer = pctxt -> buffer.data;
        }
        rtxCopyContext(pctxt, &lctxt);

        if(stat == 0) {
            stat = pe_OpenType (pctxt, openType.numocts, openType.data);
        }
    #if 1
        if(encoded){//dungnm23 check lai nhe
            rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
        }
    #endif

    }

    if(stat!=0) return LOG_RTERR(pctxt, stat);  
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}

EXTERN int  asn1PD_e2ap_RICsubscriptionFailure_protocolIEs_element (OSCTXT* pctxt, e2ap_RICsubscriptionFailure_protocolIEs_element* pvalue){
    int stat =0;

    /*decode id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PD_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PD_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");

    {
        OSUINT32 openTypeLen;
        size_t bitStartOffset, bitLength;

        stat = pd_UnconsLength(pctxt, &openTypeLen);
        if(stat<0) return LOG_RTERR(pctxt, stat);
        else if(stat == RT_OK_FRAG){
            rtxErrAddStrParm(pctxt, "open type with fragment length");
            return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
        }
        bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
        bitLength = openTypeLen * 8;

        switch(pvalue->id){//dungnm23 check case lai nhe
        
            case ASN1V_e2ap_id_RICrequestID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionFailure_IEs_id_RICrequestID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICrequestID");
                pvalue->value.u._e2ap_RICsubscriptionFailure_IEs_id_RICrequestID 
                    = rtxMemAllocType(pctxt, e2ap_RICrequestID);

                asn1Init_e2ap_RICrequestID(pvalue->value.u._e2ap_RICsubscriptionFailure_IEs_id_RICrequestID);

                stat = asn1PD_e2ap_RICrequestID (pctxt,
                        (e2ap_RICrequestID*)pvalue->value.
                        u._e2ap_RICsubscriptionFailure_IEs_id_RICrequestID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RANfunctionID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionFailure_IEs_id_RANfunctionID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RANfunctionID");
                pvalue->value.u._e2ap_RICsubscriptionFailure_IEs_id_RANfunctionID 
                    = rtxMemAllocType(pctxt, e2ap_RANfunctionID);

                asn1Init_e2ap_RANfunctionID(pvalue->value.u._e2ap_RICsubscriptionFailure_IEs_id_RANfunctionID);

                stat = asn1PD_e2ap_RANfunctionID (pctxt,
                        (e2ap_RANfunctionID*)pvalue->value.
                        u._e2ap_RICsubscriptionFailure_IEs_id_RANfunctionID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_Cause:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionFailure_IEs_id_Cause;
            RTXCTXTPUSHELEMNAME(pctxt, "id-Cause");
                pvalue->value.u._e2ap_RICsubscriptionFailure_IEs_id_Cause 
                    = rtxMemAllocType(pctxt, e2ap_Cause);

                asn1Init_e2ap_Cause(pvalue->value.u._e2ap_RICsubscriptionFailure_IEs_id_Cause);

                stat = asn1PD_e2ap_Cause (pctxt,
                        (e2ap_Cause*)pvalue->value.
                        u._e2ap_RICsubscriptionFailure_IEs_id_Cause);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_CriticalityDiagnostics:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionFailure_IEs_id_CriticalityDiagnostics;
            RTXCTXTPUSHELEMNAME(pctxt, "id-CriticalityDiagnostics");
                pvalue->value.u._e2ap_RICsubscriptionFailure_IEs_id_CriticalityDiagnostics 
                    = rtxMemAllocType(pctxt, e2ap_CriticalityDiagnostics);

                asn1Init_e2ap_CriticalityDiagnostics(pvalue->value.u._e2ap_RICsubscriptionFailure_IEs_id_CriticalityDiagnostics);

                stat = asn1PD_e2ap_CriticalityDiagnostics (pctxt,
                        (e2ap_CriticalityDiagnostics*)pvalue->value.
                        u._e2ap_RICsubscriptionFailure_IEs_id_CriticalityDiagnostics);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionFailure_IEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*) rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
    }
    {
    size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
    size_t bitsConsumed = bitEndOffset-bitStartOffset;
    if(bitsConsumed<bitLength){
        stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
    }
    else stat =(bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
    }}
    if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}


int asn1Init_e2ap_RICsubscriptionFailure_protocolIEs_element(e2ap_RICsubscriptionFailure_protocolIEs_element* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    OSCRTLMEMSET (&pvalue->value, 0, sizeof(pvalue->value));
    return 0;
}


//-----> chuaw có template rtxFreeASN1OpenType

#if 0
void asn1Free_e2ap_RICsubscriptionFailure_protocolIEs_element(OSCTXT* pctxt, e2ap_RICsubscriptionFailure_protocolIEs_element* pvalue)
{
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionFailure_IEs_id_id_RICrequestID:
            // rtxFreeE2ap_RICrequestID(pvalue->value.u._e2ap_RICsubscriptionFailure_IEs_id_id_RICrequestID);

            if(pvalue->value.i._e2ap_RICsubscriptionFailure_id_RICrequestID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICrequestID(pctxt, pvalue->value.u._e2ap_RICsubscriptionFailure_IEs_id_id_RICrequestID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionFailure_IEs_id_id_RICrequestID);
           // pvalue->value.u._e2ap_RICsubscriptionFailure_IEs_id_id_RICrequestID = NULL;
           pvalue->value.u._e2ap_RICsubscriptionFailure_IEs_id_RICrequestID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionFailure_IEs_id_id_RANfunctionID:
            // rtxFreeE2ap_RANfunctionID(pvalue->value.u._e2ap_RICsubscriptionFailure_IEs_id_id_RANfunctionID);

            if(pvalue->value.i._e2ap_RICsubscriptionFailure_id_RANfunctionID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RANfunctionID(pctxt, pvalue->value.u._e2ap_RICsubscriptionFailure_IEs_id_id_RANfunctionID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionFailure_IEs_id_id_RANfunctionID);
           // pvalue->value.u._e2ap_RICsubscriptionFailure_IEs_id_id_RANfunctionID = NULL;
           pvalue->value.u._e2ap_RICsubscriptionFailure_IEs_id_RANfunctionID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionFailure_IEs_id_id_Cause:
            // rtxFreeE2ap_Cause(pvalue->value.u._e2ap_RICsubscriptionFailure_IEs_id_id_Cause);

            if(pvalue->value.i._e2ap_RICsubscriptionFailure_id_Cause!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_Cause(pctxt, pvalue->value.u._e2ap_RICsubscriptionFailure_IEs_id_id_Cause);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionFailure_IEs_id_id_Cause);
           // pvalue->value.u._e2ap_RICsubscriptionFailure_IEs_id_id_Cause = NULL;
           pvalue->value.u._e2ap_RICsubscriptionFailure_IEs_id_Cause = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionFailure_IEs_id_id_CriticalityDiagnostics:
            // rtxFreeE2ap_CriticalityDiagnostics(pvalue->value.u._e2ap_RICsubscriptionFailure_IEs_id_id_CriticalityDiagnostics);

            if(pvalue->value.i._e2ap_RICsubscriptionFailure_id_CriticalityDiagnostics!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_CriticalityDiagnostics(pctxt, pvalue->value.u._e2ap_RICsubscriptionFailure_IEs_id_id_CriticalityDiagnostics);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionFailure_IEs_id_id_CriticalityDiagnostics);
           // pvalue->value.u._e2ap_RICsubscriptionFailure_IEs_id_id_CriticalityDiagnostics = NULL;
           pvalue->value.u._e2ap_RICsubscriptionFailure_IEs_id_CriticalityDiagnostics = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionFailure_IEs_UNDEF_:
            rtxFreeASN1OpenType(pvalue->value.u.extElem1);
            break;
        default:
            break;
    }
}

int asn1PrtToStr_e2ap_RICsubscriptionFailure_protocolIEs_element(OSCTXT* pctxt, e2ap_RICsubscriptionFailure_protocolIEs_element* pvalue)
{
    int stat =0;
    RTXCTXTPUSHELEMNAME(pctxt, "e2ap_RICsubscriptionFailure_protocolIEs_element");

    /*print id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PrtToStr_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PrtToStr_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionFailure_IEs_id_id_RICrequestID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICrequestID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICrequestID (pctxt, pvalue->value.u._e2ap_RICsubscriptionFailure_IEs_id_id_RICrequestID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionFailure_IEs_id_id_RANfunctionID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RANfunctionID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RANfunctionID (pctxt, pvalue->value.u._e2ap_RICsubscriptionFailure_IEs_id_id_RANfunctionID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionFailure_IEs_id_id_Cause:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "Cause");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_Cause (pctxt, pvalue->value.u._e2ap_RICsubscriptionFailure_IEs_id_id_Cause);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionFailure_IEs_id_id_CriticalityDiagnostics:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "CriticalityDiagnostics");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_CriticalityDiagnostics (pctxt, pvalue->value.u._e2ap_RICsubscriptionFailure_IEs_id_id_CriticalityDiagnostics);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionFailure_IEs_UNDEF_:
            {
                rtxPLogMsg(pctxt, "Extension element present - raw data not printed.\n");
                break;
            }

            default:
                stat = RTERR_INVOPT;
                return LOG_RTERR(pctxt, stat);
        }
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);
}
#endif


int asn1PrtToStr_e2ap_RICsubscriptionFailure_protocolIEs_element (const char * name,
 e2ap_RICsubscriptionFailure_protocolIEs_element* pvalue, 
 char * buffer, OSSIZE bufSize){
    if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
        return -1;
    if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
        return -1;

    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionFailure_IEs_id_RICrequestID:
            if(asn1PrtToStr_e2ap_RICrequestID("RICrequestID", 
                    pvalue->value.u._e2ap_RICsubscriptionFailure_IEs_id_RICrequestID, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionFailure_IEs_id_RANfunctionID:
            if(asn1PrtToStr_e2ap_RANfunctionID("RANfunctionID", 
                    pvalue->value.u._e2ap_RICsubscriptionFailure_IEs_id_RANfunctionID, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionFailure_IEs_id_Cause:
            if(asn1PrtToStr_e2ap_Cause("Cause", 
                    pvalue->value.u._e2ap_RICsubscriptionFailure_IEs_id_Cause, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionFailure_IEs_id_CriticalityDiagnostics:
            if(asn1PrtToStr_e2ap_CriticalityDiagnostics("CriticalityDiagnostics", 
                    pvalue->value.u._e2ap_RICsubscriptionFailure_IEs_id_CriticalityDiagnostics, buffer, bufSize)<0)
                return -1;
            break;    
        default:
        if(0!=pvalue -> value.u.extElem1){
            rtPrintToStringIndent(buffer, bufSize);
            rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

        }
        }
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

    return 0;

 }

 void asn1Free_e2ap_RICsubscriptionFailure_protocolIEs_element(OSCTXT* pctxt, e2ap_RICsubscriptionFailure_protocolIEs_element* pvalue){
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionFailure_IEs_id_RICrequestID:
            if(pvalue->value.u._e2ap_RICsubscriptionFailure_IEs_id_RICrequestID!=NULL){
            asn1Free_e2ap_RICrequestID(pctxt, pvalue->value.u._e2ap_RICsubscriptionFailure_IEs_id_RICrequestID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionFailure_IEs_id_RICrequestID);
            pvalue->value.u._e2ap_RICsubscriptionFailure_IEs_id_RICrequestID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionFailure_IEs_id_RANfunctionID:
            if(pvalue->value.u._e2ap_RICsubscriptionFailure_IEs_id_RANfunctionID!=NULL){
            asn1Free_e2ap_RANfunctionID(pctxt, pvalue->value.u._e2ap_RICsubscriptionFailure_IEs_id_RANfunctionID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionFailure_IEs_id_RANfunctionID);
            pvalue->value.u._e2ap_RICsubscriptionFailure_IEs_id_RANfunctionID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionFailure_IEs_id_Cause:
            if(pvalue->value.u._e2ap_RICsubscriptionFailure_IEs_id_Cause!=NULL){
            asn1Free_e2ap_Cause(pctxt, pvalue->value.u._e2ap_RICsubscriptionFailure_IEs_id_Cause);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionFailure_IEs_id_Cause);
            pvalue->value.u._e2ap_RICsubscriptionFailure_IEs_id_Cause = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionFailure_IEs_id_CriticalityDiagnostics:
            if(pvalue->value.u._e2ap_RICsubscriptionFailure_IEs_id_CriticalityDiagnostics!=NULL){
            asn1Free_e2ap_CriticalityDiagnostics(pctxt, pvalue->value.u._e2ap_RICsubscriptionFailure_IEs_id_CriticalityDiagnostics);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionFailure_IEs_id_CriticalityDiagnostics);
            pvalue->value.u._e2ap_RICsubscriptionFailure_IEs_id_CriticalityDiagnostics = NULL;
            }
            break;
        default:
            break;


    }
 }

 

/*****************************************/
/*           RICsubscriptionFailure                */
/*****************************************/
//2_container.c
/* 1. xxx_ProtocolIE -> mẫu cũ ở ie_big_msg */
EXTERN int asn1PE_e2ap_RICsubscriptionFailure_protocolIEs (OSCTXT* pctxt, e2ap_RICsubscriptionFailure_protocolIEs* pvalue)
{
    int stat =0;
    OSRTDListNode* pnode;
    OSUINT32 xx1;

    /*encode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pe_Length(pctxt, pvalue->count);
    if(stat<0) return LOG_RTERR(pctxt, stat);

    /*encode each element*/
    xx1 =0;
    for(pnode = pvalue->head; pnode != 0 && xx1<pvalue->count; pnode = pnode->next){
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE", xx1);
        stat = asn1PE_e2ap_RICsubscriptionFailure_protocolIEs_element (pctxt, ((e2ap_RICsubscriptionFailure_protocolIEs_element*)pnode->data));
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        xx1++;
        RTXCTXTPOPARRAYELEMNAME(pctxt);
    }

    return (stat);
}

EXTERN int  asn1PD_e2ap_RICsubscriptionFailure_protocolIEs(OSCTXT* pctxt, e2ap_RICsubscriptionFailure_protocolIEs* pvalue)
{
     int stat =0;
     OSRTDListNode* pnode;
     OSSIZE count =0;
     OSSIZE xx1=0;


     /*decode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pd_Length64(pctxt, &count); //tai sao lai 64
    if(stat!=0) return LOG_RTERR(pctxt, stat);

    /*decode each element*/
    rtxDListInit(pvalue);

    for(xx1=0; xx1 < count; xx1++){
        e2ap_RICsubscriptionFailure_protocolIEs_element* pdata;
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE",xx1);

        if(pnode == NULL) return LOG_RTERR(pctxt, RTERR_NOMEM);

        asn1Init_e2ap_RICsubscriptionFailure_protocolIEs_element(pdata);
        rtxDListAppendNode(pvalue, pnode);
        stat = asn1PD_e2ap_RICsubscriptionFailure_protocolIEs_element (pctxt, pdata);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        RTXCTXTPOPARRAYELEMNAME(pctxt);

    }
    return (stat);
}


int asn1Init_e2ap_RICsubscriptionFailure_protocolIEs(e2ap_RICsubscriptionFailure_protocolIEs* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    rtxDListFastInit (pvalue);
    return 0;
}
#if 1 //ao that day
void asn1Free_e2ap_RICsubscriptionFailure_protocolIEs(OSCTXT* pctxt, e2ap_RICsubscriptionFailure_protocolIEs* pvalue)
{
    if(0==pvalue) return;   
    e2ap_RICsubscriptionFailure_protocolIEs_element* pdata;
    OSRTDListNode* pnode=pvalue->head;
    while(0!=pnode){
        pdata = (e2ap_RICsubscriptionFailure_protocolIEs_element*)pnode->data;
       // asn1Free_e2ap_RICsubscriptionFailure_protocolIEs_element(pctxt, pdata);
        pnode = pnode->next;
    }
    rtxDListFreeAll(pctxt, pvalue);
}
#endif


EXTERN int asn1PrtToStr_e2ap_RICsubscriptionFailure_protocolIEs(const char* name, e2ap_RICsubscriptionFailure_protocolIEs* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_RICsubscriptionFailure_protocolIEs_element* pdata0;
    OSRTDListNode* pnode0;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode0 = pvalue->head;  xx1 < pvalue->count && pnode0 != 0; pnode0 = pnode0->next, xx1++){
        pdata0 = (e2ap_RICsubscriptionFailure_protocolIEs_element*)pnode0->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 0
        if(asn1PrtToStr_e2ap_RICsubscriptionFailure_protocolIEs_element(nameBuf, pdata0, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}


/*2 . RICsubscriptionFailure -> mẫu cũ ở seq_normal*/

int asn1PE_e2ap_RICsubscriptionFailure (OSCTXT* pctxt, e2ap_RICsubscriptionFailure* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RICsubscriptionFailure");
   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field protocolIEs - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
   stat = asn1PE_e2ap_RICsubscriptionFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
   if(stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RICsubscriptionFailure (OSCTXT* pctxt, e2ap_RICsubscriptionFailure* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME(pctxt, "RICsubscriptionFailure");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field protocolIEs */
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
      stat = asn1PD_e2ap_RICsubscriptionFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RICsubscriptionFailure (e2ap_RICsubscriptionFailure* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RICsubscriptionFailure_protocolIEs(&pvalue->protocolIEs);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RICsubscriptionFailure (OSCTXT* pctxt, e2ap_RICsubscriptionFailure* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_RICsubscriptionFailure_protocolIEs(pctxt, &pvalue->protocolIEs);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RICsubscriptionFailure (const char* name, e2ap_RICsubscriptionFailure* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }

   if(asn1PrtToStr_e2ap_RICsubscriptionFailure_protocolIEs("protocolIEs", &pvalue->protocolIEs, buffer, bufSize) <0){
      return -1;
   }

   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           RICeventTriggerDefinition                */
/*****************************************/
//9 mau octet string
//type 9  mau la octet string no size mau la pdusessioncommonnetworkinstance

EXTERN int asn1PE_e2ap_RICeventTriggerDefinition (OSCTXT* pctxt, e2ap_RICeventTriggerDefinition value){
   int stat = 0
   RTXCTCXTPUSHTYPENAME (pctxt, "RICeventTriggerDefinition");
   stat = pe_OctetString(pctxt, value.numocts, value.data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPTYPENAME (pctxt);

}
EXTERN int asn1PD_e2ap_RICeventTriggerDefinition (OSCTXT* pctxt, e2ap_RICeventTriggerDefinition* pvalue){
   int stat = 0;
   RTXCTCXTPUSHTYPENAME (pctxt, "RICeventTriggerDefinition");
   stat = pd_DynOctetString(pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}
EXTERN int asn1PrtToStr_e2ap_RICeventTriggerDefinition (const char* name, e2ap_RICeventTriggerDefinition *pvalue, char* buffer, OSSIZE bufSize){
   if(rtPrintToStringIndent(buffer, bufSize) < 0) return -1;
   if(rtPrintToStringHexStr(name, pvalue->numocts, pvalue->data, buffer, bufSize) < 0) return -1;
   return 0;
}
EXTERN int asn1PrtToStrm_e2ap_RICeventTriggerDefinition (OSCTXT* pctxt, const char* name, const e2ap_RICeventTriggerDefinition* pvalue){
   int stat =0;
   stat = rtPrintToStreamIndent(pctxt);
   if(stat !=0) return LOG_RTERR(pctxt, stat);
   stat = rtPrintToStreamHexStr(pctxt, name, pvalue->numocts, pvalue->data);
   if(stat !=0) return LOG_RTERR(pctxt, stat);
   return stat;
}
//EXTERN int asn1Copy_e2ap_RICeventTriggerDefinition (OSCTXT* pctxt, const e2ap_RICeventTriggerDefinition* pSrcValue, e2ap_RICeventTriggerDefinition* pDstValue);
 int asn1Init_e2ap_RICeventTriggerDefinition (e2ap_RICeventTriggerDefinition* pvalue){
   if (pvalue == 0) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   pvalue->data = 0;
   return 0;
}
 void asn1Free_e2ap_RICeventTriggerDefinition (OSCTXT* pctxt, e2ap_RICeventTriggerDefinition* pvalue){
   if (pvalue == 0) return;
   if(pvalue->numocts>0){
       rtxMemFreePtr(pctxt, (void*)pvalue->data);
       pvalue->data = 0;
       pvalue->numocts = 0;
   }
}
int asn1Init_e2ap_RICeventTriggerDefinition (e2ap_RICeventTriggerDefinition* pvalue){
   if (pvalue == 0) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   pvalue->data = 0;
   return 0;
}
/******************************************************/
/*                                                    */
/*    RICactionType                          */
/*                                                    */
/******************************************************/
//enumerated


const OSEnumItem e2ap_RICactionType_ENUMTAB[] = {
    { OSUTF8("report"), 0, 6, 0 },
    { OSUTF8("insert"), 1, 6, 1 },
    { OSUTF8("policy"), 2, 6, 2 }
};


const OSUTF8CHAR* e2ap_RICactionType_ToString (OSUINT32 value){
   OSINT32 idx = value;
   if(idx >=0 && idx < e2ap_RICactionType_ENUMTABSIZE){
      return e2ap_RICactionType_ENUMTAB[e2ap_RICactionType_ENUMTAB[idx].transidx].name;
   }else{
      return OSUTF8("_UNKNOWN_");
   }
}


int e2ap_RICactionType_ToEnum (OSCTXT* pctxt, const OSUTF8CHAR* value,e2ap_RICactionType* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes(value);
   return e2ap_RICactionType_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int e2ap_RICactionType_ToEnum2 (OSCTXT* pctxt, const OSUTF8CHAR* value, OSSIZE valueLen,e2ap_RICactionType* pvalue)
{
   OSINT32 idx = rtxLookupEnum(value, valueLen,
      e2ap_RICactionType_ENUMTAB, e2ap_RICactionType_ENUMTABSIZE);
   if (idx >= 0) {
      *pvalue = (e2ap_RICactionType)e2ap_RICactionType_ENUMTAB[idx].value;
      return 0;
   } else {
      rtxErrAddIntParm (pctxt, (const char*)value);//dungnm23 check xem là Str hay Int
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_e2ap_RICactionType (OSCTXT* pctxt, e2ap_RICactionType value)
{
   int stat = 0;
   RTXCTXTPUSHTYPENAME (pctxt, "RICactionType");
   if (value >= 3) {
      rtxErrAddIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(2));
   if(stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}

EXTERN int asn1PD_e2ap_RICactionType (OSCTXT* pctxt, e2ap_RICactionType* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RICactionType");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(2));
   if(stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return stat;
}

EXTERN int asn1PrtToStr_e2ap_RICactionType (const char* name, e2ap_RICactionType* pvalue, char* buffer, OSSIZE bufSize)
{
   int stat;

   if(rtPrintToStringIndent(buffer, bufSize) < 0) return -1;
   if(rtPrintToString(name, buffer, bufSize) < 0) return -1;

   switch(*pvalue) {
      case 0:
         stat = rtPrintToString(" = report \n", buffer, bufSize);
         break;
      case 1:
         stat = rtPrintToString(" = insert \n", buffer, bufSize);
         break;
      case 2:
         stat = rtPrintToString(" = policy \n", buffer, bufSize);
         break;
      default:
         stat = rtPrintToString(" = ???\n", buffer, bufSize);
   }

   if (stat < 0) return -1;
   return 0;

}

/*Init*/
EXTERN int asn1Init_e2ap_RICactionType (e2ap_RICactionType* pvalue){
      //if (pvalue == 0) return RTERR_NULLPTR;
      //*pvalue = 0;
      return 0;
}/*****************************************/
/*           RICactionDefinition                */
/*****************************************/
//9 mau octet string
//type 9  mau la octet string no size mau la pdusessioncommonnetworkinstance

EXTERN int asn1PE_e2ap_RICactionDefinition (OSCTXT* pctxt, e2ap_RICactionDefinition value){
   int stat = 0
   RTXCTCXTPUSHTYPENAME (pctxt, "RICactionDefinition");
   stat = pe_OctetString(pctxt, value.numocts, value.data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPTYPENAME (pctxt);

}
EXTERN int asn1PD_e2ap_RICactionDefinition (OSCTXT* pctxt, e2ap_RICactionDefinition* pvalue){
   int stat = 0;
   RTXCTCXTPUSHTYPENAME (pctxt, "RICactionDefinition");
   stat = pd_DynOctetString(pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}
EXTERN int asn1PrtToStr_e2ap_RICactionDefinition (const char* name, e2ap_RICactionDefinition *pvalue, char* buffer, OSSIZE bufSize){
   if(rtPrintToStringIndent(buffer, bufSize) < 0) return -1;
   if(rtPrintToStringHexStr(name, pvalue->numocts, pvalue->data, buffer, bufSize) < 0) return -1;
   return 0;
}
EXTERN int asn1PrtToStrm_e2ap_RICactionDefinition (OSCTXT* pctxt, const char* name, const e2ap_RICactionDefinition* pvalue){
   int stat =0;
   stat = rtPrintToStreamIndent(pctxt);
   if(stat !=0) return LOG_RTERR(pctxt, stat);
   stat = rtPrintToStreamHexStr(pctxt, name, pvalue->numocts, pvalue->data);
   if(stat !=0) return LOG_RTERR(pctxt, stat);
   return stat;
}
//EXTERN int asn1Copy_e2ap_RICactionDefinition (OSCTXT* pctxt, const e2ap_RICactionDefinition* pSrcValue, e2ap_RICactionDefinition* pDstValue);
 int asn1Init_e2ap_RICactionDefinition (e2ap_RICactionDefinition* pvalue){
   if (pvalue == 0) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   pvalue->data = 0;
   return 0;
}
 void asn1Free_e2ap_RICactionDefinition (OSCTXT* pctxt, e2ap_RICactionDefinition* pvalue){
   if (pvalue == 0) return;
   if(pvalue->numocts>0){
       rtxMemFreePtr(pctxt, (void*)pvalue->data);
       pvalue->data = 0;
       pvalue->numocts = 0;
   }
}
int asn1Init_e2ap_RICactionDefinition (e2ap_RICactionDefinition* pvalue){
   if (pvalue == 0) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   pvalue->data = 0;
   return 0;
}
/******************************************************/
/*                                                    */
/*    RICsubsequentActionType                          */
/*                                                    */
/******************************************************/
//enumerated


const OSEnumItem e2ap_RICsubsequentActionType_ENUMTAB[] = {
    { OSUTF8("continue"), 0, 8, 0 },
    { OSUTF8("wait"), 1, 4, 1 }
};


const OSUTF8CHAR* e2ap_RICsubsequentActionType_ToString (OSUINT32 value){
   OSINT32 idx = value;
   if(idx >=0 && idx < e2ap_RICsubsequentActionType_ENUMTABSIZE){
      return e2ap_RICsubsequentActionType_ENUMTAB[e2ap_RICsubsequentActionType_ENUMTAB[idx].transidx].name;
   }else{
      return OSUTF8("_UNKNOWN_");
   }
}


int e2ap_RICsubsequentActionType_ToEnum (OSCTXT* pctxt, const OSUTF8CHAR* value,e2ap_RICsubsequentActionType* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes(value);
   return e2ap_RICsubsequentActionType_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int e2ap_RICsubsequentActionType_ToEnum2 (OSCTXT* pctxt, const OSUTF8CHAR* value, OSSIZE valueLen,e2ap_RICsubsequentActionType* pvalue)
{
   OSINT32 idx = rtxLookupEnum(value, valueLen,
      e2ap_RICsubsequentActionType_ENUMTAB, e2ap_RICsubsequentActionType_ENUMTABSIZE);
   if (idx >= 0) {
      *pvalue = (e2ap_RICsubsequentActionType)e2ap_RICsubsequentActionType_ENUMTAB[idx].value;
      return 0;
   } else {
      rtxErrAddIntParm (pctxt, (const char*)value);//dungnm23 check xem là Str hay Int
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_e2ap_RICsubsequentActionType (OSCTXT* pctxt, e2ap_RICsubsequentActionType value)
{
   int stat = 0;
   RTXCTXTPUSHTYPENAME (pctxt, "RICsubsequentActionType");
   if (value >= 2) {
      rtxErrAddIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
   if(stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}

EXTERN int asn1PD_e2ap_RICsubsequentActionType (OSCTXT* pctxt, e2ap_RICsubsequentActionType* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RICsubsequentActionType");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
   if(stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return stat;
}

EXTERN int asn1PrtToStr_e2ap_RICsubsequentActionType (const char* name, e2ap_RICsubsequentActionType* pvalue, char* buffer, OSSIZE bufSize)
{
   int stat;

   if(rtPrintToStringIndent(buffer, bufSize) < 0) return -1;
   if(rtPrintToString(name, buffer, bufSize) < 0) return -1;

   switch(*pvalue) {
      case 0:
         stat = rtPrintToString(" = continue \n", buffer, bufSize);
         break;
      case 1:
         stat = rtPrintToString(" = wait \n", buffer, bufSize);
         break;
      default:
         stat = rtPrintToString(" = ???\n", buffer, bufSize);
   }

   if (stat < 0) return -1;
   return 0;

}

/*Init*/
EXTERN int asn1Init_e2ap_RICsubsequentActionType (e2ap_RICsubsequentActionType* pvalue){
      //if (pvalue == 0) return RTERR_NULLPTR;
      //*pvalue = 0;
      return 0;
}/******************************************************/
/*                                                    */
/*    RICtimeToWait                          */
/*                                                    */
/******************************************************/
//enumerated


const OSEnumItem e2ap_RICtimeToWait_ENUMTAB[] = {
    { OSUTF8("w1ms"), 0, 4, 0 },
    { OSUTF8("w2ms"), 1, 4, 1 },
    { OSUTF8("w5ms"), 2, 4, 2 },
    { OSUTF8("w10ms"), 3, 5, 3 },
    { OSUTF8("w20ms"), 4, 5, 4 },
    { OSUTF8("w30ms"), 5, 5, 5 },
    { OSUTF8("w40ms"), 6, 5, 6 },
    { OSUTF8("w50ms"), 7, 5, 7 },
    { OSUTF8("w100ms"), 8, 6, 8 },
    { OSUTF8("w200ms"), 9, 6, 9 },
    { OSUTF8("w500ms"), 10, 6, 10 },
    { OSUTF8("w1s"), 11, 3, 11 },
    { OSUTF8("w2s"), 12, 3, 12 },
    { OSUTF8("w5s"), 13, 3, 13 },
    { OSUTF8("w10s"), 14, 4, 14 },
    { OSUTF8("w20s"), 15, 4, 15 },
    { OSUTF8("w60s"), 16, 4, 16 }
};


const OSUTF8CHAR* e2ap_RICtimeToWait_ToString (OSUINT32 value){
   OSINT32 idx = value;
   if(idx >=0 && idx < e2ap_RICtimeToWait_ENUMTABSIZE){
      return e2ap_RICtimeToWait_ENUMTAB[e2ap_RICtimeToWait_ENUMTAB[idx].transidx].name;
   }else{
      return OSUTF8("_UNKNOWN_");
   }
}


int e2ap_RICtimeToWait_ToEnum (OSCTXT* pctxt, const OSUTF8CHAR* value,e2ap_RICtimeToWait* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes(value);
   return e2ap_RICtimeToWait_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int e2ap_RICtimeToWait_ToEnum2 (OSCTXT* pctxt, const OSUTF8CHAR* value, OSSIZE valueLen,e2ap_RICtimeToWait* pvalue)
{
   OSINT32 idx = rtxLookupEnum(value, valueLen,
      e2ap_RICtimeToWait_ENUMTAB, e2ap_RICtimeToWait_ENUMTABSIZE);
   if (idx >= 0) {
      *pvalue = (e2ap_RICtimeToWait)e2ap_RICtimeToWait_ENUMTAB[idx].value;
      return 0;
   } else {
      rtxErrAddIntParm (pctxt, (const char*)value);//dungnm23 check xem là Str hay Int
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_e2ap_RICtimeToWait (OSCTXT* pctxt, e2ap_RICtimeToWait value)
{
   int stat = 0;
   RTXCTXTPUSHTYPENAME (pctxt, "RICtimeToWait");
   if (value >= 17) {
      rtxErrAddIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(16));
   if(stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}

EXTERN int asn1PD_e2ap_RICtimeToWait (OSCTXT* pctxt, e2ap_RICtimeToWait* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RICtimeToWait");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(16));
   if(stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return stat;
}

EXTERN int asn1PrtToStr_e2ap_RICtimeToWait (const char* name, e2ap_RICtimeToWait* pvalue, char* buffer, OSSIZE bufSize)
{
   int stat;

   if(rtPrintToStringIndent(buffer, bufSize) < 0) return -1;
   if(rtPrintToString(name, buffer, bufSize) < 0) return -1;

   switch(*pvalue) {
      case 0:
         stat = rtPrintToString(" = w1ms \n", buffer, bufSize);
         break;
      case 1:
         stat = rtPrintToString(" = w2ms \n", buffer, bufSize);
         break;
      case 2:
         stat = rtPrintToString(" = w5ms \n", buffer, bufSize);
         break;
      case 3:
         stat = rtPrintToString(" = w10ms \n", buffer, bufSize);
         break;
      case 4:
         stat = rtPrintToString(" = w20ms \n", buffer, bufSize);
         break;
      case 5:
         stat = rtPrintToString(" = w30ms \n", buffer, bufSize);
         break;
      case 6:
         stat = rtPrintToString(" = w40ms \n", buffer, bufSize);
         break;
      case 7:
         stat = rtPrintToString(" = w50ms \n", buffer, bufSize);
         break;
      case 8:
         stat = rtPrintToString(" = w100ms \n", buffer, bufSize);
         break;
      case 9:
         stat = rtPrintToString(" = w200ms \n", buffer, bufSize);
         break;
      case 10:
         stat = rtPrintToString(" = w500ms \n", buffer, bufSize);
         break;
      case 11:
         stat = rtPrintToString(" = w1s \n", buffer, bufSize);
         break;
      case 12:
         stat = rtPrintToString(" = w2s \n", buffer, bufSize);
         break;
      case 13:
         stat = rtPrintToString(" = w5s \n", buffer, bufSize);
         break;
      case 14:
         stat = rtPrintToString(" = w10s \n", buffer, bufSize);
         break;
      case 15:
         stat = rtPrintToString(" = w20s \n", buffer, bufSize);
         break;
      case 16:
         stat = rtPrintToString(" = w60s \n", buffer, bufSize);
         break;
      default:
         stat = rtPrintToString(" = ???\n", buffer, bufSize);
   }

   if (stat < 0) return -1;
   return 0;

}

/*Init*/
EXTERN int asn1Init_e2ap_RICtimeToWait (e2ap_RICtimeToWait* pvalue){
      //if (pvalue == 0) return RTERR_NULLPTR;
      //*pvalue = 0;
      return 0;
}
/*****************************************/
/*           RICsubsequentAction                */
/*****************************************/
//sequence normal
// Các nội dung cần thiết cho template seq_normal.c.j2

// Các phần còn lại của template seq_normal.c.j2
//contain extensition bit -> theo mau cua GlobalgNB-ID
int asn1PE_e2ap_RICsubsequentAction (OSCTXT* pctxt, e2ap_RICsubsequentAction* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RICsubsequentAction");

   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field ricSubsequentActionType - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "ricSubsequentActionType");
   stat = asn1PE_e2ap_RICsubsequentActionType (pctxt, pvalue->ricSubsequentActionType);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /* encode field ricTimeToWait - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "ricTimeToWait");
   stat = asn1PE_e2ap_RICtimeToWait (pctxt, pvalue->ricTimeToWait);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);



   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RICsubsequentAction (OSCTXT* pctxt, e2ap_RICsubsequentAction* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME(pctxt, "RICsubsequentAction");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field ricSubsequentActionType */
   RTXCTXTPUSHELEMNAME(pctxt, "ricSubsequentActionType");
      stat = asn1PD_e2ap_RICsubsequentActionType (pctxt, &pvalue->ricSubsequentActionType);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field ricTimeToWait */
   RTXCTXTPUSHELEMNAME(pctxt, "ricTimeToWait");
      stat = asn1PD_e2ap_RICtimeToWait (pctxt, &pvalue->ricTimeToWait);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RICsubsequentAction (e2ap_RICsubsequentAction* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RICsubsequentActionType (&pvalue->ricSubsequentActionType);
   asn1Init_e2ap_RICtimeToWait (&pvalue->ricTimeToWait);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RICsubsequentAction (OSCTXT* pctxt, e2ap_RICsubsequentAction* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_RICsubsequentActionType (pctxt, &pvalue->ricSubsequentActionType);
   asn1Free_e2ap_RICtimeToWait (pctxt, &pvalue->ricTimeToWait);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RICsubsequentAction (const char* name, e2ap_RICsubsequentAction* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }
   if(asn1PrtToStr_e2ap_RICsubsequentActionType ("ricSubsequentActionType", &pvalue->ricSubsequentActionType, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_RICtimeToWait ("ricTimeToWait", &pvalue->ricTimeToWait, buffer, bufSize) < 0)
   {
      return -1;
   }



   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           RICactionExecutionOrder                */
/*****************************************/
//6 mau integer
// mau integer size(a...b) mau la procedurecode
EXTERN int asn1PE_e2ap_RICactionExecutionOrder (OSCTXT* pctxt, e2ap_RICactionExecutionOrder value){
    int stat = 0;
    RTXCTCXTPUSHTYPENAME (pctxt, "RICactionExecutionOrder");
    stat = pe_ConsUnsigned (pctxt, value, 0, 255);
    if (stat != 0) return LOG_RTERR (pctxt, stat);
    RTXCTXTPOPTYPENAME (pctxt);
    return stat;
}
EXTERN int asn1PD_e2ap_RICactionExecutionOrder (OSCTXT* pctxt, e2ap_RICactionExecutionOrder* pvalue){
    int stat = 0;
    RTXCTCXTPUSHTYPENAME (pctxt, "RICactionExecutionOrder");
    if(pctxt->buffer.aligned){
        int stat2 = PD_BYTE_ALIGN(pctxt);
        if(stat2 != 0) return LOG_RTERR (pctxt, stat2);
    }
    stat = rtxDecBitsToByte(pctxt, pvalue, 0);
    if (stat != 0) return LOG_RTERR (pctxt, stat);
    RTXCTXTPOPTYPENAME (pctxt);
    return stat;
}
//EXTERN int asn1Print_e2ap_RICactionExecutionOrder (const char* name, const e2ap_RICactionExecutionOrder* pvalue);
//EXTERN int asn1PrtToStr_e2ap_RICactionExecutionOrder (const char* name, e2ap_RICactionExecutionOrder* pvalue, char* buffer, OSSIZE bufSize);
//EXTERN int asn1PrtToStrm_e2ap_RICactionExecutionOrder (OSCTXT* pctxt, const char* name, const e2ap_RICactionExecutionOrder* pvalue);
EXTERN int asn1Init_e2ap_RICactionExecutionOrder (e2ap_RICactionExecutionOrder* pvalue){
    //if (pvalue == 0) return RTERR_NULLPTR;
    //*pvalue = 0;
    return 0;
}
EXTERN int asn1Free_e2ap_RICactionExecutionOrder (OSCTXT* pctxt, e2ap_RICactionExecutionOrder* pvalue){
    // No dynamic memory to free for integer
    return 0;
}

/*****************************************/
/*           RICaction-ToBeSetup-Item                */
/*****************************************/
//sequence normal
// Các nội dung cần thiết cho template seq_normal.c.j2

// Các phần còn lại của template seq_normal.c.j2
//contain extensition bit -> theo mau cua GlobalgNB-ID
int asn1PE_e2ap_RICaction_ToBeSetup_Item (OSCTXT* pctxt, e2ap_RICaction_ToBeSetup_Item* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RICaction-ToBeSetup-Item");

   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);

   /*optional bit for field ricActionDefinition*/
   stat = rtxEncBit (pctxt, pvalue->m_ricActionDefinitionPresent);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   /*optional bit for field ricSubsequentAction*/
   stat = rtxEncBit (pctxt, pvalue->m_ricSubsequentActionPresent);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   /*optional bit for field ricActionExecutionOrder*/
   stat = rtxEncBit (pctxt, pvalue->m_ricActionExecutionOrderPresent);
   if (stat != 0) return LOG_RTERR(pctxt, stat);

   /*encode root elements*/   
   /* encode field ricActionID - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "ricActionID");
   stat = asn1PE_e2ap_RICactionID (pctxt, pvalue->ricActionID);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /* encode field ricActionType - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "ricActionType");
   stat = asn1PE_e2ap_RICactionType (pctxt, pvalue->ricActionType);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /* encode field ricActionDefinition - id = -1*/  
   if (pvalue->m_ricActionDefinitionPresent) {//OPTIONAL FIELD
   RTXCTXTPUSHELEMNAME(pctxt, "ricActionDefinition");
   stat = asn1PE_e2ap_RICactionDefinition (pctxt, pvalue->ricActionDefinition);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   }

   /* encode field ricSubsequentAction - id = -1*/  
   if (pvalue->m_ricSubsequentActionPresent) {//OPTIONAL FIELD
   RTXCTXTPUSHELEMNAME(pctxt, "ricSubsequentAction");
   stat = asn1PE_e2ap_RICsubsequentAction (pctxt, pvalue->ricSubsequentAction);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   }

   /* encode field ricActionExecutionOrder - id = -1*/  
   if (pvalue->m_ricActionExecutionOrderPresent) {//OPTIONAL FIELD
   RTXCTXTPUSHELEMNAME(pctxt, "ricActionExecutionOrder");
   stat = asn1PE_e2ap_RICactionExecutionOrder (pctxt, pvalue->ricActionExecutionOrder);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   }


   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RICaction_ToBeSetup_Item (OSCTXT* pctxt, e2ap_RICaction_ToBeSetup_Item* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[5];

   RTXCTXTPUSHTYPENAME(pctxt, "RICaction-ToBeSetup-Item");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 5; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field ricActionID */
   RTXCTXTPUSHELEMNAME(pctxt, "ricActionID");
      stat = asn1PD_e2ap_RICactionID (pctxt, &pvalue->ricActionID);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field ricActionType */
   RTXCTXTPUSHELEMNAME(pctxt, "ricActionType");
      stat = asn1PD_e2ap_RICactionType (pctxt, &pvalue->ricActionType);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field ricActionDefinition */
   RTXCTXTPUSHELEMNAME(pctxt, "ricActionDefinition");
   if (optbits[0]) {
      pvalue->m_ricActionDefinitionPresent = TRUE;
      stat = asn1PD_e2ap_RICactionDefinition (pctxt, &pvalue->ricActionDefinition);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   } else {
      pvalue->m_ricActionDefinitionPresent = FALSE;
   }
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field ricSubsequentAction */
   RTXCTXTPUSHELEMNAME(pctxt, "ricSubsequentAction");
   if (optbits[0]) {
      pvalue->m_ricSubsequentActionPresent = TRUE;
      stat = asn1PD_e2ap_RICsubsequentAction (pctxt, &pvalue->ricSubsequentAction);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   } else {
      pvalue->m_ricSubsequentActionPresent = FALSE;
   }
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field ricActionExecutionOrder */
   RTXCTXTPUSHELEMNAME(pctxt, "ricActionExecutionOrder");
   if (optbits[0]) {
      pvalue->m_ricActionExecutionOrderPresent = TRUE;
      stat = asn1PD_e2ap_RICactionExecutionOrder (pctxt, &pvalue->ricActionExecutionOrder);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   } else {
      pvalue->m_ricActionExecutionOrderPresent = FALSE;
   }
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RICaction_ToBeSetup_Item (e2ap_RICaction_ToBeSetup_Item* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RICactionID (&pvalue->ricActionID);
   asn1Init_e2ap_RICactionType (&pvalue->ricActionType);
   asn1Init_e2ap_RICactionDefinition (&pvalue->ricActionDefinition);
   asn1Init_e2ap_RICsubsequentAction (&pvalue->ricSubsequentAction);
   asn1Init_e2ap_RICactionExecutionOrder (&pvalue->ricActionExecutionOrder);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RICaction_ToBeSetup_Item (OSCTXT* pctxt, e2ap_RICaction_ToBeSetup_Item* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_RICactionID (pctxt, &pvalue->ricActionID);
   asn1Free_e2ap_RICactionType (pctxt, &pvalue->ricActionType);
   asn1Free_e2ap_RICactionDefinition (pctxt, &pvalue->ricActionDefinition);
   asn1Free_e2ap_RICsubsequentAction (pctxt, &pvalue->ricSubsequentAction);
   asn1Free_e2ap_RICactionExecutionOrder (pctxt, &pvalue->ricActionExecutionOrder);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RICaction_ToBeSetup_Item (const char* name, e2ap_RICaction_ToBeSetup_Item* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }
   if(asn1PrtToStr_e2ap_RICactionID ("ricActionID", &pvalue->ricActionID, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_RICactionType ("ricActionType", &pvalue->ricActionType, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_RICactionDefinition ("ricActionDefinition", &pvalue->ricActionDefinition, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_RICsubsequentAction ("ricSubsequentAction", &pvalue->ricSubsequentAction, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_RICactionExecutionOrder ("ricActionExecutionOrder", &pvalue->ricActionExecutionOrder, buffer, bufSize) < 0)
   {
      return -1;
   }



   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           RICaction_ToBeSetup_ItemIEs                */
/*****************************************/
/* ie.c.j2 */
/*ie thường*/
int asn1PE_e2ap_RICaction_ToBeSetup_ItemIEs (OSCTXT* pctxt, e2ap_RICaction_ToBeSetup_ItemIEs* pvalue)
{
   int stat = 0;
   //RTXCTXTPUSHTYPENAME (pctxt, "RICaction-ToBeSetup-ItemIEs");

   /* encode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");
   stat = asn1PE_e2ap_ProtocolIE_ID (pctxt, pvalue->id);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");
   stat = asn1PE_e2ap_Criticality (pctxt, pvalue->criticality);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   {
      OSCTXT ictxt;
      OSOCTET* pDynamicEncodeBuffer;
      ASN1OpenType openType;
      OSBOOL  encoded = TRUE;

      openType.numocts = 0;
      openType.data = 0;

      rtxCopyContext (&ictxt, pctxt);
      pctxt->pStream = 0;

      stat = rtxInitContextBuffer (pctxt, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_RICaction_ToBeSetup_ItemIEs_id_RICaction_ToBeSetup_Item:
         
        // RTXCTXTPUSHELEMNAME (pctxt, "RICaction_ToBeSetup_ItemIEs_id_RICaction_ToBeSetup_Item");
         RTXCTXTPUSHELEMNAME (pctxt, "RICaction-ToBeSetup-Item");
         stat = asn1PE_e2ap_RICaction_ToBeSetup_Item (pctxt, pvalue->value.u._e2apRICaction_ToBeSetup_ItemIEs_id_RICaction_ToBeSetup_Item);
         RTXCTXTPOPELEMNAME (pctxt);
      
         break;

      case T_E2AP_PDU_Contents_e2ap_RICaction_ToBeSetup_ItemIEs_UNDEF_:
      {
          if(0!=pvalue->value.u.extElem1){
              openType.numocts = pvalue->value.u.extElem1->numocts;
              openType.data = pvalue->value.u.extElem1->data;
          } else {
              /* No extension element to encode */
          }
          encoded = FALSE;
          break;
      }
      default:
         encoded = FALSE;
         stat = RTERR_INVOPT;
      }

      if (encoded) {
         openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
         openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
      }
      rtxCopyContext (pctxt, &ictxt);
      if(stat ==0) stat = pe_OpenType(pctxt, openType.numocts, openType.data);
      /*free dynamic encode buffer*/
      if(encoded){
          rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
      }
   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);
   //RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

int asn1PD_e2ap_RICaction_ToBeSetup_ItemIEs (OSCTXT* pctxt, e2ap_RICaction_ToBeSetup_ItemIEs* pvalue)
{
   int stat =0;
   /*deode root element id*/
   RTXCTXTPUSHELEMNAME(pctxt, "id");
   stat = asn1PD_e2ap_ProtocolIE_ID (pctxt, &pvalue->id);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*decode root element criticality*/
   RTXCTXTPUSHELEMNAME(pctxt, "criticality");
   stat = asn1PD_e2ap_Criticality (pctxt, &pvalue->criticality);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   /*decode root element value*/
   RTXCTXTPUSHELEMNAME(pctxt, "value");
   {
      OSUINT32 openTypeLen;
      size_t bitStartOffset, bitLength;
      stat = pd_UnconsLength(pctxt, &openTypeLen);
      if(stat <0) return LOG_RTERR(pctxt, stat);
      else if(stat == RT_OK_FRAG){
         rtxErrAddStrParm(pctxt, "open type with fragmented length use - perindef");
         return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
      }
      bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
      bitLength = openTypeLen * 8;
      switch (pvalue->id){
         case T_E2AP_PDU_Contents_e2ap_RICaction_ToBeSetup_ItemIEs_id_RICaction_ToBeSetup_Item:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICaction_ToBeSetup_ItemIEs_id_RICaction_ToBeSetup_Item;
            RTXCTXTPUSHELEMNAME(pctxt, "RICaction-ToBeSetup-Item");
            //pvalue->value.u._e2ap_RICaction_ToBeSetup_ItemIEs_id_id_RICaction_ToBeSetup_Item 
             pvalue->value.u._e2apRICaction_ToBeSetup_ItemIEs_id_RICaction_ToBeSetup_Item 
                    = rtxMemAllocType(pctxt, e2ap_RICaction_ToBeSetup_Item);
            //asn1Init_e2ap_RICaction_ToBeSetup_Item(pvalue->value.u._e2ap_RICaction_ToBeSetup_ItemIEs_id_id_RICaction_ToBeSetup_Item);
            asn1Init_e2ap_RICaction_ToBeSetup_Item(pvalue->value.u._e2apRICaction_ToBeSetup_ItemIEs_id_RICaction_ToBeSetup_Item);
            stat = asn1PD_e2ap_RICaction_ToBeSetup_Item (pctxt,
                    (e2ap_RICaction_ToBeSetup_Item*)pvalue->value.
                    u._e2apRICaction_ToBeSetup_ItemIEs_id_RICaction_ToBeSetup_Item);
            if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICaction_ToBeSetup_ItemIEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*)rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
      }
      {
      size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
      size_t bitsConsumed = bitEndOffset - bitStartOffset;
      if(bitsConsumed < bitLength){
         stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
      } else {
         stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
      }
      }
   }
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   return stat;
}

void asn1Init_e2ap_RICaction_ToBeSetup_ItemIEs (e2ap_RICaction_ToBeSetup_ItemIEs* pvalue)
{
   if (!pvalue) return;
   OSCRTLMEMSET (pvalue, 0, sizeof(e2ap_RICaction_ToBeSetup_ItemIEs));
}

#if 0
void asn1Free_e2ap_RICaction_ToBeSetup_ItemIEs (OSCTXT* pctxt, e2ap_RICaction_ToBeSetup_ItemIEs* pvalue)
{
   if (!pvalue) return;
   if (pvalue->extElem1) {
      rtxMemFreeArray (pctxt, pvalue->extElem1);
      pvalue->extElem1 = 0;
      pvalue->extElem1_n = 0;
   }
}
#endif
void asn1Free_e2ap_RICaction_ToBeSetup_ItemIEs (OSCTXT* pctxt, e2ap_RICaction_ToBeSetup_ItemIEs* pvalue)
{
   if(0==pvalue) return;
   switch(pvalue->value.t){
      case T_E2AP_PDU_Contents_e2ap_RICaction_ToBeSetup_ItemIEs_id_RICaction_ToBeSetup_Item:
         asn1Free_e2ap_RICaction_ToBeSetup_Item (pctxt, pvalue->value.u._e2apRICaction_ToBeSetup_ItemIEs_id_RICaction_ToBeSetup_Item);
         rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2apRICaction_ToBeSetup_ItemIEs_id_RICaction_ToBeSetup_Item);
         pvalue->value.u._e2apRICaction_ToBeSetup_ItemIEs_id_RICaction_ToBeSetup_Item = 0;
         break;
      case T_E2AP_PDU_Contents_e2ap_RICaction_ToBeSetup_ItemIEs_UNDEF_:
         if(0!=pvalue->value.u.extElem1){
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1->data);
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
             pvalue->value.u.extElem1 =0;
         }
         break;
         default:;
   }
}

int  asn1PrtToStr_e2ap_RICaction_ToBeSetup_ItemIEs (const char * name, e2ap_RICaction_ToBeSetup_ItemIEs* pvalue, char * buffer, OSSIZE bufSize){
   if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
       return -1;

      if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
         return -1;

      if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
         return -1;
      if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
         return -1;
      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_RICaction_ToBeSetup_ItemIEs_id_RICaction_ToBeSetup_Item:
         if(asn1PrtToStr_e2ap_RICaction_ToBeSetup_Item("RICaction-ToBeSetup-Item",
                pvalue->value.u._e2apRICaction_ToBeSetup_ItemIEs_id_RICaction_ToBeSetup_Item, buffer, bufSize)<0)// dungnm23 check lai nhe xem la
            return -1;
         break;
      default:
         if(0!=pvalue -> value.u.extElem1){
             rtPrintToStringIndent(buffer, bufSize);
             rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

         }
      }
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

      return 0;

}
 

/*****************************************/
/*           RICactions_ToBeSetup_List                */
/*****************************************/
//seq_of_single_container


int asn1PE_e2ap_RICactions_ToBeSetup_List (OSCTXT* pctxt, e2ap_RICactions_ToBeSetup_List* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_RICaction_ToBeSetup_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "RICactions-ToBeSetup-List");

   /* encode length determinant */
   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;
   for (xx1 = 0; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next, xx1++) {
      pdata = (e2ap_RICaction_ToBeSetup_ItemIEs*) pnode->data;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_e2ap_RICaction_ToBeSetup_ItemIEs (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      //xx1++;
      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}

int asn1PD_e2ap_RICactions_ToBeSetup_List (OSCTXT* pctxt, e2ap_RICactions_ToBeSetup_List* ppvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_RICaction_ToBeSetup_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "RICactions-ToBeSetup-List");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (ppvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      pdata = rtxMemAllocType (pctxt, e2ap_RICaction_ToBeSetup_ItemIEs);
      if (!pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);
      asn1Init_e2ap_RICaction_ToBeSetup_ItemIEs (pdata);
      stat = asn1PD_e2ap_RICaction_ToBeSetup_ItemIEs (pctxt, pdata);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         return LOG_RTERR (pctxt, stat);
      }

      rtxDListAppendNode (ppvalue, pdata);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

void asn1Init_e2ap_RICactions_ToBeSetup_List (e2ap_RICactions_ToBeSetup_List* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
}

void asn1Free_e2ap_RICactions_ToBeSetup_List (OSCTXT* pctxt, e2ap_RICactions_ToBeSetup_List* pvalue)
{
   if(pvalue==0) return;
   OSRTDListNode* pnode = pvalue->head;
   while (pnode) {
      e2ap_RICaction_ToBeSetup_ItemIEs* pdata = (e2ap_RICaction_ToBeSetup_ItemIEs*) pnode->data;
      if (pdata) {
         asn1Free_e2ap_RICaction_ToBeSetup_ItemIEs (pctxt, pdata);
         rtxMemFreePtr (pctxt, pdata);
      }
      pnode = pnode->next;
   }
      rtxDListFreeAll(pctxt, pvalue);
}

#if 0
void asn1Free_e2ap_RICactions_ToBeSetup_List (OSCTXT* pctxt, e2ap_RICactions_ToBeSetup_List* pvalue){
   if(0==pvalue ) return;
   {
      e2ap_RICaction_ToBeSetup_ItemIEs * pdata;
      OSRTDListNode *pnode = pvalue->head;
      while(0!=pnode){
         pdata = (e2ap_RICaction_ToBeSetup_ItemIEs*)pnode->data;
         asn1Free_e2ap_RICaction_ToBeSetup_ItemIEs(pctxt, pdata);
         pnode = pnode->next;
      }
      rtxDListFreeAll(pctxt, pvalue);
   }
}
#endif


int asn1PrtToStr_e2ap_RICactions_ToBeSetup_List(const char* name, e2ap_RICactions_ToBeSetup_List* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_RICaction_ToBeSetup_ItemIEs* pdata;
    OSRTDListNode* pnode;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode = pvalue->head;  xx1 < pvalue->count && pnode != 0; pnode = pnode->next, xx1++){
        pdata = (e2ap_RICaction_ToBeSetup_ItemIEs*)pnode->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 1
        if(asn1PrtToStr_e2ap_RICaction_ToBeSetup_ItemIEs(nameBuf, pdata, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}
/*****************************************/
/*           RICsubscriptionDetails                */
/*****************************************/
//sequence normal
// Các nội dung cần thiết cho template seq_normal.c.j2

// Các phần còn lại của template seq_normal.c.j2
//contain extensition bit -> theo mau cua GlobalgNB-ID
int asn1PE_e2ap_RICsubscriptionDetails (OSCTXT* pctxt, e2ap_RICsubscriptionDetails* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RICsubscriptionDetails");

   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field ricEventTriggerDefinition - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "ricEventTriggerDefinition");
   stat = asn1PE_e2ap_RICeventTriggerDefinition (pctxt, pvalue->ricEventTriggerDefinition);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /* encode field ricAction_ToBeSetup_List - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "ricAction-ToBeSetup-List");
   stat = asn1PE_e2ap_RICactions_ToBeSetup_List (pctxt, pvalue->ricAction_ToBeSetup_List);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);



   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RICsubscriptionDetails (OSCTXT* pctxt, e2ap_RICsubscriptionDetails* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME(pctxt, "RICsubscriptionDetails");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field ricEventTriggerDefinition */
   RTXCTXTPUSHELEMNAME(pctxt, "ricEventTriggerDefinition");
      stat = asn1PD_e2ap_RICeventTriggerDefinition (pctxt, &pvalue->ricEventTriggerDefinition);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field ricAction_ToBeSetup_List */
   RTXCTXTPUSHELEMNAME(pctxt, "ricAction-ToBeSetup-List");
      stat = asn1PD_e2ap_RICactions_ToBeSetup_List (pctxt, &pvalue->ricAction_ToBeSetup_List);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RICsubscriptionDetails (e2ap_RICsubscriptionDetails* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RICeventTriggerDefinition (&pvalue->ricEventTriggerDefinition);
   asn1Init_e2ap_RICactions_ToBeSetup_List (&pvalue->ricAction_ToBeSetup_List);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RICsubscriptionDetails (OSCTXT* pctxt, e2ap_RICsubscriptionDetails* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_RICeventTriggerDefinition (pctxt, &pvalue->ricEventTriggerDefinition);
   asn1Free_e2ap_RICactions_ToBeSetup_List (pctxt, &pvalue->ricAction_ToBeSetup_List);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RICsubscriptionDetails (const char* name, e2ap_RICsubscriptionDetails* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }
   if(asn1PrtToStr_e2ap_RICeventTriggerDefinition ("ricEventTriggerDefinition", &pvalue->ricEventTriggerDefinition, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_RICactions_ToBeSetup_List ("ricAction_ToBeSetup_List", &pvalue->ricAction_ToBeSetup_List, buffer, bufSize) < 0)
   {
      return -1;
   }



   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           RICsubscriptionTime                */
/*****************************************/
//8 mau octet string
//type 8  mau la octet string size(n) mau la plmn_identity
EXTERN int asn1PE_e2ap_RICsubscriptionTime (OSCTXT* pctxt, e2ap_RICsubscriptionTime* pvalue){
   int stat = 0;
   RTXCTCXTPUSHTYPENAME (pctxt, "RICsubscriptionTime");
   PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(8), OSUINTCONST(8), 0, 0);

   stat = pe_OctetString(pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}
EXTERN int asn1PD_e2ap_RICsubscriptionTime (OSCTXT* pctxt, e2ap_RICsubscriptionTime* pvalue){
   int stat = 0;
   RTXCTCXTPUSHTYPENAME (pctxt, "RICsubscriptionTime");
   PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(8), OSUINTCONST(8), 0, 0);

   stat = pd_OctetString(pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}
//EXTERN int asn1PrtToStr_e2ap_RICsubscriptionTime (const char* name, e2ap_RICsubscriptionTime* pvalue, char* buffer, OSSIZE bufSize);
//EXTERN int asn1PrtToStrm_e2ap_RICsubscriptionTime (OSCTXT* pctxt, const char* name, const e2ap_RICsubscriptionTime* pvalue);
//EXTERN int asn1Copy_e2ap_RICsubscriptionTime (OSCTXT* pctxt, const e2ap_RICsubscriptionTime* pSrcValue, e2ap_RICsubscriptionTime* pDstValue);

int asn1Init_e2ap_RICsubscriptionTime (e2ap_RICsubscriptionTime* pvalue){
   if (pvalue == 0) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   return 0;
}
void asn1Free_e2ap_RICsubscriptionTime (OSCTXT* pctxt, e2ap_RICsubscriptionTime* pvalue){
   // No dynamic memory to free for fixed-size OCTET STRING
   return;
}
/*****************************************/
/*           RICsubscriptionRequest_IEs                */
/*****************************************/
/* ie.c.j2 */
 /* d là con của msg */
EXTERN int asn1PE_e2ap_RICsubscriptionRequest_protocolIEs_element (OSCTXT* pctxt, e2ap_RICsubscriptionRequest_protocolIEs_element* pvalue)
{
    int stat =0;

    /*encode id*/

    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PE_e2ap_ProtocolIE_ID(pctxt, pvalue->id);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PE_e2ap_Criticality(pctxt, pvalue->criticality);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
    {
        OSCTXT lctxt;
        OSOCTET *pDynamicEncodeBuffer;
        ASN1OpenType openType;
        OSBOOL encoded = TRUE;

        openType.numocts = 0;
        openType.data =0;

        rtxCopyContext(&lctxt, pctxt);
        pctxt->pStream =0;

        stat = rtxInitContextBuffer(pctxt, 0, 0);
        if(stat!=0) return LOG_RTERR(pctxt, stat);

        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionRequest_IEs_id_RICrequestID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICrequestID");
                    stat = asn1PE_e2ap_RICrequestID (pctxt, pvalue->value.u._e2ap_RICsubscriptionRequest_IEs_id_RICrequestID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionRequest_IEs_id_RANfunctionID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RANfunctionID");
                    stat = asn1PE_e2ap_RANfunctionID (pctxt, pvalue->value.u._e2ap_RICsubscriptionRequest_IEs_id_RANfunctionID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionRequest_IEs_id_RICsubscriptionDetails:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICsubscriptionDetails");
                    stat = asn1PE_e2ap_RICsubscriptionDetails (pctxt, pvalue->value.u._e2ap_RICsubscriptionRequest_IEs_id_RICsubscriptionDetails);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionRequest_IEs_id_RICsubscriptionStartTime:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICsubscriptionStartTime");
                    stat = asn1PE_e2ap_RICsubscriptionTime (pctxt, pvalue->value.u._e2ap_RICsubscriptionRequest_IEs_id_RICsubscriptionStartTime);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionRequest_IEs_id_RICsubscriptionEndTime:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICsubscriptionEndTime");
                    stat = asn1PE_e2ap_RICsubscriptionTime (pctxt, pvalue->value.u._e2ap_RICsubscriptionRequest_IEs_id_RICsubscriptionEndTime);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionRequest_IEs_UNDEF_:
            {
                if(0!=pvalue->value.u.extElem1){
                    openType.numocts = pvalue->value.u.extElem1->numocts;
                    openType.data = pvalue->value.u.extElem1->data;
                } else {
                    /* No extension element to encode */
                }
                encoded = FALSE;
                break;
            }

            default:
                encoded = FALSE;
                stat = RTERR_INVOPT;
                break;
        } 

        if(encoded){
            openType.numocts = (OSUINT32)pe_GetMsgLen(pctxt);
            openType.data = pDynamicEncodeBuffer = pctxt -> buffer.data;
        }
        rtxCopyContext(pctxt, &lctxt);

        if(stat == 0) {
            stat = pe_OpenType (pctxt, openType.numocts, openType.data);
        }
    #if 1
        if(encoded){//dungnm23 check lai nhe
            rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
        }
    #endif

    }

    if(stat!=0) return LOG_RTERR(pctxt, stat);  
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}

EXTERN int  asn1PD_e2ap_RICsubscriptionRequest_protocolIEs_element (OSCTXT* pctxt, e2ap_RICsubscriptionRequest_protocolIEs_element* pvalue){
    int stat =0;

    /*decode id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PD_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PD_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");

    {
        OSUINT32 openTypeLen;
        size_t bitStartOffset, bitLength;

        stat = pd_UnconsLength(pctxt, &openTypeLen);
        if(stat<0) return LOG_RTERR(pctxt, stat);
        else if(stat == RT_OK_FRAG){
            rtxErrAddStrParm(pctxt, "open type with fragment length");
            return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
        }
        bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
        bitLength = openTypeLen * 8;

        switch(pvalue->id){//dungnm23 check case lai nhe
        
            case ASN1V_e2ap_id_RICrequestID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionRequest_IEs_id_RICrequestID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICrequestID");
                pvalue->value.u._e2ap_RICsubscriptionRequest_IEs_id_RICrequestID 
                    = rtxMemAllocType(pctxt, e2ap_RICrequestID);

                asn1Init_e2ap_RICrequestID(pvalue->value.u._e2ap_RICsubscriptionRequest_IEs_id_RICrequestID);

                stat = asn1PD_e2ap_RICrequestID (pctxt,
                        (e2ap_RICrequestID*)pvalue->value.
                        u._e2ap_RICsubscriptionRequest_IEs_id_RICrequestID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RANfunctionID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionRequest_IEs_id_RANfunctionID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RANfunctionID");
                pvalue->value.u._e2ap_RICsubscriptionRequest_IEs_id_RANfunctionID 
                    = rtxMemAllocType(pctxt, e2ap_RANfunctionID);

                asn1Init_e2ap_RANfunctionID(pvalue->value.u._e2ap_RICsubscriptionRequest_IEs_id_RANfunctionID);

                stat = asn1PD_e2ap_RANfunctionID (pctxt,
                        (e2ap_RANfunctionID*)pvalue->value.
                        u._e2ap_RICsubscriptionRequest_IEs_id_RANfunctionID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RICsubscriptionDetails:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionRequest_IEs_id_RICsubscriptionDetails;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICsubscriptionDetails");
                pvalue->value.u._e2ap_RICsubscriptionRequest_IEs_id_RICsubscriptionDetails 
                    = rtxMemAllocType(pctxt, e2ap_RICsubscriptionDetails);

                asn1Init_e2ap_RICsubscriptionDetails(pvalue->value.u._e2ap_RICsubscriptionRequest_IEs_id_RICsubscriptionDetails);

                stat = asn1PD_e2ap_RICsubscriptionDetails (pctxt,
                        (e2ap_RICsubscriptionDetails*)pvalue->value.
                        u._e2ap_RICsubscriptionRequest_IEs_id_RICsubscriptionDetails);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RICsubscriptionStartTime:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionRequest_IEs_id_RICsubscriptionStartTime;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICsubscriptionStartTime");
                pvalue->value.u._e2ap_RICsubscriptionRequest_IEs_id_RICsubscriptionStartTime 
                    = rtxMemAllocType(pctxt, e2ap_RICsubscriptionTime);

                asn1Init_e2ap_RICsubscriptionTime(pvalue->value.u._e2ap_RICsubscriptionRequest_IEs_id_RICsubscriptionStartTime);

                stat = asn1PD_e2ap_RICsubscriptionTime (pctxt,
                        (e2ap_RICsubscriptionTime*)pvalue->value.
                        u._e2ap_RICsubscriptionRequest_IEs_id_RICsubscriptionStartTime);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RICsubscriptionEndTime:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionRequest_IEs_id_RICsubscriptionEndTime;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICsubscriptionEndTime");
                pvalue->value.u._e2ap_RICsubscriptionRequest_IEs_id_RICsubscriptionEndTime 
                    = rtxMemAllocType(pctxt, e2ap_RICsubscriptionTime);

                asn1Init_e2ap_RICsubscriptionTime(pvalue->value.u._e2ap_RICsubscriptionRequest_IEs_id_RICsubscriptionEndTime);

                stat = asn1PD_e2ap_RICsubscriptionTime (pctxt,
                        (e2ap_RICsubscriptionTime*)pvalue->value.
                        u._e2ap_RICsubscriptionRequest_IEs_id_RICsubscriptionEndTime);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionRequest_IEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*) rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
    }
    {
    size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
    size_t bitsConsumed = bitEndOffset-bitStartOffset;
    if(bitsConsumed<bitLength){
        stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
    }
    else stat =(bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
    }}
    if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}


int asn1Init_e2ap_RICsubscriptionRequest_protocolIEs_element(e2ap_RICsubscriptionRequest_protocolIEs_element* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    OSCRTLMEMSET (&pvalue->value, 0, sizeof(pvalue->value));
    return 0;
}


//-----> chuaw có template rtxFreeASN1OpenType

#if 0
void asn1Free_e2ap_RICsubscriptionRequest_protocolIEs_element(OSCTXT* pctxt, e2ap_RICsubscriptionRequest_protocolIEs_element* pvalue)
{
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionRequest_IEs_id_id_RICrequestID:
            // rtxFreeE2ap_RICrequestID(pvalue->value.u._e2ap_RICsubscriptionRequest_IEs_id_id_RICrequestID);

            if(pvalue->value.i._e2ap_RICsubscriptionRequest_id_RICrequestID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICrequestID(pctxt, pvalue->value.u._e2ap_RICsubscriptionRequest_IEs_id_id_RICrequestID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionRequest_IEs_id_id_RICrequestID);
           // pvalue->value.u._e2ap_RICsubscriptionRequest_IEs_id_id_RICrequestID = NULL;
           pvalue->value.u._e2ap_RICsubscriptionRequest_IEs_id_RICrequestID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionRequest_IEs_id_id_RANfunctionID:
            // rtxFreeE2ap_RANfunctionID(pvalue->value.u._e2ap_RICsubscriptionRequest_IEs_id_id_RANfunctionID);

            if(pvalue->value.i._e2ap_RICsubscriptionRequest_id_RANfunctionID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RANfunctionID(pctxt, pvalue->value.u._e2ap_RICsubscriptionRequest_IEs_id_id_RANfunctionID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionRequest_IEs_id_id_RANfunctionID);
           // pvalue->value.u._e2ap_RICsubscriptionRequest_IEs_id_id_RANfunctionID = NULL;
           pvalue->value.u._e2ap_RICsubscriptionRequest_IEs_id_RANfunctionID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionRequest_IEs_id_id_RICsubscriptionDetails:
            // rtxFreeE2ap_RICsubscriptionDetails(pvalue->value.u._e2ap_RICsubscriptionRequest_IEs_id_id_RICsubscriptionDetails);

            if(pvalue->value.i._e2ap_RICsubscriptionRequest_id_RICsubscriptionDetails!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICsubscriptionDetails(pctxt, pvalue->value.u._e2ap_RICsubscriptionRequest_IEs_id_id_RICsubscriptionDetails);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionRequest_IEs_id_id_RICsubscriptionDetails);
           // pvalue->value.u._e2ap_RICsubscriptionRequest_IEs_id_id_RICsubscriptionDetails = NULL;
           pvalue->value.u._e2ap_RICsubscriptionRequest_IEs_id_RICsubscriptionDetails = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionRequest_IEs_id_id_RICsubscriptionStartTime:
            // rtxFreeE2ap_RICsubscriptionTime(pvalue->value.u._e2ap_RICsubscriptionRequest_IEs_id_id_RICsubscriptionStartTime);

            if(pvalue->value.i._e2ap_RICsubscriptionRequest_id_RICsubscriptionTime!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICsubscriptionTime(pctxt, pvalue->value.u._e2ap_RICsubscriptionRequest_IEs_id_id_RICsubscriptionStartTime);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionRequest_IEs_id_id_RICsubscriptionStartTime);
           // pvalue->value.u._e2ap_RICsubscriptionRequest_IEs_id_id_RICsubscriptionStartTime = NULL;
           pvalue->value.u._e2ap_RICsubscriptionRequest_IEs_id_RICsubscriptionStartTime = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionRequest_IEs_id_id_RICsubscriptionEndTime:
            // rtxFreeE2ap_RICsubscriptionTime(pvalue->value.u._e2ap_RICsubscriptionRequest_IEs_id_id_RICsubscriptionEndTime);

            if(pvalue->value.i._e2ap_RICsubscriptionRequest_id_RICsubscriptionTime!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICsubscriptionTime(pctxt, pvalue->value.u._e2ap_RICsubscriptionRequest_IEs_id_id_RICsubscriptionEndTime);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionRequest_IEs_id_id_RICsubscriptionEndTime);
           // pvalue->value.u._e2ap_RICsubscriptionRequest_IEs_id_id_RICsubscriptionEndTime = NULL;
           pvalue->value.u._e2ap_RICsubscriptionRequest_IEs_id_RICsubscriptionEndTime = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionRequest_IEs_UNDEF_:
            rtxFreeASN1OpenType(pvalue->value.u.extElem1);
            break;
        default:
            break;
    }
}

int asn1PrtToStr_e2ap_RICsubscriptionRequest_protocolIEs_element(OSCTXT* pctxt, e2ap_RICsubscriptionRequest_protocolIEs_element* pvalue)
{
    int stat =0;
    RTXCTXTPUSHELEMNAME(pctxt, "e2ap_RICsubscriptionRequest_protocolIEs_element");

    /*print id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PrtToStr_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PrtToStr_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionRequest_IEs_id_id_RICrequestID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICrequestID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICrequestID (pctxt, pvalue->value.u._e2ap_RICsubscriptionRequest_IEs_id_id_RICrequestID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionRequest_IEs_id_id_RANfunctionID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RANfunctionID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RANfunctionID (pctxt, pvalue->value.u._e2ap_RICsubscriptionRequest_IEs_id_id_RANfunctionID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionRequest_IEs_id_id_RICsubscriptionDetails:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICsubscriptionDetails");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICsubscriptionDetails (pctxt, pvalue->value.u._e2ap_RICsubscriptionRequest_IEs_id_id_RICsubscriptionDetails);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionRequest_IEs_id_id_RICsubscriptionStartTime:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICsubscriptionTime");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICsubscriptionTime (pctxt, pvalue->value.u._e2ap_RICsubscriptionRequest_IEs_id_id_RICsubscriptionStartTime);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionRequest_IEs_id_id_RICsubscriptionEndTime:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICsubscriptionTime");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICsubscriptionTime (pctxt, pvalue->value.u._e2ap_RICsubscriptionRequest_IEs_id_id_RICsubscriptionEndTime);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionRequest_IEs_UNDEF_:
            {
                rtxPLogMsg(pctxt, "Extension element present - raw data not printed.\n");
                break;
            }

            default:
                stat = RTERR_INVOPT;
                return LOG_RTERR(pctxt, stat);
        }
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);
}
#endif


int asn1PrtToStr_e2ap_RICsubscriptionRequest_protocolIEs_element (const char * name,
 e2ap_RICsubscriptionRequest_protocolIEs_element* pvalue, 
 char * buffer, OSSIZE bufSize){
    if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
        return -1;
    if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
        return -1;

    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionRequest_IEs_id_RICrequestID:
            if(asn1PrtToStr_e2ap_RICrequestID("RICrequestID", 
                    pvalue->value.u._e2ap_RICsubscriptionRequest_IEs_id_RICrequestID, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionRequest_IEs_id_RANfunctionID:
            if(asn1PrtToStr_e2ap_RANfunctionID("RANfunctionID", 
                    pvalue->value.u._e2ap_RICsubscriptionRequest_IEs_id_RANfunctionID, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionRequest_IEs_id_RICsubscriptionDetails:
            if(asn1PrtToStr_e2ap_RICsubscriptionDetails("RICsubscriptionDetails", 
                    pvalue->value.u._e2ap_RICsubscriptionRequest_IEs_id_RICsubscriptionDetails, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionRequest_IEs_id_RICsubscriptionStartTime:
            if(asn1PrtToStr_e2ap_RICsubscriptionTime("RICsubscriptionTime", 
                    pvalue->value.u._e2ap_RICsubscriptionRequest_IEs_id_RICsubscriptionStartTime, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionRequest_IEs_id_RICsubscriptionEndTime:
            if(asn1PrtToStr_e2ap_RICsubscriptionTime("RICsubscriptionTime", 
                    pvalue->value.u._e2ap_RICsubscriptionRequest_IEs_id_RICsubscriptionEndTime, buffer, bufSize)<0)
                return -1;
            break;    
        default:
        if(0!=pvalue -> value.u.extElem1){
            rtPrintToStringIndent(buffer, bufSize);
            rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

        }
        }
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

    return 0;

 }

 void asn1Free_e2ap_RICsubscriptionRequest_protocolIEs_element(OSCTXT* pctxt, e2ap_RICsubscriptionRequest_protocolIEs_element* pvalue){
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionRequest_IEs_id_RICrequestID:
            if(pvalue->value.u._e2ap_RICsubscriptionRequest_IEs_id_RICrequestID!=NULL){
            asn1Free_e2ap_RICrequestID(pctxt, pvalue->value.u._e2ap_RICsubscriptionRequest_IEs_id_RICrequestID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionRequest_IEs_id_RICrequestID);
            pvalue->value.u._e2ap_RICsubscriptionRequest_IEs_id_RICrequestID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionRequest_IEs_id_RANfunctionID:
            if(pvalue->value.u._e2ap_RICsubscriptionRequest_IEs_id_RANfunctionID!=NULL){
            asn1Free_e2ap_RANfunctionID(pctxt, pvalue->value.u._e2ap_RICsubscriptionRequest_IEs_id_RANfunctionID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionRequest_IEs_id_RANfunctionID);
            pvalue->value.u._e2ap_RICsubscriptionRequest_IEs_id_RANfunctionID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionRequest_IEs_id_RICsubscriptionDetails:
            if(pvalue->value.u._e2ap_RICsubscriptionRequest_IEs_id_RICsubscriptionDetails!=NULL){
            asn1Free_e2ap_RICsubscriptionDetails(pctxt, pvalue->value.u._e2ap_RICsubscriptionRequest_IEs_id_RICsubscriptionDetails);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionRequest_IEs_id_RICsubscriptionDetails);
            pvalue->value.u._e2ap_RICsubscriptionRequest_IEs_id_RICsubscriptionDetails = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionRequest_IEs_id_RICsubscriptionStartTime:
            if(pvalue->value.u._e2ap_RICsubscriptionRequest_IEs_id_RICsubscriptionStartTime!=NULL){
            asn1Free_e2ap_RICsubscriptionTime(pctxt, pvalue->value.u._e2ap_RICsubscriptionRequest_IEs_id_RICsubscriptionStartTime);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionRequest_IEs_id_RICsubscriptionStartTime);
            pvalue->value.u._e2ap_RICsubscriptionRequest_IEs_id_RICsubscriptionStartTime = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionRequest_IEs_id_RICsubscriptionEndTime:
            if(pvalue->value.u._e2ap_RICsubscriptionRequest_IEs_id_RICsubscriptionEndTime!=NULL){
            asn1Free_e2ap_RICsubscriptionTime(pctxt, pvalue->value.u._e2ap_RICsubscriptionRequest_IEs_id_RICsubscriptionEndTime);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionRequest_IEs_id_RICsubscriptionEndTime);
            pvalue->value.u._e2ap_RICsubscriptionRequest_IEs_id_RICsubscriptionEndTime = NULL;
            }
            break;
        default:
            break;


    }
 }

 

/*****************************************/
/*           RICsubscriptionRequest                */
/*****************************************/
//2_container.c
/* 1. xxx_ProtocolIE -> mẫu cũ ở ie_big_msg */
EXTERN int asn1PE_e2ap_RICsubscriptionRequest_protocolIEs (OSCTXT* pctxt, e2ap_RICsubscriptionRequest_protocolIEs* pvalue)
{
    int stat =0;
    OSRTDListNode* pnode;
    OSUINT32 xx1;

    /*encode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pe_Length(pctxt, pvalue->count);
    if(stat<0) return LOG_RTERR(pctxt, stat);

    /*encode each element*/
    xx1 =0;
    for(pnode = pvalue->head; pnode != 0 && xx1<pvalue->count; pnode = pnode->next){
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE", xx1);
        stat = asn1PE_e2ap_RICsubscriptionRequest_protocolIEs_element (pctxt, ((e2ap_RICsubscriptionRequest_protocolIEs_element*)pnode->data));
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        xx1++;
        RTXCTXTPOPARRAYELEMNAME(pctxt);
    }

    return (stat);
}

EXTERN int  asn1PD_e2ap_RICsubscriptionRequest_protocolIEs(OSCTXT* pctxt, e2ap_RICsubscriptionRequest_protocolIEs* pvalue)
{
     int stat =0;
     OSRTDListNode* pnode;
     OSSIZE count =0;
     OSSIZE xx1=0;


     /*decode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pd_Length64(pctxt, &count); //tai sao lai 64
    if(stat!=0) return LOG_RTERR(pctxt, stat);

    /*decode each element*/
    rtxDListInit(pvalue);

    for(xx1=0; xx1 < count; xx1++){
        e2ap_RICsubscriptionRequest_protocolIEs_element* pdata;
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE",xx1);

        if(pnode == NULL) return LOG_RTERR(pctxt, RTERR_NOMEM);

        asn1Init_e2ap_RICsubscriptionRequest_protocolIEs_element(pdata);
        rtxDListAppendNode(pvalue, pnode);
        stat = asn1PD_e2ap_RICsubscriptionRequest_protocolIEs_element (pctxt, pdata);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        RTXCTXTPOPARRAYELEMNAME(pctxt);

    }
    return (stat);
}


int asn1Init_e2ap_RICsubscriptionRequest_protocolIEs(e2ap_RICsubscriptionRequest_protocolIEs* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    rtxDListFastInit (pvalue);
    return 0;
}
#if 1 //ao that day
void asn1Free_e2ap_RICsubscriptionRequest_protocolIEs(OSCTXT* pctxt, e2ap_RICsubscriptionRequest_protocolIEs* pvalue)
{
    if(0==pvalue) return;   
    e2ap_RICsubscriptionRequest_protocolIEs_element* pdata;
    OSRTDListNode* pnode=pvalue->head;
    while(0!=pnode){
        pdata = (e2ap_RICsubscriptionRequest_protocolIEs_element*)pnode->data;
       // asn1Free_e2ap_RICsubscriptionRequest_protocolIEs_element(pctxt, pdata);
        pnode = pnode->next;
    }
    rtxDListFreeAll(pctxt, pvalue);
}
#endif


EXTERN int asn1PrtToStr_e2ap_RICsubscriptionRequest_protocolIEs(const char* name, e2ap_RICsubscriptionRequest_protocolIEs* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_RICsubscriptionRequest_protocolIEs_element* pdata0;
    OSRTDListNode* pnode0;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode0 = pvalue->head;  xx1 < pvalue->count && pnode0 != 0; pnode0 = pnode0->next, xx1++){
        pdata0 = (e2ap_RICsubscriptionRequest_protocolIEs_element*)pnode0->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 0
        if(asn1PrtToStr_e2ap_RICsubscriptionRequest_protocolIEs_element(nameBuf, pdata0, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}


/*2 . RICsubscriptionRequest -> mẫu cũ ở seq_normal*/

int asn1PE_e2ap_RICsubscriptionRequest (OSCTXT* pctxt, e2ap_RICsubscriptionRequest* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RICsubscriptionRequest");
   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field protocolIEs - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
   stat = asn1PE_e2ap_RICsubscriptionRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if(stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RICsubscriptionRequest (OSCTXT* pctxt, e2ap_RICsubscriptionRequest* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME(pctxt, "RICsubscriptionRequest");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field protocolIEs */
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
      stat = asn1PD_e2ap_RICsubscriptionRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RICsubscriptionRequest (e2ap_RICsubscriptionRequest* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RICsubscriptionRequest_protocolIEs(&pvalue->protocolIEs);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RICsubscriptionRequest (OSCTXT* pctxt, e2ap_RICsubscriptionRequest* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_RICsubscriptionRequest_protocolIEs(pctxt, &pvalue->protocolIEs);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RICsubscriptionRequest (const char* name, e2ap_RICsubscriptionRequest* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }

   if(asn1PrtToStr_e2ap_RICsubscriptionRequest_protocolIEs("protocolIEs", &pvalue->protocolIEs, buffer, bufSize) <0){
      return -1;
   }

   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}
/*****************************************/
/*           RICaction-Admitted-Item                */
/*****************************************/
//sequence normal
// Các nội dung cần thiết cho template seq_normal.c.j2

// Các phần còn lại của template seq_normal.c.j2
//contain extensition bit -> theo mau cua GlobalgNB-ID
int asn1PE_e2ap_RICaction_Admitted_Item (OSCTXT* pctxt, e2ap_RICaction_Admitted_Item* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RICaction-Admitted-Item");

   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field ricActionID - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "ricActionID");
   stat = asn1PE_e2ap_RICactionID (pctxt, pvalue->ricActionID);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);



   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RICaction_Admitted_Item (OSCTXT* pctxt, e2ap_RICaction_Admitted_Item* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME(pctxt, "RICaction-Admitted-Item");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field ricActionID */
   RTXCTXTPUSHELEMNAME(pctxt, "ricActionID");
      stat = asn1PD_e2ap_RICactionID (pctxt, &pvalue->ricActionID);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RICaction_Admitted_Item (e2ap_RICaction_Admitted_Item* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RICactionID (&pvalue->ricActionID);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RICaction_Admitted_Item (OSCTXT* pctxt, e2ap_RICaction_Admitted_Item* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_RICactionID (pctxt, &pvalue->ricActionID);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RICaction_Admitted_Item (const char* name, e2ap_RICaction_Admitted_Item* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }
   if(asn1PrtToStr_e2ap_RICactionID ("ricActionID", &pvalue->ricActionID, buffer, bufSize) < 0)
   {
      return -1;
   }



   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           RICaction_Admitted_ItemIEs                */
/*****************************************/
/* ie.c.j2 */
/*ie thường*/
int asn1PE_e2ap_RICaction_Admitted_ItemIEs (OSCTXT* pctxt, e2ap_RICaction_Admitted_ItemIEs* pvalue)
{
   int stat = 0;
   //RTXCTXTPUSHTYPENAME (pctxt, "RICaction-Admitted-ItemIEs");

   /* encode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");
   stat = asn1PE_e2ap_ProtocolIE_ID (pctxt, pvalue->id);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");
   stat = asn1PE_e2ap_Criticality (pctxt, pvalue->criticality);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   {
      OSCTXT ictxt;
      OSOCTET* pDynamicEncodeBuffer;
      ASN1OpenType openType;
      OSBOOL  encoded = TRUE;

      openType.numocts = 0;
      openType.data = 0;

      rtxCopyContext (&ictxt, pctxt);
      pctxt->pStream = 0;

      stat = rtxInitContextBuffer (pctxt, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_RICaction_Admitted_ItemIEs_id_RICaction_Admitted_Item:
         
        // RTXCTXTPUSHELEMNAME (pctxt, "RICaction_Admitted_ItemIEs_id_RICaction_Admitted_Item");
         RTXCTXTPUSHELEMNAME (pctxt, "RICaction-Admitted-Item");
         stat = asn1PE_e2ap_RICaction_Admitted_Item (pctxt, pvalue->value.u._e2apRICaction_Admitted_ItemIEs_id_RICaction_Admitted_Item);
         RTXCTXTPOPELEMNAME (pctxt);
      
         break;

      case T_E2AP_PDU_Contents_e2ap_RICaction_Admitted_ItemIEs_UNDEF_:
      {
          if(0!=pvalue->value.u.extElem1){
              openType.numocts = pvalue->value.u.extElem1->numocts;
              openType.data = pvalue->value.u.extElem1->data;
          } else {
              /* No extension element to encode */
          }
          encoded = FALSE;
          break;
      }
      default:
         encoded = FALSE;
         stat = RTERR_INVOPT;
      }

      if (encoded) {
         openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
         openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
      }
      rtxCopyContext (pctxt, &ictxt);
      if(stat ==0) stat = pe_OpenType(pctxt, openType.numocts, openType.data);
      /*free dynamic encode buffer*/
      if(encoded){
          rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
      }
   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);
   //RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

int asn1PD_e2ap_RICaction_Admitted_ItemIEs (OSCTXT* pctxt, e2ap_RICaction_Admitted_ItemIEs* pvalue)
{
   int stat =0;
   /*deode root element id*/
   RTXCTXTPUSHELEMNAME(pctxt, "id");
   stat = asn1PD_e2ap_ProtocolIE_ID (pctxt, &pvalue->id);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*decode root element criticality*/
   RTXCTXTPUSHELEMNAME(pctxt, "criticality");
   stat = asn1PD_e2ap_Criticality (pctxt, &pvalue->criticality);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   /*decode root element value*/
   RTXCTXTPUSHELEMNAME(pctxt, "value");
   {
      OSUINT32 openTypeLen;
      size_t bitStartOffset, bitLength;
      stat = pd_UnconsLength(pctxt, &openTypeLen);
      if(stat <0) return LOG_RTERR(pctxt, stat);
      else if(stat == RT_OK_FRAG){
         rtxErrAddStrParm(pctxt, "open type with fragmented length use - perindef");
         return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
      }
      bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
      bitLength = openTypeLen * 8;
      switch (pvalue->id){
         case T_E2AP_PDU_Contents_e2ap_RICaction_Admitted_ItemIEs_id_RICaction_Admitted_Item:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICaction_Admitted_ItemIEs_id_RICaction_Admitted_Item;
            RTXCTXTPUSHELEMNAME(pctxt, "RICaction-Admitted-Item");
            //pvalue->value.u._e2ap_RICaction_Admitted_ItemIEs_id_id_RICaction_Admitted_Item 
             pvalue->value.u._e2apRICaction_Admitted_ItemIEs_id_RICaction_Admitted_Item 
                    = rtxMemAllocType(pctxt, e2ap_RICaction_Admitted_Item);
            //asn1Init_e2ap_RICaction_Admitted_Item(pvalue->value.u._e2ap_RICaction_Admitted_ItemIEs_id_id_RICaction_Admitted_Item);
            asn1Init_e2ap_RICaction_Admitted_Item(pvalue->value.u._e2apRICaction_Admitted_ItemIEs_id_RICaction_Admitted_Item);
            stat = asn1PD_e2ap_RICaction_Admitted_Item (pctxt,
                    (e2ap_RICaction_Admitted_Item*)pvalue->value.
                    u._e2apRICaction_Admitted_ItemIEs_id_RICaction_Admitted_Item);
            if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICaction_Admitted_ItemIEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*)rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
      }
      {
      size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
      size_t bitsConsumed = bitEndOffset - bitStartOffset;
      if(bitsConsumed < bitLength){
         stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
      } else {
         stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
      }
      }
   }
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   return stat;
}

void asn1Init_e2ap_RICaction_Admitted_ItemIEs (e2ap_RICaction_Admitted_ItemIEs* pvalue)
{
   if (!pvalue) return;
   OSCRTLMEMSET (pvalue, 0, sizeof(e2ap_RICaction_Admitted_ItemIEs));
}

#if 0
void asn1Free_e2ap_RICaction_Admitted_ItemIEs (OSCTXT* pctxt, e2ap_RICaction_Admitted_ItemIEs* pvalue)
{
   if (!pvalue) return;
   if (pvalue->extElem1) {
      rtxMemFreeArray (pctxt, pvalue->extElem1);
      pvalue->extElem1 = 0;
      pvalue->extElem1_n = 0;
   }
}
#endif
void asn1Free_e2ap_RICaction_Admitted_ItemIEs (OSCTXT* pctxt, e2ap_RICaction_Admitted_ItemIEs* pvalue)
{
   if(0==pvalue) return;
   switch(pvalue->value.t){
      case T_E2AP_PDU_Contents_e2ap_RICaction_Admitted_ItemIEs_id_RICaction_Admitted_Item:
         asn1Free_e2ap_RICaction_Admitted_Item (pctxt, pvalue->value.u._e2apRICaction_Admitted_ItemIEs_id_RICaction_Admitted_Item);
         rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2apRICaction_Admitted_ItemIEs_id_RICaction_Admitted_Item);
         pvalue->value.u._e2apRICaction_Admitted_ItemIEs_id_RICaction_Admitted_Item = 0;
         break;
      case T_E2AP_PDU_Contents_e2ap_RICaction_Admitted_ItemIEs_UNDEF_:
         if(0!=pvalue->value.u.extElem1){
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1->data);
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
             pvalue->value.u.extElem1 =0;
         }
         break;
         default:;
   }
}

int  asn1PrtToStr_e2ap_RICaction_Admitted_ItemIEs (const char * name, e2ap_RICaction_Admitted_ItemIEs* pvalue, char * buffer, OSSIZE bufSize){
   if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
       return -1;

      if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
         return -1;

      if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
         return -1;
      if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
         return -1;
      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_RICaction_Admitted_ItemIEs_id_RICaction_Admitted_Item:
         if(asn1PrtToStr_e2ap_RICaction_Admitted_Item("RICaction-Admitted-Item",
                pvalue->value.u._e2apRICaction_Admitted_ItemIEs_id_RICaction_Admitted_Item, buffer, bufSize)<0)// dungnm23 check lai nhe xem la
            return -1;
         break;
      default:
         if(0!=pvalue -> value.u.extElem1){
             rtPrintToStringIndent(buffer, bufSize);
             rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

         }
      }
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

      return 0;

}
 

/*****************************************/
/*           RICaction_Admitted_List                */
/*****************************************/
//seq_of_single_container


int asn1PE_e2ap_RICaction_Admitted_List (OSCTXT* pctxt, e2ap_RICaction_Admitted_List* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_RICaction_Admitted_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "RICaction-Admitted-List");

   /* encode length determinant */
   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;
   for (xx1 = 0; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next, xx1++) {
      pdata = (e2ap_RICaction_Admitted_ItemIEs*) pnode->data;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_e2ap_RICaction_Admitted_ItemIEs (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      //xx1++;
      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}

int asn1PD_e2ap_RICaction_Admitted_List (OSCTXT* pctxt, e2ap_RICaction_Admitted_List* ppvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_RICaction_Admitted_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "RICaction-Admitted-List");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (ppvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      pdata = rtxMemAllocType (pctxt, e2ap_RICaction_Admitted_ItemIEs);
      if (!pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);
      asn1Init_e2ap_RICaction_Admitted_ItemIEs (pdata);
      stat = asn1PD_e2ap_RICaction_Admitted_ItemIEs (pctxt, pdata);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         return LOG_RTERR (pctxt, stat);
      }

      rtxDListAppendNode (ppvalue, pdata);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

void asn1Init_e2ap_RICaction_Admitted_List (e2ap_RICaction_Admitted_List* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
}

void asn1Free_e2ap_RICaction_Admitted_List (OSCTXT* pctxt, e2ap_RICaction_Admitted_List* pvalue)
{
   if(pvalue==0) return;
   OSRTDListNode* pnode = pvalue->head;
   while (pnode) {
      e2ap_RICaction_Admitted_ItemIEs* pdata = (e2ap_RICaction_Admitted_ItemIEs*) pnode->data;
      if (pdata) {
         asn1Free_e2ap_RICaction_Admitted_ItemIEs (pctxt, pdata);
         rtxMemFreePtr (pctxt, pdata);
      }
      pnode = pnode->next;
   }
      rtxDListFreeAll(pctxt, pvalue);
}

#if 0
void asn1Free_e2ap_RICaction_Admitted_List (OSCTXT* pctxt, e2ap_RICaction_Admitted_List* pvalue){
   if(0==pvalue ) return;
   {
      e2ap_RICaction_Admitted_ItemIEs * pdata;
      OSRTDListNode *pnode = pvalue->head;
      while(0!=pnode){
         pdata = (e2ap_RICaction_Admitted_ItemIEs*)pnode->data;
         asn1Free_e2ap_RICaction_Admitted_ItemIEs(pctxt, pdata);
         pnode = pnode->next;
      }
      rtxDListFreeAll(pctxt, pvalue);
   }
}
#endif


int asn1PrtToStr_e2ap_RICaction_Admitted_List(const char* name, e2ap_RICaction_Admitted_List* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_RICaction_Admitted_ItemIEs* pdata;
    OSRTDListNode* pnode;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode = pvalue->head;  xx1 < pvalue->count && pnode != 0; pnode = pnode->next, xx1++){
        pdata = (e2ap_RICaction_Admitted_ItemIEs*)pnode->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 1
        if(asn1PrtToStr_e2ap_RICaction_Admitted_ItemIEs(nameBuf, pdata, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}
/*****************************************/
/*           RICaction-NotAdmitted-Item                */
/*****************************************/
//sequence normal
// Các nội dung cần thiết cho template seq_normal.c.j2

// Các phần còn lại của template seq_normal.c.j2
//contain extensition bit -> theo mau cua GlobalgNB-ID
int asn1PE_e2ap_RICaction_NotAdmitted_Item (OSCTXT* pctxt, e2ap_RICaction_NotAdmitted_Item* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RICaction-NotAdmitted-Item");

   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field ricActionID - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "ricActionID");
   stat = asn1PE_e2ap_RICactionID (pctxt, pvalue->ricActionID);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /* encode field cause - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "cause");
   stat = asn1PE_e2ap_Cause (pctxt, pvalue->cause);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);



   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RICaction_NotAdmitted_Item (OSCTXT* pctxt, e2ap_RICaction_NotAdmitted_Item* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME(pctxt, "RICaction-NotAdmitted-Item");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field ricActionID */
   RTXCTXTPUSHELEMNAME(pctxt, "ricActionID");
      stat = asn1PD_e2ap_RICactionID (pctxt, &pvalue->ricActionID);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field cause */
   RTXCTXTPUSHELEMNAME(pctxt, "cause");
      stat = asn1PD_e2ap_Cause (pctxt, &pvalue->cause);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RICaction_NotAdmitted_Item (e2ap_RICaction_NotAdmitted_Item* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RICactionID (&pvalue->ricActionID);
   asn1Init_e2ap_Cause (&pvalue->cause);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RICaction_NotAdmitted_Item (OSCTXT* pctxt, e2ap_RICaction_NotAdmitted_Item* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_RICactionID (pctxt, &pvalue->ricActionID);
   asn1Free_e2ap_Cause (pctxt, &pvalue->cause);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RICaction_NotAdmitted_Item (const char* name, e2ap_RICaction_NotAdmitted_Item* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }
   if(asn1PrtToStr_e2ap_RICactionID ("ricActionID", &pvalue->ricActionID, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_Cause ("cause", &pvalue->cause, buffer, bufSize) < 0)
   {
      return -1;
   }



   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           RICaction_NotAdmitted_ItemIEs                */
/*****************************************/
/* ie.c.j2 */
/*ie thường*/
int asn1PE_e2ap_RICaction_NotAdmitted_ItemIEs (OSCTXT* pctxt, e2ap_RICaction_NotAdmitted_ItemIEs* pvalue)
{
   int stat = 0;
   //RTXCTXTPUSHTYPENAME (pctxt, "RICaction-NotAdmitted-ItemIEs");

   /* encode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");
   stat = asn1PE_e2ap_ProtocolIE_ID (pctxt, pvalue->id);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");
   stat = asn1PE_e2ap_Criticality (pctxt, pvalue->criticality);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   {
      OSCTXT ictxt;
      OSOCTET* pDynamicEncodeBuffer;
      ASN1OpenType openType;
      OSBOOL  encoded = TRUE;

      openType.numocts = 0;
      openType.data = 0;

      rtxCopyContext (&ictxt, pctxt);
      pctxt->pStream = 0;

      stat = rtxInitContextBuffer (pctxt, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_RICaction_NotAdmitted_ItemIEs_id_RICaction_NotAdmitted_Item:
         
        // RTXCTXTPUSHELEMNAME (pctxt, "RICaction_NotAdmitted_ItemIEs_id_RICaction_NotAdmitted_Item");
         RTXCTXTPUSHELEMNAME (pctxt, "RICaction-NotAdmitted-Item");
         stat = asn1PE_e2ap_RICaction_NotAdmitted_Item (pctxt, pvalue->value.u._e2apRICaction_NotAdmitted_ItemIEs_id_RICaction_NotAdmitted_Item);
         RTXCTXTPOPELEMNAME (pctxt);
      
         break;

      case T_E2AP_PDU_Contents_e2ap_RICaction_NotAdmitted_ItemIEs_UNDEF_:
      {
          if(0!=pvalue->value.u.extElem1){
              openType.numocts = pvalue->value.u.extElem1->numocts;
              openType.data = pvalue->value.u.extElem1->data;
          } else {
              /* No extension element to encode */
          }
          encoded = FALSE;
          break;
      }
      default:
         encoded = FALSE;
         stat = RTERR_INVOPT;
      }

      if (encoded) {
         openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
         openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
      }
      rtxCopyContext (pctxt, &ictxt);
      if(stat ==0) stat = pe_OpenType(pctxt, openType.numocts, openType.data);
      /*free dynamic encode buffer*/
      if(encoded){
          rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
      }
   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);
   //RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

int asn1PD_e2ap_RICaction_NotAdmitted_ItemIEs (OSCTXT* pctxt, e2ap_RICaction_NotAdmitted_ItemIEs* pvalue)
{
   int stat =0;
   /*deode root element id*/
   RTXCTXTPUSHELEMNAME(pctxt, "id");
   stat = asn1PD_e2ap_ProtocolIE_ID (pctxt, &pvalue->id);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*decode root element criticality*/
   RTXCTXTPUSHELEMNAME(pctxt, "criticality");
   stat = asn1PD_e2ap_Criticality (pctxt, &pvalue->criticality);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   /*decode root element value*/
   RTXCTXTPUSHELEMNAME(pctxt, "value");
   {
      OSUINT32 openTypeLen;
      size_t bitStartOffset, bitLength;
      stat = pd_UnconsLength(pctxt, &openTypeLen);
      if(stat <0) return LOG_RTERR(pctxt, stat);
      else if(stat == RT_OK_FRAG){
         rtxErrAddStrParm(pctxt, "open type with fragmented length use - perindef");
         return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
      }
      bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
      bitLength = openTypeLen * 8;
      switch (pvalue->id){
         case T_E2AP_PDU_Contents_e2ap_RICaction_NotAdmitted_ItemIEs_id_RICaction_NotAdmitted_Item:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICaction_NotAdmitted_ItemIEs_id_RICaction_NotAdmitted_Item;
            RTXCTXTPUSHELEMNAME(pctxt, "RICaction-NotAdmitted-Item");
            //pvalue->value.u._e2ap_RICaction_NotAdmitted_ItemIEs_id_id_RICaction_NotAdmitted_Item 
             pvalue->value.u._e2apRICaction_NotAdmitted_ItemIEs_id_RICaction_NotAdmitted_Item 
                    = rtxMemAllocType(pctxt, e2ap_RICaction_NotAdmitted_Item);
            //asn1Init_e2ap_RICaction_NotAdmitted_Item(pvalue->value.u._e2ap_RICaction_NotAdmitted_ItemIEs_id_id_RICaction_NotAdmitted_Item);
            asn1Init_e2ap_RICaction_NotAdmitted_Item(pvalue->value.u._e2apRICaction_NotAdmitted_ItemIEs_id_RICaction_NotAdmitted_Item);
            stat = asn1PD_e2ap_RICaction_NotAdmitted_Item (pctxt,
                    (e2ap_RICaction_NotAdmitted_Item*)pvalue->value.
                    u._e2apRICaction_NotAdmitted_ItemIEs_id_RICaction_NotAdmitted_Item);
            if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICaction_NotAdmitted_ItemIEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*)rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
      }
      {
      size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
      size_t bitsConsumed = bitEndOffset - bitStartOffset;
      if(bitsConsumed < bitLength){
         stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
      } else {
         stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
      }
      }
   }
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   return stat;
}

void asn1Init_e2ap_RICaction_NotAdmitted_ItemIEs (e2ap_RICaction_NotAdmitted_ItemIEs* pvalue)
{
   if (!pvalue) return;
   OSCRTLMEMSET (pvalue, 0, sizeof(e2ap_RICaction_NotAdmitted_ItemIEs));
}

#if 0
void asn1Free_e2ap_RICaction_NotAdmitted_ItemIEs (OSCTXT* pctxt, e2ap_RICaction_NotAdmitted_ItemIEs* pvalue)
{
   if (!pvalue) return;
   if (pvalue->extElem1) {
      rtxMemFreeArray (pctxt, pvalue->extElem1);
      pvalue->extElem1 = 0;
      pvalue->extElem1_n = 0;
   }
}
#endif
void asn1Free_e2ap_RICaction_NotAdmitted_ItemIEs (OSCTXT* pctxt, e2ap_RICaction_NotAdmitted_ItemIEs* pvalue)
{
   if(0==pvalue) return;
   switch(pvalue->value.t){
      case T_E2AP_PDU_Contents_e2ap_RICaction_NotAdmitted_ItemIEs_id_RICaction_NotAdmitted_Item:
         asn1Free_e2ap_RICaction_NotAdmitted_Item (pctxt, pvalue->value.u._e2apRICaction_NotAdmitted_ItemIEs_id_RICaction_NotAdmitted_Item);
         rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2apRICaction_NotAdmitted_ItemIEs_id_RICaction_NotAdmitted_Item);
         pvalue->value.u._e2apRICaction_NotAdmitted_ItemIEs_id_RICaction_NotAdmitted_Item = 0;
         break;
      case T_E2AP_PDU_Contents_e2ap_RICaction_NotAdmitted_ItemIEs_UNDEF_:
         if(0!=pvalue->value.u.extElem1){
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1->data);
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
             pvalue->value.u.extElem1 =0;
         }
         break;
         default:;
   }
}

int  asn1PrtToStr_e2ap_RICaction_NotAdmitted_ItemIEs (const char * name, e2ap_RICaction_NotAdmitted_ItemIEs* pvalue, char * buffer, OSSIZE bufSize){
   if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
       return -1;

      if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
         return -1;

      if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
         return -1;
      if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
         return -1;
      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_RICaction_NotAdmitted_ItemIEs_id_RICaction_NotAdmitted_Item:
         if(asn1PrtToStr_e2ap_RICaction_NotAdmitted_Item("RICaction-NotAdmitted-Item",
                pvalue->value.u._e2apRICaction_NotAdmitted_ItemIEs_id_RICaction_NotAdmitted_Item, buffer, bufSize)<0)// dungnm23 check lai nhe xem la
            return -1;
         break;
      default:
         if(0!=pvalue -> value.u.extElem1){
             rtPrintToStringIndent(buffer, bufSize);
             rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

         }
      }
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

      return 0;

}
 

/*****************************************/
/*           RICaction_NotAdmitted_List                */
/*****************************************/
//seq_of_single_container


int asn1PE_e2ap_RICaction_NotAdmitted_List (OSCTXT* pctxt, e2ap_RICaction_NotAdmitted_List* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_RICaction_NotAdmitted_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "RICaction-NotAdmitted-List");

   /* encode length determinant */
   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(16), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;
   for (xx1 = 0; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next, xx1++) {
      pdata = (e2ap_RICaction_NotAdmitted_ItemIEs*) pnode->data;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_e2ap_RICaction_NotAdmitted_ItemIEs (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      //xx1++;
      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}

int asn1PD_e2ap_RICaction_NotAdmitted_List (OSCTXT* pctxt, e2ap_RICaction_NotAdmitted_List* ppvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_RICaction_NotAdmitted_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "RICaction-NotAdmitted-List");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(16), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (ppvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      pdata = rtxMemAllocType (pctxt, e2ap_RICaction_NotAdmitted_ItemIEs);
      if (!pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);
      asn1Init_e2ap_RICaction_NotAdmitted_ItemIEs (pdata);
      stat = asn1PD_e2ap_RICaction_NotAdmitted_ItemIEs (pctxt, pdata);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         return LOG_RTERR (pctxt, stat);
      }

      rtxDListAppendNode (ppvalue, pdata);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

void asn1Init_e2ap_RICaction_NotAdmitted_List (e2ap_RICaction_NotAdmitted_List* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
}

void asn1Free_e2ap_RICaction_NotAdmitted_List (OSCTXT* pctxt, e2ap_RICaction_NotAdmitted_List* pvalue)
{
   if(pvalue==0) return;
   OSRTDListNode* pnode = pvalue->head;
   while (pnode) {
      e2ap_RICaction_NotAdmitted_ItemIEs* pdata = (e2ap_RICaction_NotAdmitted_ItemIEs*) pnode->data;
      if (pdata) {
         asn1Free_e2ap_RICaction_NotAdmitted_ItemIEs (pctxt, pdata);
         rtxMemFreePtr (pctxt, pdata);
      }
      pnode = pnode->next;
   }
      rtxDListFreeAll(pctxt, pvalue);
}

#if 0
void asn1Free_e2ap_RICaction_NotAdmitted_List (OSCTXT* pctxt, e2ap_RICaction_NotAdmitted_List* pvalue){
   if(0==pvalue ) return;
   {
      e2ap_RICaction_NotAdmitted_ItemIEs * pdata;
      OSRTDListNode *pnode = pvalue->head;
      while(0!=pnode){
         pdata = (e2ap_RICaction_NotAdmitted_ItemIEs*)pnode->data;
         asn1Free_e2ap_RICaction_NotAdmitted_ItemIEs(pctxt, pdata);
         pnode = pnode->next;
      }
      rtxDListFreeAll(pctxt, pvalue);
   }
}
#endif


int asn1PrtToStr_e2ap_RICaction_NotAdmitted_List(const char* name, e2ap_RICaction_NotAdmitted_List* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_RICaction_NotAdmitted_ItemIEs* pdata;
    OSRTDListNode* pnode;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode = pvalue->head;  xx1 < pvalue->count && pnode != 0; pnode = pnode->next, xx1++){
        pdata = (e2ap_RICaction_NotAdmitted_ItemIEs*)pnode->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 1
        if(asn1PrtToStr_e2ap_RICaction_NotAdmitted_ItemIEs(nameBuf, pdata, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}/*****************************************/
/*           RICsubscriptionResponse_IEs                */
/*****************************************/
/* ie.c.j2 */
 /* d là con của msg */
EXTERN int asn1PE_e2ap_RICsubscriptionResponse_protocolIEs_element (OSCTXT* pctxt, e2ap_RICsubscriptionResponse_protocolIEs_element* pvalue)
{
    int stat =0;

    /*encode id*/

    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PE_e2ap_ProtocolIE_ID(pctxt, pvalue->id);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PE_e2ap_Criticality(pctxt, pvalue->criticality);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
    {
        OSCTXT lctxt;
        OSOCTET *pDynamicEncodeBuffer;
        ASN1OpenType openType;
        OSBOOL encoded = TRUE;

        openType.numocts = 0;
        openType.data =0;

        rtxCopyContext(&lctxt, pctxt);
        pctxt->pStream =0;

        stat = rtxInitContextBuffer(pctxt, 0, 0);
        if(stat!=0) return LOG_RTERR(pctxt, stat);

        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionResponse_IEs_id_RICrequestID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICrequestID");
                    stat = asn1PE_e2ap_RICrequestID (pctxt, pvalue->value.u._e2ap_RICsubscriptionResponse_IEs_id_RICrequestID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionResponse_IEs_id_RANfunctionID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RANfunctionID");
                    stat = asn1PE_e2ap_RANfunctionID (pctxt, pvalue->value.u._e2ap_RICsubscriptionResponse_IEs_id_RANfunctionID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionResponse_IEs_id_RICactions_Admitted:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICactions-Admitted");
                    stat = asn1PE_e2ap_RICaction_Admitted_List (pctxt, pvalue->value.u._e2ap_RICsubscriptionResponse_IEs_id_RICactions_Admitted);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionResponse_IEs_id_RICactions_NotAdmitted:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICactions-NotAdmitted");
                    stat = asn1PE_e2ap_RICaction_NotAdmitted_List (pctxt, pvalue->value.u._e2ap_RICsubscriptionResponse_IEs_id_RICactions_NotAdmitted);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionResponse_IEs_UNDEF_:
            {
                if(0!=pvalue->value.u.extElem1){
                    openType.numocts = pvalue->value.u.extElem1->numocts;
                    openType.data = pvalue->value.u.extElem1->data;
                } else {
                    /* No extension element to encode */
                }
                encoded = FALSE;
                break;
            }

            default:
                encoded = FALSE;
                stat = RTERR_INVOPT;
                break;
        } 

        if(encoded){
            openType.numocts = (OSUINT32)pe_GetMsgLen(pctxt);
            openType.data = pDynamicEncodeBuffer = pctxt -> buffer.data;
        }
        rtxCopyContext(pctxt, &lctxt);

        if(stat == 0) {
            stat = pe_OpenType (pctxt, openType.numocts, openType.data);
        }
    #if 1
        if(encoded){//dungnm23 check lai nhe
            rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
        }
    #endif

    }

    if(stat!=0) return LOG_RTERR(pctxt, stat);  
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}

EXTERN int  asn1PD_e2ap_RICsubscriptionResponse_protocolIEs_element (OSCTXT* pctxt, e2ap_RICsubscriptionResponse_protocolIEs_element* pvalue){
    int stat =0;

    /*decode id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PD_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PD_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");

    {
        OSUINT32 openTypeLen;
        size_t bitStartOffset, bitLength;

        stat = pd_UnconsLength(pctxt, &openTypeLen);
        if(stat<0) return LOG_RTERR(pctxt, stat);
        else if(stat == RT_OK_FRAG){
            rtxErrAddStrParm(pctxt, "open type with fragment length");
            return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
        }
        bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
        bitLength = openTypeLen * 8;

        switch(pvalue->id){//dungnm23 check case lai nhe
        
            case ASN1V_e2ap_id_RICrequestID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionResponse_IEs_id_RICrequestID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICrequestID");
                pvalue->value.u._e2ap_RICsubscriptionResponse_IEs_id_RICrequestID 
                    = rtxMemAllocType(pctxt, e2ap_RICrequestID);

                asn1Init_e2ap_RICrequestID(pvalue->value.u._e2ap_RICsubscriptionResponse_IEs_id_RICrequestID);

                stat = asn1PD_e2ap_RICrequestID (pctxt,
                        (e2ap_RICrequestID*)pvalue->value.
                        u._e2ap_RICsubscriptionResponse_IEs_id_RICrequestID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RANfunctionID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionResponse_IEs_id_RANfunctionID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RANfunctionID");
                pvalue->value.u._e2ap_RICsubscriptionResponse_IEs_id_RANfunctionID 
                    = rtxMemAllocType(pctxt, e2ap_RANfunctionID);

                asn1Init_e2ap_RANfunctionID(pvalue->value.u._e2ap_RICsubscriptionResponse_IEs_id_RANfunctionID);

                stat = asn1PD_e2ap_RANfunctionID (pctxt,
                        (e2ap_RANfunctionID*)pvalue->value.
                        u._e2ap_RICsubscriptionResponse_IEs_id_RANfunctionID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RICactions_Admitted:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionResponse_IEs_id_RICactions_Admitted;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICactions-Admitted");
                pvalue->value.u._e2ap_RICsubscriptionResponse_IEs_id_RICactions_Admitted 
                    = rtxMemAllocType(pctxt, e2ap_RICaction_Admitted_List);

                asn1Init_e2ap_RICaction_Admitted_List(pvalue->value.u._e2ap_RICsubscriptionResponse_IEs_id_RICactions_Admitted);

                stat = asn1PD_e2ap_RICaction_Admitted_List (pctxt,
                        (e2ap_RICaction_Admitted_List*)pvalue->value.
                        u._e2ap_RICsubscriptionResponse_IEs_id_RICactions_Admitted);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RICactions_NotAdmitted:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionResponse_IEs_id_RICactions_NotAdmitted;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICactions-NotAdmitted");
                pvalue->value.u._e2ap_RICsubscriptionResponse_IEs_id_RICactions_NotAdmitted 
                    = rtxMemAllocType(pctxt, e2ap_RICaction_NotAdmitted_List);

                asn1Init_e2ap_RICaction_NotAdmitted_List(pvalue->value.u._e2ap_RICsubscriptionResponse_IEs_id_RICactions_NotAdmitted);

                stat = asn1PD_e2ap_RICaction_NotAdmitted_List (pctxt,
                        (e2ap_RICaction_NotAdmitted_List*)pvalue->value.
                        u._e2ap_RICsubscriptionResponse_IEs_id_RICactions_NotAdmitted);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionResponse_IEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*) rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
    }
    {
    size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
    size_t bitsConsumed = bitEndOffset-bitStartOffset;
    if(bitsConsumed<bitLength){
        stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
    }
    else stat =(bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
    }}
    if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}


int asn1Init_e2ap_RICsubscriptionResponse_protocolIEs_element(e2ap_RICsubscriptionResponse_protocolIEs_element* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    OSCRTLMEMSET (&pvalue->value, 0, sizeof(pvalue->value));
    return 0;
}


//-----> chuaw có template rtxFreeASN1OpenType

#if 0
void asn1Free_e2ap_RICsubscriptionResponse_protocolIEs_element(OSCTXT* pctxt, e2ap_RICsubscriptionResponse_protocolIEs_element* pvalue)
{
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionResponse_IEs_id_id_RICrequestID:
            // rtxFreeE2ap_RICrequestID(pvalue->value.u._e2ap_RICsubscriptionResponse_IEs_id_id_RICrequestID);

            if(pvalue->value.i._e2ap_RICsubscriptionResponse_id_RICrequestID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICrequestID(pctxt, pvalue->value.u._e2ap_RICsubscriptionResponse_IEs_id_id_RICrequestID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionResponse_IEs_id_id_RICrequestID);
           // pvalue->value.u._e2ap_RICsubscriptionResponse_IEs_id_id_RICrequestID = NULL;
           pvalue->value.u._e2ap_RICsubscriptionResponse_IEs_id_RICrequestID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionResponse_IEs_id_id_RANfunctionID:
            // rtxFreeE2ap_RANfunctionID(pvalue->value.u._e2ap_RICsubscriptionResponse_IEs_id_id_RANfunctionID);

            if(pvalue->value.i._e2ap_RICsubscriptionResponse_id_RANfunctionID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RANfunctionID(pctxt, pvalue->value.u._e2ap_RICsubscriptionResponse_IEs_id_id_RANfunctionID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionResponse_IEs_id_id_RANfunctionID);
           // pvalue->value.u._e2ap_RICsubscriptionResponse_IEs_id_id_RANfunctionID = NULL;
           pvalue->value.u._e2ap_RICsubscriptionResponse_IEs_id_RANfunctionID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionResponse_IEs_id_id_RICactions_Admitted:
            // rtxFreeE2ap_RICaction_Admitted_List(pvalue->value.u._e2ap_RICsubscriptionResponse_IEs_id_id_RICactions_Admitted);

            if(pvalue->value.i._e2ap_RICsubscriptionResponse_id_RICaction_Admitted_List!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICaction_Admitted_List(pctxt, pvalue->value.u._e2ap_RICsubscriptionResponse_IEs_id_id_RICactions_Admitted);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionResponse_IEs_id_id_RICactions_Admitted);
           // pvalue->value.u._e2ap_RICsubscriptionResponse_IEs_id_id_RICactions_Admitted = NULL;
           pvalue->value.u._e2ap_RICsubscriptionResponse_IEs_id_RICactions_Admitted = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionResponse_IEs_id_id_RICactions_NotAdmitted:
            // rtxFreeE2ap_RICaction_NotAdmitted_List(pvalue->value.u._e2ap_RICsubscriptionResponse_IEs_id_id_RICactions_NotAdmitted);

            if(pvalue->value.i._e2ap_RICsubscriptionResponse_id_RICaction_NotAdmitted_List!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICaction_NotAdmitted_List(pctxt, pvalue->value.u._e2ap_RICsubscriptionResponse_IEs_id_id_RICactions_NotAdmitted);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionResponse_IEs_id_id_RICactions_NotAdmitted);
           // pvalue->value.u._e2ap_RICsubscriptionResponse_IEs_id_id_RICactions_NotAdmitted = NULL;
           pvalue->value.u._e2ap_RICsubscriptionResponse_IEs_id_RICactions_NotAdmitted = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionResponse_IEs_UNDEF_:
            rtxFreeASN1OpenType(pvalue->value.u.extElem1);
            break;
        default:
            break;
    }
}

int asn1PrtToStr_e2ap_RICsubscriptionResponse_protocolIEs_element(OSCTXT* pctxt, e2ap_RICsubscriptionResponse_protocolIEs_element* pvalue)
{
    int stat =0;
    RTXCTXTPUSHELEMNAME(pctxt, "e2ap_RICsubscriptionResponse_protocolIEs_element");

    /*print id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PrtToStr_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PrtToStr_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionResponse_IEs_id_id_RICrequestID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICrequestID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICrequestID (pctxt, pvalue->value.u._e2ap_RICsubscriptionResponse_IEs_id_id_RICrequestID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionResponse_IEs_id_id_RANfunctionID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RANfunctionID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RANfunctionID (pctxt, pvalue->value.u._e2ap_RICsubscriptionResponse_IEs_id_id_RANfunctionID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionResponse_IEs_id_id_RICactions_Admitted:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICaction-Admitted-List");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICaction_Admitted_List (pctxt, pvalue->value.u._e2ap_RICsubscriptionResponse_IEs_id_id_RICactions_Admitted);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionResponse_IEs_id_id_RICactions_NotAdmitted:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICaction-NotAdmitted-List");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICaction_NotAdmitted_List (pctxt, pvalue->value.u._e2ap_RICsubscriptionResponse_IEs_id_id_RICactions_NotAdmitted);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionResponse_IEs_UNDEF_:
            {
                rtxPLogMsg(pctxt, "Extension element present - raw data not printed.\n");
                break;
            }

            default:
                stat = RTERR_INVOPT;
                return LOG_RTERR(pctxt, stat);
        }
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);
}
#endif


int asn1PrtToStr_e2ap_RICsubscriptionResponse_protocolIEs_element (const char * name,
 e2ap_RICsubscriptionResponse_protocolIEs_element* pvalue, 
 char * buffer, OSSIZE bufSize){
    if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
        return -1;
    if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
        return -1;

    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionResponse_IEs_id_RICrequestID:
            if(asn1PrtToStr_e2ap_RICrequestID("RICrequestID", 
                    pvalue->value.u._e2ap_RICsubscriptionResponse_IEs_id_RICrequestID, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionResponse_IEs_id_RANfunctionID:
            if(asn1PrtToStr_e2ap_RANfunctionID("RANfunctionID", 
                    pvalue->value.u._e2ap_RICsubscriptionResponse_IEs_id_RANfunctionID, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionResponse_IEs_id_RICactions_Admitted:
            if(asn1PrtToStr_e2ap_RICaction_Admitted_List("RICaction-Admitted-List", 
                    pvalue->value.u._e2ap_RICsubscriptionResponse_IEs_id_RICactions_Admitted, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionResponse_IEs_id_RICactions_NotAdmitted:
            if(asn1PrtToStr_e2ap_RICaction_NotAdmitted_List("RICaction-NotAdmitted-List", 
                    pvalue->value.u._e2ap_RICsubscriptionResponse_IEs_id_RICactions_NotAdmitted, buffer, bufSize)<0)
                return -1;
            break;    
        default:
        if(0!=pvalue -> value.u.extElem1){
            rtPrintToStringIndent(buffer, bufSize);
            rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

        }
        }
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

    return 0;

 }

 void asn1Free_e2ap_RICsubscriptionResponse_protocolIEs_element(OSCTXT* pctxt, e2ap_RICsubscriptionResponse_protocolIEs_element* pvalue){
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionResponse_IEs_id_RICrequestID:
            if(pvalue->value.u._e2ap_RICsubscriptionResponse_IEs_id_RICrequestID!=NULL){
            asn1Free_e2ap_RICrequestID(pctxt, pvalue->value.u._e2ap_RICsubscriptionResponse_IEs_id_RICrequestID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionResponse_IEs_id_RICrequestID);
            pvalue->value.u._e2ap_RICsubscriptionResponse_IEs_id_RICrequestID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionResponse_IEs_id_RANfunctionID:
            if(pvalue->value.u._e2ap_RICsubscriptionResponse_IEs_id_RANfunctionID!=NULL){
            asn1Free_e2ap_RANfunctionID(pctxt, pvalue->value.u._e2ap_RICsubscriptionResponse_IEs_id_RANfunctionID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionResponse_IEs_id_RANfunctionID);
            pvalue->value.u._e2ap_RICsubscriptionResponse_IEs_id_RANfunctionID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionResponse_IEs_id_RICactions_Admitted:
            if(pvalue->value.u._e2ap_RICsubscriptionResponse_IEs_id_RICactions_Admitted!=NULL){
            asn1Free_e2ap_RICaction_Admitted_List(pctxt, pvalue->value.u._e2ap_RICsubscriptionResponse_IEs_id_RICactions_Admitted);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionResponse_IEs_id_RICactions_Admitted);
            pvalue->value.u._e2ap_RICsubscriptionResponse_IEs_id_RICactions_Admitted = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionResponse_IEs_id_RICactions_NotAdmitted:
            if(pvalue->value.u._e2ap_RICsubscriptionResponse_IEs_id_RICactions_NotAdmitted!=NULL){
            asn1Free_e2ap_RICaction_NotAdmitted_List(pctxt, pvalue->value.u._e2ap_RICsubscriptionResponse_IEs_id_RICactions_NotAdmitted);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionResponse_IEs_id_RICactions_NotAdmitted);
            pvalue->value.u._e2ap_RICsubscriptionResponse_IEs_id_RICactions_NotAdmitted = NULL;
            }
            break;
        default:
            break;


    }
 }

 

/*****************************************/
/*           RICsubscriptionResponse                */
/*****************************************/
//2_container.c
/* 1. xxx_ProtocolIE -> mẫu cũ ở ie_big_msg */
EXTERN int asn1PE_e2ap_RICsubscriptionResponse_protocolIEs (OSCTXT* pctxt, e2ap_RICsubscriptionResponse_protocolIEs* pvalue)
{
    int stat =0;
    OSRTDListNode* pnode;
    OSUINT32 xx1;

    /*encode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pe_Length(pctxt, pvalue->count);
    if(stat<0) return LOG_RTERR(pctxt, stat);

    /*encode each element*/
    xx1 =0;
    for(pnode = pvalue->head; pnode != 0 && xx1<pvalue->count; pnode = pnode->next){
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE", xx1);
        stat = asn1PE_e2ap_RICsubscriptionResponse_protocolIEs_element (pctxt, ((e2ap_RICsubscriptionResponse_protocolIEs_element*)pnode->data));
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        xx1++;
        RTXCTXTPOPARRAYELEMNAME(pctxt);
    }

    return (stat);
}

EXTERN int  asn1PD_e2ap_RICsubscriptionResponse_protocolIEs(OSCTXT* pctxt, e2ap_RICsubscriptionResponse_protocolIEs* pvalue)
{
     int stat =0;
     OSRTDListNode* pnode;
     OSSIZE count =0;
     OSSIZE xx1=0;


     /*decode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pd_Length64(pctxt, &count); //tai sao lai 64
    if(stat!=0) return LOG_RTERR(pctxt, stat);

    /*decode each element*/
    rtxDListInit(pvalue);

    for(xx1=0; xx1 < count; xx1++){
        e2ap_RICsubscriptionResponse_protocolIEs_element* pdata;
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE",xx1);

        if(pnode == NULL) return LOG_RTERR(pctxt, RTERR_NOMEM);

        asn1Init_e2ap_RICsubscriptionResponse_protocolIEs_element(pdata);
        rtxDListAppendNode(pvalue, pnode);
        stat = asn1PD_e2ap_RICsubscriptionResponse_protocolIEs_element (pctxt, pdata);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        RTXCTXTPOPARRAYELEMNAME(pctxt);

    }
    return (stat);
}


int asn1Init_e2ap_RICsubscriptionResponse_protocolIEs(e2ap_RICsubscriptionResponse_protocolIEs* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    rtxDListFastInit (pvalue);
    return 0;
}
#if 1 //ao that day
void asn1Free_e2ap_RICsubscriptionResponse_protocolIEs(OSCTXT* pctxt, e2ap_RICsubscriptionResponse_protocolIEs* pvalue)
{
    if(0==pvalue) return;   
    e2ap_RICsubscriptionResponse_protocolIEs_element* pdata;
    OSRTDListNode* pnode=pvalue->head;
    while(0!=pnode){
        pdata = (e2ap_RICsubscriptionResponse_protocolIEs_element*)pnode->data;
       // asn1Free_e2ap_RICsubscriptionResponse_protocolIEs_element(pctxt, pdata);
        pnode = pnode->next;
    }
    rtxDListFreeAll(pctxt, pvalue);
}
#endif


EXTERN int asn1PrtToStr_e2ap_RICsubscriptionResponse_protocolIEs(const char* name, e2ap_RICsubscriptionResponse_protocolIEs* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_RICsubscriptionResponse_protocolIEs_element* pdata0;
    OSRTDListNode* pnode0;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode0 = pvalue->head;  xx1 < pvalue->count && pnode0 != 0; pnode0 = pnode0->next, xx1++){
        pdata0 = (e2ap_RICsubscriptionResponse_protocolIEs_element*)pnode0->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 0
        if(asn1PrtToStr_e2ap_RICsubscriptionResponse_protocolIEs_element(nameBuf, pdata0, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}


/*2 . RICsubscriptionResponse -> mẫu cũ ở seq_normal*/

int asn1PE_e2ap_RICsubscriptionResponse (OSCTXT* pctxt, e2ap_RICsubscriptionResponse* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RICsubscriptionResponse");
   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field protocolIEs - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
   stat = asn1PE_e2ap_RICsubscriptionResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
   if(stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RICsubscriptionResponse (OSCTXT* pctxt, e2ap_RICsubscriptionResponse* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME(pctxt, "RICsubscriptionResponse");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field protocolIEs */
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
      stat = asn1PD_e2ap_RICsubscriptionResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RICsubscriptionResponse (e2ap_RICsubscriptionResponse* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RICsubscriptionResponse_protocolIEs(&pvalue->protocolIEs);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RICsubscriptionResponse (OSCTXT* pctxt, e2ap_RICsubscriptionResponse* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_RICsubscriptionResponse_protocolIEs(pctxt, &pvalue->protocolIEs);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RICsubscriptionResponse (const char* name, e2ap_RICsubscriptionResponse* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }

   if(asn1PrtToStr_e2ap_RICsubscriptionResponse_protocolIEs("protocolIEs", &pvalue->protocolIEs, buffer, bufSize) <0){
      return -1;
   }

   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           RICsubscriptionAuditFailure_IEs                */
/*****************************************/
/* ie.c.j2 */
 /* d là con của msg */
EXTERN int asn1PE_e2ap_RICsubscriptionAuditFailure_protocolIEs_element (OSCTXT* pctxt, e2ap_RICsubscriptionAuditFailure_protocolIEs_element* pvalue)
{
    int stat =0;

    /*encode id*/

    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PE_e2ap_ProtocolIE_ID(pctxt, pvalue->id);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PE_e2ap_Criticality(pctxt, pvalue->criticality);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
    {
        OSCTXT lctxt;
        OSOCTET *pDynamicEncodeBuffer;
        ASN1OpenType openType;
        OSBOOL encoded = TRUE;

        openType.numocts = 0;
        openType.data =0;

        rtxCopyContext(&lctxt, pctxt);
        pctxt->pStream =0;

        stat = rtxInitContextBuffer(pctxt, 0, 0);
        if(stat!=0) return LOG_RTERR(pctxt, stat);

        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionAuditFailure_IEs_id_RICrequestID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICrequestID");
                    stat = asn1PE_e2ap_RICrequestID (pctxt, pvalue->value.u._e2ap_RICsubscriptionAuditFailure_IEs_id_RICrequestID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionAuditFailure_IEs_id_Cause:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-Cause");
                    stat = asn1PE_e2ap_Cause (pctxt, pvalue->value.u._e2ap_RICsubscriptionAuditFailure_IEs_id_Cause);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionAuditFailure_IEs_id_CriticalityDiagnostics:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-CriticalityDiagnostics");
                    stat = asn1PE_e2ap_CriticalityDiagnostics (pctxt, pvalue->value.u._e2ap_RICsubscriptionAuditFailure_IEs_id_CriticalityDiagnostics);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionAuditFailure_IEs_UNDEF_:
            {
                if(0!=pvalue->value.u.extElem1){
                    openType.numocts = pvalue->value.u.extElem1->numocts;
                    openType.data = pvalue->value.u.extElem1->data;
                } else {
                    /* No extension element to encode */
                }
                encoded = FALSE;
                break;
            }

            default:
                encoded = FALSE;
                stat = RTERR_INVOPT;
                break;
        } 

        if(encoded){
            openType.numocts = (OSUINT32)pe_GetMsgLen(pctxt);
            openType.data = pDynamicEncodeBuffer = pctxt -> buffer.data;
        }
        rtxCopyContext(pctxt, &lctxt);

        if(stat == 0) {
            stat = pe_OpenType (pctxt, openType.numocts, openType.data);
        }
    #if 1
        if(encoded){//dungnm23 check lai nhe
            rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
        }
    #endif

    }

    if(stat!=0) return LOG_RTERR(pctxt, stat);  
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}

EXTERN int  asn1PD_e2ap_RICsubscriptionAuditFailure_protocolIEs_element (OSCTXT* pctxt, e2ap_RICsubscriptionAuditFailure_protocolIEs_element* pvalue){
    int stat =0;

    /*decode id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PD_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PD_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");

    {
        OSUINT32 openTypeLen;
        size_t bitStartOffset, bitLength;

        stat = pd_UnconsLength(pctxt, &openTypeLen);
        if(stat<0) return LOG_RTERR(pctxt, stat);
        else if(stat == RT_OK_FRAG){
            rtxErrAddStrParm(pctxt, "open type with fragment length");
            return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
        }
        bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
        bitLength = openTypeLen * 8;

        switch(pvalue->id){//dungnm23 check case lai nhe
        
            case ASN1V_e2ap_id_RICrequestID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionAuditFailure_IEs_id_RICrequestID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICrequestID");
                pvalue->value.u._e2ap_RICsubscriptionAuditFailure_IEs_id_RICrequestID 
                    = rtxMemAllocType(pctxt, e2ap_RICrequestID);

                asn1Init_e2ap_RICrequestID(pvalue->value.u._e2ap_RICsubscriptionAuditFailure_IEs_id_RICrequestID);

                stat = asn1PD_e2ap_RICrequestID (pctxt,
                        (e2ap_RICrequestID*)pvalue->value.
                        u._e2ap_RICsubscriptionAuditFailure_IEs_id_RICrequestID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_Cause:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionAuditFailure_IEs_id_Cause;
            RTXCTXTPUSHELEMNAME(pctxt, "id-Cause");
                pvalue->value.u._e2ap_RICsubscriptionAuditFailure_IEs_id_Cause 
                    = rtxMemAllocType(pctxt, e2ap_Cause);

                asn1Init_e2ap_Cause(pvalue->value.u._e2ap_RICsubscriptionAuditFailure_IEs_id_Cause);

                stat = asn1PD_e2ap_Cause (pctxt,
                        (e2ap_Cause*)pvalue->value.
                        u._e2ap_RICsubscriptionAuditFailure_IEs_id_Cause);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_CriticalityDiagnostics:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionAuditFailure_IEs_id_CriticalityDiagnostics;
            RTXCTXTPUSHELEMNAME(pctxt, "id-CriticalityDiagnostics");
                pvalue->value.u._e2ap_RICsubscriptionAuditFailure_IEs_id_CriticalityDiagnostics 
                    = rtxMemAllocType(pctxt, e2ap_CriticalityDiagnostics);

                asn1Init_e2ap_CriticalityDiagnostics(pvalue->value.u._e2ap_RICsubscriptionAuditFailure_IEs_id_CriticalityDiagnostics);

                stat = asn1PD_e2ap_CriticalityDiagnostics (pctxt,
                        (e2ap_CriticalityDiagnostics*)pvalue->value.
                        u._e2ap_RICsubscriptionAuditFailure_IEs_id_CriticalityDiagnostics);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionAuditFailure_IEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*) rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
    }
    {
    size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
    size_t bitsConsumed = bitEndOffset-bitStartOffset;
    if(bitsConsumed<bitLength){
        stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
    }
    else stat =(bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
    }}
    if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}


int asn1Init_e2ap_RICsubscriptionAuditFailure_protocolIEs_element(e2ap_RICsubscriptionAuditFailure_protocolIEs_element* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    OSCRTLMEMSET (&pvalue->value, 0, sizeof(pvalue->value));
    return 0;
}


//-----> chuaw có template rtxFreeASN1OpenType

#if 0
void asn1Free_e2ap_RICsubscriptionAuditFailure_protocolIEs_element(OSCTXT* pctxt, e2ap_RICsubscriptionAuditFailure_protocolIEs_element* pvalue)
{
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionAuditFailure_IEs_id_id_RICrequestID:
            // rtxFreeE2ap_RICrequestID(pvalue->value.u._e2ap_RICsubscriptionAuditFailure_IEs_id_id_RICrequestID);

            if(pvalue->value.i._e2ap_RICsubscriptionAuditFailure_id_RICrequestID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICrequestID(pctxt, pvalue->value.u._e2ap_RICsubscriptionAuditFailure_IEs_id_id_RICrequestID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionAuditFailure_IEs_id_id_RICrequestID);
           // pvalue->value.u._e2ap_RICsubscriptionAuditFailure_IEs_id_id_RICrequestID = NULL;
           pvalue->value.u._e2ap_RICsubscriptionAuditFailure_IEs_id_RICrequestID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionAuditFailure_IEs_id_id_Cause:
            // rtxFreeE2ap_Cause(pvalue->value.u._e2ap_RICsubscriptionAuditFailure_IEs_id_id_Cause);

            if(pvalue->value.i._e2ap_RICsubscriptionAuditFailure_id_Cause!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_Cause(pctxt, pvalue->value.u._e2ap_RICsubscriptionAuditFailure_IEs_id_id_Cause);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionAuditFailure_IEs_id_id_Cause);
           // pvalue->value.u._e2ap_RICsubscriptionAuditFailure_IEs_id_id_Cause = NULL;
           pvalue->value.u._e2ap_RICsubscriptionAuditFailure_IEs_id_Cause = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionAuditFailure_IEs_id_id_CriticalityDiagnostics:
            // rtxFreeE2ap_CriticalityDiagnostics(pvalue->value.u._e2ap_RICsubscriptionAuditFailure_IEs_id_id_CriticalityDiagnostics);

            if(pvalue->value.i._e2ap_RICsubscriptionAuditFailure_id_CriticalityDiagnostics!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_CriticalityDiagnostics(pctxt, pvalue->value.u._e2ap_RICsubscriptionAuditFailure_IEs_id_id_CriticalityDiagnostics);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionAuditFailure_IEs_id_id_CriticalityDiagnostics);
           // pvalue->value.u._e2ap_RICsubscriptionAuditFailure_IEs_id_id_CriticalityDiagnostics = NULL;
           pvalue->value.u._e2ap_RICsubscriptionAuditFailure_IEs_id_CriticalityDiagnostics = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionAuditFailure_IEs_UNDEF_:
            rtxFreeASN1OpenType(pvalue->value.u.extElem1);
            break;
        default:
            break;
    }
}

int asn1PrtToStr_e2ap_RICsubscriptionAuditFailure_protocolIEs_element(OSCTXT* pctxt, e2ap_RICsubscriptionAuditFailure_protocolIEs_element* pvalue)
{
    int stat =0;
    RTXCTXTPUSHELEMNAME(pctxt, "e2ap_RICsubscriptionAuditFailure_protocolIEs_element");

    /*print id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PrtToStr_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PrtToStr_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionAuditFailure_IEs_id_id_RICrequestID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICrequestID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICrequestID (pctxt, pvalue->value.u._e2ap_RICsubscriptionAuditFailure_IEs_id_id_RICrequestID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionAuditFailure_IEs_id_id_Cause:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "Cause");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_Cause (pctxt, pvalue->value.u._e2ap_RICsubscriptionAuditFailure_IEs_id_id_Cause);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionAuditFailure_IEs_id_id_CriticalityDiagnostics:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "CriticalityDiagnostics");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_CriticalityDiagnostics (pctxt, pvalue->value.u._e2ap_RICsubscriptionAuditFailure_IEs_id_id_CriticalityDiagnostics);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionAuditFailure_IEs_UNDEF_:
            {
                rtxPLogMsg(pctxt, "Extension element present - raw data not printed.\n");
                break;
            }

            default:
                stat = RTERR_INVOPT;
                return LOG_RTERR(pctxt, stat);
        }
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);
}
#endif


int asn1PrtToStr_e2ap_RICsubscriptionAuditFailure_protocolIEs_element (const char * name,
 e2ap_RICsubscriptionAuditFailure_protocolIEs_element* pvalue, 
 char * buffer, OSSIZE bufSize){
    if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
        return -1;
    if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
        return -1;

    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionAuditFailure_IEs_id_RICrequestID:
            if(asn1PrtToStr_e2ap_RICrequestID("RICrequestID", 
                    pvalue->value.u._e2ap_RICsubscriptionAuditFailure_IEs_id_RICrequestID, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionAuditFailure_IEs_id_Cause:
            if(asn1PrtToStr_e2ap_Cause("Cause", 
                    pvalue->value.u._e2ap_RICsubscriptionAuditFailure_IEs_id_Cause, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionAuditFailure_IEs_id_CriticalityDiagnostics:
            if(asn1PrtToStr_e2ap_CriticalityDiagnostics("CriticalityDiagnostics", 
                    pvalue->value.u._e2ap_RICsubscriptionAuditFailure_IEs_id_CriticalityDiagnostics, buffer, bufSize)<0)
                return -1;
            break;    
        default:
        if(0!=pvalue -> value.u.extElem1){
            rtPrintToStringIndent(buffer, bufSize);
            rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

        }
        }
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

    return 0;

 }

 void asn1Free_e2ap_RICsubscriptionAuditFailure_protocolIEs_element(OSCTXT* pctxt, e2ap_RICsubscriptionAuditFailure_protocolIEs_element* pvalue){
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionAuditFailure_IEs_id_RICrequestID:
            if(pvalue->value.u._e2ap_RICsubscriptionAuditFailure_IEs_id_RICrequestID!=NULL){
            asn1Free_e2ap_RICrequestID(pctxt, pvalue->value.u._e2ap_RICsubscriptionAuditFailure_IEs_id_RICrequestID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionAuditFailure_IEs_id_RICrequestID);
            pvalue->value.u._e2ap_RICsubscriptionAuditFailure_IEs_id_RICrequestID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionAuditFailure_IEs_id_Cause:
            if(pvalue->value.u._e2ap_RICsubscriptionAuditFailure_IEs_id_Cause!=NULL){
            asn1Free_e2ap_Cause(pctxt, pvalue->value.u._e2ap_RICsubscriptionAuditFailure_IEs_id_Cause);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionAuditFailure_IEs_id_Cause);
            pvalue->value.u._e2ap_RICsubscriptionAuditFailure_IEs_id_Cause = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionAuditFailure_IEs_id_CriticalityDiagnostics:
            if(pvalue->value.u._e2ap_RICsubscriptionAuditFailure_IEs_id_CriticalityDiagnostics!=NULL){
            asn1Free_e2ap_CriticalityDiagnostics(pctxt, pvalue->value.u._e2ap_RICsubscriptionAuditFailure_IEs_id_CriticalityDiagnostics);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionAuditFailure_IEs_id_CriticalityDiagnostics);
            pvalue->value.u._e2ap_RICsubscriptionAuditFailure_IEs_id_CriticalityDiagnostics = NULL;
            }
            break;
        default:
            break;


    }
 }

 

/*****************************************/
/*           RICsubscriptionAuditFailure                */
/*****************************************/
//2_container.c
/* 1. xxx_ProtocolIE -> mẫu cũ ở ie_big_msg */
EXTERN int asn1PE_e2ap_RICsubscriptionAuditFailure_protocolIEs (OSCTXT* pctxt, e2ap_RICsubscriptionAuditFailure_protocolIEs* pvalue)
{
    int stat =0;
    OSRTDListNode* pnode;
    OSUINT32 xx1;

    /*encode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pe_Length(pctxt, pvalue->count);
    if(stat<0) return LOG_RTERR(pctxt, stat);

    /*encode each element*/
    xx1 =0;
    for(pnode = pvalue->head; pnode != 0 && xx1<pvalue->count; pnode = pnode->next){
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE", xx1);
        stat = asn1PE_e2ap_RICsubscriptionAuditFailure_protocolIEs_element (pctxt, ((e2ap_RICsubscriptionAuditFailure_protocolIEs_element*)pnode->data));
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        xx1++;
        RTXCTXTPOPARRAYELEMNAME(pctxt);
    }

    return (stat);
}

EXTERN int  asn1PD_e2ap_RICsubscriptionAuditFailure_protocolIEs(OSCTXT* pctxt, e2ap_RICsubscriptionAuditFailure_protocolIEs* pvalue)
{
     int stat =0;
     OSRTDListNode* pnode;
     OSSIZE count =0;
     OSSIZE xx1=0;


     /*decode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pd_Length64(pctxt, &count); //tai sao lai 64
    if(stat!=0) return LOG_RTERR(pctxt, stat);

    /*decode each element*/
    rtxDListInit(pvalue);

    for(xx1=0; xx1 < count; xx1++){
        e2ap_RICsubscriptionAuditFailure_protocolIEs_element* pdata;
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE",xx1);

        if(pnode == NULL) return LOG_RTERR(pctxt, RTERR_NOMEM);

        asn1Init_e2ap_RICsubscriptionAuditFailure_protocolIEs_element(pdata);
        rtxDListAppendNode(pvalue, pnode);
        stat = asn1PD_e2ap_RICsubscriptionAuditFailure_protocolIEs_element (pctxt, pdata);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        RTXCTXTPOPARRAYELEMNAME(pctxt);

    }
    return (stat);
}


int asn1Init_e2ap_RICsubscriptionAuditFailure_protocolIEs(e2ap_RICsubscriptionAuditFailure_protocolIEs* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    rtxDListFastInit (pvalue);
    return 0;
}
#if 1 //ao that day
void asn1Free_e2ap_RICsubscriptionAuditFailure_protocolIEs(OSCTXT* pctxt, e2ap_RICsubscriptionAuditFailure_protocolIEs* pvalue)
{
    if(0==pvalue) return;   
    e2ap_RICsubscriptionAuditFailure_protocolIEs_element* pdata;
    OSRTDListNode* pnode=pvalue->head;
    while(0!=pnode){
        pdata = (e2ap_RICsubscriptionAuditFailure_protocolIEs_element*)pnode->data;
       // asn1Free_e2ap_RICsubscriptionAuditFailure_protocolIEs_element(pctxt, pdata);
        pnode = pnode->next;
    }
    rtxDListFreeAll(pctxt, pvalue);
}
#endif


EXTERN int asn1PrtToStr_e2ap_RICsubscriptionAuditFailure_protocolIEs(const char* name, e2ap_RICsubscriptionAuditFailure_protocolIEs* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_RICsubscriptionAuditFailure_protocolIEs_element* pdata0;
    OSRTDListNode* pnode0;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode0 = pvalue->head;  xx1 < pvalue->count && pnode0 != 0; pnode0 = pnode0->next, xx1++){
        pdata0 = (e2ap_RICsubscriptionAuditFailure_protocolIEs_element*)pnode0->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 0
        if(asn1PrtToStr_e2ap_RICsubscriptionAuditFailure_protocolIEs_element(nameBuf, pdata0, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}


/*2 . RICsubscriptionAuditFailure -> mẫu cũ ở seq_normal*/

int asn1PE_e2ap_RICsubscriptionAuditFailure (OSCTXT* pctxt, e2ap_RICsubscriptionAuditFailure* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RICsubscriptionAuditFailure");
   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field protocolIEs - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
   stat = asn1PE_e2ap_RICsubscriptionAuditFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
   if(stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RICsubscriptionAuditFailure (OSCTXT* pctxt, e2ap_RICsubscriptionAuditFailure* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME(pctxt, "RICsubscriptionAuditFailure");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field protocolIEs */
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
      stat = asn1PD_e2ap_RICsubscriptionAuditFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RICsubscriptionAuditFailure (e2ap_RICsubscriptionAuditFailure* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RICsubscriptionAuditFailure_protocolIEs(&pvalue->protocolIEs);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RICsubscriptionAuditFailure (OSCTXT* pctxt, e2ap_RICsubscriptionAuditFailure* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_RICsubscriptionAuditFailure_protocolIEs(pctxt, &pvalue->protocolIEs);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RICsubscriptionAuditFailure (const char* name, e2ap_RICsubscriptionAuditFailure* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }

   if(asn1PrtToStr_e2ap_RICsubscriptionAuditFailure_protocolIEs("protocolIEs", &pvalue->protocolIEs, buffer, bufSize) <0){
      return -1;
   }

   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/******************************************************/
/*                                                    */
/*    ListedRecordsOnly                          */
/*                                                    */
/******************************************************/
//enumerated


const OSEnumItem e2ap_ListedRecordsOnly_ENUMTAB[] = {
    { OSUTF8("true"), 0, 4, 0 }
};


const OSUTF8CHAR* e2ap_ListedRecordsOnly_ToString (OSUINT32 value){
   OSINT32 idx = value;
   if(idx >=0 && idx < e2ap_ListedRecordsOnly_ENUMTABSIZE){
      return e2ap_ListedRecordsOnly_ENUMTAB[e2ap_ListedRecordsOnly_ENUMTAB[idx].transidx].name;
   }else{
      return OSUTF8("_UNKNOWN_");
   }
}


int e2ap_ListedRecordsOnly_ToEnum (OSCTXT* pctxt, const OSUTF8CHAR* value,e2ap_ListedRecordsOnly* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes(value);
   return e2ap_ListedRecordsOnly_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int e2ap_ListedRecordsOnly_ToEnum2 (OSCTXT* pctxt, const OSUTF8CHAR* value, OSSIZE valueLen,e2ap_ListedRecordsOnly* pvalue)
{
   OSINT32 idx = rtxLookupEnum(value, valueLen,
      e2ap_ListedRecordsOnly_ENUMTAB, e2ap_ListedRecordsOnly_ENUMTABSIZE);
   if (idx >= 0) {
      *pvalue = (e2ap_ListedRecordsOnly)e2ap_ListedRecordsOnly_ENUMTAB[idx].value;
      return 0;
   } else {
      rtxErrAddIntParm (pctxt, (const char*)value);//dungnm23 check xem là Str hay Int
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_e2ap_ListedRecordsOnly (OSCTXT* pctxt, e2ap_ListedRecordsOnly value)
{
   int stat = 0;
   RTXCTXTPUSHTYPENAME (pctxt, "ListedRecordsOnly");
   if (value >= 1) {
      rtxErrAddIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(0));
   if(stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}

EXTERN int asn1PD_e2ap_ListedRecordsOnly (OSCTXT* pctxt, e2ap_ListedRecordsOnly* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ListedRecordsOnly");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(0));
   if(stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return stat;
}

EXTERN int asn1PrtToStr_e2ap_ListedRecordsOnly (const char* name, e2ap_ListedRecordsOnly* pvalue, char* buffer, OSSIZE bufSize)
{
   int stat;

   if(rtPrintToStringIndent(buffer, bufSize) < 0) return -1;
   if(rtPrintToString(name, buffer, bufSize) < 0) return -1;

   switch(*pvalue) {
      case 0:
         stat = rtPrintToString(" = true \n", buffer, bufSize);
         break;
      default:
         stat = rtPrintToString(" = ???\n", buffer, bufSize);
   }

   if (stat < 0) return -1;
   return 0;

}

/*Init*/
EXTERN int asn1Init_e2ap_ListedRecordsOnly (e2ap_ListedRecordsOnly* pvalue){
      //if (pvalue == 0) return RTERR_NULLPTR;
      //*pvalue = 0;
      return 0;
}
/*****************************************/
/*           RICsubscriptionAuditFlag                */
/*****************************************/
//sequence normal
// Các nội dung cần thiết cho template seq_normal.c.j2

// Các phần còn lại của template seq_normal.c.j2
//contain extensition bit -> theo mau cua GlobalgNB-ID
int asn1PE_e2ap_RICsubscriptionAuditFlag (OSCTXT* pctxt, e2ap_RICsubscriptionAuditFlag* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RICsubscriptionAuditFlag");

   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);

   /*optional bit for field listedRecordsOnly*/
   stat = rtxEncBit (pctxt, pvalue->m_listedRecordsOnlyPresent);
   if (stat != 0) return LOG_RTERR(pctxt, stat);

   /*encode root elements*/   
   /* encode field listedRecordsOnly - id = -1*/  
   if (pvalue->m_listedRecordsOnlyPresent) {//OPTIONAL FIELD
   RTXCTXTPUSHELEMNAME(pctxt, "listedRecordsOnly");
   stat = asn1PE_e2ap_ListedRecordsOnly (pctxt, pvalue->listedRecordsOnly);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   }


   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RICsubscriptionAuditFlag (OSCTXT* pctxt, e2ap_RICsubscriptionAuditFlag* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME(pctxt, "RICsubscriptionAuditFlag");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field listedRecordsOnly */
   RTXCTXTPUSHELEMNAME(pctxt, "listedRecordsOnly");
   if (optbits[0]) {
      pvalue->m_listedRecordsOnlyPresent = TRUE;
      stat = asn1PD_e2ap_ListedRecordsOnly (pctxt, &pvalue->listedRecordsOnly);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   } else {
      pvalue->m_listedRecordsOnlyPresent = FALSE;
   }
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RICsubscriptionAuditFlag (e2ap_RICsubscriptionAuditFlag* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_ListedRecordsOnly (&pvalue->listedRecordsOnly);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RICsubscriptionAuditFlag (OSCTXT* pctxt, e2ap_RICsubscriptionAuditFlag* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_ListedRecordsOnly (pctxt, &pvalue->listedRecordsOnly);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RICsubscriptionAuditFlag (const char* name, e2ap_RICsubscriptionAuditFlag* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }
   if(asn1PrtToStr_e2ap_ListedRecordsOnly ("listedRecordsOnly", &pvalue->listedRecordsOnly, buffer, bufSize) < 0)
   {
      return -1;
   }



   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}
/*****************************************/
/*           RICsubscriptionAudit-Item                */
/*****************************************/
//sequence normal
// Các nội dung cần thiết cho template seq_normal.c.j2

// Các phần còn lại của template seq_normal.c.j2
//contain extensition bit -> theo mau cua GlobalgNB-ID
int asn1PE_e2ap_RICsubscriptionAudit_Item (OSCTXT* pctxt, e2ap_RICsubscriptionAudit_Item* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RICsubscriptionAudit-Item");

   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field ricRequestID - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "ricRequestID");
   stat = asn1PE_e2ap_RICrequestID (pctxt, pvalue->ricRequestID);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /* encode field ranFunctionID - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "ranFunctionID");
   stat = asn1PE_e2ap_RANfunctionID (pctxt, pvalue->ranFunctionID);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);



   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RICsubscriptionAudit_Item (OSCTXT* pctxt, e2ap_RICsubscriptionAudit_Item* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME(pctxt, "RICsubscriptionAudit-Item");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field ricRequestID */
   RTXCTXTPUSHELEMNAME(pctxt, "ricRequestID");
      stat = asn1PD_e2ap_RICrequestID (pctxt, &pvalue->ricRequestID);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field ranFunctionID */
   RTXCTXTPUSHELEMNAME(pctxt, "ranFunctionID");
      stat = asn1PD_e2ap_RANfunctionID (pctxt, &pvalue->ranFunctionID);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RICsubscriptionAudit_Item (e2ap_RICsubscriptionAudit_Item* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RICrequestID (&pvalue->ricRequestID);
   asn1Init_e2ap_RANfunctionID (&pvalue->ranFunctionID);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RICsubscriptionAudit_Item (OSCTXT* pctxt, e2ap_RICsubscriptionAudit_Item* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_RICrequestID (pctxt, &pvalue->ricRequestID);
   asn1Free_e2ap_RANfunctionID (pctxt, &pvalue->ranFunctionID);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RICsubscriptionAudit_Item (const char* name, e2ap_RICsubscriptionAudit_Item* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }
   if(asn1PrtToStr_e2ap_RICrequestID ("ricRequestID", &pvalue->ricRequestID, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_RANfunctionID ("ranFunctionID", &pvalue->ranFunctionID, buffer, bufSize) < 0)
   {
      return -1;
   }



   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           RICsubscriptionAudit_ItemIEs                */
/*****************************************/
/* ie.c.j2 */
/*ie thường*/
int asn1PE_e2ap_RICsubscriptionAudit_ItemIEs (OSCTXT* pctxt, e2ap_RICsubscriptionAudit_ItemIEs* pvalue)
{
   int stat = 0;
   //RTXCTXTPUSHTYPENAME (pctxt, "RICsubscriptionAudit-ItemIEs");

   /* encode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");
   stat = asn1PE_e2ap_ProtocolIE_ID (pctxt, pvalue->id);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");
   stat = asn1PE_e2ap_Criticality (pctxt, pvalue->criticality);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   {
      OSCTXT ictxt;
      OSOCTET* pDynamicEncodeBuffer;
      ASN1OpenType openType;
      OSBOOL  encoded = TRUE;

      openType.numocts = 0;
      openType.data = 0;

      rtxCopyContext (&ictxt, pctxt);
      pctxt->pStream = 0;

      stat = rtxInitContextBuffer (pctxt, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_RICsubscriptionAudit_ItemIEs_id_RICsubscriptionAudit_Item:
         
        // RTXCTXTPUSHELEMNAME (pctxt, "RICsubscriptionAudit_ItemIEs_id_RICsubscriptionAudit_Item");
         RTXCTXTPUSHELEMNAME (pctxt, "RICsubscriptionAudit-Item");
         stat = asn1PE_e2ap_RICsubscriptionAudit_Item (pctxt, pvalue->value.u._e2apRICsubscriptionAudit_ItemIEs_id_RICsubscriptionAudit_Item);
         RTXCTXTPOPELEMNAME (pctxt);
      
         break;

      case T_E2AP_PDU_Contents_e2ap_RICsubscriptionAudit_ItemIEs_UNDEF_:
      {
          if(0!=pvalue->value.u.extElem1){
              openType.numocts = pvalue->value.u.extElem1->numocts;
              openType.data = pvalue->value.u.extElem1->data;
          } else {
              /* No extension element to encode */
          }
          encoded = FALSE;
          break;
      }
      default:
         encoded = FALSE;
         stat = RTERR_INVOPT;
      }

      if (encoded) {
         openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
         openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
      }
      rtxCopyContext (pctxt, &ictxt);
      if(stat ==0) stat = pe_OpenType(pctxt, openType.numocts, openType.data);
      /*free dynamic encode buffer*/
      if(encoded){
          rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
      }
   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);
   //RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

int asn1PD_e2ap_RICsubscriptionAudit_ItemIEs (OSCTXT* pctxt, e2ap_RICsubscriptionAudit_ItemIEs* pvalue)
{
   int stat =0;
   /*deode root element id*/
   RTXCTXTPUSHELEMNAME(pctxt, "id");
   stat = asn1PD_e2ap_ProtocolIE_ID (pctxt, &pvalue->id);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*decode root element criticality*/
   RTXCTXTPUSHELEMNAME(pctxt, "criticality");
   stat = asn1PD_e2ap_Criticality (pctxt, &pvalue->criticality);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   /*decode root element value*/
   RTXCTXTPUSHELEMNAME(pctxt, "value");
   {
      OSUINT32 openTypeLen;
      size_t bitStartOffset, bitLength;
      stat = pd_UnconsLength(pctxt, &openTypeLen);
      if(stat <0) return LOG_RTERR(pctxt, stat);
      else if(stat == RT_OK_FRAG){
         rtxErrAddStrParm(pctxt, "open type with fragmented length use - perindef");
         return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
      }
      bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
      bitLength = openTypeLen * 8;
      switch (pvalue->id){
         case T_E2AP_PDU_Contents_e2ap_RICsubscriptionAudit_ItemIEs_id_RICsubscriptionAudit_Item:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionAudit_ItemIEs_id_RICsubscriptionAudit_Item;
            RTXCTXTPUSHELEMNAME(pctxt, "RICsubscriptionAudit-Item");
            //pvalue->value.u._e2ap_RICsubscriptionAudit_ItemIEs_id_id_RICsubscriptionAudit_Item 
             pvalue->value.u._e2apRICsubscriptionAudit_ItemIEs_id_RICsubscriptionAudit_Item 
                    = rtxMemAllocType(pctxt, e2ap_RICsubscriptionAudit_Item);
            //asn1Init_e2ap_RICsubscriptionAudit_Item(pvalue->value.u._e2ap_RICsubscriptionAudit_ItemIEs_id_id_RICsubscriptionAudit_Item);
            asn1Init_e2ap_RICsubscriptionAudit_Item(pvalue->value.u._e2apRICsubscriptionAudit_ItemIEs_id_RICsubscriptionAudit_Item);
            stat = asn1PD_e2ap_RICsubscriptionAudit_Item (pctxt,
                    (e2ap_RICsubscriptionAudit_Item*)pvalue->value.
                    u._e2apRICsubscriptionAudit_ItemIEs_id_RICsubscriptionAudit_Item);
            if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionAudit_ItemIEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*)rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
      }
      {
      size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
      size_t bitsConsumed = bitEndOffset - bitStartOffset;
      if(bitsConsumed < bitLength){
         stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
      } else {
         stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
      }
      }
   }
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   return stat;
}

void asn1Init_e2ap_RICsubscriptionAudit_ItemIEs (e2ap_RICsubscriptionAudit_ItemIEs* pvalue)
{
   if (!pvalue) return;
   OSCRTLMEMSET (pvalue, 0, sizeof(e2ap_RICsubscriptionAudit_ItemIEs));
}

#if 0
void asn1Free_e2ap_RICsubscriptionAudit_ItemIEs (OSCTXT* pctxt, e2ap_RICsubscriptionAudit_ItemIEs* pvalue)
{
   if (!pvalue) return;
   if (pvalue->extElem1) {
      rtxMemFreeArray (pctxt, pvalue->extElem1);
      pvalue->extElem1 = 0;
      pvalue->extElem1_n = 0;
   }
}
#endif
void asn1Free_e2ap_RICsubscriptionAudit_ItemIEs (OSCTXT* pctxt, e2ap_RICsubscriptionAudit_ItemIEs* pvalue)
{
   if(0==pvalue) return;
   switch(pvalue->value.t){
      case T_E2AP_PDU_Contents_e2ap_RICsubscriptionAudit_ItemIEs_id_RICsubscriptionAudit_Item:
         asn1Free_e2ap_RICsubscriptionAudit_Item (pctxt, pvalue->value.u._e2apRICsubscriptionAudit_ItemIEs_id_RICsubscriptionAudit_Item);
         rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2apRICsubscriptionAudit_ItemIEs_id_RICsubscriptionAudit_Item);
         pvalue->value.u._e2apRICsubscriptionAudit_ItemIEs_id_RICsubscriptionAudit_Item = 0;
         break;
      case T_E2AP_PDU_Contents_e2ap_RICsubscriptionAudit_ItemIEs_UNDEF_:
         if(0!=pvalue->value.u.extElem1){
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1->data);
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
             pvalue->value.u.extElem1 =0;
         }
         break;
         default:;
   }
}

int  asn1PrtToStr_e2ap_RICsubscriptionAudit_ItemIEs (const char * name, e2ap_RICsubscriptionAudit_ItemIEs* pvalue, char * buffer, OSSIZE bufSize){
   if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
       return -1;

      if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
         return -1;

      if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
         return -1;
      if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
         return -1;
      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_RICsubscriptionAudit_ItemIEs_id_RICsubscriptionAudit_Item:
         if(asn1PrtToStr_e2ap_RICsubscriptionAudit_Item("RICsubscriptionAudit-Item",
                pvalue->value.u._e2apRICsubscriptionAudit_ItemIEs_id_RICsubscriptionAudit_Item, buffer, bufSize)<0)// dungnm23 check lai nhe xem la
            return -1;
         break;
      default:
         if(0!=pvalue -> value.u.extElem1){
             rtPrintToStringIndent(buffer, bufSize);
             rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

         }
      }
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

      return 0;

}
 

/*****************************************/
/*           RICsubscriptionAuditList                */
/*****************************************/
//seq_of_single_container


int asn1PE_e2ap_RICsubscriptionAuditList (OSCTXT* pctxt, e2ap_RICsubscriptionAuditList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_RICsubscriptionAudit_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "RICsubscriptionAuditList");

   /* encode length determinant */
   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(2147483648), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;
   for (xx1 = 0; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next, xx1++) {
      pdata = (e2ap_RICsubscriptionAudit_ItemIEs*) pnode->data;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_e2ap_RICsubscriptionAudit_ItemIEs (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      //xx1++;
      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}

int asn1PD_e2ap_RICsubscriptionAuditList (OSCTXT* pctxt, e2ap_RICsubscriptionAuditList* ppvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_RICsubscriptionAudit_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "RICsubscriptionAuditList");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(2147483648), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (ppvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      pdata = rtxMemAllocType (pctxt, e2ap_RICsubscriptionAudit_ItemIEs);
      if (!pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);
      asn1Init_e2ap_RICsubscriptionAudit_ItemIEs (pdata);
      stat = asn1PD_e2ap_RICsubscriptionAudit_ItemIEs (pctxt, pdata);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         return LOG_RTERR (pctxt, stat);
      }

      rtxDListAppendNode (ppvalue, pdata);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

void asn1Init_e2ap_RICsubscriptionAuditList (e2ap_RICsubscriptionAuditList* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
}

void asn1Free_e2ap_RICsubscriptionAuditList (OSCTXT* pctxt, e2ap_RICsubscriptionAuditList* pvalue)
{
   if(pvalue==0) return;
   OSRTDListNode* pnode = pvalue->head;
   while (pnode) {
      e2ap_RICsubscriptionAudit_ItemIEs* pdata = (e2ap_RICsubscriptionAudit_ItemIEs*) pnode->data;
      if (pdata) {
         asn1Free_e2ap_RICsubscriptionAudit_ItemIEs (pctxt, pdata);
         rtxMemFreePtr (pctxt, pdata);
      }
      pnode = pnode->next;
   }
      rtxDListFreeAll(pctxt, pvalue);
}

#if 0
void asn1Free_e2ap_RICsubscriptionAuditList (OSCTXT* pctxt, e2ap_RICsubscriptionAuditList* pvalue){
   if(0==pvalue ) return;
   {
      e2ap_RICsubscriptionAudit_ItemIEs * pdata;
      OSRTDListNode *pnode = pvalue->head;
      while(0!=pnode){
         pdata = (e2ap_RICsubscriptionAudit_ItemIEs*)pnode->data;
         asn1Free_e2ap_RICsubscriptionAudit_ItemIEs(pctxt, pdata);
         pnode = pnode->next;
      }
      rtxDListFreeAll(pctxt, pvalue);
   }
}
#endif


int asn1PrtToStr_e2ap_RICsubscriptionAuditList(const char* name, e2ap_RICsubscriptionAuditList* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_RICsubscriptionAudit_ItemIEs* pdata;
    OSRTDListNode* pnode;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode = pvalue->head;  xx1 < pvalue->count && pnode != 0; pnode = pnode->next, xx1++){
        pdata = (e2ap_RICsubscriptionAudit_ItemIEs*)pnode->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 1
        if(asn1PrtToStr_e2ap_RICsubscriptionAudit_ItemIEs(nameBuf, pdata, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}/*****************************************/
/*           RICsubscriptionAuditRequest_IEs                */
/*****************************************/
/* ie.c.j2 */
 /* d là con của msg */
EXTERN int asn1PE_e2ap_RICsubscriptionAuditRequest_protocolIEs_element (OSCTXT* pctxt, e2ap_RICsubscriptionAuditRequest_protocolIEs_element* pvalue)
{
    int stat =0;

    /*encode id*/

    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PE_e2ap_ProtocolIE_ID(pctxt, pvalue->id);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PE_e2ap_Criticality(pctxt, pvalue->criticality);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
    {
        OSCTXT lctxt;
        OSOCTET *pDynamicEncodeBuffer;
        ASN1OpenType openType;
        OSBOOL encoded = TRUE;

        openType.numocts = 0;
        openType.data =0;

        rtxCopyContext(&lctxt, pctxt);
        pctxt->pStream =0;

        stat = rtxInitContextBuffer(pctxt, 0, 0);
        if(stat!=0) return LOG_RTERR(pctxt, stat);

        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionAuditRequest_IEs_id_RICrequestID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICrequestID");
                    stat = asn1PE_e2ap_RICrequestID (pctxt, pvalue->value.u._e2ap_RICsubscriptionAuditRequest_IEs_id_RICrequestID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionAuditRequest_IEs_id_RICsubscriptionAuditFlag:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICsubscriptionAuditFlag");
                    stat = asn1PE_e2ap_RICsubscriptionAuditFlag (pctxt, pvalue->value.u._e2ap_RICsubscriptionAuditRequest_IEs_id_RICsubscriptionAuditFlag);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionAuditRequest_IEs_id_RICsubscriptionAuditList:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICsubscriptionAuditList");
                    stat = asn1PE_e2ap_RICsubscriptionAuditList (pctxt, pvalue->value.u._e2ap_RICsubscriptionAuditRequest_IEs_id_RICsubscriptionAuditList);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionAuditRequest_IEs_UNDEF_:
            {
                if(0!=pvalue->value.u.extElem1){
                    openType.numocts = pvalue->value.u.extElem1->numocts;
                    openType.data = pvalue->value.u.extElem1->data;
                } else {
                    /* No extension element to encode */
                }
                encoded = FALSE;
                break;
            }

            default:
                encoded = FALSE;
                stat = RTERR_INVOPT;
                break;
        } 

        if(encoded){
            openType.numocts = (OSUINT32)pe_GetMsgLen(pctxt);
            openType.data = pDynamicEncodeBuffer = pctxt -> buffer.data;
        }
        rtxCopyContext(pctxt, &lctxt);

        if(stat == 0) {
            stat = pe_OpenType (pctxt, openType.numocts, openType.data);
        }
    #if 1
        if(encoded){//dungnm23 check lai nhe
            rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
        }
    #endif

    }

    if(stat!=0) return LOG_RTERR(pctxt, stat);  
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}

EXTERN int  asn1PD_e2ap_RICsubscriptionAuditRequest_protocolIEs_element (OSCTXT* pctxt, e2ap_RICsubscriptionAuditRequest_protocolIEs_element* pvalue){
    int stat =0;

    /*decode id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PD_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PD_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");

    {
        OSUINT32 openTypeLen;
        size_t bitStartOffset, bitLength;

        stat = pd_UnconsLength(pctxt, &openTypeLen);
        if(stat<0) return LOG_RTERR(pctxt, stat);
        else if(stat == RT_OK_FRAG){
            rtxErrAddStrParm(pctxt, "open type with fragment length");
            return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
        }
        bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
        bitLength = openTypeLen * 8;

        switch(pvalue->id){//dungnm23 check case lai nhe
        
            case ASN1V_e2ap_id_RICrequestID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionAuditRequest_IEs_id_RICrequestID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICrequestID");
                pvalue->value.u._e2ap_RICsubscriptionAuditRequest_IEs_id_RICrequestID 
                    = rtxMemAllocType(pctxt, e2ap_RICrequestID);

                asn1Init_e2ap_RICrequestID(pvalue->value.u._e2ap_RICsubscriptionAuditRequest_IEs_id_RICrequestID);

                stat = asn1PD_e2ap_RICrequestID (pctxt,
                        (e2ap_RICrequestID*)pvalue->value.
                        u._e2ap_RICsubscriptionAuditRequest_IEs_id_RICrequestID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RICsubscriptionAuditFlag:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionAuditRequest_IEs_id_RICsubscriptionAuditFlag;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICsubscriptionAuditFlag");
                pvalue->value.u._e2ap_RICsubscriptionAuditRequest_IEs_id_RICsubscriptionAuditFlag 
                    = rtxMemAllocType(pctxt, e2ap_RICsubscriptionAuditFlag);

                asn1Init_e2ap_RICsubscriptionAuditFlag(pvalue->value.u._e2ap_RICsubscriptionAuditRequest_IEs_id_RICsubscriptionAuditFlag);

                stat = asn1PD_e2ap_RICsubscriptionAuditFlag (pctxt,
                        (e2ap_RICsubscriptionAuditFlag*)pvalue->value.
                        u._e2ap_RICsubscriptionAuditRequest_IEs_id_RICsubscriptionAuditFlag);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RICsubscriptionAuditList:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionAuditRequest_IEs_id_RICsubscriptionAuditList;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICsubscriptionAuditList");
                pvalue->value.u._e2ap_RICsubscriptionAuditRequest_IEs_id_RICsubscriptionAuditList 
                    = rtxMemAllocType(pctxt, e2ap_RICsubscriptionAuditList);

                asn1Init_e2ap_RICsubscriptionAuditList(pvalue->value.u._e2ap_RICsubscriptionAuditRequest_IEs_id_RICsubscriptionAuditList);

                stat = asn1PD_e2ap_RICsubscriptionAuditList (pctxt,
                        (e2ap_RICsubscriptionAuditList*)pvalue->value.
                        u._e2ap_RICsubscriptionAuditRequest_IEs_id_RICsubscriptionAuditList);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionAuditRequest_IEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*) rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
    }
    {
    size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
    size_t bitsConsumed = bitEndOffset-bitStartOffset;
    if(bitsConsumed<bitLength){
        stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
    }
    else stat =(bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
    }}
    if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}


int asn1Init_e2ap_RICsubscriptionAuditRequest_protocolIEs_element(e2ap_RICsubscriptionAuditRequest_protocolIEs_element* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    OSCRTLMEMSET (&pvalue->value, 0, sizeof(pvalue->value));
    return 0;
}


//-----> chuaw có template rtxFreeASN1OpenType

#if 0
void asn1Free_e2ap_RICsubscriptionAuditRequest_protocolIEs_element(OSCTXT* pctxt, e2ap_RICsubscriptionAuditRequest_protocolIEs_element* pvalue)
{
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionAuditRequest_IEs_id_id_RICrequestID:
            // rtxFreeE2ap_RICrequestID(pvalue->value.u._e2ap_RICsubscriptionAuditRequest_IEs_id_id_RICrequestID);

            if(pvalue->value.i._e2ap_RICsubscriptionAuditRequest_id_RICrequestID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICrequestID(pctxt, pvalue->value.u._e2ap_RICsubscriptionAuditRequest_IEs_id_id_RICrequestID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionAuditRequest_IEs_id_id_RICrequestID);
           // pvalue->value.u._e2ap_RICsubscriptionAuditRequest_IEs_id_id_RICrequestID = NULL;
           pvalue->value.u._e2ap_RICsubscriptionAuditRequest_IEs_id_RICrequestID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionAuditRequest_IEs_id_id_RICsubscriptionAuditFlag:
            // rtxFreeE2ap_RICsubscriptionAuditFlag(pvalue->value.u._e2ap_RICsubscriptionAuditRequest_IEs_id_id_RICsubscriptionAuditFlag);

            if(pvalue->value.i._e2ap_RICsubscriptionAuditRequest_id_RICsubscriptionAuditFlag!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICsubscriptionAuditFlag(pctxt, pvalue->value.u._e2ap_RICsubscriptionAuditRequest_IEs_id_id_RICsubscriptionAuditFlag);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionAuditRequest_IEs_id_id_RICsubscriptionAuditFlag);
           // pvalue->value.u._e2ap_RICsubscriptionAuditRequest_IEs_id_id_RICsubscriptionAuditFlag = NULL;
           pvalue->value.u._e2ap_RICsubscriptionAuditRequest_IEs_id_RICsubscriptionAuditFlag = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionAuditRequest_IEs_id_id_RICsubscriptionAuditList:
            // rtxFreeE2ap_RICsubscriptionAuditList(pvalue->value.u._e2ap_RICsubscriptionAuditRequest_IEs_id_id_RICsubscriptionAuditList);

            if(pvalue->value.i._e2ap_RICsubscriptionAuditRequest_id_RICsubscriptionAuditList!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICsubscriptionAuditList(pctxt, pvalue->value.u._e2ap_RICsubscriptionAuditRequest_IEs_id_id_RICsubscriptionAuditList);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionAuditRequest_IEs_id_id_RICsubscriptionAuditList);
           // pvalue->value.u._e2ap_RICsubscriptionAuditRequest_IEs_id_id_RICsubscriptionAuditList = NULL;
           pvalue->value.u._e2ap_RICsubscriptionAuditRequest_IEs_id_RICsubscriptionAuditList = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionAuditRequest_IEs_UNDEF_:
            rtxFreeASN1OpenType(pvalue->value.u.extElem1);
            break;
        default:
            break;
    }
}

int asn1PrtToStr_e2ap_RICsubscriptionAuditRequest_protocolIEs_element(OSCTXT* pctxt, e2ap_RICsubscriptionAuditRequest_protocolIEs_element* pvalue)
{
    int stat =0;
    RTXCTXTPUSHELEMNAME(pctxt, "e2ap_RICsubscriptionAuditRequest_protocolIEs_element");

    /*print id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PrtToStr_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PrtToStr_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionAuditRequest_IEs_id_id_RICrequestID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICrequestID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICrequestID (pctxt, pvalue->value.u._e2ap_RICsubscriptionAuditRequest_IEs_id_id_RICrequestID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionAuditRequest_IEs_id_id_RICsubscriptionAuditFlag:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICsubscriptionAuditFlag");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICsubscriptionAuditFlag (pctxt, pvalue->value.u._e2ap_RICsubscriptionAuditRequest_IEs_id_id_RICsubscriptionAuditFlag);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionAuditRequest_IEs_id_id_RICsubscriptionAuditList:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICsubscriptionAuditList");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICsubscriptionAuditList (pctxt, pvalue->value.u._e2ap_RICsubscriptionAuditRequest_IEs_id_id_RICsubscriptionAuditList);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionAuditRequest_IEs_UNDEF_:
            {
                rtxPLogMsg(pctxt, "Extension element present - raw data not printed.\n");
                break;
            }

            default:
                stat = RTERR_INVOPT;
                return LOG_RTERR(pctxt, stat);
        }
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);
}
#endif


int asn1PrtToStr_e2ap_RICsubscriptionAuditRequest_protocolIEs_element (const char * name,
 e2ap_RICsubscriptionAuditRequest_protocolIEs_element* pvalue, 
 char * buffer, OSSIZE bufSize){
    if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
        return -1;
    if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
        return -1;

    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionAuditRequest_IEs_id_RICrequestID:
            if(asn1PrtToStr_e2ap_RICrequestID("RICrequestID", 
                    pvalue->value.u._e2ap_RICsubscriptionAuditRequest_IEs_id_RICrequestID, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionAuditRequest_IEs_id_RICsubscriptionAuditFlag:
            if(asn1PrtToStr_e2ap_RICsubscriptionAuditFlag("RICsubscriptionAuditFlag", 
                    pvalue->value.u._e2ap_RICsubscriptionAuditRequest_IEs_id_RICsubscriptionAuditFlag, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionAuditRequest_IEs_id_RICsubscriptionAuditList:
            if(asn1PrtToStr_e2ap_RICsubscriptionAuditList("RICsubscriptionAuditList", 
                    pvalue->value.u._e2ap_RICsubscriptionAuditRequest_IEs_id_RICsubscriptionAuditList, buffer, bufSize)<0)
                return -1;
            break;    
        default:
        if(0!=pvalue -> value.u.extElem1){
            rtPrintToStringIndent(buffer, bufSize);
            rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

        }
        }
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

    return 0;

 }

 void asn1Free_e2ap_RICsubscriptionAuditRequest_protocolIEs_element(OSCTXT* pctxt, e2ap_RICsubscriptionAuditRequest_protocolIEs_element* pvalue){
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionAuditRequest_IEs_id_RICrequestID:
            if(pvalue->value.u._e2ap_RICsubscriptionAuditRequest_IEs_id_RICrequestID!=NULL){
            asn1Free_e2ap_RICrequestID(pctxt, pvalue->value.u._e2ap_RICsubscriptionAuditRequest_IEs_id_RICrequestID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionAuditRequest_IEs_id_RICrequestID);
            pvalue->value.u._e2ap_RICsubscriptionAuditRequest_IEs_id_RICrequestID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionAuditRequest_IEs_id_RICsubscriptionAuditFlag:
            if(pvalue->value.u._e2ap_RICsubscriptionAuditRequest_IEs_id_RICsubscriptionAuditFlag!=NULL){
            asn1Free_e2ap_RICsubscriptionAuditFlag(pctxt, pvalue->value.u._e2ap_RICsubscriptionAuditRequest_IEs_id_RICsubscriptionAuditFlag);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionAuditRequest_IEs_id_RICsubscriptionAuditFlag);
            pvalue->value.u._e2ap_RICsubscriptionAuditRequest_IEs_id_RICsubscriptionAuditFlag = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionAuditRequest_IEs_id_RICsubscriptionAuditList:
            if(pvalue->value.u._e2ap_RICsubscriptionAuditRequest_IEs_id_RICsubscriptionAuditList!=NULL){
            asn1Free_e2ap_RICsubscriptionAuditList(pctxt, pvalue->value.u._e2ap_RICsubscriptionAuditRequest_IEs_id_RICsubscriptionAuditList);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionAuditRequest_IEs_id_RICsubscriptionAuditList);
            pvalue->value.u._e2ap_RICsubscriptionAuditRequest_IEs_id_RICsubscriptionAuditList = NULL;
            }
            break;
        default:
            break;


    }
 }

 

/*****************************************/
/*           RICsubscriptionAuditRequest                */
/*****************************************/
//2_container.c
/* 1. xxx_ProtocolIE -> mẫu cũ ở ie_big_msg */
EXTERN int asn1PE_e2ap_RICsubscriptionAuditRequest_protocolIEs (OSCTXT* pctxt, e2ap_RICsubscriptionAuditRequest_protocolIEs* pvalue)
{
    int stat =0;
    OSRTDListNode* pnode;
    OSUINT32 xx1;

    /*encode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pe_Length(pctxt, pvalue->count);
    if(stat<0) return LOG_RTERR(pctxt, stat);

    /*encode each element*/
    xx1 =0;
    for(pnode = pvalue->head; pnode != 0 && xx1<pvalue->count; pnode = pnode->next){
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE", xx1);
        stat = asn1PE_e2ap_RICsubscriptionAuditRequest_protocolIEs_element (pctxt, ((e2ap_RICsubscriptionAuditRequest_protocolIEs_element*)pnode->data));
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        xx1++;
        RTXCTXTPOPARRAYELEMNAME(pctxt);
    }

    return (stat);
}

EXTERN int  asn1PD_e2ap_RICsubscriptionAuditRequest_protocolIEs(OSCTXT* pctxt, e2ap_RICsubscriptionAuditRequest_protocolIEs* pvalue)
{
     int stat =0;
     OSRTDListNode* pnode;
     OSSIZE count =0;
     OSSIZE xx1=0;


     /*decode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pd_Length64(pctxt, &count); //tai sao lai 64
    if(stat!=0) return LOG_RTERR(pctxt, stat);

    /*decode each element*/
    rtxDListInit(pvalue);

    for(xx1=0; xx1 < count; xx1++){
        e2ap_RICsubscriptionAuditRequest_protocolIEs_element* pdata;
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE",xx1);

        if(pnode == NULL) return LOG_RTERR(pctxt, RTERR_NOMEM);

        asn1Init_e2ap_RICsubscriptionAuditRequest_protocolIEs_element(pdata);
        rtxDListAppendNode(pvalue, pnode);
        stat = asn1PD_e2ap_RICsubscriptionAuditRequest_protocolIEs_element (pctxt, pdata);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        RTXCTXTPOPARRAYELEMNAME(pctxt);

    }
    return (stat);
}


int asn1Init_e2ap_RICsubscriptionAuditRequest_protocolIEs(e2ap_RICsubscriptionAuditRequest_protocolIEs* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    rtxDListFastInit (pvalue);
    return 0;
}
#if 1 //ao that day
void asn1Free_e2ap_RICsubscriptionAuditRequest_protocolIEs(OSCTXT* pctxt, e2ap_RICsubscriptionAuditRequest_protocolIEs* pvalue)
{
    if(0==pvalue) return;   
    e2ap_RICsubscriptionAuditRequest_protocolIEs_element* pdata;
    OSRTDListNode* pnode=pvalue->head;
    while(0!=pnode){
        pdata = (e2ap_RICsubscriptionAuditRequest_protocolIEs_element*)pnode->data;
       // asn1Free_e2ap_RICsubscriptionAuditRequest_protocolIEs_element(pctxt, pdata);
        pnode = pnode->next;
    }
    rtxDListFreeAll(pctxt, pvalue);
}
#endif


EXTERN int asn1PrtToStr_e2ap_RICsubscriptionAuditRequest_protocolIEs(const char* name, e2ap_RICsubscriptionAuditRequest_protocolIEs* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_RICsubscriptionAuditRequest_protocolIEs_element* pdata0;
    OSRTDListNode* pnode0;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode0 = pvalue->head;  xx1 < pvalue->count && pnode0 != 0; pnode0 = pnode0->next, xx1++){
        pdata0 = (e2ap_RICsubscriptionAuditRequest_protocolIEs_element*)pnode0->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 0
        if(asn1PrtToStr_e2ap_RICsubscriptionAuditRequest_protocolIEs_element(nameBuf, pdata0, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}


/*2 . RICsubscriptionAuditRequest -> mẫu cũ ở seq_normal*/

int asn1PE_e2ap_RICsubscriptionAuditRequest (OSCTXT* pctxt, e2ap_RICsubscriptionAuditRequest* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RICsubscriptionAuditRequest");
   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field protocolIEs - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
   stat = asn1PE_e2ap_RICsubscriptionAuditRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if(stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RICsubscriptionAuditRequest (OSCTXT* pctxt, e2ap_RICsubscriptionAuditRequest* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME(pctxt, "RICsubscriptionAuditRequest");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field protocolIEs */
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
      stat = asn1PD_e2ap_RICsubscriptionAuditRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RICsubscriptionAuditRequest (e2ap_RICsubscriptionAuditRequest* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RICsubscriptionAuditRequest_protocolIEs(&pvalue->protocolIEs);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RICsubscriptionAuditRequest (OSCTXT* pctxt, e2ap_RICsubscriptionAuditRequest* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_RICsubscriptionAuditRequest_protocolIEs(pctxt, &pvalue->protocolIEs);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RICsubscriptionAuditRequest (const char* name, e2ap_RICsubscriptionAuditRequest* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }

   if(asn1PrtToStr_e2ap_RICsubscriptionAuditRequest_protocolIEs("protocolIEs", &pvalue->protocolIEs, buffer, bufSize) <0){
      return -1;
   }

   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}
/*****************************************/
/*           RICsubscriptionAuditAction-Item                */
/*****************************************/
//sequence normal
// Các nội dung cần thiết cho template seq_normal.c.j2

// Các phần còn lại của template seq_normal.c.j2
//contain extensition bit -> theo mau cua GlobalgNB-ID
int asn1PE_e2ap_RICsubscriptionAuditAction_Item (OSCTXT* pctxt, e2ap_RICsubscriptionAuditAction_Item* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RICsubscriptionAuditAction-Item");

   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field ricRequestID - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "ricRequestID");
   stat = asn1PE_e2ap_RICrequestID (pctxt, pvalue->ricRequestID);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /* encode field ranFunctionID - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "ranFunctionID");
   stat = asn1PE_e2ap_RANfunctionID (pctxt, pvalue->ranFunctionID);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /* encode field ricAction_Admitted_List - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "ricAction-Admitted-List");
   stat = asn1PE_e2ap_RICaction_Admitted_List (pctxt, pvalue->ricAction_Admitted_List);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);



   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RICsubscriptionAuditAction_Item (OSCTXT* pctxt, e2ap_RICsubscriptionAuditAction_Item* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[3];

   RTXCTXTPUSHTYPENAME(pctxt, "RICsubscriptionAuditAction-Item");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field ricRequestID */
   RTXCTXTPUSHELEMNAME(pctxt, "ricRequestID");
      stat = asn1PD_e2ap_RICrequestID (pctxt, &pvalue->ricRequestID);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field ranFunctionID */
   RTXCTXTPUSHELEMNAME(pctxt, "ranFunctionID");
      stat = asn1PD_e2ap_RANfunctionID (pctxt, &pvalue->ranFunctionID);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field ricAction_Admitted_List */
   RTXCTXTPUSHELEMNAME(pctxt, "ricAction-Admitted-List");
      stat = asn1PD_e2ap_RICaction_Admitted_List (pctxt, &pvalue->ricAction_Admitted_List);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RICsubscriptionAuditAction_Item (e2ap_RICsubscriptionAuditAction_Item* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RICrequestID (&pvalue->ricRequestID);
   asn1Init_e2ap_RANfunctionID (&pvalue->ranFunctionID);
   asn1Init_e2ap_RICaction_Admitted_List (&pvalue->ricAction_Admitted_List);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RICsubscriptionAuditAction_Item (OSCTXT* pctxt, e2ap_RICsubscriptionAuditAction_Item* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_RICrequestID (pctxt, &pvalue->ricRequestID);
   asn1Free_e2ap_RANfunctionID (pctxt, &pvalue->ranFunctionID);
   asn1Free_e2ap_RICaction_Admitted_List (pctxt, &pvalue->ricAction_Admitted_List);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RICsubscriptionAuditAction_Item (const char* name, e2ap_RICsubscriptionAuditAction_Item* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }
   if(asn1PrtToStr_e2ap_RICrequestID ("ricRequestID", &pvalue->ricRequestID, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_RANfunctionID ("ranFunctionID", &pvalue->ranFunctionID, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_RICaction_Admitted_List ("ricAction_Admitted_List", &pvalue->ricAction_Admitted_List, buffer, bufSize) < 0)
   {
      return -1;
   }



   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           RICsubscriptionAuditAction_ItemIEs                */
/*****************************************/
/* ie.c.j2 */
/*ie thường*/
int asn1PE_e2ap_RICsubscriptionAuditAction_ItemIEs (OSCTXT* pctxt, e2ap_RICsubscriptionAuditAction_ItemIEs* pvalue)
{
   int stat = 0;
   //RTXCTXTPUSHTYPENAME (pctxt, "RICsubscriptionAuditAction-ItemIEs");

   /* encode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");
   stat = asn1PE_e2ap_ProtocolIE_ID (pctxt, pvalue->id);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");
   stat = asn1PE_e2ap_Criticality (pctxt, pvalue->criticality);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   {
      OSCTXT ictxt;
      OSOCTET* pDynamicEncodeBuffer;
      ASN1OpenType openType;
      OSBOOL  encoded = TRUE;

      openType.numocts = 0;
      openType.data = 0;

      rtxCopyContext (&ictxt, pctxt);
      pctxt->pStream = 0;

      stat = rtxInitContextBuffer (pctxt, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_RICsubscriptionAuditAction_ItemIEs_id_RICsubscriptionAuditAction_Item:
         
        // RTXCTXTPUSHELEMNAME (pctxt, "RICsubscriptionAuditAction_ItemIEs_id_RICsubscriptionAuditAction_Item");
         RTXCTXTPUSHELEMNAME (pctxt, "RICsubscriptionAuditAction-Item");
         stat = asn1PE_e2ap_RICsubscriptionAuditAction_Item (pctxt, pvalue->value.u._e2apRICsubscriptionAuditAction_ItemIEs_id_RICsubscriptionAuditAction_Item);
         RTXCTXTPOPELEMNAME (pctxt);
      
         break;

      case T_E2AP_PDU_Contents_e2ap_RICsubscriptionAuditAction_ItemIEs_UNDEF_:
      {
          if(0!=pvalue->value.u.extElem1){
              openType.numocts = pvalue->value.u.extElem1->numocts;
              openType.data = pvalue->value.u.extElem1->data;
          } else {
              /* No extension element to encode */
          }
          encoded = FALSE;
          break;
      }
      default:
         encoded = FALSE;
         stat = RTERR_INVOPT;
      }

      if (encoded) {
         openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
         openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
      }
      rtxCopyContext (pctxt, &ictxt);
      if(stat ==0) stat = pe_OpenType(pctxt, openType.numocts, openType.data);
      /*free dynamic encode buffer*/
      if(encoded){
          rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
      }
   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);
   //RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

int asn1PD_e2ap_RICsubscriptionAuditAction_ItemIEs (OSCTXT* pctxt, e2ap_RICsubscriptionAuditAction_ItemIEs* pvalue)
{
   int stat =0;
   /*deode root element id*/
   RTXCTXTPUSHELEMNAME(pctxt, "id");
   stat = asn1PD_e2ap_ProtocolIE_ID (pctxt, &pvalue->id);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*decode root element criticality*/
   RTXCTXTPUSHELEMNAME(pctxt, "criticality");
   stat = asn1PD_e2ap_Criticality (pctxt, &pvalue->criticality);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   /*decode root element value*/
   RTXCTXTPUSHELEMNAME(pctxt, "value");
   {
      OSUINT32 openTypeLen;
      size_t bitStartOffset, bitLength;
      stat = pd_UnconsLength(pctxt, &openTypeLen);
      if(stat <0) return LOG_RTERR(pctxt, stat);
      else if(stat == RT_OK_FRAG){
         rtxErrAddStrParm(pctxt, "open type with fragmented length use - perindef");
         return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
      }
      bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
      bitLength = openTypeLen * 8;
      switch (pvalue->id){
         case T_E2AP_PDU_Contents_e2ap_RICsubscriptionAuditAction_ItemIEs_id_RICsubscriptionAuditAction_Item:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionAuditAction_ItemIEs_id_RICsubscriptionAuditAction_Item;
            RTXCTXTPUSHELEMNAME(pctxt, "RICsubscriptionAuditAction-Item");
            //pvalue->value.u._e2ap_RICsubscriptionAuditAction_ItemIEs_id_id_RICsubscriptionAuditAction_Item 
             pvalue->value.u._e2apRICsubscriptionAuditAction_ItemIEs_id_RICsubscriptionAuditAction_Item 
                    = rtxMemAllocType(pctxt, e2ap_RICsubscriptionAuditAction_Item);
            //asn1Init_e2ap_RICsubscriptionAuditAction_Item(pvalue->value.u._e2ap_RICsubscriptionAuditAction_ItemIEs_id_id_RICsubscriptionAuditAction_Item);
            asn1Init_e2ap_RICsubscriptionAuditAction_Item(pvalue->value.u._e2apRICsubscriptionAuditAction_ItemIEs_id_RICsubscriptionAuditAction_Item);
            stat = asn1PD_e2ap_RICsubscriptionAuditAction_Item (pctxt,
                    (e2ap_RICsubscriptionAuditAction_Item*)pvalue->value.
                    u._e2apRICsubscriptionAuditAction_ItemIEs_id_RICsubscriptionAuditAction_Item);
            if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionAuditAction_ItemIEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*)rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
      }
      {
      size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
      size_t bitsConsumed = bitEndOffset - bitStartOffset;
      if(bitsConsumed < bitLength){
         stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
      } else {
         stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
      }
      }
   }
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   return stat;
}

void asn1Init_e2ap_RICsubscriptionAuditAction_ItemIEs (e2ap_RICsubscriptionAuditAction_ItemIEs* pvalue)
{
   if (!pvalue) return;
   OSCRTLMEMSET (pvalue, 0, sizeof(e2ap_RICsubscriptionAuditAction_ItemIEs));
}

#if 0
void asn1Free_e2ap_RICsubscriptionAuditAction_ItemIEs (OSCTXT* pctxt, e2ap_RICsubscriptionAuditAction_ItemIEs* pvalue)
{
   if (!pvalue) return;
   if (pvalue->extElem1) {
      rtxMemFreeArray (pctxt, pvalue->extElem1);
      pvalue->extElem1 = 0;
      pvalue->extElem1_n = 0;
   }
}
#endif
void asn1Free_e2ap_RICsubscriptionAuditAction_ItemIEs (OSCTXT* pctxt, e2ap_RICsubscriptionAuditAction_ItemIEs* pvalue)
{
   if(0==pvalue) return;
   switch(pvalue->value.t){
      case T_E2AP_PDU_Contents_e2ap_RICsubscriptionAuditAction_ItemIEs_id_RICsubscriptionAuditAction_Item:
         asn1Free_e2ap_RICsubscriptionAuditAction_Item (pctxt, pvalue->value.u._e2apRICsubscriptionAuditAction_ItemIEs_id_RICsubscriptionAuditAction_Item);
         rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2apRICsubscriptionAuditAction_ItemIEs_id_RICsubscriptionAuditAction_Item);
         pvalue->value.u._e2apRICsubscriptionAuditAction_ItemIEs_id_RICsubscriptionAuditAction_Item = 0;
         break;
      case T_E2AP_PDU_Contents_e2ap_RICsubscriptionAuditAction_ItemIEs_UNDEF_:
         if(0!=pvalue->value.u.extElem1){
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1->data);
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
             pvalue->value.u.extElem1 =0;
         }
         break;
         default:;
   }
}

int  asn1PrtToStr_e2ap_RICsubscriptionAuditAction_ItemIEs (const char * name, e2ap_RICsubscriptionAuditAction_ItemIEs* pvalue, char * buffer, OSSIZE bufSize){
   if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
       return -1;

      if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
         return -1;

      if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
         return -1;
      if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
         return -1;
      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_RICsubscriptionAuditAction_ItemIEs_id_RICsubscriptionAuditAction_Item:
         if(asn1PrtToStr_e2ap_RICsubscriptionAuditAction_Item("RICsubscriptionAuditAction-Item",
                pvalue->value.u._e2apRICsubscriptionAuditAction_ItemIEs_id_RICsubscriptionAuditAction_Item, buffer, bufSize)<0)// dungnm23 check lai nhe xem la
            return -1;
         break;
      default:
         if(0!=pvalue -> value.u.extElem1){
             rtPrintToStringIndent(buffer, bufSize);
             rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

         }
      }
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

      return 0;

}
 

/*****************************************/
/*           RICsubscriptionAuditActionList                */
/*****************************************/
//seq_of_single_container


int asn1PE_e2ap_RICsubscriptionAuditActionList (OSCTXT* pctxt, e2ap_RICsubscriptionAuditActionList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_RICsubscriptionAuditAction_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "RICsubscriptionAuditActionList");

   /* encode length determinant */
   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(2147483648), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;
   for (xx1 = 0; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next, xx1++) {
      pdata = (e2ap_RICsubscriptionAuditAction_ItemIEs*) pnode->data;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_e2ap_RICsubscriptionAuditAction_ItemIEs (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      //xx1++;
      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}

int asn1PD_e2ap_RICsubscriptionAuditActionList (OSCTXT* pctxt, e2ap_RICsubscriptionAuditActionList* ppvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_RICsubscriptionAuditAction_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "RICsubscriptionAuditActionList");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(2147483648), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (ppvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      pdata = rtxMemAllocType (pctxt, e2ap_RICsubscriptionAuditAction_ItemIEs);
      if (!pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);
      asn1Init_e2ap_RICsubscriptionAuditAction_ItemIEs (pdata);
      stat = asn1PD_e2ap_RICsubscriptionAuditAction_ItemIEs (pctxt, pdata);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         return LOG_RTERR (pctxt, stat);
      }

      rtxDListAppendNode (ppvalue, pdata);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

void asn1Init_e2ap_RICsubscriptionAuditActionList (e2ap_RICsubscriptionAuditActionList* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
}

void asn1Free_e2ap_RICsubscriptionAuditActionList (OSCTXT* pctxt, e2ap_RICsubscriptionAuditActionList* pvalue)
{
   if(pvalue==0) return;
   OSRTDListNode* pnode = pvalue->head;
   while (pnode) {
      e2ap_RICsubscriptionAuditAction_ItemIEs* pdata = (e2ap_RICsubscriptionAuditAction_ItemIEs*) pnode->data;
      if (pdata) {
         asn1Free_e2ap_RICsubscriptionAuditAction_ItemIEs (pctxt, pdata);
         rtxMemFreePtr (pctxt, pdata);
      }
      pnode = pnode->next;
   }
      rtxDListFreeAll(pctxt, pvalue);
}

#if 0
void asn1Free_e2ap_RICsubscriptionAuditActionList (OSCTXT* pctxt, e2ap_RICsubscriptionAuditActionList* pvalue){
   if(0==pvalue ) return;
   {
      e2ap_RICsubscriptionAuditAction_ItemIEs * pdata;
      OSRTDListNode *pnode = pvalue->head;
      while(0!=pnode){
         pdata = (e2ap_RICsubscriptionAuditAction_ItemIEs*)pnode->data;
         asn1Free_e2ap_RICsubscriptionAuditAction_ItemIEs(pctxt, pdata);
         pnode = pnode->next;
      }
      rtxDListFreeAll(pctxt, pvalue);
   }
}
#endif


int asn1PrtToStr_e2ap_RICsubscriptionAuditActionList(const char* name, e2ap_RICsubscriptionAuditActionList* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_RICsubscriptionAuditAction_ItemIEs* pdata;
    OSRTDListNode* pnode;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode = pvalue->head;  xx1 < pvalue->count && pnode != 0; pnode = pnode->next, xx1++){
        pdata = (e2ap_RICsubscriptionAuditAction_ItemIEs*)pnode->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 1
        if(asn1PrtToStr_e2ap_RICsubscriptionAuditAction_ItemIEs(nameBuf, pdata, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}/*****************************************/
/*           RICsubscriptionAuditResponse_IEs                */
/*****************************************/
/* ie.c.j2 */
 /* d là con của msg */
EXTERN int asn1PE_e2ap_RICsubscriptionAuditResponse_protocolIEs_element (OSCTXT* pctxt, e2ap_RICsubscriptionAuditResponse_protocolIEs_element* pvalue)
{
    int stat =0;

    /*encode id*/

    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PE_e2ap_ProtocolIE_ID(pctxt, pvalue->id);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PE_e2ap_Criticality(pctxt, pvalue->criticality);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
    {
        OSCTXT lctxt;
        OSOCTET *pDynamicEncodeBuffer;
        ASN1OpenType openType;
        OSBOOL encoded = TRUE;

        openType.numocts = 0;
        openType.data =0;

        rtxCopyContext(&lctxt, pctxt);
        pctxt->pStream =0;

        stat = rtxInitContextBuffer(pctxt, 0, 0);
        if(stat!=0) return LOG_RTERR(pctxt, stat);

        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionAuditResponse_IEs_id_RICrequestID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICrequestID");
                    stat = asn1PE_e2ap_RICrequestID (pctxt, pvalue->value.u._e2ap_RICsubscriptionAuditResponse_IEs_id_RICrequestID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionAuditResponse_IEs_id_RICsubscriptionAuditConfirmedList:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICsubscriptionAuditConfirmedList");
                    stat = asn1PE_e2ap_RICsubscriptionAuditActionList (pctxt, pvalue->value.u._e2ap_RICsubscriptionAuditResponse_IEs_id_RICsubscriptionAuditConfirmedList);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionAuditResponse_IEs_id_RICsubscriptionAuditUnkownList:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICsubscriptionAuditUnkownList");
                    stat = asn1PE_e2ap_RICsubscriptionAuditList (pctxt, pvalue->value.u._e2ap_RICsubscriptionAuditResponse_IEs_id_RICsubscriptionAuditUnkownList);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionAuditResponse_IEs_id_RICsubscriptionAuditMissingList:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICsubscriptionAuditMissingList");
                    stat = asn1PE_e2ap_RICsubscriptionAuditActionList (pctxt, pvalue->value.u._e2ap_RICsubscriptionAuditResponse_IEs_id_RICsubscriptionAuditMissingList);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionAuditResponse_IEs_UNDEF_:
            {
                if(0!=pvalue->value.u.extElem1){
                    openType.numocts = pvalue->value.u.extElem1->numocts;
                    openType.data = pvalue->value.u.extElem1->data;
                } else {
                    /* No extension element to encode */
                }
                encoded = FALSE;
                break;
            }

            default:
                encoded = FALSE;
                stat = RTERR_INVOPT;
                break;
        } 

        if(encoded){
            openType.numocts = (OSUINT32)pe_GetMsgLen(pctxt);
            openType.data = pDynamicEncodeBuffer = pctxt -> buffer.data;
        }
        rtxCopyContext(pctxt, &lctxt);

        if(stat == 0) {
            stat = pe_OpenType (pctxt, openType.numocts, openType.data);
        }
    #if 1
        if(encoded){//dungnm23 check lai nhe
            rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
        }
    #endif

    }

    if(stat!=0) return LOG_RTERR(pctxt, stat);  
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}

EXTERN int  asn1PD_e2ap_RICsubscriptionAuditResponse_protocolIEs_element (OSCTXT* pctxt, e2ap_RICsubscriptionAuditResponse_protocolIEs_element* pvalue){
    int stat =0;

    /*decode id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PD_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PD_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");

    {
        OSUINT32 openTypeLen;
        size_t bitStartOffset, bitLength;

        stat = pd_UnconsLength(pctxt, &openTypeLen);
        if(stat<0) return LOG_RTERR(pctxt, stat);
        else if(stat == RT_OK_FRAG){
            rtxErrAddStrParm(pctxt, "open type with fragment length");
            return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
        }
        bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
        bitLength = openTypeLen * 8;

        switch(pvalue->id){//dungnm23 check case lai nhe
        
            case ASN1V_e2ap_id_RICrequestID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionAuditResponse_IEs_id_RICrequestID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICrequestID");
                pvalue->value.u._e2ap_RICsubscriptionAuditResponse_IEs_id_RICrequestID 
                    = rtxMemAllocType(pctxt, e2ap_RICrequestID);

                asn1Init_e2ap_RICrequestID(pvalue->value.u._e2ap_RICsubscriptionAuditResponse_IEs_id_RICrequestID);

                stat = asn1PD_e2ap_RICrequestID (pctxt,
                        (e2ap_RICrequestID*)pvalue->value.
                        u._e2ap_RICsubscriptionAuditResponse_IEs_id_RICrequestID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RICsubscriptionAuditConfirmedList:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionAuditResponse_IEs_id_RICsubscriptionAuditConfirmedList;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICsubscriptionAuditConfirmedList");
                pvalue->value.u._e2ap_RICsubscriptionAuditResponse_IEs_id_RICsubscriptionAuditConfirmedList 
                    = rtxMemAllocType(pctxt, e2ap_RICsubscriptionAuditActionList);

                asn1Init_e2ap_RICsubscriptionAuditActionList(pvalue->value.u._e2ap_RICsubscriptionAuditResponse_IEs_id_RICsubscriptionAuditConfirmedList);

                stat = asn1PD_e2ap_RICsubscriptionAuditActionList (pctxt,
                        (e2ap_RICsubscriptionAuditActionList*)pvalue->value.
                        u._e2ap_RICsubscriptionAuditResponse_IEs_id_RICsubscriptionAuditConfirmedList);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RICsubscriptionAuditUnkownList:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionAuditResponse_IEs_id_RICsubscriptionAuditUnkownList;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICsubscriptionAuditUnkownList");
                pvalue->value.u._e2ap_RICsubscriptionAuditResponse_IEs_id_RICsubscriptionAuditUnkownList 
                    = rtxMemAllocType(pctxt, e2ap_RICsubscriptionAuditList);

                asn1Init_e2ap_RICsubscriptionAuditList(pvalue->value.u._e2ap_RICsubscriptionAuditResponse_IEs_id_RICsubscriptionAuditUnkownList);

                stat = asn1PD_e2ap_RICsubscriptionAuditList (pctxt,
                        (e2ap_RICsubscriptionAuditList*)pvalue->value.
                        u._e2ap_RICsubscriptionAuditResponse_IEs_id_RICsubscriptionAuditUnkownList);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RICsubscriptionAuditMissingList:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionAuditResponse_IEs_id_RICsubscriptionAuditMissingList;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICsubscriptionAuditMissingList");
                pvalue->value.u._e2ap_RICsubscriptionAuditResponse_IEs_id_RICsubscriptionAuditMissingList 
                    = rtxMemAllocType(pctxt, e2ap_RICsubscriptionAuditActionList);

                asn1Init_e2ap_RICsubscriptionAuditActionList(pvalue->value.u._e2ap_RICsubscriptionAuditResponse_IEs_id_RICsubscriptionAuditMissingList);

                stat = asn1PD_e2ap_RICsubscriptionAuditActionList (pctxt,
                        (e2ap_RICsubscriptionAuditActionList*)pvalue->value.
                        u._e2ap_RICsubscriptionAuditResponse_IEs_id_RICsubscriptionAuditMissingList);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionAuditResponse_IEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*) rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
    }
    {
    size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
    size_t bitsConsumed = bitEndOffset-bitStartOffset;
    if(bitsConsumed<bitLength){
        stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
    }
    else stat =(bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
    }}
    if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}


int asn1Init_e2ap_RICsubscriptionAuditResponse_protocolIEs_element(e2ap_RICsubscriptionAuditResponse_protocolIEs_element* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    OSCRTLMEMSET (&pvalue->value, 0, sizeof(pvalue->value));
    return 0;
}


//-----> chuaw có template rtxFreeASN1OpenType

#if 0
void asn1Free_e2ap_RICsubscriptionAuditResponse_protocolIEs_element(OSCTXT* pctxt, e2ap_RICsubscriptionAuditResponse_protocolIEs_element* pvalue)
{
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionAuditResponse_IEs_id_id_RICrequestID:
            // rtxFreeE2ap_RICrequestID(pvalue->value.u._e2ap_RICsubscriptionAuditResponse_IEs_id_id_RICrequestID);

            if(pvalue->value.i._e2ap_RICsubscriptionAuditResponse_id_RICrequestID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICrequestID(pctxt, pvalue->value.u._e2ap_RICsubscriptionAuditResponse_IEs_id_id_RICrequestID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionAuditResponse_IEs_id_id_RICrequestID);
           // pvalue->value.u._e2ap_RICsubscriptionAuditResponse_IEs_id_id_RICrequestID = NULL;
           pvalue->value.u._e2ap_RICsubscriptionAuditResponse_IEs_id_RICrequestID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionAuditResponse_IEs_id_id_RICsubscriptionAuditConfirmedList:
            // rtxFreeE2ap_RICsubscriptionAuditActionList(pvalue->value.u._e2ap_RICsubscriptionAuditResponse_IEs_id_id_RICsubscriptionAuditConfirmedList);

            if(pvalue->value.i._e2ap_RICsubscriptionAuditResponse_id_RICsubscriptionAuditActionList!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICsubscriptionAuditActionList(pctxt, pvalue->value.u._e2ap_RICsubscriptionAuditResponse_IEs_id_id_RICsubscriptionAuditConfirmedList);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionAuditResponse_IEs_id_id_RICsubscriptionAuditConfirmedList);
           // pvalue->value.u._e2ap_RICsubscriptionAuditResponse_IEs_id_id_RICsubscriptionAuditConfirmedList = NULL;
           pvalue->value.u._e2ap_RICsubscriptionAuditResponse_IEs_id_RICsubscriptionAuditConfirmedList = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionAuditResponse_IEs_id_id_RICsubscriptionAuditUnkownList:
            // rtxFreeE2ap_RICsubscriptionAuditList(pvalue->value.u._e2ap_RICsubscriptionAuditResponse_IEs_id_id_RICsubscriptionAuditUnkownList);

            if(pvalue->value.i._e2ap_RICsubscriptionAuditResponse_id_RICsubscriptionAuditList!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICsubscriptionAuditList(pctxt, pvalue->value.u._e2ap_RICsubscriptionAuditResponse_IEs_id_id_RICsubscriptionAuditUnkownList);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionAuditResponse_IEs_id_id_RICsubscriptionAuditUnkownList);
           // pvalue->value.u._e2ap_RICsubscriptionAuditResponse_IEs_id_id_RICsubscriptionAuditUnkownList = NULL;
           pvalue->value.u._e2ap_RICsubscriptionAuditResponse_IEs_id_RICsubscriptionAuditUnkownList = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionAuditResponse_IEs_id_id_RICsubscriptionAuditMissingList:
            // rtxFreeE2ap_RICsubscriptionAuditActionList(pvalue->value.u._e2ap_RICsubscriptionAuditResponse_IEs_id_id_RICsubscriptionAuditMissingList);

            if(pvalue->value.i._e2ap_RICsubscriptionAuditResponse_id_RICsubscriptionAuditActionList!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICsubscriptionAuditActionList(pctxt, pvalue->value.u._e2ap_RICsubscriptionAuditResponse_IEs_id_id_RICsubscriptionAuditMissingList);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionAuditResponse_IEs_id_id_RICsubscriptionAuditMissingList);
           // pvalue->value.u._e2ap_RICsubscriptionAuditResponse_IEs_id_id_RICsubscriptionAuditMissingList = NULL;
           pvalue->value.u._e2ap_RICsubscriptionAuditResponse_IEs_id_RICsubscriptionAuditMissingList = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionAuditResponse_IEs_UNDEF_:
            rtxFreeASN1OpenType(pvalue->value.u.extElem1);
            break;
        default:
            break;
    }
}

int asn1PrtToStr_e2ap_RICsubscriptionAuditResponse_protocolIEs_element(OSCTXT* pctxt, e2ap_RICsubscriptionAuditResponse_protocolIEs_element* pvalue)
{
    int stat =0;
    RTXCTXTPUSHELEMNAME(pctxt, "e2ap_RICsubscriptionAuditResponse_protocolIEs_element");

    /*print id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PrtToStr_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PrtToStr_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionAuditResponse_IEs_id_id_RICrequestID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICrequestID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICrequestID (pctxt, pvalue->value.u._e2ap_RICsubscriptionAuditResponse_IEs_id_id_RICrequestID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionAuditResponse_IEs_id_id_RICsubscriptionAuditConfirmedList:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICsubscriptionAuditActionList");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICsubscriptionAuditActionList (pctxt, pvalue->value.u._e2ap_RICsubscriptionAuditResponse_IEs_id_id_RICsubscriptionAuditConfirmedList);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionAuditResponse_IEs_id_id_RICsubscriptionAuditUnkownList:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICsubscriptionAuditList");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICsubscriptionAuditList (pctxt, pvalue->value.u._e2ap_RICsubscriptionAuditResponse_IEs_id_id_RICsubscriptionAuditUnkownList);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionAuditResponse_IEs_id_id_RICsubscriptionAuditMissingList:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICsubscriptionAuditActionList");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICsubscriptionAuditActionList (pctxt, pvalue->value.u._e2ap_RICsubscriptionAuditResponse_IEs_id_id_RICsubscriptionAuditMissingList);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionAuditResponse_IEs_UNDEF_:
            {
                rtxPLogMsg(pctxt, "Extension element present - raw data not printed.\n");
                break;
            }

            default:
                stat = RTERR_INVOPT;
                return LOG_RTERR(pctxt, stat);
        }
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);
}
#endif


int asn1PrtToStr_e2ap_RICsubscriptionAuditResponse_protocolIEs_element (const char * name,
 e2ap_RICsubscriptionAuditResponse_protocolIEs_element* pvalue, 
 char * buffer, OSSIZE bufSize){
    if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
        return -1;
    if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
        return -1;

    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionAuditResponse_IEs_id_RICrequestID:
            if(asn1PrtToStr_e2ap_RICrequestID("RICrequestID", 
                    pvalue->value.u._e2ap_RICsubscriptionAuditResponse_IEs_id_RICrequestID, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionAuditResponse_IEs_id_RICsubscriptionAuditConfirmedList:
            if(asn1PrtToStr_e2ap_RICsubscriptionAuditActionList("RICsubscriptionAuditActionList", 
                    pvalue->value.u._e2ap_RICsubscriptionAuditResponse_IEs_id_RICsubscriptionAuditConfirmedList, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionAuditResponse_IEs_id_RICsubscriptionAuditUnkownList:
            if(asn1PrtToStr_e2ap_RICsubscriptionAuditList("RICsubscriptionAuditList", 
                    pvalue->value.u._e2ap_RICsubscriptionAuditResponse_IEs_id_RICsubscriptionAuditUnkownList, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionAuditResponse_IEs_id_RICsubscriptionAuditMissingList:
            if(asn1PrtToStr_e2ap_RICsubscriptionAuditActionList("RICsubscriptionAuditActionList", 
                    pvalue->value.u._e2ap_RICsubscriptionAuditResponse_IEs_id_RICsubscriptionAuditMissingList, buffer, bufSize)<0)
                return -1;
            break;    
        default:
        if(0!=pvalue -> value.u.extElem1){
            rtPrintToStringIndent(buffer, bufSize);
            rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

        }
        }
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

    return 0;

 }

 void asn1Free_e2ap_RICsubscriptionAuditResponse_protocolIEs_element(OSCTXT* pctxt, e2ap_RICsubscriptionAuditResponse_protocolIEs_element* pvalue){
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionAuditResponse_IEs_id_RICrequestID:
            if(pvalue->value.u._e2ap_RICsubscriptionAuditResponse_IEs_id_RICrequestID!=NULL){
            asn1Free_e2ap_RICrequestID(pctxt, pvalue->value.u._e2ap_RICsubscriptionAuditResponse_IEs_id_RICrequestID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionAuditResponse_IEs_id_RICrequestID);
            pvalue->value.u._e2ap_RICsubscriptionAuditResponse_IEs_id_RICrequestID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionAuditResponse_IEs_id_RICsubscriptionAuditConfirmedList:
            if(pvalue->value.u._e2ap_RICsubscriptionAuditResponse_IEs_id_RICsubscriptionAuditConfirmedList!=NULL){
            asn1Free_e2ap_RICsubscriptionAuditActionList(pctxt, pvalue->value.u._e2ap_RICsubscriptionAuditResponse_IEs_id_RICsubscriptionAuditConfirmedList);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionAuditResponse_IEs_id_RICsubscriptionAuditConfirmedList);
            pvalue->value.u._e2ap_RICsubscriptionAuditResponse_IEs_id_RICsubscriptionAuditConfirmedList = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionAuditResponse_IEs_id_RICsubscriptionAuditUnkownList:
            if(pvalue->value.u._e2ap_RICsubscriptionAuditResponse_IEs_id_RICsubscriptionAuditUnkownList!=NULL){
            asn1Free_e2ap_RICsubscriptionAuditList(pctxt, pvalue->value.u._e2ap_RICsubscriptionAuditResponse_IEs_id_RICsubscriptionAuditUnkownList);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionAuditResponse_IEs_id_RICsubscriptionAuditUnkownList);
            pvalue->value.u._e2ap_RICsubscriptionAuditResponse_IEs_id_RICsubscriptionAuditUnkownList = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionAuditResponse_IEs_id_RICsubscriptionAuditMissingList:
            if(pvalue->value.u._e2ap_RICsubscriptionAuditResponse_IEs_id_RICsubscriptionAuditMissingList!=NULL){
            asn1Free_e2ap_RICsubscriptionAuditActionList(pctxt, pvalue->value.u._e2ap_RICsubscriptionAuditResponse_IEs_id_RICsubscriptionAuditMissingList);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionAuditResponse_IEs_id_RICsubscriptionAuditMissingList);
            pvalue->value.u._e2ap_RICsubscriptionAuditResponse_IEs_id_RICsubscriptionAuditMissingList = NULL;
            }
            break;
        default:
            break;


    }
 }

 

/*****************************************/
/*           RICsubscriptionAuditResponse                */
/*****************************************/
//2_container.c
/* 1. xxx_ProtocolIE -> mẫu cũ ở ie_big_msg */
EXTERN int asn1PE_e2ap_RICsubscriptionAuditResponse_protocolIEs (OSCTXT* pctxt, e2ap_RICsubscriptionAuditResponse_protocolIEs* pvalue)
{
    int stat =0;
    OSRTDListNode* pnode;
    OSUINT32 xx1;

    /*encode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pe_Length(pctxt, pvalue->count);
    if(stat<0) return LOG_RTERR(pctxt, stat);

    /*encode each element*/
    xx1 =0;
    for(pnode = pvalue->head; pnode != 0 && xx1<pvalue->count; pnode = pnode->next){
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE", xx1);
        stat = asn1PE_e2ap_RICsubscriptionAuditResponse_protocolIEs_element (pctxt, ((e2ap_RICsubscriptionAuditResponse_protocolIEs_element*)pnode->data));
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        xx1++;
        RTXCTXTPOPARRAYELEMNAME(pctxt);
    }

    return (stat);
}

EXTERN int  asn1PD_e2ap_RICsubscriptionAuditResponse_protocolIEs(OSCTXT* pctxt, e2ap_RICsubscriptionAuditResponse_protocolIEs* pvalue)
{
     int stat =0;
     OSRTDListNode* pnode;
     OSSIZE count =0;
     OSSIZE xx1=0;


     /*decode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pd_Length64(pctxt, &count); //tai sao lai 64
    if(stat!=0) return LOG_RTERR(pctxt, stat);

    /*decode each element*/
    rtxDListInit(pvalue);

    for(xx1=0; xx1 < count; xx1++){
        e2ap_RICsubscriptionAuditResponse_protocolIEs_element* pdata;
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE",xx1);

        if(pnode == NULL) return LOG_RTERR(pctxt, RTERR_NOMEM);

        asn1Init_e2ap_RICsubscriptionAuditResponse_protocolIEs_element(pdata);
        rtxDListAppendNode(pvalue, pnode);
        stat = asn1PD_e2ap_RICsubscriptionAuditResponse_protocolIEs_element (pctxt, pdata);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        RTXCTXTPOPARRAYELEMNAME(pctxt);

    }
    return (stat);
}


int asn1Init_e2ap_RICsubscriptionAuditResponse_protocolIEs(e2ap_RICsubscriptionAuditResponse_protocolIEs* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    rtxDListFastInit (pvalue);
    return 0;
}
#if 1 //ao that day
void asn1Free_e2ap_RICsubscriptionAuditResponse_protocolIEs(OSCTXT* pctxt, e2ap_RICsubscriptionAuditResponse_protocolIEs* pvalue)
{
    if(0==pvalue) return;   
    e2ap_RICsubscriptionAuditResponse_protocolIEs_element* pdata;
    OSRTDListNode* pnode=pvalue->head;
    while(0!=pnode){
        pdata = (e2ap_RICsubscriptionAuditResponse_protocolIEs_element*)pnode->data;
       // asn1Free_e2ap_RICsubscriptionAuditResponse_protocolIEs_element(pctxt, pdata);
        pnode = pnode->next;
    }
    rtxDListFreeAll(pctxt, pvalue);
}
#endif


EXTERN int asn1PrtToStr_e2ap_RICsubscriptionAuditResponse_protocolIEs(const char* name, e2ap_RICsubscriptionAuditResponse_protocolIEs* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_RICsubscriptionAuditResponse_protocolIEs_element* pdata0;
    OSRTDListNode* pnode0;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode0 = pvalue->head;  xx1 < pvalue->count && pnode0 != 0; pnode0 = pnode0->next, xx1++){
        pdata0 = (e2ap_RICsubscriptionAuditResponse_protocolIEs_element*)pnode0->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 0
        if(asn1PrtToStr_e2ap_RICsubscriptionAuditResponse_protocolIEs_element(nameBuf, pdata0, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}


/*2 . RICsubscriptionAuditResponse -> mẫu cũ ở seq_normal*/

int asn1PE_e2ap_RICsubscriptionAuditResponse (OSCTXT* pctxt, e2ap_RICsubscriptionAuditResponse* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RICsubscriptionAuditResponse");
   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field protocolIEs - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
   stat = asn1PE_e2ap_RICsubscriptionAuditResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
   if(stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RICsubscriptionAuditResponse (OSCTXT* pctxt, e2ap_RICsubscriptionAuditResponse* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME(pctxt, "RICsubscriptionAuditResponse");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field protocolIEs */
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
      stat = asn1PD_e2ap_RICsubscriptionAuditResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RICsubscriptionAuditResponse (e2ap_RICsubscriptionAuditResponse* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RICsubscriptionAuditResponse_protocolIEs(&pvalue->protocolIEs);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RICsubscriptionAuditResponse (OSCTXT* pctxt, e2ap_RICsubscriptionAuditResponse* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_RICsubscriptionAuditResponse_protocolIEs(pctxt, &pvalue->protocolIEs);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RICsubscriptionAuditResponse (const char* name, e2ap_RICsubscriptionAuditResponse* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }

   if(asn1PrtToStr_e2ap_RICsubscriptionAuditResponse_protocolIEs("protocolIEs", &pvalue->protocolIEs, buffer, bufSize) <0){
      return -1;
   }

   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           RICsubscriptionDeleteFailure_IEs                */
/*****************************************/
/* ie.c.j2 */
 /* d là con của msg */
EXTERN int asn1PE_e2ap_RICsubscriptionDeleteFailure_protocolIEs_element (OSCTXT* pctxt, e2ap_RICsubscriptionDeleteFailure_protocolIEs_element* pvalue)
{
    int stat =0;

    /*encode id*/

    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PE_e2ap_ProtocolIE_ID(pctxt, pvalue->id);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PE_e2ap_Criticality(pctxt, pvalue->criticality);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
    {
        OSCTXT lctxt;
        OSOCTET *pDynamicEncodeBuffer;
        ASN1OpenType openType;
        OSBOOL encoded = TRUE;

        openType.numocts = 0;
        openType.data =0;

        rtxCopyContext(&lctxt, pctxt);
        pctxt->pStream =0;

        stat = rtxInitContextBuffer(pctxt, 0, 0);
        if(stat!=0) return LOG_RTERR(pctxt, stat);

        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionDeleteFailure_IEs_id_RICrequestID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICrequestID");
                    stat = asn1PE_e2ap_RICrequestID (pctxt, pvalue->value.u._e2ap_RICsubscriptionDeleteFailure_IEs_id_RICrequestID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionDeleteFailure_IEs_id_RANfunctionID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RANfunctionID");
                    stat = asn1PE_e2ap_RANfunctionID (pctxt, pvalue->value.u._e2ap_RICsubscriptionDeleteFailure_IEs_id_RANfunctionID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionDeleteFailure_IEs_id_Cause:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-Cause");
                    stat = asn1PE_e2ap_Cause (pctxt, pvalue->value.u._e2ap_RICsubscriptionDeleteFailure_IEs_id_Cause);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionDeleteFailure_IEs_id_CriticalityDiagnostics:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-CriticalityDiagnostics");
                    stat = asn1PE_e2ap_CriticalityDiagnostics (pctxt, pvalue->value.u._e2ap_RICsubscriptionDeleteFailure_IEs_id_CriticalityDiagnostics);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionDeleteFailure_IEs_UNDEF_:
            {
                if(0!=pvalue->value.u.extElem1){
                    openType.numocts = pvalue->value.u.extElem1->numocts;
                    openType.data = pvalue->value.u.extElem1->data;
                } else {
                    /* No extension element to encode */
                }
                encoded = FALSE;
                break;
            }

            default:
                encoded = FALSE;
                stat = RTERR_INVOPT;
                break;
        } 

        if(encoded){
            openType.numocts = (OSUINT32)pe_GetMsgLen(pctxt);
            openType.data = pDynamicEncodeBuffer = pctxt -> buffer.data;
        }
        rtxCopyContext(pctxt, &lctxt);

        if(stat == 0) {
            stat = pe_OpenType (pctxt, openType.numocts, openType.data);
        }
    #if 1
        if(encoded){//dungnm23 check lai nhe
            rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
        }
    #endif

    }

    if(stat!=0) return LOG_RTERR(pctxt, stat);  
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}

EXTERN int  asn1PD_e2ap_RICsubscriptionDeleteFailure_protocolIEs_element (OSCTXT* pctxt, e2ap_RICsubscriptionDeleteFailure_protocolIEs_element* pvalue){
    int stat =0;

    /*decode id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PD_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PD_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");

    {
        OSUINT32 openTypeLen;
        size_t bitStartOffset, bitLength;

        stat = pd_UnconsLength(pctxt, &openTypeLen);
        if(stat<0) return LOG_RTERR(pctxt, stat);
        else if(stat == RT_OK_FRAG){
            rtxErrAddStrParm(pctxt, "open type with fragment length");
            return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
        }
        bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
        bitLength = openTypeLen * 8;

        switch(pvalue->id){//dungnm23 check case lai nhe
        
            case ASN1V_e2ap_id_RICrequestID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionDeleteFailure_IEs_id_RICrequestID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICrequestID");
                pvalue->value.u._e2ap_RICsubscriptionDeleteFailure_IEs_id_RICrequestID 
                    = rtxMemAllocType(pctxt, e2ap_RICrequestID);

                asn1Init_e2ap_RICrequestID(pvalue->value.u._e2ap_RICsubscriptionDeleteFailure_IEs_id_RICrequestID);

                stat = asn1PD_e2ap_RICrequestID (pctxt,
                        (e2ap_RICrequestID*)pvalue->value.
                        u._e2ap_RICsubscriptionDeleteFailure_IEs_id_RICrequestID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RANfunctionID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionDeleteFailure_IEs_id_RANfunctionID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RANfunctionID");
                pvalue->value.u._e2ap_RICsubscriptionDeleteFailure_IEs_id_RANfunctionID 
                    = rtxMemAllocType(pctxt, e2ap_RANfunctionID);

                asn1Init_e2ap_RANfunctionID(pvalue->value.u._e2ap_RICsubscriptionDeleteFailure_IEs_id_RANfunctionID);

                stat = asn1PD_e2ap_RANfunctionID (pctxt,
                        (e2ap_RANfunctionID*)pvalue->value.
                        u._e2ap_RICsubscriptionDeleteFailure_IEs_id_RANfunctionID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_Cause:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionDeleteFailure_IEs_id_Cause;
            RTXCTXTPUSHELEMNAME(pctxt, "id-Cause");
                pvalue->value.u._e2ap_RICsubscriptionDeleteFailure_IEs_id_Cause 
                    = rtxMemAllocType(pctxt, e2ap_Cause);

                asn1Init_e2ap_Cause(pvalue->value.u._e2ap_RICsubscriptionDeleteFailure_IEs_id_Cause);

                stat = asn1PD_e2ap_Cause (pctxt,
                        (e2ap_Cause*)pvalue->value.
                        u._e2ap_RICsubscriptionDeleteFailure_IEs_id_Cause);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_CriticalityDiagnostics:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionDeleteFailure_IEs_id_CriticalityDiagnostics;
            RTXCTXTPUSHELEMNAME(pctxt, "id-CriticalityDiagnostics");
                pvalue->value.u._e2ap_RICsubscriptionDeleteFailure_IEs_id_CriticalityDiagnostics 
                    = rtxMemAllocType(pctxt, e2ap_CriticalityDiagnostics);

                asn1Init_e2ap_CriticalityDiagnostics(pvalue->value.u._e2ap_RICsubscriptionDeleteFailure_IEs_id_CriticalityDiagnostics);

                stat = asn1PD_e2ap_CriticalityDiagnostics (pctxt,
                        (e2ap_CriticalityDiagnostics*)pvalue->value.
                        u._e2ap_RICsubscriptionDeleteFailure_IEs_id_CriticalityDiagnostics);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionDeleteFailure_IEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*) rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
    }
    {
    size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
    size_t bitsConsumed = bitEndOffset-bitStartOffset;
    if(bitsConsumed<bitLength){
        stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
    }
    else stat =(bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
    }}
    if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}


int asn1Init_e2ap_RICsubscriptionDeleteFailure_protocolIEs_element(e2ap_RICsubscriptionDeleteFailure_protocolIEs_element* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    OSCRTLMEMSET (&pvalue->value, 0, sizeof(pvalue->value));
    return 0;
}


//-----> chuaw có template rtxFreeASN1OpenType

#if 0
void asn1Free_e2ap_RICsubscriptionDeleteFailure_protocolIEs_element(OSCTXT* pctxt, e2ap_RICsubscriptionDeleteFailure_protocolIEs_element* pvalue)
{
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionDeleteFailure_IEs_id_id_RICrequestID:
            // rtxFreeE2ap_RICrequestID(pvalue->value.u._e2ap_RICsubscriptionDeleteFailure_IEs_id_id_RICrequestID);

            if(pvalue->value.i._e2ap_RICsubscriptionDeleteFailure_id_RICrequestID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICrequestID(pctxt, pvalue->value.u._e2ap_RICsubscriptionDeleteFailure_IEs_id_id_RICrequestID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionDeleteFailure_IEs_id_id_RICrequestID);
           // pvalue->value.u._e2ap_RICsubscriptionDeleteFailure_IEs_id_id_RICrequestID = NULL;
           pvalue->value.u._e2ap_RICsubscriptionDeleteFailure_IEs_id_RICrequestID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionDeleteFailure_IEs_id_id_RANfunctionID:
            // rtxFreeE2ap_RANfunctionID(pvalue->value.u._e2ap_RICsubscriptionDeleteFailure_IEs_id_id_RANfunctionID);

            if(pvalue->value.i._e2ap_RICsubscriptionDeleteFailure_id_RANfunctionID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RANfunctionID(pctxt, pvalue->value.u._e2ap_RICsubscriptionDeleteFailure_IEs_id_id_RANfunctionID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionDeleteFailure_IEs_id_id_RANfunctionID);
           // pvalue->value.u._e2ap_RICsubscriptionDeleteFailure_IEs_id_id_RANfunctionID = NULL;
           pvalue->value.u._e2ap_RICsubscriptionDeleteFailure_IEs_id_RANfunctionID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionDeleteFailure_IEs_id_id_Cause:
            // rtxFreeE2ap_Cause(pvalue->value.u._e2ap_RICsubscriptionDeleteFailure_IEs_id_id_Cause);

            if(pvalue->value.i._e2ap_RICsubscriptionDeleteFailure_id_Cause!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_Cause(pctxt, pvalue->value.u._e2ap_RICsubscriptionDeleteFailure_IEs_id_id_Cause);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionDeleteFailure_IEs_id_id_Cause);
           // pvalue->value.u._e2ap_RICsubscriptionDeleteFailure_IEs_id_id_Cause = NULL;
           pvalue->value.u._e2ap_RICsubscriptionDeleteFailure_IEs_id_Cause = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionDeleteFailure_IEs_id_id_CriticalityDiagnostics:
            // rtxFreeE2ap_CriticalityDiagnostics(pvalue->value.u._e2ap_RICsubscriptionDeleteFailure_IEs_id_id_CriticalityDiagnostics);

            if(pvalue->value.i._e2ap_RICsubscriptionDeleteFailure_id_CriticalityDiagnostics!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_CriticalityDiagnostics(pctxt, pvalue->value.u._e2ap_RICsubscriptionDeleteFailure_IEs_id_id_CriticalityDiagnostics);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionDeleteFailure_IEs_id_id_CriticalityDiagnostics);
           // pvalue->value.u._e2ap_RICsubscriptionDeleteFailure_IEs_id_id_CriticalityDiagnostics = NULL;
           pvalue->value.u._e2ap_RICsubscriptionDeleteFailure_IEs_id_CriticalityDiagnostics = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionDeleteFailure_IEs_UNDEF_:
            rtxFreeASN1OpenType(pvalue->value.u.extElem1);
            break;
        default:
            break;
    }
}

int asn1PrtToStr_e2ap_RICsubscriptionDeleteFailure_protocolIEs_element(OSCTXT* pctxt, e2ap_RICsubscriptionDeleteFailure_protocolIEs_element* pvalue)
{
    int stat =0;
    RTXCTXTPUSHELEMNAME(pctxt, "e2ap_RICsubscriptionDeleteFailure_protocolIEs_element");

    /*print id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PrtToStr_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PrtToStr_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionDeleteFailure_IEs_id_id_RICrequestID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICrequestID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICrequestID (pctxt, pvalue->value.u._e2ap_RICsubscriptionDeleteFailure_IEs_id_id_RICrequestID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionDeleteFailure_IEs_id_id_RANfunctionID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RANfunctionID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RANfunctionID (pctxt, pvalue->value.u._e2ap_RICsubscriptionDeleteFailure_IEs_id_id_RANfunctionID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionDeleteFailure_IEs_id_id_Cause:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "Cause");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_Cause (pctxt, pvalue->value.u._e2ap_RICsubscriptionDeleteFailure_IEs_id_id_Cause);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionDeleteFailure_IEs_id_id_CriticalityDiagnostics:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "CriticalityDiagnostics");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_CriticalityDiagnostics (pctxt, pvalue->value.u._e2ap_RICsubscriptionDeleteFailure_IEs_id_id_CriticalityDiagnostics);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionDeleteFailure_IEs_UNDEF_:
            {
                rtxPLogMsg(pctxt, "Extension element present - raw data not printed.\n");
                break;
            }

            default:
                stat = RTERR_INVOPT;
                return LOG_RTERR(pctxt, stat);
        }
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);
}
#endif


int asn1PrtToStr_e2ap_RICsubscriptionDeleteFailure_protocolIEs_element (const char * name,
 e2ap_RICsubscriptionDeleteFailure_protocolIEs_element* pvalue, 
 char * buffer, OSSIZE bufSize){
    if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
        return -1;
    if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
        return -1;

    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionDeleteFailure_IEs_id_RICrequestID:
            if(asn1PrtToStr_e2ap_RICrequestID("RICrequestID", 
                    pvalue->value.u._e2ap_RICsubscriptionDeleteFailure_IEs_id_RICrequestID, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionDeleteFailure_IEs_id_RANfunctionID:
            if(asn1PrtToStr_e2ap_RANfunctionID("RANfunctionID", 
                    pvalue->value.u._e2ap_RICsubscriptionDeleteFailure_IEs_id_RANfunctionID, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionDeleteFailure_IEs_id_Cause:
            if(asn1PrtToStr_e2ap_Cause("Cause", 
                    pvalue->value.u._e2ap_RICsubscriptionDeleteFailure_IEs_id_Cause, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionDeleteFailure_IEs_id_CriticalityDiagnostics:
            if(asn1PrtToStr_e2ap_CriticalityDiagnostics("CriticalityDiagnostics", 
                    pvalue->value.u._e2ap_RICsubscriptionDeleteFailure_IEs_id_CriticalityDiagnostics, buffer, bufSize)<0)
                return -1;
            break;    
        default:
        if(0!=pvalue -> value.u.extElem1){
            rtPrintToStringIndent(buffer, bufSize);
            rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

        }
        }
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

    return 0;

 }

 void asn1Free_e2ap_RICsubscriptionDeleteFailure_protocolIEs_element(OSCTXT* pctxt, e2ap_RICsubscriptionDeleteFailure_protocolIEs_element* pvalue){
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionDeleteFailure_IEs_id_RICrequestID:
            if(pvalue->value.u._e2ap_RICsubscriptionDeleteFailure_IEs_id_RICrequestID!=NULL){
            asn1Free_e2ap_RICrequestID(pctxt, pvalue->value.u._e2ap_RICsubscriptionDeleteFailure_IEs_id_RICrequestID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionDeleteFailure_IEs_id_RICrequestID);
            pvalue->value.u._e2ap_RICsubscriptionDeleteFailure_IEs_id_RICrequestID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionDeleteFailure_IEs_id_RANfunctionID:
            if(pvalue->value.u._e2ap_RICsubscriptionDeleteFailure_IEs_id_RANfunctionID!=NULL){
            asn1Free_e2ap_RANfunctionID(pctxt, pvalue->value.u._e2ap_RICsubscriptionDeleteFailure_IEs_id_RANfunctionID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionDeleteFailure_IEs_id_RANfunctionID);
            pvalue->value.u._e2ap_RICsubscriptionDeleteFailure_IEs_id_RANfunctionID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionDeleteFailure_IEs_id_Cause:
            if(pvalue->value.u._e2ap_RICsubscriptionDeleteFailure_IEs_id_Cause!=NULL){
            asn1Free_e2ap_Cause(pctxt, pvalue->value.u._e2ap_RICsubscriptionDeleteFailure_IEs_id_Cause);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionDeleteFailure_IEs_id_Cause);
            pvalue->value.u._e2ap_RICsubscriptionDeleteFailure_IEs_id_Cause = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionDeleteFailure_IEs_id_CriticalityDiagnostics:
            if(pvalue->value.u._e2ap_RICsubscriptionDeleteFailure_IEs_id_CriticalityDiagnostics!=NULL){
            asn1Free_e2ap_CriticalityDiagnostics(pctxt, pvalue->value.u._e2ap_RICsubscriptionDeleteFailure_IEs_id_CriticalityDiagnostics);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionDeleteFailure_IEs_id_CriticalityDiagnostics);
            pvalue->value.u._e2ap_RICsubscriptionDeleteFailure_IEs_id_CriticalityDiagnostics = NULL;
            }
            break;
        default:
            break;


    }
 }

 

/*****************************************/
/*           RICsubscriptionDeleteFailure                */
/*****************************************/
//2_container.c
/* 1. xxx_ProtocolIE -> mẫu cũ ở ie_big_msg */
EXTERN int asn1PE_e2ap_RICsubscriptionDeleteFailure_protocolIEs (OSCTXT* pctxt, e2ap_RICsubscriptionDeleteFailure_protocolIEs* pvalue)
{
    int stat =0;
    OSRTDListNode* pnode;
    OSUINT32 xx1;

    /*encode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pe_Length(pctxt, pvalue->count);
    if(stat<0) return LOG_RTERR(pctxt, stat);

    /*encode each element*/
    xx1 =0;
    for(pnode = pvalue->head; pnode != 0 && xx1<pvalue->count; pnode = pnode->next){
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE", xx1);
        stat = asn1PE_e2ap_RICsubscriptionDeleteFailure_protocolIEs_element (pctxt, ((e2ap_RICsubscriptionDeleteFailure_protocolIEs_element*)pnode->data));
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        xx1++;
        RTXCTXTPOPARRAYELEMNAME(pctxt);
    }

    return (stat);
}

EXTERN int  asn1PD_e2ap_RICsubscriptionDeleteFailure_protocolIEs(OSCTXT* pctxt, e2ap_RICsubscriptionDeleteFailure_protocolIEs* pvalue)
{
     int stat =0;
     OSRTDListNode* pnode;
     OSSIZE count =0;
     OSSIZE xx1=0;


     /*decode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pd_Length64(pctxt, &count); //tai sao lai 64
    if(stat!=0) return LOG_RTERR(pctxt, stat);

    /*decode each element*/
    rtxDListInit(pvalue);

    for(xx1=0; xx1 < count; xx1++){
        e2ap_RICsubscriptionDeleteFailure_protocolIEs_element* pdata;
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE",xx1);

        if(pnode == NULL) return LOG_RTERR(pctxt, RTERR_NOMEM);

        asn1Init_e2ap_RICsubscriptionDeleteFailure_protocolIEs_element(pdata);
        rtxDListAppendNode(pvalue, pnode);
        stat = asn1PD_e2ap_RICsubscriptionDeleteFailure_protocolIEs_element (pctxt, pdata);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        RTXCTXTPOPARRAYELEMNAME(pctxt);

    }
    return (stat);
}


int asn1Init_e2ap_RICsubscriptionDeleteFailure_protocolIEs(e2ap_RICsubscriptionDeleteFailure_protocolIEs* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    rtxDListFastInit (pvalue);
    return 0;
}
#if 1 //ao that day
void asn1Free_e2ap_RICsubscriptionDeleteFailure_protocolIEs(OSCTXT* pctxt, e2ap_RICsubscriptionDeleteFailure_protocolIEs* pvalue)
{
    if(0==pvalue) return;   
    e2ap_RICsubscriptionDeleteFailure_protocolIEs_element* pdata;
    OSRTDListNode* pnode=pvalue->head;
    while(0!=pnode){
        pdata = (e2ap_RICsubscriptionDeleteFailure_protocolIEs_element*)pnode->data;
       // asn1Free_e2ap_RICsubscriptionDeleteFailure_protocolIEs_element(pctxt, pdata);
        pnode = pnode->next;
    }
    rtxDListFreeAll(pctxt, pvalue);
}
#endif


EXTERN int asn1PrtToStr_e2ap_RICsubscriptionDeleteFailure_protocolIEs(const char* name, e2ap_RICsubscriptionDeleteFailure_protocolIEs* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_RICsubscriptionDeleteFailure_protocolIEs_element* pdata0;
    OSRTDListNode* pnode0;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode0 = pvalue->head;  xx1 < pvalue->count && pnode0 != 0; pnode0 = pnode0->next, xx1++){
        pdata0 = (e2ap_RICsubscriptionDeleteFailure_protocolIEs_element*)pnode0->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 0
        if(asn1PrtToStr_e2ap_RICsubscriptionDeleteFailure_protocolIEs_element(nameBuf, pdata0, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}


/*2 . RICsubscriptionDeleteFailure -> mẫu cũ ở seq_normal*/

int asn1PE_e2ap_RICsubscriptionDeleteFailure (OSCTXT* pctxt, e2ap_RICsubscriptionDeleteFailure* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RICsubscriptionDeleteFailure");
   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field protocolIEs - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
   stat = asn1PE_e2ap_RICsubscriptionDeleteFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
   if(stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RICsubscriptionDeleteFailure (OSCTXT* pctxt, e2ap_RICsubscriptionDeleteFailure* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME(pctxt, "RICsubscriptionDeleteFailure");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field protocolIEs */
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
      stat = asn1PD_e2ap_RICsubscriptionDeleteFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RICsubscriptionDeleteFailure (e2ap_RICsubscriptionDeleteFailure* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RICsubscriptionDeleteFailure_protocolIEs(&pvalue->protocolIEs);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RICsubscriptionDeleteFailure (OSCTXT* pctxt, e2ap_RICsubscriptionDeleteFailure* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_RICsubscriptionDeleteFailure_protocolIEs(pctxt, &pvalue->protocolIEs);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RICsubscriptionDeleteFailure (const char* name, e2ap_RICsubscriptionDeleteFailure* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }

   if(asn1PrtToStr_e2ap_RICsubscriptionDeleteFailure_protocolIEs("protocolIEs", &pvalue->protocolIEs, buffer, bufSize) <0){
      return -1;
   }

   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           RICsubscriptionDeleteRequest_IEs                */
/*****************************************/
/* ie.c.j2 */
 /* d là con của msg */
EXTERN int asn1PE_e2ap_RICsubscriptionDeleteRequest_protocolIEs_element (OSCTXT* pctxt, e2ap_RICsubscriptionDeleteRequest_protocolIEs_element* pvalue)
{
    int stat =0;

    /*encode id*/

    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PE_e2ap_ProtocolIE_ID(pctxt, pvalue->id);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PE_e2ap_Criticality(pctxt, pvalue->criticality);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
    {
        OSCTXT lctxt;
        OSOCTET *pDynamicEncodeBuffer;
        ASN1OpenType openType;
        OSBOOL encoded = TRUE;

        openType.numocts = 0;
        openType.data =0;

        rtxCopyContext(&lctxt, pctxt);
        pctxt->pStream =0;

        stat = rtxInitContextBuffer(pctxt, 0, 0);
        if(stat!=0) return LOG_RTERR(pctxt, stat);

        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionDeleteRequest_IEs_id_RICrequestID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICrequestID");
                    stat = asn1PE_e2ap_RICrequestID (pctxt, pvalue->value.u._e2ap_RICsubscriptionDeleteRequest_IEs_id_RICrequestID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionDeleteRequest_IEs_id_RANfunctionID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RANfunctionID");
                    stat = asn1PE_e2ap_RANfunctionID (pctxt, pvalue->value.u._e2ap_RICsubscriptionDeleteRequest_IEs_id_RANfunctionID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionDeleteRequest_IEs_UNDEF_:
            {
                if(0!=pvalue->value.u.extElem1){
                    openType.numocts = pvalue->value.u.extElem1->numocts;
                    openType.data = pvalue->value.u.extElem1->data;
                } else {
                    /* No extension element to encode */
                }
                encoded = FALSE;
                break;
            }

            default:
                encoded = FALSE;
                stat = RTERR_INVOPT;
                break;
        } 

        if(encoded){
            openType.numocts = (OSUINT32)pe_GetMsgLen(pctxt);
            openType.data = pDynamicEncodeBuffer = pctxt -> buffer.data;
        }
        rtxCopyContext(pctxt, &lctxt);

        if(stat == 0) {
            stat = pe_OpenType (pctxt, openType.numocts, openType.data);
        }
    #if 1
        if(encoded){//dungnm23 check lai nhe
            rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
        }
    #endif

    }

    if(stat!=0) return LOG_RTERR(pctxt, stat);  
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}

EXTERN int  asn1PD_e2ap_RICsubscriptionDeleteRequest_protocolIEs_element (OSCTXT* pctxt, e2ap_RICsubscriptionDeleteRequest_protocolIEs_element* pvalue){
    int stat =0;

    /*decode id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PD_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PD_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");

    {
        OSUINT32 openTypeLen;
        size_t bitStartOffset, bitLength;

        stat = pd_UnconsLength(pctxt, &openTypeLen);
        if(stat<0) return LOG_RTERR(pctxt, stat);
        else if(stat == RT_OK_FRAG){
            rtxErrAddStrParm(pctxt, "open type with fragment length");
            return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
        }
        bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
        bitLength = openTypeLen * 8;

        switch(pvalue->id){//dungnm23 check case lai nhe
        
            case ASN1V_e2ap_id_RICrequestID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionDeleteRequest_IEs_id_RICrequestID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICrequestID");
                pvalue->value.u._e2ap_RICsubscriptionDeleteRequest_IEs_id_RICrequestID 
                    = rtxMemAllocType(pctxt, e2ap_RICrequestID);

                asn1Init_e2ap_RICrequestID(pvalue->value.u._e2ap_RICsubscriptionDeleteRequest_IEs_id_RICrequestID);

                stat = asn1PD_e2ap_RICrequestID (pctxt,
                        (e2ap_RICrequestID*)pvalue->value.
                        u._e2ap_RICsubscriptionDeleteRequest_IEs_id_RICrequestID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RANfunctionID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionDeleteRequest_IEs_id_RANfunctionID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RANfunctionID");
                pvalue->value.u._e2ap_RICsubscriptionDeleteRequest_IEs_id_RANfunctionID 
                    = rtxMemAllocType(pctxt, e2ap_RANfunctionID);

                asn1Init_e2ap_RANfunctionID(pvalue->value.u._e2ap_RICsubscriptionDeleteRequest_IEs_id_RANfunctionID);

                stat = asn1PD_e2ap_RANfunctionID (pctxt,
                        (e2ap_RANfunctionID*)pvalue->value.
                        u._e2ap_RICsubscriptionDeleteRequest_IEs_id_RANfunctionID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionDeleteRequest_IEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*) rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
    }
    {
    size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
    size_t bitsConsumed = bitEndOffset-bitStartOffset;
    if(bitsConsumed<bitLength){
        stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
    }
    else stat =(bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
    }}
    if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}


int asn1Init_e2ap_RICsubscriptionDeleteRequest_protocolIEs_element(e2ap_RICsubscriptionDeleteRequest_protocolIEs_element* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    OSCRTLMEMSET (&pvalue->value, 0, sizeof(pvalue->value));
    return 0;
}


//-----> chuaw có template rtxFreeASN1OpenType

#if 0
void asn1Free_e2ap_RICsubscriptionDeleteRequest_protocolIEs_element(OSCTXT* pctxt, e2ap_RICsubscriptionDeleteRequest_protocolIEs_element* pvalue)
{
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionDeleteRequest_IEs_id_id_RICrequestID:
            // rtxFreeE2ap_RICrequestID(pvalue->value.u._e2ap_RICsubscriptionDeleteRequest_IEs_id_id_RICrequestID);

            if(pvalue->value.i._e2ap_RICsubscriptionDeleteRequest_id_RICrequestID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICrequestID(pctxt, pvalue->value.u._e2ap_RICsubscriptionDeleteRequest_IEs_id_id_RICrequestID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionDeleteRequest_IEs_id_id_RICrequestID);
           // pvalue->value.u._e2ap_RICsubscriptionDeleteRequest_IEs_id_id_RICrequestID = NULL;
           pvalue->value.u._e2ap_RICsubscriptionDeleteRequest_IEs_id_RICrequestID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionDeleteRequest_IEs_id_id_RANfunctionID:
            // rtxFreeE2ap_RANfunctionID(pvalue->value.u._e2ap_RICsubscriptionDeleteRequest_IEs_id_id_RANfunctionID);

            if(pvalue->value.i._e2ap_RICsubscriptionDeleteRequest_id_RANfunctionID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RANfunctionID(pctxt, pvalue->value.u._e2ap_RICsubscriptionDeleteRequest_IEs_id_id_RANfunctionID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionDeleteRequest_IEs_id_id_RANfunctionID);
           // pvalue->value.u._e2ap_RICsubscriptionDeleteRequest_IEs_id_id_RANfunctionID = NULL;
           pvalue->value.u._e2ap_RICsubscriptionDeleteRequest_IEs_id_RANfunctionID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionDeleteRequest_IEs_UNDEF_:
            rtxFreeASN1OpenType(pvalue->value.u.extElem1);
            break;
        default:
            break;
    }
}

int asn1PrtToStr_e2ap_RICsubscriptionDeleteRequest_protocolIEs_element(OSCTXT* pctxt, e2ap_RICsubscriptionDeleteRequest_protocolIEs_element* pvalue)
{
    int stat =0;
    RTXCTXTPUSHELEMNAME(pctxt, "e2ap_RICsubscriptionDeleteRequest_protocolIEs_element");

    /*print id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PrtToStr_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PrtToStr_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionDeleteRequest_IEs_id_id_RICrequestID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICrequestID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICrequestID (pctxt, pvalue->value.u._e2ap_RICsubscriptionDeleteRequest_IEs_id_id_RICrequestID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionDeleteRequest_IEs_id_id_RANfunctionID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RANfunctionID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RANfunctionID (pctxt, pvalue->value.u._e2ap_RICsubscriptionDeleteRequest_IEs_id_id_RANfunctionID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionDeleteRequest_IEs_UNDEF_:
            {
                rtxPLogMsg(pctxt, "Extension element present - raw data not printed.\n");
                break;
            }

            default:
                stat = RTERR_INVOPT;
                return LOG_RTERR(pctxt, stat);
        }
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);
}
#endif


int asn1PrtToStr_e2ap_RICsubscriptionDeleteRequest_protocolIEs_element (const char * name,
 e2ap_RICsubscriptionDeleteRequest_protocolIEs_element* pvalue, 
 char * buffer, OSSIZE bufSize){
    if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
        return -1;
    if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
        return -1;

    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionDeleteRequest_IEs_id_RICrequestID:
            if(asn1PrtToStr_e2ap_RICrequestID("RICrequestID", 
                    pvalue->value.u._e2ap_RICsubscriptionDeleteRequest_IEs_id_RICrequestID, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionDeleteRequest_IEs_id_RANfunctionID:
            if(asn1PrtToStr_e2ap_RANfunctionID("RANfunctionID", 
                    pvalue->value.u._e2ap_RICsubscriptionDeleteRequest_IEs_id_RANfunctionID, buffer, bufSize)<0)
                return -1;
            break;    
        default:
        if(0!=pvalue -> value.u.extElem1){
            rtPrintToStringIndent(buffer, bufSize);
            rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

        }
        }
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

    return 0;

 }

 void asn1Free_e2ap_RICsubscriptionDeleteRequest_protocolIEs_element(OSCTXT* pctxt, e2ap_RICsubscriptionDeleteRequest_protocolIEs_element* pvalue){
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionDeleteRequest_IEs_id_RICrequestID:
            if(pvalue->value.u._e2ap_RICsubscriptionDeleteRequest_IEs_id_RICrequestID!=NULL){
            asn1Free_e2ap_RICrequestID(pctxt, pvalue->value.u._e2ap_RICsubscriptionDeleteRequest_IEs_id_RICrequestID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionDeleteRequest_IEs_id_RICrequestID);
            pvalue->value.u._e2ap_RICsubscriptionDeleteRequest_IEs_id_RICrequestID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionDeleteRequest_IEs_id_RANfunctionID:
            if(pvalue->value.u._e2ap_RICsubscriptionDeleteRequest_IEs_id_RANfunctionID!=NULL){
            asn1Free_e2ap_RANfunctionID(pctxt, pvalue->value.u._e2ap_RICsubscriptionDeleteRequest_IEs_id_RANfunctionID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionDeleteRequest_IEs_id_RANfunctionID);
            pvalue->value.u._e2ap_RICsubscriptionDeleteRequest_IEs_id_RANfunctionID = NULL;
            }
            break;
        default:
            break;


    }
 }

 

/*****************************************/
/*           RICsubscriptionDeleteRequest                */
/*****************************************/
//2_container.c
/* 1. xxx_ProtocolIE -> mẫu cũ ở ie_big_msg */
EXTERN int asn1PE_e2ap_RICsubscriptionDeleteRequest_protocolIEs (OSCTXT* pctxt, e2ap_RICsubscriptionDeleteRequest_protocolIEs* pvalue)
{
    int stat =0;
    OSRTDListNode* pnode;
    OSUINT32 xx1;

    /*encode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pe_Length(pctxt, pvalue->count);
    if(stat<0) return LOG_RTERR(pctxt, stat);

    /*encode each element*/
    xx1 =0;
    for(pnode = pvalue->head; pnode != 0 && xx1<pvalue->count; pnode = pnode->next){
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE", xx1);
        stat = asn1PE_e2ap_RICsubscriptionDeleteRequest_protocolIEs_element (pctxt, ((e2ap_RICsubscriptionDeleteRequest_protocolIEs_element*)pnode->data));
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        xx1++;
        RTXCTXTPOPARRAYELEMNAME(pctxt);
    }

    return (stat);
}

EXTERN int  asn1PD_e2ap_RICsubscriptionDeleteRequest_protocolIEs(OSCTXT* pctxt, e2ap_RICsubscriptionDeleteRequest_protocolIEs* pvalue)
{
     int stat =0;
     OSRTDListNode* pnode;
     OSSIZE count =0;
     OSSIZE xx1=0;


     /*decode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pd_Length64(pctxt, &count); //tai sao lai 64
    if(stat!=0) return LOG_RTERR(pctxt, stat);

    /*decode each element*/
    rtxDListInit(pvalue);

    for(xx1=0; xx1 < count; xx1++){
        e2ap_RICsubscriptionDeleteRequest_protocolIEs_element* pdata;
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE",xx1);

        if(pnode == NULL) return LOG_RTERR(pctxt, RTERR_NOMEM);

        asn1Init_e2ap_RICsubscriptionDeleteRequest_protocolIEs_element(pdata);
        rtxDListAppendNode(pvalue, pnode);
        stat = asn1PD_e2ap_RICsubscriptionDeleteRequest_protocolIEs_element (pctxt, pdata);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        RTXCTXTPOPARRAYELEMNAME(pctxt);

    }
    return (stat);
}


int asn1Init_e2ap_RICsubscriptionDeleteRequest_protocolIEs(e2ap_RICsubscriptionDeleteRequest_protocolIEs* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    rtxDListFastInit (pvalue);
    return 0;
}
#if 1 //ao that day
void asn1Free_e2ap_RICsubscriptionDeleteRequest_protocolIEs(OSCTXT* pctxt, e2ap_RICsubscriptionDeleteRequest_protocolIEs* pvalue)
{
    if(0==pvalue) return;   
    e2ap_RICsubscriptionDeleteRequest_protocolIEs_element* pdata;
    OSRTDListNode* pnode=pvalue->head;
    while(0!=pnode){
        pdata = (e2ap_RICsubscriptionDeleteRequest_protocolIEs_element*)pnode->data;
       // asn1Free_e2ap_RICsubscriptionDeleteRequest_protocolIEs_element(pctxt, pdata);
        pnode = pnode->next;
    }
    rtxDListFreeAll(pctxt, pvalue);
}
#endif


EXTERN int asn1PrtToStr_e2ap_RICsubscriptionDeleteRequest_protocolIEs(const char* name, e2ap_RICsubscriptionDeleteRequest_protocolIEs* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_RICsubscriptionDeleteRequest_protocolIEs_element* pdata0;
    OSRTDListNode* pnode0;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode0 = pvalue->head;  xx1 < pvalue->count && pnode0 != 0; pnode0 = pnode0->next, xx1++){
        pdata0 = (e2ap_RICsubscriptionDeleteRequest_protocolIEs_element*)pnode0->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 0
        if(asn1PrtToStr_e2ap_RICsubscriptionDeleteRequest_protocolIEs_element(nameBuf, pdata0, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}


/*2 . RICsubscriptionDeleteRequest -> mẫu cũ ở seq_normal*/

int asn1PE_e2ap_RICsubscriptionDeleteRequest (OSCTXT* pctxt, e2ap_RICsubscriptionDeleteRequest* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RICsubscriptionDeleteRequest");
   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field protocolIEs - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
   stat = asn1PE_e2ap_RICsubscriptionDeleteRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if(stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RICsubscriptionDeleteRequest (OSCTXT* pctxt, e2ap_RICsubscriptionDeleteRequest* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME(pctxt, "RICsubscriptionDeleteRequest");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field protocolIEs */
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
      stat = asn1PD_e2ap_RICsubscriptionDeleteRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RICsubscriptionDeleteRequest (e2ap_RICsubscriptionDeleteRequest* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RICsubscriptionDeleteRequest_protocolIEs(&pvalue->protocolIEs);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RICsubscriptionDeleteRequest (OSCTXT* pctxt, e2ap_RICsubscriptionDeleteRequest* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_RICsubscriptionDeleteRequest_protocolIEs(pctxt, &pvalue->protocolIEs);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RICsubscriptionDeleteRequest (const char* name, e2ap_RICsubscriptionDeleteRequest* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }

   if(asn1PrtToStr_e2ap_RICsubscriptionDeleteRequest_protocolIEs("protocolIEs", &pvalue->protocolIEs, buffer, bufSize) <0){
      return -1;
   }

   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           RICsubscriptionDeleteResponse_IEs                */
/*****************************************/
/* ie.c.j2 */
 /* d là con của msg */
EXTERN int asn1PE_e2ap_RICsubscriptionDeleteResponse_protocolIEs_element (OSCTXT* pctxt, e2ap_RICsubscriptionDeleteResponse_protocolIEs_element* pvalue)
{
    int stat =0;

    /*encode id*/

    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PE_e2ap_ProtocolIE_ID(pctxt, pvalue->id);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PE_e2ap_Criticality(pctxt, pvalue->criticality);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
    {
        OSCTXT lctxt;
        OSOCTET *pDynamicEncodeBuffer;
        ASN1OpenType openType;
        OSBOOL encoded = TRUE;

        openType.numocts = 0;
        openType.data =0;

        rtxCopyContext(&lctxt, pctxt);
        pctxt->pStream =0;

        stat = rtxInitContextBuffer(pctxt, 0, 0);
        if(stat!=0) return LOG_RTERR(pctxt, stat);

        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionDeleteResponse_IEs_id_RICrequestID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICrequestID");
                    stat = asn1PE_e2ap_RICrequestID (pctxt, pvalue->value.u._e2ap_RICsubscriptionDeleteResponse_IEs_id_RICrequestID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionDeleteResponse_IEs_id_RANfunctionID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RANfunctionID");
                    stat = asn1PE_e2ap_RANfunctionID (pctxt, pvalue->value.u._e2ap_RICsubscriptionDeleteResponse_IEs_id_RANfunctionID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionDeleteResponse_IEs_UNDEF_:
            {
                if(0!=pvalue->value.u.extElem1){
                    openType.numocts = pvalue->value.u.extElem1->numocts;
                    openType.data = pvalue->value.u.extElem1->data;
                } else {
                    /* No extension element to encode */
                }
                encoded = FALSE;
                break;
            }

            default:
                encoded = FALSE;
                stat = RTERR_INVOPT;
                break;
        } 

        if(encoded){
            openType.numocts = (OSUINT32)pe_GetMsgLen(pctxt);
            openType.data = pDynamicEncodeBuffer = pctxt -> buffer.data;
        }
        rtxCopyContext(pctxt, &lctxt);

        if(stat == 0) {
            stat = pe_OpenType (pctxt, openType.numocts, openType.data);
        }
    #if 1
        if(encoded){//dungnm23 check lai nhe
            rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
        }
    #endif

    }

    if(stat!=0) return LOG_RTERR(pctxt, stat);  
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}

EXTERN int  asn1PD_e2ap_RICsubscriptionDeleteResponse_protocolIEs_element (OSCTXT* pctxt, e2ap_RICsubscriptionDeleteResponse_protocolIEs_element* pvalue){
    int stat =0;

    /*decode id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PD_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PD_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");

    {
        OSUINT32 openTypeLen;
        size_t bitStartOffset, bitLength;

        stat = pd_UnconsLength(pctxt, &openTypeLen);
        if(stat<0) return LOG_RTERR(pctxt, stat);
        else if(stat == RT_OK_FRAG){
            rtxErrAddStrParm(pctxt, "open type with fragment length");
            return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
        }
        bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
        bitLength = openTypeLen * 8;

        switch(pvalue->id){//dungnm23 check case lai nhe
        
            case ASN1V_e2ap_id_RICrequestID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionDeleteResponse_IEs_id_RICrequestID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICrequestID");
                pvalue->value.u._e2ap_RICsubscriptionDeleteResponse_IEs_id_RICrequestID 
                    = rtxMemAllocType(pctxt, e2ap_RICrequestID);

                asn1Init_e2ap_RICrequestID(pvalue->value.u._e2ap_RICsubscriptionDeleteResponse_IEs_id_RICrequestID);

                stat = asn1PD_e2ap_RICrequestID (pctxt,
                        (e2ap_RICrequestID*)pvalue->value.
                        u._e2ap_RICsubscriptionDeleteResponse_IEs_id_RICrequestID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RANfunctionID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionDeleteResponse_IEs_id_RANfunctionID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RANfunctionID");
                pvalue->value.u._e2ap_RICsubscriptionDeleteResponse_IEs_id_RANfunctionID 
                    = rtxMemAllocType(pctxt, e2ap_RANfunctionID);

                asn1Init_e2ap_RANfunctionID(pvalue->value.u._e2ap_RICsubscriptionDeleteResponse_IEs_id_RANfunctionID);

                stat = asn1PD_e2ap_RANfunctionID (pctxt,
                        (e2ap_RANfunctionID*)pvalue->value.
                        u._e2ap_RICsubscriptionDeleteResponse_IEs_id_RANfunctionID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionDeleteResponse_IEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*) rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
    }
    {
    size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
    size_t bitsConsumed = bitEndOffset-bitStartOffset;
    if(bitsConsumed<bitLength){
        stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
    }
    else stat =(bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
    }}
    if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}


int asn1Init_e2ap_RICsubscriptionDeleteResponse_protocolIEs_element(e2ap_RICsubscriptionDeleteResponse_protocolIEs_element* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    OSCRTLMEMSET (&pvalue->value, 0, sizeof(pvalue->value));
    return 0;
}


//-----> chuaw có template rtxFreeASN1OpenType

#if 0
void asn1Free_e2ap_RICsubscriptionDeleteResponse_protocolIEs_element(OSCTXT* pctxt, e2ap_RICsubscriptionDeleteResponse_protocolIEs_element* pvalue)
{
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionDeleteResponse_IEs_id_id_RICrequestID:
            // rtxFreeE2ap_RICrequestID(pvalue->value.u._e2ap_RICsubscriptionDeleteResponse_IEs_id_id_RICrequestID);

            if(pvalue->value.i._e2ap_RICsubscriptionDeleteResponse_id_RICrequestID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICrequestID(pctxt, pvalue->value.u._e2ap_RICsubscriptionDeleteResponse_IEs_id_id_RICrequestID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionDeleteResponse_IEs_id_id_RICrequestID);
           // pvalue->value.u._e2ap_RICsubscriptionDeleteResponse_IEs_id_id_RICrequestID = NULL;
           pvalue->value.u._e2ap_RICsubscriptionDeleteResponse_IEs_id_RICrequestID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionDeleteResponse_IEs_id_id_RANfunctionID:
            // rtxFreeE2ap_RANfunctionID(pvalue->value.u._e2ap_RICsubscriptionDeleteResponse_IEs_id_id_RANfunctionID);

            if(pvalue->value.i._e2ap_RICsubscriptionDeleteResponse_id_RANfunctionID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RANfunctionID(pctxt, pvalue->value.u._e2ap_RICsubscriptionDeleteResponse_IEs_id_id_RANfunctionID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionDeleteResponse_IEs_id_id_RANfunctionID);
           // pvalue->value.u._e2ap_RICsubscriptionDeleteResponse_IEs_id_id_RANfunctionID = NULL;
           pvalue->value.u._e2ap_RICsubscriptionDeleteResponse_IEs_id_RANfunctionID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionDeleteResponse_IEs_UNDEF_:
            rtxFreeASN1OpenType(pvalue->value.u.extElem1);
            break;
        default:
            break;
    }
}

int asn1PrtToStr_e2ap_RICsubscriptionDeleteResponse_protocolIEs_element(OSCTXT* pctxt, e2ap_RICsubscriptionDeleteResponse_protocolIEs_element* pvalue)
{
    int stat =0;
    RTXCTXTPUSHELEMNAME(pctxt, "e2ap_RICsubscriptionDeleteResponse_protocolIEs_element");

    /*print id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PrtToStr_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PrtToStr_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionDeleteResponse_IEs_id_id_RICrequestID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICrequestID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICrequestID (pctxt, pvalue->value.u._e2ap_RICsubscriptionDeleteResponse_IEs_id_id_RICrequestID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionDeleteResponse_IEs_id_id_RANfunctionID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RANfunctionID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RANfunctionID (pctxt, pvalue->value.u._e2ap_RICsubscriptionDeleteResponse_IEs_id_id_RANfunctionID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionDeleteResponse_IEs_UNDEF_:
            {
                rtxPLogMsg(pctxt, "Extension element present - raw data not printed.\n");
                break;
            }

            default:
                stat = RTERR_INVOPT;
                return LOG_RTERR(pctxt, stat);
        }
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);
}
#endif


int asn1PrtToStr_e2ap_RICsubscriptionDeleteResponse_protocolIEs_element (const char * name,
 e2ap_RICsubscriptionDeleteResponse_protocolIEs_element* pvalue, 
 char * buffer, OSSIZE bufSize){
    if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
        return -1;
    if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
        return -1;

    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionDeleteResponse_IEs_id_RICrequestID:
            if(asn1PrtToStr_e2ap_RICrequestID("RICrequestID", 
                    pvalue->value.u._e2ap_RICsubscriptionDeleteResponse_IEs_id_RICrequestID, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionDeleteResponse_IEs_id_RANfunctionID:
            if(asn1PrtToStr_e2ap_RANfunctionID("RANfunctionID", 
                    pvalue->value.u._e2ap_RICsubscriptionDeleteResponse_IEs_id_RANfunctionID, buffer, bufSize)<0)
                return -1;
            break;    
        default:
        if(0!=pvalue -> value.u.extElem1){
            rtPrintToStringIndent(buffer, bufSize);
            rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

        }
        }
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

    return 0;

 }

 void asn1Free_e2ap_RICsubscriptionDeleteResponse_protocolIEs_element(OSCTXT* pctxt, e2ap_RICsubscriptionDeleteResponse_protocolIEs_element* pvalue){
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionDeleteResponse_IEs_id_RICrequestID:
            if(pvalue->value.u._e2ap_RICsubscriptionDeleteResponse_IEs_id_RICrequestID!=NULL){
            asn1Free_e2ap_RICrequestID(pctxt, pvalue->value.u._e2ap_RICsubscriptionDeleteResponse_IEs_id_RICrequestID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionDeleteResponse_IEs_id_RICrequestID);
            pvalue->value.u._e2ap_RICsubscriptionDeleteResponse_IEs_id_RICrequestID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionDeleteResponse_IEs_id_RANfunctionID:
            if(pvalue->value.u._e2ap_RICsubscriptionDeleteResponse_IEs_id_RANfunctionID!=NULL){
            asn1Free_e2ap_RANfunctionID(pctxt, pvalue->value.u._e2ap_RICsubscriptionDeleteResponse_IEs_id_RANfunctionID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionDeleteResponse_IEs_id_RANfunctionID);
            pvalue->value.u._e2ap_RICsubscriptionDeleteResponse_IEs_id_RANfunctionID = NULL;
            }
            break;
        default:
            break;


    }
 }

 

/*****************************************/
/*           RICsubscriptionDeleteResponse                */
/*****************************************/
//2_container.c
/* 1. xxx_ProtocolIE -> mẫu cũ ở ie_big_msg */
EXTERN int asn1PE_e2ap_RICsubscriptionDeleteResponse_protocolIEs (OSCTXT* pctxt, e2ap_RICsubscriptionDeleteResponse_protocolIEs* pvalue)
{
    int stat =0;
    OSRTDListNode* pnode;
    OSUINT32 xx1;

    /*encode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pe_Length(pctxt, pvalue->count);
    if(stat<0) return LOG_RTERR(pctxt, stat);

    /*encode each element*/
    xx1 =0;
    for(pnode = pvalue->head; pnode != 0 && xx1<pvalue->count; pnode = pnode->next){
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE", xx1);
        stat = asn1PE_e2ap_RICsubscriptionDeleteResponse_protocolIEs_element (pctxt, ((e2ap_RICsubscriptionDeleteResponse_protocolIEs_element*)pnode->data));
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        xx1++;
        RTXCTXTPOPARRAYELEMNAME(pctxt);
    }

    return (stat);
}

EXTERN int  asn1PD_e2ap_RICsubscriptionDeleteResponse_protocolIEs(OSCTXT* pctxt, e2ap_RICsubscriptionDeleteResponse_protocolIEs* pvalue)
{
     int stat =0;
     OSRTDListNode* pnode;
     OSSIZE count =0;
     OSSIZE xx1=0;


     /*decode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pd_Length64(pctxt, &count); //tai sao lai 64
    if(stat!=0) return LOG_RTERR(pctxt, stat);

    /*decode each element*/
    rtxDListInit(pvalue);

    for(xx1=0; xx1 < count; xx1++){
        e2ap_RICsubscriptionDeleteResponse_protocolIEs_element* pdata;
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE",xx1);

        if(pnode == NULL) return LOG_RTERR(pctxt, RTERR_NOMEM);

        asn1Init_e2ap_RICsubscriptionDeleteResponse_protocolIEs_element(pdata);
        rtxDListAppendNode(pvalue, pnode);
        stat = asn1PD_e2ap_RICsubscriptionDeleteResponse_protocolIEs_element (pctxt, pdata);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        RTXCTXTPOPARRAYELEMNAME(pctxt);

    }
    return (stat);
}


int asn1Init_e2ap_RICsubscriptionDeleteResponse_protocolIEs(e2ap_RICsubscriptionDeleteResponse_protocolIEs* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    rtxDListFastInit (pvalue);
    return 0;
}
#if 1 //ao that day
void asn1Free_e2ap_RICsubscriptionDeleteResponse_protocolIEs(OSCTXT* pctxt, e2ap_RICsubscriptionDeleteResponse_protocolIEs* pvalue)
{
    if(0==pvalue) return;   
    e2ap_RICsubscriptionDeleteResponse_protocolIEs_element* pdata;
    OSRTDListNode* pnode=pvalue->head;
    while(0!=pnode){
        pdata = (e2ap_RICsubscriptionDeleteResponse_protocolIEs_element*)pnode->data;
       // asn1Free_e2ap_RICsubscriptionDeleteResponse_protocolIEs_element(pctxt, pdata);
        pnode = pnode->next;
    }
    rtxDListFreeAll(pctxt, pvalue);
}
#endif


EXTERN int asn1PrtToStr_e2ap_RICsubscriptionDeleteResponse_protocolIEs(const char* name, e2ap_RICsubscriptionDeleteResponse_protocolIEs* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_RICsubscriptionDeleteResponse_protocolIEs_element* pdata0;
    OSRTDListNode* pnode0;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode0 = pvalue->head;  xx1 < pvalue->count && pnode0 != 0; pnode0 = pnode0->next, xx1++){
        pdata0 = (e2ap_RICsubscriptionDeleteResponse_protocolIEs_element*)pnode0->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 0
        if(asn1PrtToStr_e2ap_RICsubscriptionDeleteResponse_protocolIEs_element(nameBuf, pdata0, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}


/*2 . RICsubscriptionDeleteResponse -> mẫu cũ ở seq_normal*/

int asn1PE_e2ap_RICsubscriptionDeleteResponse (OSCTXT* pctxt, e2ap_RICsubscriptionDeleteResponse* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RICsubscriptionDeleteResponse");
   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field protocolIEs - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
   stat = asn1PE_e2ap_RICsubscriptionDeleteResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
   if(stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RICsubscriptionDeleteResponse (OSCTXT* pctxt, e2ap_RICsubscriptionDeleteResponse* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME(pctxt, "RICsubscriptionDeleteResponse");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field protocolIEs */
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
      stat = asn1PD_e2ap_RICsubscriptionDeleteResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RICsubscriptionDeleteResponse (e2ap_RICsubscriptionDeleteResponse* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RICsubscriptionDeleteResponse_protocolIEs(&pvalue->protocolIEs);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RICsubscriptionDeleteResponse (OSCTXT* pctxt, e2ap_RICsubscriptionDeleteResponse* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_RICsubscriptionDeleteResponse_protocolIEs(pctxt, &pvalue->protocolIEs);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RICsubscriptionDeleteResponse (const char* name, e2ap_RICsubscriptionDeleteResponse* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }

   if(asn1PrtToStr_e2ap_RICsubscriptionDeleteResponse_protocolIEs("protocolIEs", &pvalue->protocolIEs, buffer, bufSize) <0){
      return -1;
   }

   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}
/*****************************************/
/*           RICsubscription-withCause-Item                */
/*****************************************/
//sequence normal
// Các nội dung cần thiết cho template seq_normal.c.j2

// Các phần còn lại của template seq_normal.c.j2
//contain extensition bit -> theo mau cua GlobalgNB-ID
int asn1PE_e2ap_RICsubscription_withCause_Item (OSCTXT* pctxt, e2ap_RICsubscription_withCause_Item* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RICsubscription-withCause-Item");

   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field ricRequestID - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "ricRequestID");
   stat = asn1PE_e2ap_RICrequestID (pctxt, pvalue->ricRequestID);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /* encode field ranFunctionID - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "ranFunctionID");
   stat = asn1PE_e2ap_RANfunctionID (pctxt, pvalue->ranFunctionID);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /* encode field cause - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "cause");
   stat = asn1PE_e2ap_Cause (pctxt, pvalue->cause);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);



   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RICsubscription_withCause_Item (OSCTXT* pctxt, e2ap_RICsubscription_withCause_Item* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[3];

   RTXCTXTPUSHTYPENAME(pctxt, "RICsubscription-withCause-Item");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field ricRequestID */
   RTXCTXTPUSHELEMNAME(pctxt, "ricRequestID");
      stat = asn1PD_e2ap_RICrequestID (pctxt, &pvalue->ricRequestID);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field ranFunctionID */
   RTXCTXTPUSHELEMNAME(pctxt, "ranFunctionID");
      stat = asn1PD_e2ap_RANfunctionID (pctxt, &pvalue->ranFunctionID);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field cause */
   RTXCTXTPUSHELEMNAME(pctxt, "cause");
      stat = asn1PD_e2ap_Cause (pctxt, &pvalue->cause);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RICsubscription_withCause_Item (e2ap_RICsubscription_withCause_Item* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RICrequestID (&pvalue->ricRequestID);
   asn1Init_e2ap_RANfunctionID (&pvalue->ranFunctionID);
   asn1Init_e2ap_Cause (&pvalue->cause);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RICsubscription_withCause_Item (OSCTXT* pctxt, e2ap_RICsubscription_withCause_Item* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_RICrequestID (pctxt, &pvalue->ricRequestID);
   asn1Free_e2ap_RANfunctionID (pctxt, &pvalue->ranFunctionID);
   asn1Free_e2ap_Cause (pctxt, &pvalue->cause);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RICsubscription_withCause_Item (const char* name, e2ap_RICsubscription_withCause_Item* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }
   if(asn1PrtToStr_e2ap_RICrequestID ("ricRequestID", &pvalue->ricRequestID, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_RANfunctionID ("ranFunctionID", &pvalue->ranFunctionID, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_Cause ("cause", &pvalue->cause, buffer, bufSize) < 0)
   {
      return -1;
   }



   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           RICsubscription_withCause_ItemIEs                */
/*****************************************/
/* ie.c.j2 */
/*ie thường*/
int asn1PE_e2ap_RICsubscription_withCause_ItemIEs (OSCTXT* pctxt, e2ap_RICsubscription_withCause_ItemIEs* pvalue)
{
   int stat = 0;
   //RTXCTXTPUSHTYPENAME (pctxt, "RICsubscription-withCause-ItemIEs");

   /* encode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");
   stat = asn1PE_e2ap_ProtocolIE_ID (pctxt, pvalue->id);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");
   stat = asn1PE_e2ap_Criticality (pctxt, pvalue->criticality);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   {
      OSCTXT ictxt;
      OSOCTET* pDynamicEncodeBuffer;
      ASN1OpenType openType;
      OSBOOL  encoded = TRUE;

      openType.numocts = 0;
      openType.data = 0;

      rtxCopyContext (&ictxt, pctxt);
      pctxt->pStream = 0;

      stat = rtxInitContextBuffer (pctxt, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_RICsubscription_withCause_ItemIEs_id_RICsubscription_withCause_Item:
         
        // RTXCTXTPUSHELEMNAME (pctxt, "RICsubscription_withCause_ItemIEs_id_RICsubscription_withCause_Item");
         RTXCTXTPUSHELEMNAME (pctxt, "RICsubscription-withCause-Item");
         stat = asn1PE_e2ap_RICsubscription_withCause_Item (pctxt, pvalue->value.u._e2apRICsubscription_withCause_ItemIEs_id_RICsubscription_withCause_Item);
         RTXCTXTPOPELEMNAME (pctxt);
      
         break;

      case T_E2AP_PDU_Contents_e2ap_RICsubscription_withCause_ItemIEs_UNDEF_:
      {
          if(0!=pvalue->value.u.extElem1){
              openType.numocts = pvalue->value.u.extElem1->numocts;
              openType.data = pvalue->value.u.extElem1->data;
          } else {
              /* No extension element to encode */
          }
          encoded = FALSE;
          break;
      }
      default:
         encoded = FALSE;
         stat = RTERR_INVOPT;
      }

      if (encoded) {
         openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
         openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
      }
      rtxCopyContext (pctxt, &ictxt);
      if(stat ==0) stat = pe_OpenType(pctxt, openType.numocts, openType.data);
      /*free dynamic encode buffer*/
      if(encoded){
          rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
      }
   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);
   //RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

int asn1PD_e2ap_RICsubscription_withCause_ItemIEs (OSCTXT* pctxt, e2ap_RICsubscription_withCause_ItemIEs* pvalue)
{
   int stat =0;
   /*deode root element id*/
   RTXCTXTPUSHELEMNAME(pctxt, "id");
   stat = asn1PD_e2ap_ProtocolIE_ID (pctxt, &pvalue->id);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*decode root element criticality*/
   RTXCTXTPUSHELEMNAME(pctxt, "criticality");
   stat = asn1PD_e2ap_Criticality (pctxt, &pvalue->criticality);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   /*decode root element value*/
   RTXCTXTPUSHELEMNAME(pctxt, "value");
   {
      OSUINT32 openTypeLen;
      size_t bitStartOffset, bitLength;
      stat = pd_UnconsLength(pctxt, &openTypeLen);
      if(stat <0) return LOG_RTERR(pctxt, stat);
      else if(stat == RT_OK_FRAG){
         rtxErrAddStrParm(pctxt, "open type with fragmented length use - perindef");
         return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
      }
      bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
      bitLength = openTypeLen * 8;
      switch (pvalue->id){
         case T_E2AP_PDU_Contents_e2ap_RICsubscription_withCause_ItemIEs_id_RICsubscription_withCause_Item:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscription_withCause_ItemIEs_id_RICsubscription_withCause_Item;
            RTXCTXTPUSHELEMNAME(pctxt, "RICsubscription-withCause-Item");
            //pvalue->value.u._e2ap_RICsubscription_withCause_ItemIEs_id_id_RICsubscription_withCause_Item 
             pvalue->value.u._e2apRICsubscription_withCause_ItemIEs_id_RICsubscription_withCause_Item 
                    = rtxMemAllocType(pctxt, e2ap_RICsubscription_withCause_Item);
            //asn1Init_e2ap_RICsubscription_withCause_Item(pvalue->value.u._e2ap_RICsubscription_withCause_ItemIEs_id_id_RICsubscription_withCause_Item);
            asn1Init_e2ap_RICsubscription_withCause_Item(pvalue->value.u._e2apRICsubscription_withCause_ItemIEs_id_RICsubscription_withCause_Item);
            stat = asn1PD_e2ap_RICsubscription_withCause_Item (pctxt,
                    (e2ap_RICsubscription_withCause_Item*)pvalue->value.
                    u._e2apRICsubscription_withCause_ItemIEs_id_RICsubscription_withCause_Item);
            if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscription_withCause_ItemIEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*)rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
      }
      {
      size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
      size_t bitsConsumed = bitEndOffset - bitStartOffset;
      if(bitsConsumed < bitLength){
         stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
      } else {
         stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
      }
      }
   }
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   return stat;
}

void asn1Init_e2ap_RICsubscription_withCause_ItemIEs (e2ap_RICsubscription_withCause_ItemIEs* pvalue)
{
   if (!pvalue) return;
   OSCRTLMEMSET (pvalue, 0, sizeof(e2ap_RICsubscription_withCause_ItemIEs));
}

#if 0
void asn1Free_e2ap_RICsubscription_withCause_ItemIEs (OSCTXT* pctxt, e2ap_RICsubscription_withCause_ItemIEs* pvalue)
{
   if (!pvalue) return;
   if (pvalue->extElem1) {
      rtxMemFreeArray (pctxt, pvalue->extElem1);
      pvalue->extElem1 = 0;
      pvalue->extElem1_n = 0;
   }
}
#endif
void asn1Free_e2ap_RICsubscription_withCause_ItemIEs (OSCTXT* pctxt, e2ap_RICsubscription_withCause_ItemIEs* pvalue)
{
   if(0==pvalue) return;
   switch(pvalue->value.t){
      case T_E2AP_PDU_Contents_e2ap_RICsubscription_withCause_ItemIEs_id_RICsubscription_withCause_Item:
         asn1Free_e2ap_RICsubscription_withCause_Item (pctxt, pvalue->value.u._e2apRICsubscription_withCause_ItemIEs_id_RICsubscription_withCause_Item);
         rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2apRICsubscription_withCause_ItemIEs_id_RICsubscription_withCause_Item);
         pvalue->value.u._e2apRICsubscription_withCause_ItemIEs_id_RICsubscription_withCause_Item = 0;
         break;
      case T_E2AP_PDU_Contents_e2ap_RICsubscription_withCause_ItemIEs_UNDEF_:
         if(0!=pvalue->value.u.extElem1){
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1->data);
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
             pvalue->value.u.extElem1 =0;
         }
         break;
         default:;
   }
}

int  asn1PrtToStr_e2ap_RICsubscription_withCause_ItemIEs (const char * name, e2ap_RICsubscription_withCause_ItemIEs* pvalue, char * buffer, OSSIZE bufSize){
   if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
       return -1;

      if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
         return -1;

      if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
         return -1;
      if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
         return -1;
      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_RICsubscription_withCause_ItemIEs_id_RICsubscription_withCause_Item:
         if(asn1PrtToStr_e2ap_RICsubscription_withCause_Item("RICsubscription-withCause-Item",
                pvalue->value.u._e2apRICsubscription_withCause_ItemIEs_id_RICsubscription_withCause_Item, buffer, bufSize)<0)// dungnm23 check lai nhe xem la
            return -1;
         break;
      default:
         if(0!=pvalue -> value.u.extElem1){
             rtPrintToStringIndent(buffer, bufSize);
             rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

         }
      }
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

      return 0;

}
 

/*****************************************/
/*           RICsubscription_List_withCause                */
/*****************************************/
//seq_of_single_container


int asn1PE_e2ap_RICsubscription_List_withCause (OSCTXT* pctxt, e2ap_RICsubscription_List_withCause* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_RICsubscription_withCause_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "RICsubscription-List-withCause");

   /* encode length determinant */
   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1024), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;
   for (xx1 = 0; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next, xx1++) {
      pdata = (e2ap_RICsubscription_withCause_ItemIEs*) pnode->data;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_e2ap_RICsubscription_withCause_ItemIEs (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      //xx1++;
      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}

int asn1PD_e2ap_RICsubscription_List_withCause (OSCTXT* pctxt, e2ap_RICsubscription_List_withCause* ppvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_RICsubscription_withCause_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "RICsubscription-List-withCause");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1024), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (ppvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      pdata = rtxMemAllocType (pctxt, e2ap_RICsubscription_withCause_ItemIEs);
      if (!pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);
      asn1Init_e2ap_RICsubscription_withCause_ItemIEs (pdata);
      stat = asn1PD_e2ap_RICsubscription_withCause_ItemIEs (pctxt, pdata);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         return LOG_RTERR (pctxt, stat);
      }

      rtxDListAppendNode (ppvalue, pdata);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

void asn1Init_e2ap_RICsubscription_List_withCause (e2ap_RICsubscription_List_withCause* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
}

void asn1Free_e2ap_RICsubscription_List_withCause (OSCTXT* pctxt, e2ap_RICsubscription_List_withCause* pvalue)
{
   if(pvalue==0) return;
   OSRTDListNode* pnode = pvalue->head;
   while (pnode) {
      e2ap_RICsubscription_withCause_ItemIEs* pdata = (e2ap_RICsubscription_withCause_ItemIEs*) pnode->data;
      if (pdata) {
         asn1Free_e2ap_RICsubscription_withCause_ItemIEs (pctxt, pdata);
         rtxMemFreePtr (pctxt, pdata);
      }
      pnode = pnode->next;
   }
      rtxDListFreeAll(pctxt, pvalue);
}

#if 0
void asn1Free_e2ap_RICsubscription_List_withCause (OSCTXT* pctxt, e2ap_RICsubscription_List_withCause* pvalue){
   if(0==pvalue ) return;
   {
      e2ap_RICsubscription_withCause_ItemIEs * pdata;
      OSRTDListNode *pnode = pvalue->head;
      while(0!=pnode){
         pdata = (e2ap_RICsubscription_withCause_ItemIEs*)pnode->data;
         asn1Free_e2ap_RICsubscription_withCause_ItemIEs(pctxt, pdata);
         pnode = pnode->next;
      }
      rtxDListFreeAll(pctxt, pvalue);
   }
}
#endif


int asn1PrtToStr_e2ap_RICsubscription_List_withCause(const char* name, e2ap_RICsubscription_List_withCause* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_RICsubscription_withCause_ItemIEs* pdata;
    OSRTDListNode* pnode;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode = pvalue->head;  xx1 < pvalue->count && pnode != 0; pnode = pnode->next, xx1++){
        pdata = (e2ap_RICsubscription_withCause_ItemIEs*)pnode->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 1
        if(asn1PrtToStr_e2ap_RICsubscription_withCause_ItemIEs(nameBuf, pdata, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}/*****************************************/
/*           RICsubscriptionDeleteRequired_IEs                */
/*****************************************/
/* ie.c.j2 */
 /* d là con của msg */
EXTERN int asn1PE_e2ap_RICsubscriptionDeleteRequired_protocolIEs_element (OSCTXT* pctxt, e2ap_RICsubscriptionDeleteRequired_protocolIEs_element* pvalue)
{
    int stat =0;

    /*encode id*/

    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PE_e2ap_ProtocolIE_ID(pctxt, pvalue->id);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PE_e2ap_Criticality(pctxt, pvalue->criticality);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
    {
        OSCTXT lctxt;
        OSOCTET *pDynamicEncodeBuffer;
        ASN1OpenType openType;
        OSBOOL encoded = TRUE;

        openType.numocts = 0;
        openType.data =0;

        rtxCopyContext(&lctxt, pctxt);
        pctxt->pStream =0;

        stat = rtxInitContextBuffer(pctxt, 0, 0);
        if(stat!=0) return LOG_RTERR(pctxt, stat);

        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionDeleteRequired_IEs_id_RICsubscriptionToBeRemoved:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICsubscriptionToBeRemoved");
                    stat = asn1PE_e2ap_RICsubscription_List_withCause (pctxt, pvalue->value.u._e2ap_RICsubscriptionDeleteRequired_IEs_id_RICsubscriptionToBeRemoved);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionDeleteRequired_IEs_UNDEF_:
            {
                if(0!=pvalue->value.u.extElem1){
                    openType.numocts = pvalue->value.u.extElem1->numocts;
                    openType.data = pvalue->value.u.extElem1->data;
                } else {
                    /* No extension element to encode */
                }
                encoded = FALSE;
                break;
            }

            default:
                encoded = FALSE;
                stat = RTERR_INVOPT;
                break;
        } 

        if(encoded){
            openType.numocts = (OSUINT32)pe_GetMsgLen(pctxt);
            openType.data = pDynamicEncodeBuffer = pctxt -> buffer.data;
        }
        rtxCopyContext(pctxt, &lctxt);

        if(stat == 0) {
            stat = pe_OpenType (pctxt, openType.numocts, openType.data);
        }
    #if 1
        if(encoded){//dungnm23 check lai nhe
            rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
        }
    #endif

    }

    if(stat!=0) return LOG_RTERR(pctxt, stat);  
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}

EXTERN int  asn1PD_e2ap_RICsubscriptionDeleteRequired_protocolIEs_element (OSCTXT* pctxt, e2ap_RICsubscriptionDeleteRequired_protocolIEs_element* pvalue){
    int stat =0;

    /*decode id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PD_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PD_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");

    {
        OSUINT32 openTypeLen;
        size_t bitStartOffset, bitLength;

        stat = pd_UnconsLength(pctxt, &openTypeLen);
        if(stat<0) return LOG_RTERR(pctxt, stat);
        else if(stat == RT_OK_FRAG){
            rtxErrAddStrParm(pctxt, "open type with fragment length");
            return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
        }
        bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
        bitLength = openTypeLen * 8;

        switch(pvalue->id){//dungnm23 check case lai nhe
        
            case ASN1V_e2ap_id_RICsubscriptionToBeRemoved:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionDeleteRequired_IEs_id_RICsubscriptionToBeRemoved;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICsubscriptionToBeRemoved");
                pvalue->value.u._e2ap_RICsubscriptionDeleteRequired_IEs_id_RICsubscriptionToBeRemoved 
                    = rtxMemAllocType(pctxt, e2ap_RICsubscription_List_withCause);

                asn1Init_e2ap_RICsubscription_List_withCause(pvalue->value.u._e2ap_RICsubscriptionDeleteRequired_IEs_id_RICsubscriptionToBeRemoved);

                stat = asn1PD_e2ap_RICsubscription_List_withCause (pctxt,
                        (e2ap_RICsubscription_List_withCause*)pvalue->value.
                        u._e2ap_RICsubscriptionDeleteRequired_IEs_id_RICsubscriptionToBeRemoved);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionDeleteRequired_IEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*) rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
    }
    {
    size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
    size_t bitsConsumed = bitEndOffset-bitStartOffset;
    if(bitsConsumed<bitLength){
        stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
    }
    else stat =(bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
    }}
    if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}


int asn1Init_e2ap_RICsubscriptionDeleteRequired_protocolIEs_element(e2ap_RICsubscriptionDeleteRequired_protocolIEs_element* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    OSCRTLMEMSET (&pvalue->value, 0, sizeof(pvalue->value));
    return 0;
}


//-----> chuaw có template rtxFreeASN1OpenType

#if 0
void asn1Free_e2ap_RICsubscriptionDeleteRequired_protocolIEs_element(OSCTXT* pctxt, e2ap_RICsubscriptionDeleteRequired_protocolIEs_element* pvalue)
{
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionDeleteRequired_IEs_id_id_RICsubscriptionToBeRemoved:
            // rtxFreeE2ap_RICsubscription_List_withCause(pvalue->value.u._e2ap_RICsubscriptionDeleteRequired_IEs_id_id_RICsubscriptionToBeRemoved);

            if(pvalue->value.i._e2ap_RICsubscriptionDeleteRequired_id_RICsubscription_List_withCause!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICsubscription_List_withCause(pctxt, pvalue->value.u._e2ap_RICsubscriptionDeleteRequired_IEs_id_id_RICsubscriptionToBeRemoved);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionDeleteRequired_IEs_id_id_RICsubscriptionToBeRemoved);
           // pvalue->value.u._e2ap_RICsubscriptionDeleteRequired_IEs_id_id_RICsubscriptionToBeRemoved = NULL;
           pvalue->value.u._e2ap_RICsubscriptionDeleteRequired_IEs_id_RICsubscriptionToBeRemoved = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionDeleteRequired_IEs_UNDEF_:
            rtxFreeASN1OpenType(pvalue->value.u.extElem1);
            break;
        default:
            break;
    }
}

int asn1PrtToStr_e2ap_RICsubscriptionDeleteRequired_protocolIEs_element(OSCTXT* pctxt, e2ap_RICsubscriptionDeleteRequired_protocolIEs_element* pvalue)
{
    int stat =0;
    RTXCTXTPUSHELEMNAME(pctxt, "e2ap_RICsubscriptionDeleteRequired_protocolIEs_element");

    /*print id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PrtToStr_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PrtToStr_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionDeleteRequired_IEs_id_id_RICsubscriptionToBeRemoved:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICsubscription-List-withCause");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICsubscription_List_withCause (pctxt, pvalue->value.u._e2ap_RICsubscriptionDeleteRequired_IEs_id_id_RICsubscriptionToBeRemoved);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionDeleteRequired_IEs_UNDEF_:
            {
                rtxPLogMsg(pctxt, "Extension element present - raw data not printed.\n");
                break;
            }

            default:
                stat = RTERR_INVOPT;
                return LOG_RTERR(pctxt, stat);
        }
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);
}
#endif


int asn1PrtToStr_e2ap_RICsubscriptionDeleteRequired_protocolIEs_element (const char * name,
 e2ap_RICsubscriptionDeleteRequired_protocolIEs_element* pvalue, 
 char * buffer, OSSIZE bufSize){
    if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
        return -1;
    if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
        return -1;

    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionDeleteRequired_IEs_id_RICsubscriptionToBeRemoved:
            if(asn1PrtToStr_e2ap_RICsubscription_List_withCause("RICsubscription-List-withCause", 
                    pvalue->value.u._e2ap_RICsubscriptionDeleteRequired_IEs_id_RICsubscriptionToBeRemoved, buffer, bufSize)<0)
                return -1;
            break;    
        default:
        if(0!=pvalue -> value.u.extElem1){
            rtPrintToStringIndent(buffer, bufSize);
            rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

        }
        }
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

    return 0;

 }

 void asn1Free_e2ap_RICsubscriptionDeleteRequired_protocolIEs_element(OSCTXT* pctxt, e2ap_RICsubscriptionDeleteRequired_protocolIEs_element* pvalue){
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionDeleteRequired_IEs_id_RICsubscriptionToBeRemoved:
            if(pvalue->value.u._e2ap_RICsubscriptionDeleteRequired_IEs_id_RICsubscriptionToBeRemoved!=NULL){
            asn1Free_e2ap_RICsubscription_List_withCause(pctxt, pvalue->value.u._e2ap_RICsubscriptionDeleteRequired_IEs_id_RICsubscriptionToBeRemoved);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionDeleteRequired_IEs_id_RICsubscriptionToBeRemoved);
            pvalue->value.u._e2ap_RICsubscriptionDeleteRequired_IEs_id_RICsubscriptionToBeRemoved = NULL;
            }
            break;
        default:
            break;


    }
 }

 

/*****************************************/
/*           RICsubscriptionDeleteRequired                */
/*****************************************/
//2_container.c
/* 1. xxx_ProtocolIE -> mẫu cũ ở ie_big_msg */
EXTERN int asn1PE_e2ap_RICsubscriptionDeleteRequired_protocolIEs (OSCTXT* pctxt, e2ap_RICsubscriptionDeleteRequired_protocolIEs* pvalue)
{
    int stat =0;
    OSRTDListNode* pnode;
    OSUINT32 xx1;

    /*encode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pe_Length(pctxt, pvalue->count);
    if(stat<0) return LOG_RTERR(pctxt, stat);

    /*encode each element*/
    xx1 =0;
    for(pnode = pvalue->head; pnode != 0 && xx1<pvalue->count; pnode = pnode->next){
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE", xx1);
        stat = asn1PE_e2ap_RICsubscriptionDeleteRequired_protocolIEs_element (pctxt, ((e2ap_RICsubscriptionDeleteRequired_protocolIEs_element*)pnode->data));
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        xx1++;
        RTXCTXTPOPARRAYELEMNAME(pctxt);
    }

    return (stat);
}

EXTERN int  asn1PD_e2ap_RICsubscriptionDeleteRequired_protocolIEs(OSCTXT* pctxt, e2ap_RICsubscriptionDeleteRequired_protocolIEs* pvalue)
{
     int stat =0;
     OSRTDListNode* pnode;
     OSSIZE count =0;
     OSSIZE xx1=0;


     /*decode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pd_Length64(pctxt, &count); //tai sao lai 64
    if(stat!=0) return LOG_RTERR(pctxt, stat);

    /*decode each element*/
    rtxDListInit(pvalue);

    for(xx1=0; xx1 < count; xx1++){
        e2ap_RICsubscriptionDeleteRequired_protocolIEs_element* pdata;
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE",xx1);

        if(pnode == NULL) return LOG_RTERR(pctxt, RTERR_NOMEM);

        asn1Init_e2ap_RICsubscriptionDeleteRequired_protocolIEs_element(pdata);
        rtxDListAppendNode(pvalue, pnode);
        stat = asn1PD_e2ap_RICsubscriptionDeleteRequired_protocolIEs_element (pctxt, pdata);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        RTXCTXTPOPARRAYELEMNAME(pctxt);

    }
    return (stat);
}


int asn1Init_e2ap_RICsubscriptionDeleteRequired_protocolIEs(e2ap_RICsubscriptionDeleteRequired_protocolIEs* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    rtxDListFastInit (pvalue);
    return 0;
}
#if 1 //ao that day
void asn1Free_e2ap_RICsubscriptionDeleteRequired_protocolIEs(OSCTXT* pctxt, e2ap_RICsubscriptionDeleteRequired_protocolIEs* pvalue)
{
    if(0==pvalue) return;   
    e2ap_RICsubscriptionDeleteRequired_protocolIEs_element* pdata;
    OSRTDListNode* pnode=pvalue->head;
    while(0!=pnode){
        pdata = (e2ap_RICsubscriptionDeleteRequired_protocolIEs_element*)pnode->data;
       // asn1Free_e2ap_RICsubscriptionDeleteRequired_protocolIEs_element(pctxt, pdata);
        pnode = pnode->next;
    }
    rtxDListFreeAll(pctxt, pvalue);
}
#endif


EXTERN int asn1PrtToStr_e2ap_RICsubscriptionDeleteRequired_protocolIEs(const char* name, e2ap_RICsubscriptionDeleteRequired_protocolIEs* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_RICsubscriptionDeleteRequired_protocolIEs_element* pdata0;
    OSRTDListNode* pnode0;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode0 = pvalue->head;  xx1 < pvalue->count && pnode0 != 0; pnode0 = pnode0->next, xx1++){
        pdata0 = (e2ap_RICsubscriptionDeleteRequired_protocolIEs_element*)pnode0->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 0
        if(asn1PrtToStr_e2ap_RICsubscriptionDeleteRequired_protocolIEs_element(nameBuf, pdata0, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}


/*2 . RICsubscriptionDeleteRequired -> mẫu cũ ở seq_normal*/

int asn1PE_e2ap_RICsubscriptionDeleteRequired (OSCTXT* pctxt, e2ap_RICsubscriptionDeleteRequired* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RICsubscriptionDeleteRequired");
   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field protocolIEs - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
   stat = asn1PE_e2ap_RICsubscriptionDeleteRequired_protocolIEs (pctxt, &pvalue->protocolIEs);
   if(stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RICsubscriptionDeleteRequired (OSCTXT* pctxt, e2ap_RICsubscriptionDeleteRequired* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME(pctxt, "RICsubscriptionDeleteRequired");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field protocolIEs */
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
      stat = asn1PD_e2ap_RICsubscriptionDeleteRequired_protocolIEs (pctxt, &pvalue->protocolIEs);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RICsubscriptionDeleteRequired (e2ap_RICsubscriptionDeleteRequired* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RICsubscriptionDeleteRequired_protocolIEs(&pvalue->protocolIEs);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RICsubscriptionDeleteRequired (OSCTXT* pctxt, e2ap_RICsubscriptionDeleteRequired* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_RICsubscriptionDeleteRequired_protocolIEs(pctxt, &pvalue->protocolIEs);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RICsubscriptionDeleteRequired (const char* name, e2ap_RICsubscriptionDeleteRequired* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }

   if(asn1PrtToStr_e2ap_RICsubscriptionDeleteRequired_protocolIEs("protocolIEs", &pvalue->protocolIEs, buffer, bufSize) <0){
      return -1;
   }

   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}
/*****************************************/
/*           RICaction-ToBeRemovedForModification-Item                */
/*****************************************/
//sequence normal
// Các nội dung cần thiết cho template seq_normal.c.j2

// Các phần còn lại của template seq_normal.c.j2
//contain extensition bit -> theo mau cua GlobalgNB-ID
int asn1PE_e2ap_RICaction_ToBeRemovedForModification_Item (OSCTXT* pctxt, e2ap_RICaction_ToBeRemovedForModification_Item* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RICaction-ToBeRemovedForModification-Item");

   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field ricActionID - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "ricActionID");
   stat = asn1PE_e2ap_RICactionID (pctxt, pvalue->ricActionID);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);



   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RICaction_ToBeRemovedForModification_Item (OSCTXT* pctxt, e2ap_RICaction_ToBeRemovedForModification_Item* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME(pctxt, "RICaction-ToBeRemovedForModification-Item");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field ricActionID */
   RTXCTXTPUSHELEMNAME(pctxt, "ricActionID");
      stat = asn1PD_e2ap_RICactionID (pctxt, &pvalue->ricActionID);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RICaction_ToBeRemovedForModification_Item (e2ap_RICaction_ToBeRemovedForModification_Item* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RICactionID (&pvalue->ricActionID);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RICaction_ToBeRemovedForModification_Item (OSCTXT* pctxt, e2ap_RICaction_ToBeRemovedForModification_Item* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_RICactionID (pctxt, &pvalue->ricActionID);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RICaction_ToBeRemovedForModification_Item (const char* name, e2ap_RICaction_ToBeRemovedForModification_Item* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }
   if(asn1PrtToStr_e2ap_RICactionID ("ricActionID", &pvalue->ricActionID, buffer, bufSize) < 0)
   {
      return -1;
   }



   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           RICaction_ToBeRemovedForModification_ItemIEs                */
/*****************************************/
/* ie.c.j2 */
/*ie thường*/
int asn1PE_e2ap_RICaction_ToBeRemovedForModification_ItemIEs (OSCTXT* pctxt, e2ap_RICaction_ToBeRemovedForModification_ItemIEs* pvalue)
{
   int stat = 0;
   //RTXCTXTPUSHTYPENAME (pctxt, "RICaction-ToBeRemovedForModification-ItemIEs");

   /* encode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");
   stat = asn1PE_e2ap_ProtocolIE_ID (pctxt, pvalue->id);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");
   stat = asn1PE_e2ap_Criticality (pctxt, pvalue->criticality);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   {
      OSCTXT ictxt;
      OSOCTET* pDynamicEncodeBuffer;
      ASN1OpenType openType;
      OSBOOL  encoded = TRUE;

      openType.numocts = 0;
      openType.data = 0;

      rtxCopyContext (&ictxt, pctxt);
      pctxt->pStream = 0;

      stat = rtxInitContextBuffer (pctxt, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_RICaction_ToBeRemovedForModification_ItemIEs_id_RICaction_ToBeRemovedForModification_Item:
         
        // RTXCTXTPUSHELEMNAME (pctxt, "RICaction_ToBeRemovedForModification_ItemIEs_id_RICaction_ToBeRemovedForModification_Item");
         RTXCTXTPUSHELEMNAME (pctxt, "RICaction-ToBeRemovedForModification-Item");
         stat = asn1PE_e2ap_RICaction_ToBeRemovedForModification_Item (pctxt, pvalue->value.u._e2apRICaction_ToBeRemovedForModification_ItemIEs_id_RICaction_ToBeRemovedForModification_Item);
         RTXCTXTPOPELEMNAME (pctxt);
      
         break;

      case T_E2AP_PDU_Contents_e2ap_RICaction_ToBeRemovedForModification_ItemIEs_UNDEF_:
      {
          if(0!=pvalue->value.u.extElem1){
              openType.numocts = pvalue->value.u.extElem1->numocts;
              openType.data = pvalue->value.u.extElem1->data;
          } else {
              /* No extension element to encode */
          }
          encoded = FALSE;
          break;
      }
      default:
         encoded = FALSE;
         stat = RTERR_INVOPT;
      }

      if (encoded) {
         openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
         openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
      }
      rtxCopyContext (pctxt, &ictxt);
      if(stat ==0) stat = pe_OpenType(pctxt, openType.numocts, openType.data);
      /*free dynamic encode buffer*/
      if(encoded){
          rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
      }
   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);
   //RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

int asn1PD_e2ap_RICaction_ToBeRemovedForModification_ItemIEs (OSCTXT* pctxt, e2ap_RICaction_ToBeRemovedForModification_ItemIEs* pvalue)
{
   int stat =0;
   /*deode root element id*/
   RTXCTXTPUSHELEMNAME(pctxt, "id");
   stat = asn1PD_e2ap_ProtocolIE_ID (pctxt, &pvalue->id);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*decode root element criticality*/
   RTXCTXTPUSHELEMNAME(pctxt, "criticality");
   stat = asn1PD_e2ap_Criticality (pctxt, &pvalue->criticality);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   /*decode root element value*/
   RTXCTXTPUSHELEMNAME(pctxt, "value");
   {
      OSUINT32 openTypeLen;
      size_t bitStartOffset, bitLength;
      stat = pd_UnconsLength(pctxt, &openTypeLen);
      if(stat <0) return LOG_RTERR(pctxt, stat);
      else if(stat == RT_OK_FRAG){
         rtxErrAddStrParm(pctxt, "open type with fragmented length use - perindef");
         return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
      }
      bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
      bitLength = openTypeLen * 8;
      switch (pvalue->id){
         case T_E2AP_PDU_Contents_e2ap_RICaction_ToBeRemovedForModification_ItemIEs_id_RICaction_ToBeRemovedForModification_Item:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICaction_ToBeRemovedForModification_ItemIEs_id_RICaction_ToBeRemovedForModification_Item;
            RTXCTXTPUSHELEMNAME(pctxt, "RICaction-ToBeRemovedForModification-Item");
            //pvalue->value.u._e2ap_RICaction_ToBeRemovedForModification_ItemIEs_id_id_RICaction_ToBeRemovedForModification_Item 
             pvalue->value.u._e2apRICaction_ToBeRemovedForModification_ItemIEs_id_RICaction_ToBeRemovedForModification_Item 
                    = rtxMemAllocType(pctxt, e2ap_RICaction_ToBeRemovedForModification_Item);
            //asn1Init_e2ap_RICaction_ToBeRemovedForModification_Item(pvalue->value.u._e2ap_RICaction_ToBeRemovedForModification_ItemIEs_id_id_RICaction_ToBeRemovedForModification_Item);
            asn1Init_e2ap_RICaction_ToBeRemovedForModification_Item(pvalue->value.u._e2apRICaction_ToBeRemovedForModification_ItemIEs_id_RICaction_ToBeRemovedForModification_Item);
            stat = asn1PD_e2ap_RICaction_ToBeRemovedForModification_Item (pctxt,
                    (e2ap_RICaction_ToBeRemovedForModification_Item*)pvalue->value.
                    u._e2apRICaction_ToBeRemovedForModification_ItemIEs_id_RICaction_ToBeRemovedForModification_Item);
            if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICaction_ToBeRemovedForModification_ItemIEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*)rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
      }
      {
      size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
      size_t bitsConsumed = bitEndOffset - bitStartOffset;
      if(bitsConsumed < bitLength){
         stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
      } else {
         stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
      }
      }
   }
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   return stat;
}

void asn1Init_e2ap_RICaction_ToBeRemovedForModification_ItemIEs (e2ap_RICaction_ToBeRemovedForModification_ItemIEs* pvalue)
{
   if (!pvalue) return;
   OSCRTLMEMSET (pvalue, 0, sizeof(e2ap_RICaction_ToBeRemovedForModification_ItemIEs));
}

#if 0
void asn1Free_e2ap_RICaction_ToBeRemovedForModification_ItemIEs (OSCTXT* pctxt, e2ap_RICaction_ToBeRemovedForModification_ItemIEs* pvalue)
{
   if (!pvalue) return;
   if (pvalue->extElem1) {
      rtxMemFreeArray (pctxt, pvalue->extElem1);
      pvalue->extElem1 = 0;
      pvalue->extElem1_n = 0;
   }
}
#endif
void asn1Free_e2ap_RICaction_ToBeRemovedForModification_ItemIEs (OSCTXT* pctxt, e2ap_RICaction_ToBeRemovedForModification_ItemIEs* pvalue)
{
   if(0==pvalue) return;
   switch(pvalue->value.t){
      case T_E2AP_PDU_Contents_e2ap_RICaction_ToBeRemovedForModification_ItemIEs_id_RICaction_ToBeRemovedForModification_Item:
         asn1Free_e2ap_RICaction_ToBeRemovedForModification_Item (pctxt, pvalue->value.u._e2apRICaction_ToBeRemovedForModification_ItemIEs_id_RICaction_ToBeRemovedForModification_Item);
         rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2apRICaction_ToBeRemovedForModification_ItemIEs_id_RICaction_ToBeRemovedForModification_Item);
         pvalue->value.u._e2apRICaction_ToBeRemovedForModification_ItemIEs_id_RICaction_ToBeRemovedForModification_Item = 0;
         break;
      case T_E2AP_PDU_Contents_e2ap_RICaction_ToBeRemovedForModification_ItemIEs_UNDEF_:
         if(0!=pvalue->value.u.extElem1){
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1->data);
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
             pvalue->value.u.extElem1 =0;
         }
         break;
         default:;
   }
}

int  asn1PrtToStr_e2ap_RICaction_ToBeRemovedForModification_ItemIEs (const char * name, e2ap_RICaction_ToBeRemovedForModification_ItemIEs* pvalue, char * buffer, OSSIZE bufSize){
   if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
       return -1;

      if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
         return -1;

      if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
         return -1;
      if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
         return -1;
      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_RICaction_ToBeRemovedForModification_ItemIEs_id_RICaction_ToBeRemovedForModification_Item:
         if(asn1PrtToStr_e2ap_RICaction_ToBeRemovedForModification_Item("RICaction-ToBeRemovedForModification-Item",
                pvalue->value.u._e2apRICaction_ToBeRemovedForModification_ItemIEs_id_RICaction_ToBeRemovedForModification_Item, buffer, bufSize)<0)// dungnm23 check lai nhe xem la
            return -1;
         break;
      default:
         if(0!=pvalue -> value.u.extElem1){
             rtPrintToStringIndent(buffer, bufSize);
             rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

         }
      }
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

      return 0;

}
 

/*****************************************/
/*           RICactions_ToBeRemovedForModification_List                */
/*****************************************/
//seq_of_single_container


int asn1PE_e2ap_RICactions_ToBeRemovedForModification_List (OSCTXT* pctxt, e2ap_RICactions_ToBeRemovedForModification_List* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_RICaction_ToBeRemovedForModification_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "RICactions-ToBeRemovedForModification-List");

   /* encode length determinant */
   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(16), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;
   for (xx1 = 0; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next, xx1++) {
      pdata = (e2ap_RICaction_ToBeRemovedForModification_ItemIEs*) pnode->data;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_e2ap_RICaction_ToBeRemovedForModification_ItemIEs (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      //xx1++;
      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}

int asn1PD_e2ap_RICactions_ToBeRemovedForModification_List (OSCTXT* pctxt, e2ap_RICactions_ToBeRemovedForModification_List* ppvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_RICaction_ToBeRemovedForModification_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "RICactions-ToBeRemovedForModification-List");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(16), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (ppvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      pdata = rtxMemAllocType (pctxt, e2ap_RICaction_ToBeRemovedForModification_ItemIEs);
      if (!pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);
      asn1Init_e2ap_RICaction_ToBeRemovedForModification_ItemIEs (pdata);
      stat = asn1PD_e2ap_RICaction_ToBeRemovedForModification_ItemIEs (pctxt, pdata);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         return LOG_RTERR (pctxt, stat);
      }

      rtxDListAppendNode (ppvalue, pdata);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

void asn1Init_e2ap_RICactions_ToBeRemovedForModification_List (e2ap_RICactions_ToBeRemovedForModification_List* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
}

void asn1Free_e2ap_RICactions_ToBeRemovedForModification_List (OSCTXT* pctxt, e2ap_RICactions_ToBeRemovedForModification_List* pvalue)
{
   if(pvalue==0) return;
   OSRTDListNode* pnode = pvalue->head;
   while (pnode) {
      e2ap_RICaction_ToBeRemovedForModification_ItemIEs* pdata = (e2ap_RICaction_ToBeRemovedForModification_ItemIEs*) pnode->data;
      if (pdata) {
         asn1Free_e2ap_RICaction_ToBeRemovedForModification_ItemIEs (pctxt, pdata);
         rtxMemFreePtr (pctxt, pdata);
      }
      pnode = pnode->next;
   }
      rtxDListFreeAll(pctxt, pvalue);
}

#if 0
void asn1Free_e2ap_RICactions_ToBeRemovedForModification_List (OSCTXT* pctxt, e2ap_RICactions_ToBeRemovedForModification_List* pvalue){
   if(0==pvalue ) return;
   {
      e2ap_RICaction_ToBeRemovedForModification_ItemIEs * pdata;
      OSRTDListNode *pnode = pvalue->head;
      while(0!=pnode){
         pdata = (e2ap_RICaction_ToBeRemovedForModification_ItemIEs*)pnode->data;
         asn1Free_e2ap_RICaction_ToBeRemovedForModification_ItemIEs(pctxt, pdata);
         pnode = pnode->next;
      }
      rtxDListFreeAll(pctxt, pvalue);
   }
}
#endif


int asn1PrtToStr_e2ap_RICactions_ToBeRemovedForModification_List(const char* name, e2ap_RICactions_ToBeRemovedForModification_List* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_RICaction_ToBeRemovedForModification_ItemIEs* pdata;
    OSRTDListNode* pnode;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode = pvalue->head;  xx1 < pvalue->count && pnode != 0; pnode = pnode->next, xx1++){
        pdata = (e2ap_RICaction_ToBeRemovedForModification_ItemIEs*)pnode->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 1
        if(asn1PrtToStr_e2ap_RICaction_ToBeRemovedForModification_ItemIEs(nameBuf, pdata, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}
/*****************************************/
/*           RICaction-ToBeModifiedForModification-Item                */
/*****************************************/
//sequence normal
// Các nội dung cần thiết cho template seq_normal.c.j2

// Các phần còn lại của template seq_normal.c.j2
//contain extensition bit -> theo mau cua GlobalgNB-ID
int asn1PE_e2ap_RICaction_ToBeModifiedForModification_Item (OSCTXT* pctxt, e2ap_RICaction_ToBeModifiedForModification_Item* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RICaction-ToBeModifiedForModification-Item");

   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);

   /*optional bit for field ricActionDefinition*/
   stat = rtxEncBit (pctxt, pvalue->m_ricActionDefinitionPresent);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   /*optional bit for field ricActionExecutionOrder*/
   stat = rtxEncBit (pctxt, pvalue->m_ricActionExecutionOrderPresent);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   /*optional bit for field ricSubsequentAction*/
   stat = rtxEncBit (pctxt, pvalue->m_ricSubsequentActionPresent);
   if (stat != 0) return LOG_RTERR(pctxt, stat);

   /*encode root elements*/   
   /* encode field ricActionID - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "ricActionID");
   stat = asn1PE_e2ap_RICactionID (pctxt, pvalue->ricActionID);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /* encode field ricActionDefinition - id = -1*/  
   if (pvalue->m_ricActionDefinitionPresent) {//OPTIONAL FIELD
   RTXCTXTPUSHELEMNAME(pctxt, "ricActionDefinition");
   stat = asn1PE_e2ap_RICactionDefinition (pctxt, pvalue->ricActionDefinition);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   }

   /* encode field ricActionExecutionOrder - id = -1*/  
   if (pvalue->m_ricActionExecutionOrderPresent) {//OPTIONAL FIELD
   RTXCTXTPUSHELEMNAME(pctxt, "ricActionExecutionOrder");
   stat = asn1PE_e2ap_RICactionExecutionOrder (pctxt, pvalue->ricActionExecutionOrder);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   }

   /* encode field ricSubsequentAction - id = -1*/  
   if (pvalue->m_ricSubsequentActionPresent) {//OPTIONAL FIELD
   RTXCTXTPUSHELEMNAME(pctxt, "ricSubsequentAction");
   stat = asn1PE_e2ap_RICsubsequentAction (pctxt, pvalue->ricSubsequentAction);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   }


   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RICaction_ToBeModifiedForModification_Item (OSCTXT* pctxt, e2ap_RICaction_ToBeModifiedForModification_Item* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[4];

   RTXCTXTPUSHTYPENAME(pctxt, "RICaction-ToBeModifiedForModification-Item");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 4; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field ricActionID */
   RTXCTXTPUSHELEMNAME(pctxt, "ricActionID");
      stat = asn1PD_e2ap_RICactionID (pctxt, &pvalue->ricActionID);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field ricActionDefinition */
   RTXCTXTPUSHELEMNAME(pctxt, "ricActionDefinition");
   if (optbits[0]) {
      pvalue->m_ricActionDefinitionPresent = TRUE;
      stat = asn1PD_e2ap_RICactionDefinition (pctxt, &pvalue->ricActionDefinition);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   } else {
      pvalue->m_ricActionDefinitionPresent = FALSE;
   }
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field ricActionExecutionOrder */
   RTXCTXTPUSHELEMNAME(pctxt, "ricActionExecutionOrder");
   if (optbits[0]) {
      pvalue->m_ricActionExecutionOrderPresent = TRUE;
      stat = asn1PD_e2ap_RICactionExecutionOrder (pctxt, &pvalue->ricActionExecutionOrder);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   } else {
      pvalue->m_ricActionExecutionOrderPresent = FALSE;
   }
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field ricSubsequentAction */
   RTXCTXTPUSHELEMNAME(pctxt, "ricSubsequentAction");
   if (optbits[0]) {
      pvalue->m_ricSubsequentActionPresent = TRUE;
      stat = asn1PD_e2ap_RICsubsequentAction (pctxt, &pvalue->ricSubsequentAction);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   } else {
      pvalue->m_ricSubsequentActionPresent = FALSE;
   }
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RICaction_ToBeModifiedForModification_Item (e2ap_RICaction_ToBeModifiedForModification_Item* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RICactionID (&pvalue->ricActionID);
   asn1Init_e2ap_RICactionDefinition (&pvalue->ricActionDefinition);
   asn1Init_e2ap_RICactionExecutionOrder (&pvalue->ricActionExecutionOrder);
   asn1Init_e2ap_RICsubsequentAction (&pvalue->ricSubsequentAction);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RICaction_ToBeModifiedForModification_Item (OSCTXT* pctxt, e2ap_RICaction_ToBeModifiedForModification_Item* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_RICactionID (pctxt, &pvalue->ricActionID);
   asn1Free_e2ap_RICactionDefinition (pctxt, &pvalue->ricActionDefinition);
   asn1Free_e2ap_RICactionExecutionOrder (pctxt, &pvalue->ricActionExecutionOrder);
   asn1Free_e2ap_RICsubsequentAction (pctxt, &pvalue->ricSubsequentAction);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RICaction_ToBeModifiedForModification_Item (const char* name, e2ap_RICaction_ToBeModifiedForModification_Item* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }
   if(asn1PrtToStr_e2ap_RICactionID ("ricActionID", &pvalue->ricActionID, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_RICactionDefinition ("ricActionDefinition", &pvalue->ricActionDefinition, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_RICactionExecutionOrder ("ricActionExecutionOrder", &pvalue->ricActionExecutionOrder, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_RICsubsequentAction ("ricSubsequentAction", &pvalue->ricSubsequentAction, buffer, bufSize) < 0)
   {
      return -1;
   }



   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           RICaction_ToBeModifiedForModification_ItemIEs                */
/*****************************************/
/* ie.c.j2 */
/*ie thường*/
int asn1PE_e2ap_RICaction_ToBeModifiedForModification_ItemIEs (OSCTXT* pctxt, e2ap_RICaction_ToBeModifiedForModification_ItemIEs* pvalue)
{
   int stat = 0;
   //RTXCTXTPUSHTYPENAME (pctxt, "RICaction-ToBeModifiedForModification-ItemIEs");

   /* encode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");
   stat = asn1PE_e2ap_ProtocolIE_ID (pctxt, pvalue->id);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");
   stat = asn1PE_e2ap_Criticality (pctxt, pvalue->criticality);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   {
      OSCTXT ictxt;
      OSOCTET* pDynamicEncodeBuffer;
      ASN1OpenType openType;
      OSBOOL  encoded = TRUE;

      openType.numocts = 0;
      openType.data = 0;

      rtxCopyContext (&ictxt, pctxt);
      pctxt->pStream = 0;

      stat = rtxInitContextBuffer (pctxt, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_RICaction_ToBeModifiedForModification_ItemIEs_id_RICaction_ToBeModifiedForModification_Item:
         
        // RTXCTXTPUSHELEMNAME (pctxt, "RICaction_ToBeModifiedForModification_ItemIEs_id_RICaction_ToBeModifiedForModification_Item");
         RTXCTXTPUSHELEMNAME (pctxt, "RICaction-ToBeModifiedForModification-Item");
         stat = asn1PE_e2ap_RICaction_ToBeModifiedForModification_Item (pctxt, pvalue->value.u._e2apRICaction_ToBeModifiedForModification_ItemIEs_id_RICaction_ToBeModifiedForModification_Item);
         RTXCTXTPOPELEMNAME (pctxt);
      
         break;

      case T_E2AP_PDU_Contents_e2ap_RICaction_ToBeModifiedForModification_ItemIEs_UNDEF_:
      {
          if(0!=pvalue->value.u.extElem1){
              openType.numocts = pvalue->value.u.extElem1->numocts;
              openType.data = pvalue->value.u.extElem1->data;
          } else {
              /* No extension element to encode */
          }
          encoded = FALSE;
          break;
      }
      default:
         encoded = FALSE;
         stat = RTERR_INVOPT;
      }

      if (encoded) {
         openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
         openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
      }
      rtxCopyContext (pctxt, &ictxt);
      if(stat ==0) stat = pe_OpenType(pctxt, openType.numocts, openType.data);
      /*free dynamic encode buffer*/
      if(encoded){
          rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
      }
   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);
   //RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

int asn1PD_e2ap_RICaction_ToBeModifiedForModification_ItemIEs (OSCTXT* pctxt, e2ap_RICaction_ToBeModifiedForModification_ItemIEs* pvalue)
{
   int stat =0;
   /*deode root element id*/
   RTXCTXTPUSHELEMNAME(pctxt, "id");
   stat = asn1PD_e2ap_ProtocolIE_ID (pctxt, &pvalue->id);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*decode root element criticality*/
   RTXCTXTPUSHELEMNAME(pctxt, "criticality");
   stat = asn1PD_e2ap_Criticality (pctxt, &pvalue->criticality);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   /*decode root element value*/
   RTXCTXTPUSHELEMNAME(pctxt, "value");
   {
      OSUINT32 openTypeLen;
      size_t bitStartOffset, bitLength;
      stat = pd_UnconsLength(pctxt, &openTypeLen);
      if(stat <0) return LOG_RTERR(pctxt, stat);
      else if(stat == RT_OK_FRAG){
         rtxErrAddStrParm(pctxt, "open type with fragmented length use - perindef");
         return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
      }
      bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
      bitLength = openTypeLen * 8;
      switch (pvalue->id){
         case T_E2AP_PDU_Contents_e2ap_RICaction_ToBeModifiedForModification_ItemIEs_id_RICaction_ToBeModifiedForModification_Item:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICaction_ToBeModifiedForModification_ItemIEs_id_RICaction_ToBeModifiedForModification_Item;
            RTXCTXTPUSHELEMNAME(pctxt, "RICaction-ToBeModifiedForModification-Item");
            //pvalue->value.u._e2ap_RICaction_ToBeModifiedForModification_ItemIEs_id_id_RICaction_ToBeModifiedForModification_Item 
             pvalue->value.u._e2apRICaction_ToBeModifiedForModification_ItemIEs_id_RICaction_ToBeModifiedForModification_Item 
                    = rtxMemAllocType(pctxt, e2ap_RICaction_ToBeModifiedForModification_Item);
            //asn1Init_e2ap_RICaction_ToBeModifiedForModification_Item(pvalue->value.u._e2ap_RICaction_ToBeModifiedForModification_ItemIEs_id_id_RICaction_ToBeModifiedForModification_Item);
            asn1Init_e2ap_RICaction_ToBeModifiedForModification_Item(pvalue->value.u._e2apRICaction_ToBeModifiedForModification_ItemIEs_id_RICaction_ToBeModifiedForModification_Item);
            stat = asn1PD_e2ap_RICaction_ToBeModifiedForModification_Item (pctxt,
                    (e2ap_RICaction_ToBeModifiedForModification_Item*)pvalue->value.
                    u._e2apRICaction_ToBeModifiedForModification_ItemIEs_id_RICaction_ToBeModifiedForModification_Item);
            if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICaction_ToBeModifiedForModification_ItemIEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*)rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
      }
      {
      size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
      size_t bitsConsumed = bitEndOffset - bitStartOffset;
      if(bitsConsumed < bitLength){
         stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
      } else {
         stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
      }
      }
   }
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   return stat;
}

void asn1Init_e2ap_RICaction_ToBeModifiedForModification_ItemIEs (e2ap_RICaction_ToBeModifiedForModification_ItemIEs* pvalue)
{
   if (!pvalue) return;
   OSCRTLMEMSET (pvalue, 0, sizeof(e2ap_RICaction_ToBeModifiedForModification_ItemIEs));
}

#if 0
void asn1Free_e2ap_RICaction_ToBeModifiedForModification_ItemIEs (OSCTXT* pctxt, e2ap_RICaction_ToBeModifiedForModification_ItemIEs* pvalue)
{
   if (!pvalue) return;
   if (pvalue->extElem1) {
      rtxMemFreeArray (pctxt, pvalue->extElem1);
      pvalue->extElem1 = 0;
      pvalue->extElem1_n = 0;
   }
}
#endif
void asn1Free_e2ap_RICaction_ToBeModifiedForModification_ItemIEs (OSCTXT* pctxt, e2ap_RICaction_ToBeModifiedForModification_ItemIEs* pvalue)
{
   if(0==pvalue) return;
   switch(pvalue->value.t){
      case T_E2AP_PDU_Contents_e2ap_RICaction_ToBeModifiedForModification_ItemIEs_id_RICaction_ToBeModifiedForModification_Item:
         asn1Free_e2ap_RICaction_ToBeModifiedForModification_Item (pctxt, pvalue->value.u._e2apRICaction_ToBeModifiedForModification_ItemIEs_id_RICaction_ToBeModifiedForModification_Item);
         rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2apRICaction_ToBeModifiedForModification_ItemIEs_id_RICaction_ToBeModifiedForModification_Item);
         pvalue->value.u._e2apRICaction_ToBeModifiedForModification_ItemIEs_id_RICaction_ToBeModifiedForModification_Item = 0;
         break;
      case T_E2AP_PDU_Contents_e2ap_RICaction_ToBeModifiedForModification_ItemIEs_UNDEF_:
         if(0!=pvalue->value.u.extElem1){
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1->data);
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
             pvalue->value.u.extElem1 =0;
         }
         break;
         default:;
   }
}

int  asn1PrtToStr_e2ap_RICaction_ToBeModifiedForModification_ItemIEs (const char * name, e2ap_RICaction_ToBeModifiedForModification_ItemIEs* pvalue, char * buffer, OSSIZE bufSize){
   if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
       return -1;

      if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
         return -1;

      if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
         return -1;
      if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
         return -1;
      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_RICaction_ToBeModifiedForModification_ItemIEs_id_RICaction_ToBeModifiedForModification_Item:
         if(asn1PrtToStr_e2ap_RICaction_ToBeModifiedForModification_Item("RICaction-ToBeModifiedForModification-Item",
                pvalue->value.u._e2apRICaction_ToBeModifiedForModification_ItemIEs_id_RICaction_ToBeModifiedForModification_Item, buffer, bufSize)<0)// dungnm23 check lai nhe xem la
            return -1;
         break;
      default:
         if(0!=pvalue -> value.u.extElem1){
             rtPrintToStringIndent(buffer, bufSize);
             rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

         }
      }
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

      return 0;

}
 

/*****************************************/
/*           RICactions_ToBeModifiedForModification_List                */
/*****************************************/
//seq_of_single_container


int asn1PE_e2ap_RICactions_ToBeModifiedForModification_List (OSCTXT* pctxt, e2ap_RICactions_ToBeModifiedForModification_List* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_RICaction_ToBeModifiedForModification_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "RICactions-ToBeModifiedForModification-List");

   /* encode length determinant */
   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(16), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;
   for (xx1 = 0; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next, xx1++) {
      pdata = (e2ap_RICaction_ToBeModifiedForModification_ItemIEs*) pnode->data;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_e2ap_RICaction_ToBeModifiedForModification_ItemIEs (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      //xx1++;
      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}

int asn1PD_e2ap_RICactions_ToBeModifiedForModification_List (OSCTXT* pctxt, e2ap_RICactions_ToBeModifiedForModification_List* ppvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_RICaction_ToBeModifiedForModification_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "RICactions-ToBeModifiedForModification-List");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(16), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (ppvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      pdata = rtxMemAllocType (pctxt, e2ap_RICaction_ToBeModifiedForModification_ItemIEs);
      if (!pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);
      asn1Init_e2ap_RICaction_ToBeModifiedForModification_ItemIEs (pdata);
      stat = asn1PD_e2ap_RICaction_ToBeModifiedForModification_ItemIEs (pctxt, pdata);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         return LOG_RTERR (pctxt, stat);
      }

      rtxDListAppendNode (ppvalue, pdata);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

void asn1Init_e2ap_RICactions_ToBeModifiedForModification_List (e2ap_RICactions_ToBeModifiedForModification_List* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
}

void asn1Free_e2ap_RICactions_ToBeModifiedForModification_List (OSCTXT* pctxt, e2ap_RICactions_ToBeModifiedForModification_List* pvalue)
{
   if(pvalue==0) return;
   OSRTDListNode* pnode = pvalue->head;
   while (pnode) {
      e2ap_RICaction_ToBeModifiedForModification_ItemIEs* pdata = (e2ap_RICaction_ToBeModifiedForModification_ItemIEs*) pnode->data;
      if (pdata) {
         asn1Free_e2ap_RICaction_ToBeModifiedForModification_ItemIEs (pctxt, pdata);
         rtxMemFreePtr (pctxt, pdata);
      }
      pnode = pnode->next;
   }
      rtxDListFreeAll(pctxt, pvalue);
}

#if 0
void asn1Free_e2ap_RICactions_ToBeModifiedForModification_List (OSCTXT* pctxt, e2ap_RICactions_ToBeModifiedForModification_List* pvalue){
   if(0==pvalue ) return;
   {
      e2ap_RICaction_ToBeModifiedForModification_ItemIEs * pdata;
      OSRTDListNode *pnode = pvalue->head;
      while(0!=pnode){
         pdata = (e2ap_RICaction_ToBeModifiedForModification_ItemIEs*)pnode->data;
         asn1Free_e2ap_RICaction_ToBeModifiedForModification_ItemIEs(pctxt, pdata);
         pnode = pnode->next;
      }
      rtxDListFreeAll(pctxt, pvalue);
   }
}
#endif


int asn1PrtToStr_e2ap_RICactions_ToBeModifiedForModification_List(const char* name, e2ap_RICactions_ToBeModifiedForModification_List* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_RICaction_ToBeModifiedForModification_ItemIEs* pdata;
    OSRTDListNode* pnode;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode = pvalue->head;  xx1 < pvalue->count && pnode != 0; pnode = pnode->next, xx1++){
        pdata = (e2ap_RICaction_ToBeModifiedForModification_ItemIEs*)pnode->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 1
        if(asn1PrtToStr_e2ap_RICaction_ToBeModifiedForModification_ItemIEs(nameBuf, pdata, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}
/*****************************************/
/*           RICaction-ToBeAddedForModification-Item                */
/*****************************************/
//sequence normal
// Các nội dung cần thiết cho template seq_normal.c.j2

// Các phần còn lại của template seq_normal.c.j2
//contain extensition bit -> theo mau cua GlobalgNB-ID
int asn1PE_e2ap_RICaction_ToBeAddedForModification_Item (OSCTXT* pctxt, e2ap_RICaction_ToBeAddedForModification_Item* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RICaction-ToBeAddedForModification-Item");

   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);

   /*optional bit for field ricSubsequentAction*/
   stat = rtxEncBit (pctxt, pvalue->m_ricSubsequentActionPresent);
   if (stat != 0) return LOG_RTERR(pctxt, stat);

   /*encode root elements*/   
   /* encode field ricActionID - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "ricActionID");
   stat = asn1PE_e2ap_RICactionID (pctxt, pvalue->ricActionID);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /* encode field ricActionType - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "ricActionType");
   stat = asn1PE_e2ap_RICactionType (pctxt, pvalue->ricActionType);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /* encode field ricActionDefinition - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "ricActionDefinition");
   stat = asn1PE_e2ap_RICactionDefinition (pctxt, pvalue->ricActionDefinition);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /* encode field ricActionExecutionOrder - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "ricActionExecutionOrder");
   stat = asn1PE_e2ap_RICactionExecutionOrder (pctxt, pvalue->ricActionExecutionOrder);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /* encode field ricSubsequentAction - id = -1*/  
   if (pvalue->m_ricSubsequentActionPresent) {//OPTIONAL FIELD
   RTXCTXTPUSHELEMNAME(pctxt, "ricSubsequentAction");
   stat = asn1PE_e2ap_RICsubsequentAction (pctxt, pvalue->ricSubsequentAction);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   }


   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RICaction_ToBeAddedForModification_Item (OSCTXT* pctxt, e2ap_RICaction_ToBeAddedForModification_Item* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[5];

   RTXCTXTPUSHTYPENAME(pctxt, "RICaction-ToBeAddedForModification-Item");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 5; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field ricActionID */
   RTXCTXTPUSHELEMNAME(pctxt, "ricActionID");
      stat = asn1PD_e2ap_RICactionID (pctxt, &pvalue->ricActionID);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field ricActionType */
   RTXCTXTPUSHELEMNAME(pctxt, "ricActionType");
      stat = asn1PD_e2ap_RICactionType (pctxt, &pvalue->ricActionType);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field ricActionDefinition */
   RTXCTXTPUSHELEMNAME(pctxt, "ricActionDefinition");
      stat = asn1PD_e2ap_RICactionDefinition (pctxt, &pvalue->ricActionDefinition);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field ricActionExecutionOrder */
   RTXCTXTPUSHELEMNAME(pctxt, "ricActionExecutionOrder");
      stat = asn1PD_e2ap_RICactionExecutionOrder (pctxt, &pvalue->ricActionExecutionOrder);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field ricSubsequentAction */
   RTXCTXTPUSHELEMNAME(pctxt, "ricSubsequentAction");
   if (optbits[0]) {
      pvalue->m_ricSubsequentActionPresent = TRUE;
      stat = asn1PD_e2ap_RICsubsequentAction (pctxt, &pvalue->ricSubsequentAction);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   } else {
      pvalue->m_ricSubsequentActionPresent = FALSE;
   }
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RICaction_ToBeAddedForModification_Item (e2ap_RICaction_ToBeAddedForModification_Item* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RICactionID (&pvalue->ricActionID);
   asn1Init_e2ap_RICactionType (&pvalue->ricActionType);
   asn1Init_e2ap_RICactionDefinition (&pvalue->ricActionDefinition);
   asn1Init_e2ap_RICactionExecutionOrder (&pvalue->ricActionExecutionOrder);
   asn1Init_e2ap_RICsubsequentAction (&pvalue->ricSubsequentAction);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RICaction_ToBeAddedForModification_Item (OSCTXT* pctxt, e2ap_RICaction_ToBeAddedForModification_Item* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_RICactionID (pctxt, &pvalue->ricActionID);
   asn1Free_e2ap_RICactionType (pctxt, &pvalue->ricActionType);
   asn1Free_e2ap_RICactionDefinition (pctxt, &pvalue->ricActionDefinition);
   asn1Free_e2ap_RICactionExecutionOrder (pctxt, &pvalue->ricActionExecutionOrder);
   asn1Free_e2ap_RICsubsequentAction (pctxt, &pvalue->ricSubsequentAction);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RICaction_ToBeAddedForModification_Item (const char* name, e2ap_RICaction_ToBeAddedForModification_Item* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }
   if(asn1PrtToStr_e2ap_RICactionID ("ricActionID", &pvalue->ricActionID, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_RICactionType ("ricActionType", &pvalue->ricActionType, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_RICactionDefinition ("ricActionDefinition", &pvalue->ricActionDefinition, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_RICactionExecutionOrder ("ricActionExecutionOrder", &pvalue->ricActionExecutionOrder, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_RICsubsequentAction ("ricSubsequentAction", &pvalue->ricSubsequentAction, buffer, bufSize) < 0)
   {
      return -1;
   }



   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           RICaction_ToBeAddedForModification_ItemIEs                */
/*****************************************/
/* ie.c.j2 */
/*ie thường*/
int asn1PE_e2ap_RICaction_ToBeAddedForModification_ItemIEs (OSCTXT* pctxt, e2ap_RICaction_ToBeAddedForModification_ItemIEs* pvalue)
{
   int stat = 0;
   //RTXCTXTPUSHTYPENAME (pctxt, "RICaction-ToBeAddedForModification-ItemIEs");

   /* encode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");
   stat = asn1PE_e2ap_ProtocolIE_ID (pctxt, pvalue->id);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");
   stat = asn1PE_e2ap_Criticality (pctxt, pvalue->criticality);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   {
      OSCTXT ictxt;
      OSOCTET* pDynamicEncodeBuffer;
      ASN1OpenType openType;
      OSBOOL  encoded = TRUE;

      openType.numocts = 0;
      openType.data = 0;

      rtxCopyContext (&ictxt, pctxt);
      pctxt->pStream = 0;

      stat = rtxInitContextBuffer (pctxt, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_RICaction_ToBeAddedForModification_ItemIEs_id_RICaction_ToBeAddedForModification_Item:
         
        // RTXCTXTPUSHELEMNAME (pctxt, "RICaction_ToBeAddedForModification_ItemIEs_id_RICaction_ToBeAddedForModification_Item");
         RTXCTXTPUSHELEMNAME (pctxt, "RICaction-ToBeAddedForModification-Item");
         stat = asn1PE_e2ap_RICaction_ToBeAddedForModification_Item (pctxt, pvalue->value.u._e2apRICaction_ToBeAddedForModification_ItemIEs_id_RICaction_ToBeAddedForModification_Item);
         RTXCTXTPOPELEMNAME (pctxt);
      
         break;

      case T_E2AP_PDU_Contents_e2ap_RICaction_ToBeAddedForModification_ItemIEs_UNDEF_:
      {
          if(0!=pvalue->value.u.extElem1){
              openType.numocts = pvalue->value.u.extElem1->numocts;
              openType.data = pvalue->value.u.extElem1->data;
          } else {
              /* No extension element to encode */
          }
          encoded = FALSE;
          break;
      }
      default:
         encoded = FALSE;
         stat = RTERR_INVOPT;
      }

      if (encoded) {
         openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
         openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
      }
      rtxCopyContext (pctxt, &ictxt);
      if(stat ==0) stat = pe_OpenType(pctxt, openType.numocts, openType.data);
      /*free dynamic encode buffer*/
      if(encoded){
          rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
      }
   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);
   //RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

int asn1PD_e2ap_RICaction_ToBeAddedForModification_ItemIEs (OSCTXT* pctxt, e2ap_RICaction_ToBeAddedForModification_ItemIEs* pvalue)
{
   int stat =0;
   /*deode root element id*/
   RTXCTXTPUSHELEMNAME(pctxt, "id");
   stat = asn1PD_e2ap_ProtocolIE_ID (pctxt, &pvalue->id);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*decode root element criticality*/
   RTXCTXTPUSHELEMNAME(pctxt, "criticality");
   stat = asn1PD_e2ap_Criticality (pctxt, &pvalue->criticality);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   /*decode root element value*/
   RTXCTXTPUSHELEMNAME(pctxt, "value");
   {
      OSUINT32 openTypeLen;
      size_t bitStartOffset, bitLength;
      stat = pd_UnconsLength(pctxt, &openTypeLen);
      if(stat <0) return LOG_RTERR(pctxt, stat);
      else if(stat == RT_OK_FRAG){
         rtxErrAddStrParm(pctxt, "open type with fragmented length use - perindef");
         return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
      }
      bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
      bitLength = openTypeLen * 8;
      switch (pvalue->id){
         case T_E2AP_PDU_Contents_e2ap_RICaction_ToBeAddedForModification_ItemIEs_id_RICaction_ToBeAddedForModification_Item:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICaction_ToBeAddedForModification_ItemIEs_id_RICaction_ToBeAddedForModification_Item;
            RTXCTXTPUSHELEMNAME(pctxt, "RICaction-ToBeAddedForModification-Item");
            //pvalue->value.u._e2ap_RICaction_ToBeAddedForModification_ItemIEs_id_id_RICaction_ToBeAddedForModification_Item 
             pvalue->value.u._e2apRICaction_ToBeAddedForModification_ItemIEs_id_RICaction_ToBeAddedForModification_Item 
                    = rtxMemAllocType(pctxt, e2ap_RICaction_ToBeAddedForModification_Item);
            //asn1Init_e2ap_RICaction_ToBeAddedForModification_Item(pvalue->value.u._e2ap_RICaction_ToBeAddedForModification_ItemIEs_id_id_RICaction_ToBeAddedForModification_Item);
            asn1Init_e2ap_RICaction_ToBeAddedForModification_Item(pvalue->value.u._e2apRICaction_ToBeAddedForModification_ItemIEs_id_RICaction_ToBeAddedForModification_Item);
            stat = asn1PD_e2ap_RICaction_ToBeAddedForModification_Item (pctxt,
                    (e2ap_RICaction_ToBeAddedForModification_Item*)pvalue->value.
                    u._e2apRICaction_ToBeAddedForModification_ItemIEs_id_RICaction_ToBeAddedForModification_Item);
            if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICaction_ToBeAddedForModification_ItemIEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*)rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
      }
      {
      size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
      size_t bitsConsumed = bitEndOffset - bitStartOffset;
      if(bitsConsumed < bitLength){
         stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
      } else {
         stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
      }
      }
   }
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   return stat;
}

void asn1Init_e2ap_RICaction_ToBeAddedForModification_ItemIEs (e2ap_RICaction_ToBeAddedForModification_ItemIEs* pvalue)
{
   if (!pvalue) return;
   OSCRTLMEMSET (pvalue, 0, sizeof(e2ap_RICaction_ToBeAddedForModification_ItemIEs));
}

#if 0
void asn1Free_e2ap_RICaction_ToBeAddedForModification_ItemIEs (OSCTXT* pctxt, e2ap_RICaction_ToBeAddedForModification_ItemIEs* pvalue)
{
   if (!pvalue) return;
   if (pvalue->extElem1) {
      rtxMemFreeArray (pctxt, pvalue->extElem1);
      pvalue->extElem1 = 0;
      pvalue->extElem1_n = 0;
   }
}
#endif
void asn1Free_e2ap_RICaction_ToBeAddedForModification_ItemIEs (OSCTXT* pctxt, e2ap_RICaction_ToBeAddedForModification_ItemIEs* pvalue)
{
   if(0==pvalue) return;
   switch(pvalue->value.t){
      case T_E2AP_PDU_Contents_e2ap_RICaction_ToBeAddedForModification_ItemIEs_id_RICaction_ToBeAddedForModification_Item:
         asn1Free_e2ap_RICaction_ToBeAddedForModification_Item (pctxt, pvalue->value.u._e2apRICaction_ToBeAddedForModification_ItemIEs_id_RICaction_ToBeAddedForModification_Item);
         rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2apRICaction_ToBeAddedForModification_ItemIEs_id_RICaction_ToBeAddedForModification_Item);
         pvalue->value.u._e2apRICaction_ToBeAddedForModification_ItemIEs_id_RICaction_ToBeAddedForModification_Item = 0;
         break;
      case T_E2AP_PDU_Contents_e2ap_RICaction_ToBeAddedForModification_ItemIEs_UNDEF_:
         if(0!=pvalue->value.u.extElem1){
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1->data);
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
             pvalue->value.u.extElem1 =0;
         }
         break;
         default:;
   }
}

int  asn1PrtToStr_e2ap_RICaction_ToBeAddedForModification_ItemIEs (const char * name, e2ap_RICaction_ToBeAddedForModification_ItemIEs* pvalue, char * buffer, OSSIZE bufSize){
   if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
       return -1;

      if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
         return -1;

      if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
         return -1;
      if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
         return -1;
      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_RICaction_ToBeAddedForModification_ItemIEs_id_RICaction_ToBeAddedForModification_Item:
         if(asn1PrtToStr_e2ap_RICaction_ToBeAddedForModification_Item("RICaction-ToBeAddedForModification-Item",
                pvalue->value.u._e2apRICaction_ToBeAddedForModification_ItemIEs_id_RICaction_ToBeAddedForModification_Item, buffer, bufSize)<0)// dungnm23 check lai nhe xem la
            return -1;
         break;
      default:
         if(0!=pvalue -> value.u.extElem1){
             rtPrintToStringIndent(buffer, bufSize);
             rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

         }
      }
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

      return 0;

}
 

/*****************************************/
/*           RICactions_ToBeAddedForModification_List                */
/*****************************************/
//seq_of_single_container


int asn1PE_e2ap_RICactions_ToBeAddedForModification_List (OSCTXT* pctxt, e2ap_RICactions_ToBeAddedForModification_List* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_RICaction_ToBeAddedForModification_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "RICactions-ToBeAddedForModification-List");

   /* encode length determinant */
   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(16), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;
   for (xx1 = 0; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next, xx1++) {
      pdata = (e2ap_RICaction_ToBeAddedForModification_ItemIEs*) pnode->data;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_e2ap_RICaction_ToBeAddedForModification_ItemIEs (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      //xx1++;
      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}

int asn1PD_e2ap_RICactions_ToBeAddedForModification_List (OSCTXT* pctxt, e2ap_RICactions_ToBeAddedForModification_List* ppvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_RICaction_ToBeAddedForModification_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "RICactions-ToBeAddedForModification-List");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(16), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (ppvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      pdata = rtxMemAllocType (pctxt, e2ap_RICaction_ToBeAddedForModification_ItemIEs);
      if (!pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);
      asn1Init_e2ap_RICaction_ToBeAddedForModification_ItemIEs (pdata);
      stat = asn1PD_e2ap_RICaction_ToBeAddedForModification_ItemIEs (pctxt, pdata);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         return LOG_RTERR (pctxt, stat);
      }

      rtxDListAppendNode (ppvalue, pdata);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

void asn1Init_e2ap_RICactions_ToBeAddedForModification_List (e2ap_RICactions_ToBeAddedForModification_List* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
}

void asn1Free_e2ap_RICactions_ToBeAddedForModification_List (OSCTXT* pctxt, e2ap_RICactions_ToBeAddedForModification_List* pvalue)
{
   if(pvalue==0) return;
   OSRTDListNode* pnode = pvalue->head;
   while (pnode) {
      e2ap_RICaction_ToBeAddedForModification_ItemIEs* pdata = (e2ap_RICaction_ToBeAddedForModification_ItemIEs*) pnode->data;
      if (pdata) {
         asn1Free_e2ap_RICaction_ToBeAddedForModification_ItemIEs (pctxt, pdata);
         rtxMemFreePtr (pctxt, pdata);
      }
      pnode = pnode->next;
   }
      rtxDListFreeAll(pctxt, pvalue);
}

#if 0
void asn1Free_e2ap_RICactions_ToBeAddedForModification_List (OSCTXT* pctxt, e2ap_RICactions_ToBeAddedForModification_List* pvalue){
   if(0==pvalue ) return;
   {
      e2ap_RICaction_ToBeAddedForModification_ItemIEs * pdata;
      OSRTDListNode *pnode = pvalue->head;
      while(0!=pnode){
         pdata = (e2ap_RICaction_ToBeAddedForModification_ItemIEs*)pnode->data;
         asn1Free_e2ap_RICaction_ToBeAddedForModification_ItemIEs(pctxt, pdata);
         pnode = pnode->next;
      }
      rtxDListFreeAll(pctxt, pvalue);
   }
}
#endif


int asn1PrtToStr_e2ap_RICactions_ToBeAddedForModification_List(const char* name, e2ap_RICactions_ToBeAddedForModification_List* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_RICaction_ToBeAddedForModification_ItemIEs* pdata;
    OSRTDListNode* pnode;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode = pvalue->head;  xx1 < pvalue->count && pnode != 0; pnode = pnode->next, xx1++){
        pdata = (e2ap_RICaction_ToBeAddedForModification_ItemIEs*)pnode->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 1
        if(asn1PrtToStr_e2ap_RICaction_ToBeAddedForModification_ItemIEs(nameBuf, pdata, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}/*****************************************/
/*           RICsubscriptionModificationRequest_IEs                */
/*****************************************/
/* ie.c.j2 */
 /* d là con của msg */
EXTERN int asn1PE_e2ap_RICsubscriptionModificationRequest_protocolIEs_element (OSCTXT* pctxt, e2ap_RICsubscriptionModificationRequest_protocolIEs_element* pvalue)
{
    int stat =0;

    /*encode id*/

    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PE_e2ap_ProtocolIE_ID(pctxt, pvalue->id);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PE_e2ap_Criticality(pctxt, pvalue->criticality);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
    {
        OSCTXT lctxt;
        OSOCTET *pDynamicEncodeBuffer;
        ASN1OpenType openType;
        OSBOOL encoded = TRUE;

        openType.numocts = 0;
        openType.data =0;

        rtxCopyContext(&lctxt, pctxt);
        pctxt->pStream =0;

        stat = rtxInitContextBuffer(pctxt, 0, 0);
        if(stat!=0) return LOG_RTERR(pctxt, stat);

        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRequest_IEs_id_RICrequestID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICrequestID");
                    stat = asn1PE_e2ap_RICrequestID (pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_RICrequestID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRequest_IEs_id_RANfunctionID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RANfunctionID");
                    stat = asn1PE_e2ap_RANfunctionID (pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_RANfunctionID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRequest_IEs_id_RICeventTriggerDefinitionToBeModified:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICeventTriggerDefinitionToBeModified");
                    stat = asn1PE_e2ap_RICeventTriggerDefinition (pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_RICeventTriggerDefinitionToBeModified);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRequest_IEs_id_RICactionsToBeRemovedForModification_List:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICactionsToBeRemovedForModification-List");
                    stat = asn1PE_e2ap_RICactions_ToBeRemovedForModification_List (pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_RICactionsToBeRemovedForModification_List);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRequest_IEs_id_RICactionsToBeModifiedForModification_List:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICactionsToBeModifiedForModification-List");
                    stat = asn1PE_e2ap_RICactions_ToBeModifiedForModification_List (pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_RICactionsToBeModifiedForModification_List);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRequest_IEs_id_RICactionsToBeAddedForModification_List:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICactionsToBeAddedForModification-List");
                    stat = asn1PE_e2ap_RICactions_ToBeAddedForModification_List (pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_RICactionsToBeAddedForModification_List);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRequest_IEs_UNDEF_:
            {
                if(0!=pvalue->value.u.extElem1){
                    openType.numocts = pvalue->value.u.extElem1->numocts;
                    openType.data = pvalue->value.u.extElem1->data;
                } else {
                    /* No extension element to encode */
                }
                encoded = FALSE;
                break;
            }

            default:
                encoded = FALSE;
                stat = RTERR_INVOPT;
                break;
        } 

        if(encoded){
            openType.numocts = (OSUINT32)pe_GetMsgLen(pctxt);
            openType.data = pDynamicEncodeBuffer = pctxt -> buffer.data;
        }
        rtxCopyContext(pctxt, &lctxt);

        if(stat == 0) {
            stat = pe_OpenType (pctxt, openType.numocts, openType.data);
        }
    #if 1
        if(encoded){//dungnm23 check lai nhe
            rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
        }
    #endif

    }

    if(stat!=0) return LOG_RTERR(pctxt, stat);  
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}

EXTERN int  asn1PD_e2ap_RICsubscriptionModificationRequest_protocolIEs_element (OSCTXT* pctxt, e2ap_RICsubscriptionModificationRequest_protocolIEs_element* pvalue){
    int stat =0;

    /*decode id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PD_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PD_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");

    {
        OSUINT32 openTypeLen;
        size_t bitStartOffset, bitLength;

        stat = pd_UnconsLength(pctxt, &openTypeLen);
        if(stat<0) return LOG_RTERR(pctxt, stat);
        else if(stat == RT_OK_FRAG){
            rtxErrAddStrParm(pctxt, "open type with fragment length");
            return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
        }
        bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
        bitLength = openTypeLen * 8;

        switch(pvalue->id){//dungnm23 check case lai nhe
        
            case ASN1V_e2ap_id_RICrequestID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRequest_IEs_id_RICrequestID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICrequestID");
                pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_RICrequestID 
                    = rtxMemAllocType(pctxt, e2ap_RICrequestID);

                asn1Init_e2ap_RICrequestID(pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_RICrequestID);

                stat = asn1PD_e2ap_RICrequestID (pctxt,
                        (e2ap_RICrequestID*)pvalue->value.
                        u._e2ap_RICsubscriptionModificationRequest_IEs_id_RICrequestID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RANfunctionID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRequest_IEs_id_RANfunctionID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RANfunctionID");
                pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_RANfunctionID 
                    = rtxMemAllocType(pctxt, e2ap_RANfunctionID);

                asn1Init_e2ap_RANfunctionID(pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_RANfunctionID);

                stat = asn1PD_e2ap_RANfunctionID (pctxt,
                        (e2ap_RANfunctionID*)pvalue->value.
                        u._e2ap_RICsubscriptionModificationRequest_IEs_id_RANfunctionID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RICeventTriggerDefinitionToBeModified:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRequest_IEs_id_RICeventTriggerDefinitionToBeModified;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICeventTriggerDefinitionToBeModified");
                pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_RICeventTriggerDefinitionToBeModified 
                    = rtxMemAllocType(pctxt, e2ap_RICeventTriggerDefinition);

                asn1Init_e2ap_RICeventTriggerDefinition(pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_RICeventTriggerDefinitionToBeModified);

                stat = asn1PD_e2ap_RICeventTriggerDefinition (pctxt,
                        (e2ap_RICeventTriggerDefinition*)pvalue->value.
                        u._e2ap_RICsubscriptionModificationRequest_IEs_id_RICeventTriggerDefinitionToBeModified);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RICactionsToBeRemovedForModification_List:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRequest_IEs_id_RICactionsToBeRemovedForModification_List;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICactionsToBeRemovedForModification-List");
                pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_RICactionsToBeRemovedForModification_List 
                    = rtxMemAllocType(pctxt, e2ap_RICactions_ToBeRemovedForModification_List);

                asn1Init_e2ap_RICactions_ToBeRemovedForModification_List(pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_RICactionsToBeRemovedForModification_List);

                stat = asn1PD_e2ap_RICactions_ToBeRemovedForModification_List (pctxt,
                        (e2ap_RICactions_ToBeRemovedForModification_List*)pvalue->value.
                        u._e2ap_RICsubscriptionModificationRequest_IEs_id_RICactionsToBeRemovedForModification_List);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RICactionsToBeModifiedForModification_List:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRequest_IEs_id_RICactionsToBeModifiedForModification_List;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICactionsToBeModifiedForModification-List");
                pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_RICactionsToBeModifiedForModification_List 
                    = rtxMemAllocType(pctxt, e2ap_RICactions_ToBeModifiedForModification_List);

                asn1Init_e2ap_RICactions_ToBeModifiedForModification_List(pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_RICactionsToBeModifiedForModification_List);

                stat = asn1PD_e2ap_RICactions_ToBeModifiedForModification_List (pctxt,
                        (e2ap_RICactions_ToBeModifiedForModification_List*)pvalue->value.
                        u._e2ap_RICsubscriptionModificationRequest_IEs_id_RICactionsToBeModifiedForModification_List);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RICactionsToBeAddedForModification_List:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRequest_IEs_id_RICactionsToBeAddedForModification_List;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICactionsToBeAddedForModification-List");
                pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_RICactionsToBeAddedForModification_List 
                    = rtxMemAllocType(pctxt, e2ap_RICactions_ToBeAddedForModification_List);

                asn1Init_e2ap_RICactions_ToBeAddedForModification_List(pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_RICactionsToBeAddedForModification_List);

                stat = asn1PD_e2ap_RICactions_ToBeAddedForModification_List (pctxt,
                        (e2ap_RICactions_ToBeAddedForModification_List*)pvalue->value.
                        u._e2ap_RICsubscriptionModificationRequest_IEs_id_RICactionsToBeAddedForModification_List);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRequest_IEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*) rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
    }
    {
    size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
    size_t bitsConsumed = bitEndOffset-bitStartOffset;
    if(bitsConsumed<bitLength){
        stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
    }
    else stat =(bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
    }}
    if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}


int asn1Init_e2ap_RICsubscriptionModificationRequest_protocolIEs_element(e2ap_RICsubscriptionModificationRequest_protocolIEs_element* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    OSCRTLMEMSET (&pvalue->value, 0, sizeof(pvalue->value));
    return 0;
}


//-----> chuaw có template rtxFreeASN1OpenType

#if 0
void asn1Free_e2ap_RICsubscriptionModificationRequest_protocolIEs_element(OSCTXT* pctxt, e2ap_RICsubscriptionModificationRequest_protocolIEs_element* pvalue)
{
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRequest_IEs_id_id_RICrequestID:
            // rtxFreeE2ap_RICrequestID(pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_id_RICrequestID);

            if(pvalue->value.i._e2ap_RICsubscriptionModificationRequest_id_RICrequestID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICrequestID(pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_id_RICrequestID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_id_RICrequestID);
           // pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_id_RICrequestID = NULL;
           pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_RICrequestID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRequest_IEs_id_id_RANfunctionID:
            // rtxFreeE2ap_RANfunctionID(pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_id_RANfunctionID);

            if(pvalue->value.i._e2ap_RICsubscriptionModificationRequest_id_RANfunctionID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RANfunctionID(pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_id_RANfunctionID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_id_RANfunctionID);
           // pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_id_RANfunctionID = NULL;
           pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_RANfunctionID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRequest_IEs_id_id_RICeventTriggerDefinitionToBeModified:
            // rtxFreeE2ap_RICeventTriggerDefinition(pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_id_RICeventTriggerDefinitionToBeModified);

            if(pvalue->value.i._e2ap_RICsubscriptionModificationRequest_id_RICeventTriggerDefinition!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICeventTriggerDefinition(pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_id_RICeventTriggerDefinitionToBeModified);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_id_RICeventTriggerDefinitionToBeModified);
           // pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_id_RICeventTriggerDefinitionToBeModified = NULL;
           pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_RICeventTriggerDefinitionToBeModified = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRequest_IEs_id_id_RICactionsToBeRemovedForModification_List:
            // rtxFreeE2ap_RICactions_ToBeRemovedForModification_List(pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_id_RICactionsToBeRemovedForModification_List);

            if(pvalue->value.i._e2ap_RICsubscriptionModificationRequest_id_RICactions_ToBeRemovedForModification_List!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICactions_ToBeRemovedForModification_List(pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_id_RICactionsToBeRemovedForModification_List);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_id_RICactionsToBeRemovedForModification_List);
           // pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_id_RICactionsToBeRemovedForModification_List = NULL;
           pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_RICactionsToBeRemovedForModification_List = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRequest_IEs_id_id_RICactionsToBeModifiedForModification_List:
            // rtxFreeE2ap_RICactions_ToBeModifiedForModification_List(pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_id_RICactionsToBeModifiedForModification_List);

            if(pvalue->value.i._e2ap_RICsubscriptionModificationRequest_id_RICactions_ToBeModifiedForModification_List!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICactions_ToBeModifiedForModification_List(pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_id_RICactionsToBeModifiedForModification_List);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_id_RICactionsToBeModifiedForModification_List);
           // pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_id_RICactionsToBeModifiedForModification_List = NULL;
           pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_RICactionsToBeModifiedForModification_List = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRequest_IEs_id_id_RICactionsToBeAddedForModification_List:
            // rtxFreeE2ap_RICactions_ToBeAddedForModification_List(pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_id_RICactionsToBeAddedForModification_List);

            if(pvalue->value.i._e2ap_RICsubscriptionModificationRequest_id_RICactions_ToBeAddedForModification_List!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICactions_ToBeAddedForModification_List(pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_id_RICactionsToBeAddedForModification_List);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_id_RICactionsToBeAddedForModification_List);
           // pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_id_RICactionsToBeAddedForModification_List = NULL;
           pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_RICactionsToBeAddedForModification_List = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRequest_IEs_UNDEF_:
            rtxFreeASN1OpenType(pvalue->value.u.extElem1);
            break;
        default:
            break;
    }
}

int asn1PrtToStr_e2ap_RICsubscriptionModificationRequest_protocolIEs_element(OSCTXT* pctxt, e2ap_RICsubscriptionModificationRequest_protocolIEs_element* pvalue)
{
    int stat =0;
    RTXCTXTPUSHELEMNAME(pctxt, "e2ap_RICsubscriptionModificationRequest_protocolIEs_element");

    /*print id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PrtToStr_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PrtToStr_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRequest_IEs_id_id_RICrequestID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICrequestID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICrequestID (pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_id_RICrequestID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRequest_IEs_id_id_RANfunctionID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RANfunctionID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RANfunctionID (pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_id_RANfunctionID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRequest_IEs_id_id_RICeventTriggerDefinitionToBeModified:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICeventTriggerDefinition");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICeventTriggerDefinition (pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_id_RICeventTriggerDefinitionToBeModified);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRequest_IEs_id_id_RICactionsToBeRemovedForModification_List:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICactions-ToBeRemovedForModification-List");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICactions_ToBeRemovedForModification_List (pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_id_RICactionsToBeRemovedForModification_List);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRequest_IEs_id_id_RICactionsToBeModifiedForModification_List:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICactions-ToBeModifiedForModification-List");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICactions_ToBeModifiedForModification_List (pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_id_RICactionsToBeModifiedForModification_List);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRequest_IEs_id_id_RICactionsToBeAddedForModification_List:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICactions-ToBeAddedForModification-List");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICactions_ToBeAddedForModification_List (pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_id_RICactionsToBeAddedForModification_List);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRequest_IEs_UNDEF_:
            {
                rtxPLogMsg(pctxt, "Extension element present - raw data not printed.\n");
                break;
            }

            default:
                stat = RTERR_INVOPT;
                return LOG_RTERR(pctxt, stat);
        }
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);
}
#endif


int asn1PrtToStr_e2ap_RICsubscriptionModificationRequest_protocolIEs_element (const char * name,
 e2ap_RICsubscriptionModificationRequest_protocolIEs_element* pvalue, 
 char * buffer, OSSIZE bufSize){
    if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
        return -1;
    if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
        return -1;

    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRequest_IEs_id_RICrequestID:
            if(asn1PrtToStr_e2ap_RICrequestID("RICrequestID", 
                    pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_RICrequestID, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRequest_IEs_id_RANfunctionID:
            if(asn1PrtToStr_e2ap_RANfunctionID("RANfunctionID", 
                    pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_RANfunctionID, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRequest_IEs_id_RICeventTriggerDefinitionToBeModified:
            if(asn1PrtToStr_e2ap_RICeventTriggerDefinition("RICeventTriggerDefinition", 
                    pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_RICeventTriggerDefinitionToBeModified, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRequest_IEs_id_RICactionsToBeRemovedForModification_List:
            if(asn1PrtToStr_e2ap_RICactions_ToBeRemovedForModification_List("RICactions-ToBeRemovedForModification-List", 
                    pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_RICactionsToBeRemovedForModification_List, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRequest_IEs_id_RICactionsToBeModifiedForModification_List:
            if(asn1PrtToStr_e2ap_RICactions_ToBeModifiedForModification_List("RICactions-ToBeModifiedForModification-List", 
                    pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_RICactionsToBeModifiedForModification_List, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRequest_IEs_id_RICactionsToBeAddedForModification_List:
            if(asn1PrtToStr_e2ap_RICactions_ToBeAddedForModification_List("RICactions-ToBeAddedForModification-List", 
                    pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_RICactionsToBeAddedForModification_List, buffer, bufSize)<0)
                return -1;
            break;    
        default:
        if(0!=pvalue -> value.u.extElem1){
            rtPrintToStringIndent(buffer, bufSize);
            rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

        }
        }
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

    return 0;

 }

 void asn1Free_e2ap_RICsubscriptionModificationRequest_protocolIEs_element(OSCTXT* pctxt, e2ap_RICsubscriptionModificationRequest_protocolIEs_element* pvalue){
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRequest_IEs_id_RICrequestID:
            if(pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_RICrequestID!=NULL){
            asn1Free_e2ap_RICrequestID(pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_RICrequestID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_RICrequestID);
            pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_RICrequestID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRequest_IEs_id_RANfunctionID:
            if(pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_RANfunctionID!=NULL){
            asn1Free_e2ap_RANfunctionID(pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_RANfunctionID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_RANfunctionID);
            pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_RANfunctionID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRequest_IEs_id_RICeventTriggerDefinitionToBeModified:
            if(pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_RICeventTriggerDefinitionToBeModified!=NULL){
            asn1Free_e2ap_RICeventTriggerDefinition(pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_RICeventTriggerDefinitionToBeModified);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_RICeventTriggerDefinitionToBeModified);
            pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_RICeventTriggerDefinitionToBeModified = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRequest_IEs_id_RICactionsToBeRemovedForModification_List:
            if(pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_RICactionsToBeRemovedForModification_List!=NULL){
            asn1Free_e2ap_RICactions_ToBeRemovedForModification_List(pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_RICactionsToBeRemovedForModification_List);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_RICactionsToBeRemovedForModification_List);
            pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_RICactionsToBeRemovedForModification_List = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRequest_IEs_id_RICactionsToBeModifiedForModification_List:
            if(pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_RICactionsToBeModifiedForModification_List!=NULL){
            asn1Free_e2ap_RICactions_ToBeModifiedForModification_List(pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_RICactionsToBeModifiedForModification_List);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_RICactionsToBeModifiedForModification_List);
            pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_RICactionsToBeModifiedForModification_List = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRequest_IEs_id_RICactionsToBeAddedForModification_List:
            if(pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_RICactionsToBeAddedForModification_List!=NULL){
            asn1Free_e2ap_RICactions_ToBeAddedForModification_List(pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_RICactionsToBeAddedForModification_List);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_RICactionsToBeAddedForModification_List);
            pvalue->value.u._e2ap_RICsubscriptionModificationRequest_IEs_id_RICactionsToBeAddedForModification_List = NULL;
            }
            break;
        default:
            break;


    }
 }

 

/*****************************************/
/*           RICsubscriptionModificationRequest                */
/*****************************************/
//2_container.c
/* 1. xxx_ProtocolIE -> mẫu cũ ở ie_big_msg */
EXTERN int asn1PE_e2ap_RICsubscriptionModificationRequest_protocolIEs (OSCTXT* pctxt, e2ap_RICsubscriptionModificationRequest_protocolIEs* pvalue)
{
    int stat =0;
    OSRTDListNode* pnode;
    OSUINT32 xx1;

    /*encode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pe_Length(pctxt, pvalue->count);
    if(stat<0) return LOG_RTERR(pctxt, stat);

    /*encode each element*/
    xx1 =0;
    for(pnode = pvalue->head; pnode != 0 && xx1<pvalue->count; pnode = pnode->next){
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE", xx1);
        stat = asn1PE_e2ap_RICsubscriptionModificationRequest_protocolIEs_element (pctxt, ((e2ap_RICsubscriptionModificationRequest_protocolIEs_element*)pnode->data));
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        xx1++;
        RTXCTXTPOPARRAYELEMNAME(pctxt);
    }

    return (stat);
}

EXTERN int  asn1PD_e2ap_RICsubscriptionModificationRequest_protocolIEs(OSCTXT* pctxt, e2ap_RICsubscriptionModificationRequest_protocolIEs* pvalue)
{
     int stat =0;
     OSRTDListNode* pnode;
     OSSIZE count =0;
     OSSIZE xx1=0;


     /*decode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pd_Length64(pctxt, &count); //tai sao lai 64
    if(stat!=0) return LOG_RTERR(pctxt, stat);

    /*decode each element*/
    rtxDListInit(pvalue);

    for(xx1=0; xx1 < count; xx1++){
        e2ap_RICsubscriptionModificationRequest_protocolIEs_element* pdata;
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE",xx1);

        if(pnode == NULL) return LOG_RTERR(pctxt, RTERR_NOMEM);

        asn1Init_e2ap_RICsubscriptionModificationRequest_protocolIEs_element(pdata);
        rtxDListAppendNode(pvalue, pnode);
        stat = asn1PD_e2ap_RICsubscriptionModificationRequest_protocolIEs_element (pctxt, pdata);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        RTXCTXTPOPARRAYELEMNAME(pctxt);

    }
    return (stat);
}


int asn1Init_e2ap_RICsubscriptionModificationRequest_protocolIEs(e2ap_RICsubscriptionModificationRequest_protocolIEs* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    rtxDListFastInit (pvalue);
    return 0;
}
#if 1 //ao that day
void asn1Free_e2ap_RICsubscriptionModificationRequest_protocolIEs(OSCTXT* pctxt, e2ap_RICsubscriptionModificationRequest_protocolIEs* pvalue)
{
    if(0==pvalue) return;   
    e2ap_RICsubscriptionModificationRequest_protocolIEs_element* pdata;
    OSRTDListNode* pnode=pvalue->head;
    while(0!=pnode){
        pdata = (e2ap_RICsubscriptionModificationRequest_protocolIEs_element*)pnode->data;
       // asn1Free_e2ap_RICsubscriptionModificationRequest_protocolIEs_element(pctxt, pdata);
        pnode = pnode->next;
    }
    rtxDListFreeAll(pctxt, pvalue);
}
#endif


EXTERN int asn1PrtToStr_e2ap_RICsubscriptionModificationRequest_protocolIEs(const char* name, e2ap_RICsubscriptionModificationRequest_protocolIEs* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_RICsubscriptionModificationRequest_protocolIEs_element* pdata0;
    OSRTDListNode* pnode0;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode0 = pvalue->head;  xx1 < pvalue->count && pnode0 != 0; pnode0 = pnode0->next, xx1++){
        pdata0 = (e2ap_RICsubscriptionModificationRequest_protocolIEs_element*)pnode0->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 0
        if(asn1PrtToStr_e2ap_RICsubscriptionModificationRequest_protocolIEs_element(nameBuf, pdata0, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}


/*2 . RICsubscriptionModificationRequest -> mẫu cũ ở seq_normal*/

int asn1PE_e2ap_RICsubscriptionModificationRequest (OSCTXT* pctxt, e2ap_RICsubscriptionModificationRequest* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RICsubscriptionModificationRequest");
   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field protocolIEs - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
   stat = asn1PE_e2ap_RICsubscriptionModificationRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if(stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RICsubscriptionModificationRequest (OSCTXT* pctxt, e2ap_RICsubscriptionModificationRequest* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME(pctxt, "RICsubscriptionModificationRequest");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field protocolIEs */
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
      stat = asn1PD_e2ap_RICsubscriptionModificationRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RICsubscriptionModificationRequest (e2ap_RICsubscriptionModificationRequest* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RICsubscriptionModificationRequest_protocolIEs(&pvalue->protocolIEs);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RICsubscriptionModificationRequest (OSCTXT* pctxt, e2ap_RICsubscriptionModificationRequest* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_RICsubscriptionModificationRequest_protocolIEs(pctxt, &pvalue->protocolIEs);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RICsubscriptionModificationRequest (const char* name, e2ap_RICsubscriptionModificationRequest* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }

   if(asn1PrtToStr_e2ap_RICsubscriptionModificationRequest_protocolIEs("protocolIEs", &pvalue->protocolIEs, buffer, bufSize) <0){
      return -1;
   }

   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}
/*****************************************/
/*           RICaction-RemovedForModification-Item                */
/*****************************************/
//sequence normal
// Các nội dung cần thiết cho template seq_normal.c.j2

// Các phần còn lại của template seq_normal.c.j2
//contain extensition bit -> theo mau cua GlobalgNB-ID
int asn1PE_e2ap_RICaction_RemovedForModification_Item (OSCTXT* pctxt, e2ap_RICaction_RemovedForModification_Item* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RICaction-RemovedForModification-Item");

   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field ricActionID - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "ricActionID");
   stat = asn1PE_e2ap_RICactionID (pctxt, pvalue->ricActionID);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);



   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RICaction_RemovedForModification_Item (OSCTXT* pctxt, e2ap_RICaction_RemovedForModification_Item* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME(pctxt, "RICaction-RemovedForModification-Item");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field ricActionID */
   RTXCTXTPUSHELEMNAME(pctxt, "ricActionID");
      stat = asn1PD_e2ap_RICactionID (pctxt, &pvalue->ricActionID);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RICaction_RemovedForModification_Item (e2ap_RICaction_RemovedForModification_Item* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RICactionID (&pvalue->ricActionID);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RICaction_RemovedForModification_Item (OSCTXT* pctxt, e2ap_RICaction_RemovedForModification_Item* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_RICactionID (pctxt, &pvalue->ricActionID);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RICaction_RemovedForModification_Item (const char* name, e2ap_RICaction_RemovedForModification_Item* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }
   if(asn1PrtToStr_e2ap_RICactionID ("ricActionID", &pvalue->ricActionID, buffer, bufSize) < 0)
   {
      return -1;
   }



   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           RICaction_RemovedForModification_ItemIEs                */
/*****************************************/
/* ie.c.j2 */
/*ie thường*/
int asn1PE_e2ap_RICaction_RemovedForModification_ItemIEs (OSCTXT* pctxt, e2ap_RICaction_RemovedForModification_ItemIEs* pvalue)
{
   int stat = 0;
   //RTXCTXTPUSHTYPENAME (pctxt, "RICaction-RemovedForModification-ItemIEs");

   /* encode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");
   stat = asn1PE_e2ap_ProtocolIE_ID (pctxt, pvalue->id);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");
   stat = asn1PE_e2ap_Criticality (pctxt, pvalue->criticality);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   {
      OSCTXT ictxt;
      OSOCTET* pDynamicEncodeBuffer;
      ASN1OpenType openType;
      OSBOOL  encoded = TRUE;

      openType.numocts = 0;
      openType.data = 0;

      rtxCopyContext (&ictxt, pctxt);
      pctxt->pStream = 0;

      stat = rtxInitContextBuffer (pctxt, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_RICaction_RemovedForModification_ItemIEs_id_RICaction_RemovedForModification_Item:
         
        // RTXCTXTPUSHELEMNAME (pctxt, "RICaction_RemovedForModification_ItemIEs_id_RICaction_RemovedForModification_Item");
         RTXCTXTPUSHELEMNAME (pctxt, "RICaction-RemovedForModification-Item");
         stat = asn1PE_e2ap_RICaction_RemovedForModification_Item (pctxt, pvalue->value.u._e2apRICaction_RemovedForModification_ItemIEs_id_RICaction_RemovedForModification_Item);
         RTXCTXTPOPELEMNAME (pctxt);
      
         break;

      case T_E2AP_PDU_Contents_e2ap_RICaction_RemovedForModification_ItemIEs_UNDEF_:
      {
          if(0!=pvalue->value.u.extElem1){
              openType.numocts = pvalue->value.u.extElem1->numocts;
              openType.data = pvalue->value.u.extElem1->data;
          } else {
              /* No extension element to encode */
          }
          encoded = FALSE;
          break;
      }
      default:
         encoded = FALSE;
         stat = RTERR_INVOPT;
      }

      if (encoded) {
         openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
         openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
      }
      rtxCopyContext (pctxt, &ictxt);
      if(stat ==0) stat = pe_OpenType(pctxt, openType.numocts, openType.data);
      /*free dynamic encode buffer*/
      if(encoded){
          rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
      }
   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);
   //RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

int asn1PD_e2ap_RICaction_RemovedForModification_ItemIEs (OSCTXT* pctxt, e2ap_RICaction_RemovedForModification_ItemIEs* pvalue)
{
   int stat =0;
   /*deode root element id*/
   RTXCTXTPUSHELEMNAME(pctxt, "id");
   stat = asn1PD_e2ap_ProtocolIE_ID (pctxt, &pvalue->id);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*decode root element criticality*/
   RTXCTXTPUSHELEMNAME(pctxt, "criticality");
   stat = asn1PD_e2ap_Criticality (pctxt, &pvalue->criticality);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   /*decode root element value*/
   RTXCTXTPUSHELEMNAME(pctxt, "value");
   {
      OSUINT32 openTypeLen;
      size_t bitStartOffset, bitLength;
      stat = pd_UnconsLength(pctxt, &openTypeLen);
      if(stat <0) return LOG_RTERR(pctxt, stat);
      else if(stat == RT_OK_FRAG){
         rtxErrAddStrParm(pctxt, "open type with fragmented length use - perindef");
         return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
      }
      bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
      bitLength = openTypeLen * 8;
      switch (pvalue->id){
         case T_E2AP_PDU_Contents_e2ap_RICaction_RemovedForModification_ItemIEs_id_RICaction_RemovedForModification_Item:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICaction_RemovedForModification_ItemIEs_id_RICaction_RemovedForModification_Item;
            RTXCTXTPUSHELEMNAME(pctxt, "RICaction-RemovedForModification-Item");
            //pvalue->value.u._e2ap_RICaction_RemovedForModification_ItemIEs_id_id_RICaction_RemovedForModification_Item 
             pvalue->value.u._e2apRICaction_RemovedForModification_ItemIEs_id_RICaction_RemovedForModification_Item 
                    = rtxMemAllocType(pctxt, e2ap_RICaction_RemovedForModification_Item);
            //asn1Init_e2ap_RICaction_RemovedForModification_Item(pvalue->value.u._e2ap_RICaction_RemovedForModification_ItemIEs_id_id_RICaction_RemovedForModification_Item);
            asn1Init_e2ap_RICaction_RemovedForModification_Item(pvalue->value.u._e2apRICaction_RemovedForModification_ItemIEs_id_RICaction_RemovedForModification_Item);
            stat = asn1PD_e2ap_RICaction_RemovedForModification_Item (pctxt,
                    (e2ap_RICaction_RemovedForModification_Item*)pvalue->value.
                    u._e2apRICaction_RemovedForModification_ItemIEs_id_RICaction_RemovedForModification_Item);
            if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICaction_RemovedForModification_ItemIEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*)rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
      }
      {
      size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
      size_t bitsConsumed = bitEndOffset - bitStartOffset;
      if(bitsConsumed < bitLength){
         stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
      } else {
         stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
      }
      }
   }
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   return stat;
}

void asn1Init_e2ap_RICaction_RemovedForModification_ItemIEs (e2ap_RICaction_RemovedForModification_ItemIEs* pvalue)
{
   if (!pvalue) return;
   OSCRTLMEMSET (pvalue, 0, sizeof(e2ap_RICaction_RemovedForModification_ItemIEs));
}

#if 0
void asn1Free_e2ap_RICaction_RemovedForModification_ItemIEs (OSCTXT* pctxt, e2ap_RICaction_RemovedForModification_ItemIEs* pvalue)
{
   if (!pvalue) return;
   if (pvalue->extElem1) {
      rtxMemFreeArray (pctxt, pvalue->extElem1);
      pvalue->extElem1 = 0;
      pvalue->extElem1_n = 0;
   }
}
#endif
void asn1Free_e2ap_RICaction_RemovedForModification_ItemIEs (OSCTXT* pctxt, e2ap_RICaction_RemovedForModification_ItemIEs* pvalue)
{
   if(0==pvalue) return;
   switch(pvalue->value.t){
      case T_E2AP_PDU_Contents_e2ap_RICaction_RemovedForModification_ItemIEs_id_RICaction_RemovedForModification_Item:
         asn1Free_e2ap_RICaction_RemovedForModification_Item (pctxt, pvalue->value.u._e2apRICaction_RemovedForModification_ItemIEs_id_RICaction_RemovedForModification_Item);
         rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2apRICaction_RemovedForModification_ItemIEs_id_RICaction_RemovedForModification_Item);
         pvalue->value.u._e2apRICaction_RemovedForModification_ItemIEs_id_RICaction_RemovedForModification_Item = 0;
         break;
      case T_E2AP_PDU_Contents_e2ap_RICaction_RemovedForModification_ItemIEs_UNDEF_:
         if(0!=pvalue->value.u.extElem1){
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1->data);
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
             pvalue->value.u.extElem1 =0;
         }
         break;
         default:;
   }
}

int  asn1PrtToStr_e2ap_RICaction_RemovedForModification_ItemIEs (const char * name, e2ap_RICaction_RemovedForModification_ItemIEs* pvalue, char * buffer, OSSIZE bufSize){
   if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
       return -1;

      if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
         return -1;

      if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
         return -1;
      if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
         return -1;
      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_RICaction_RemovedForModification_ItemIEs_id_RICaction_RemovedForModification_Item:
         if(asn1PrtToStr_e2ap_RICaction_RemovedForModification_Item("RICaction-RemovedForModification-Item",
                pvalue->value.u._e2apRICaction_RemovedForModification_ItemIEs_id_RICaction_RemovedForModification_Item, buffer, bufSize)<0)// dungnm23 check lai nhe xem la
            return -1;
         break;
      default:
         if(0!=pvalue -> value.u.extElem1){
             rtPrintToStringIndent(buffer, bufSize);
             rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

         }
      }
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

      return 0;

}
 

/*****************************************/
/*           RICactions_RemovedForModification_List                */
/*****************************************/
//seq_of_single_container


int asn1PE_e2ap_RICactions_RemovedForModification_List (OSCTXT* pctxt, e2ap_RICactions_RemovedForModification_List* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_RICaction_RemovedForModification_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "RICactions-RemovedForModification-List");

   /* encode length determinant */
   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(16), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;
   for (xx1 = 0; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next, xx1++) {
      pdata = (e2ap_RICaction_RemovedForModification_ItemIEs*) pnode->data;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_e2ap_RICaction_RemovedForModification_ItemIEs (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      //xx1++;
      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}

int asn1PD_e2ap_RICactions_RemovedForModification_List (OSCTXT* pctxt, e2ap_RICactions_RemovedForModification_List* ppvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_RICaction_RemovedForModification_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "RICactions-RemovedForModification-List");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(16), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (ppvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      pdata = rtxMemAllocType (pctxt, e2ap_RICaction_RemovedForModification_ItemIEs);
      if (!pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);
      asn1Init_e2ap_RICaction_RemovedForModification_ItemIEs (pdata);
      stat = asn1PD_e2ap_RICaction_RemovedForModification_ItemIEs (pctxt, pdata);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         return LOG_RTERR (pctxt, stat);
      }

      rtxDListAppendNode (ppvalue, pdata);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

void asn1Init_e2ap_RICactions_RemovedForModification_List (e2ap_RICactions_RemovedForModification_List* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
}

void asn1Free_e2ap_RICactions_RemovedForModification_List (OSCTXT* pctxt, e2ap_RICactions_RemovedForModification_List* pvalue)
{
   if(pvalue==0) return;
   OSRTDListNode* pnode = pvalue->head;
   while (pnode) {
      e2ap_RICaction_RemovedForModification_ItemIEs* pdata = (e2ap_RICaction_RemovedForModification_ItemIEs*) pnode->data;
      if (pdata) {
         asn1Free_e2ap_RICaction_RemovedForModification_ItemIEs (pctxt, pdata);
         rtxMemFreePtr (pctxt, pdata);
      }
      pnode = pnode->next;
   }
      rtxDListFreeAll(pctxt, pvalue);
}

#if 0
void asn1Free_e2ap_RICactions_RemovedForModification_List (OSCTXT* pctxt, e2ap_RICactions_RemovedForModification_List* pvalue){
   if(0==pvalue ) return;
   {
      e2ap_RICaction_RemovedForModification_ItemIEs * pdata;
      OSRTDListNode *pnode = pvalue->head;
      while(0!=pnode){
         pdata = (e2ap_RICaction_RemovedForModification_ItemIEs*)pnode->data;
         asn1Free_e2ap_RICaction_RemovedForModification_ItemIEs(pctxt, pdata);
         pnode = pnode->next;
      }
      rtxDListFreeAll(pctxt, pvalue);
   }
}
#endif


int asn1PrtToStr_e2ap_RICactions_RemovedForModification_List(const char* name, e2ap_RICactions_RemovedForModification_List* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_RICaction_RemovedForModification_ItemIEs* pdata;
    OSRTDListNode* pnode;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode = pvalue->head;  xx1 < pvalue->count && pnode != 0; pnode = pnode->next, xx1++){
        pdata = (e2ap_RICaction_RemovedForModification_ItemIEs*)pnode->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 1
        if(asn1PrtToStr_e2ap_RICaction_RemovedForModification_ItemIEs(nameBuf, pdata, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}
/*****************************************/
/*           RICaction-FailedToBeRemovedForModification-Item                */
/*****************************************/
//sequence normal
// Các nội dung cần thiết cho template seq_normal.c.j2

// Các phần còn lại của template seq_normal.c.j2
//contain extensition bit -> theo mau cua GlobalgNB-ID
int asn1PE_e2ap_RICaction_FailedToBeRemovedForModification_Item (OSCTXT* pctxt, e2ap_RICaction_FailedToBeRemovedForModification_Item* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RICaction-FailedToBeRemovedForModification-Item");

   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field ricActionID - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "ricActionID");
   stat = asn1PE_e2ap_RICactionID (pctxt, pvalue->ricActionID);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /* encode field cause - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "cause");
   stat = asn1PE_e2ap_Cause (pctxt, pvalue->cause);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);



   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RICaction_FailedToBeRemovedForModification_Item (OSCTXT* pctxt, e2ap_RICaction_FailedToBeRemovedForModification_Item* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME(pctxt, "RICaction-FailedToBeRemovedForModification-Item");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field ricActionID */
   RTXCTXTPUSHELEMNAME(pctxt, "ricActionID");
      stat = asn1PD_e2ap_RICactionID (pctxt, &pvalue->ricActionID);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field cause */
   RTXCTXTPUSHELEMNAME(pctxt, "cause");
      stat = asn1PD_e2ap_Cause (pctxt, &pvalue->cause);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RICaction_FailedToBeRemovedForModification_Item (e2ap_RICaction_FailedToBeRemovedForModification_Item* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RICactionID (&pvalue->ricActionID);
   asn1Init_e2ap_Cause (&pvalue->cause);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RICaction_FailedToBeRemovedForModification_Item (OSCTXT* pctxt, e2ap_RICaction_FailedToBeRemovedForModification_Item* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_RICactionID (pctxt, &pvalue->ricActionID);
   asn1Free_e2ap_Cause (pctxt, &pvalue->cause);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RICaction_FailedToBeRemovedForModification_Item (const char* name, e2ap_RICaction_FailedToBeRemovedForModification_Item* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }
   if(asn1PrtToStr_e2ap_RICactionID ("ricActionID", &pvalue->ricActionID, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_Cause ("cause", &pvalue->cause, buffer, bufSize) < 0)
   {
      return -1;
   }



   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           RICaction_FailedToBeRemovedForModification_ItemIEs                */
/*****************************************/
/* ie.c.j2 */
/*ie thường*/
int asn1PE_e2ap_RICaction_FailedToBeRemovedForModification_ItemIEs (OSCTXT* pctxt, e2ap_RICaction_FailedToBeRemovedForModification_ItemIEs* pvalue)
{
   int stat = 0;
   //RTXCTXTPUSHTYPENAME (pctxt, "RICaction-FailedToBeRemovedForModification-ItemIEs");

   /* encode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");
   stat = asn1PE_e2ap_ProtocolIE_ID (pctxt, pvalue->id);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");
   stat = asn1PE_e2ap_Criticality (pctxt, pvalue->criticality);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   {
      OSCTXT ictxt;
      OSOCTET* pDynamicEncodeBuffer;
      ASN1OpenType openType;
      OSBOOL  encoded = TRUE;

      openType.numocts = 0;
      openType.data = 0;

      rtxCopyContext (&ictxt, pctxt);
      pctxt->pStream = 0;

      stat = rtxInitContextBuffer (pctxt, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_RICaction_FailedToBeRemovedForModification_ItemIEs_id_RICaction_FailedToBeRemovedForModification_Item:
         
        // RTXCTXTPUSHELEMNAME (pctxt, "RICaction_FailedToBeRemovedForModification_ItemIEs_id_RICaction_FailedToBeRemovedForModification_Item");
         RTXCTXTPUSHELEMNAME (pctxt, "RICaction-FailedToBeRemovedForModification-Item");
         stat = asn1PE_e2ap_RICaction_FailedToBeRemovedForModification_Item (pctxt, pvalue->value.u._e2apRICaction_FailedToBeRemovedForModification_ItemIEs_id_RICaction_FailedToBeRemovedForModification_Item);
         RTXCTXTPOPELEMNAME (pctxt);
      
         break;

      case T_E2AP_PDU_Contents_e2ap_RICaction_FailedToBeRemovedForModification_ItemIEs_UNDEF_:
      {
          if(0!=pvalue->value.u.extElem1){
              openType.numocts = pvalue->value.u.extElem1->numocts;
              openType.data = pvalue->value.u.extElem1->data;
          } else {
              /* No extension element to encode */
          }
          encoded = FALSE;
          break;
      }
      default:
         encoded = FALSE;
         stat = RTERR_INVOPT;
      }

      if (encoded) {
         openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
         openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
      }
      rtxCopyContext (pctxt, &ictxt);
      if(stat ==0) stat = pe_OpenType(pctxt, openType.numocts, openType.data);
      /*free dynamic encode buffer*/
      if(encoded){
          rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
      }
   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);
   //RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

int asn1PD_e2ap_RICaction_FailedToBeRemovedForModification_ItemIEs (OSCTXT* pctxt, e2ap_RICaction_FailedToBeRemovedForModification_ItemIEs* pvalue)
{
   int stat =0;
   /*deode root element id*/
   RTXCTXTPUSHELEMNAME(pctxt, "id");
   stat = asn1PD_e2ap_ProtocolIE_ID (pctxt, &pvalue->id);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*decode root element criticality*/
   RTXCTXTPUSHELEMNAME(pctxt, "criticality");
   stat = asn1PD_e2ap_Criticality (pctxt, &pvalue->criticality);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   /*decode root element value*/
   RTXCTXTPUSHELEMNAME(pctxt, "value");
   {
      OSUINT32 openTypeLen;
      size_t bitStartOffset, bitLength;
      stat = pd_UnconsLength(pctxt, &openTypeLen);
      if(stat <0) return LOG_RTERR(pctxt, stat);
      else if(stat == RT_OK_FRAG){
         rtxErrAddStrParm(pctxt, "open type with fragmented length use - perindef");
         return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
      }
      bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
      bitLength = openTypeLen * 8;
      switch (pvalue->id){
         case T_E2AP_PDU_Contents_e2ap_RICaction_FailedToBeRemovedForModification_ItemIEs_id_RICaction_FailedToBeRemovedForModification_Item:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICaction_FailedToBeRemovedForModification_ItemIEs_id_RICaction_FailedToBeRemovedForModification_Item;
            RTXCTXTPUSHELEMNAME(pctxt, "RICaction-FailedToBeRemovedForModification-Item");
            //pvalue->value.u._e2ap_RICaction_FailedToBeRemovedForModification_ItemIEs_id_id_RICaction_FailedToBeRemovedForModification_Item 
             pvalue->value.u._e2apRICaction_FailedToBeRemovedForModification_ItemIEs_id_RICaction_FailedToBeRemovedForModification_Item 
                    = rtxMemAllocType(pctxt, e2ap_RICaction_FailedToBeRemovedForModification_Item);
            //asn1Init_e2ap_RICaction_FailedToBeRemovedForModification_Item(pvalue->value.u._e2ap_RICaction_FailedToBeRemovedForModification_ItemIEs_id_id_RICaction_FailedToBeRemovedForModification_Item);
            asn1Init_e2ap_RICaction_FailedToBeRemovedForModification_Item(pvalue->value.u._e2apRICaction_FailedToBeRemovedForModification_ItemIEs_id_RICaction_FailedToBeRemovedForModification_Item);
            stat = asn1PD_e2ap_RICaction_FailedToBeRemovedForModification_Item (pctxt,
                    (e2ap_RICaction_FailedToBeRemovedForModification_Item*)pvalue->value.
                    u._e2apRICaction_FailedToBeRemovedForModification_ItemIEs_id_RICaction_FailedToBeRemovedForModification_Item);
            if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICaction_FailedToBeRemovedForModification_ItemIEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*)rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
      }
      {
      size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
      size_t bitsConsumed = bitEndOffset - bitStartOffset;
      if(bitsConsumed < bitLength){
         stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
      } else {
         stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
      }
      }
   }
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   return stat;
}

void asn1Init_e2ap_RICaction_FailedToBeRemovedForModification_ItemIEs (e2ap_RICaction_FailedToBeRemovedForModification_ItemIEs* pvalue)
{
   if (!pvalue) return;
   OSCRTLMEMSET (pvalue, 0, sizeof(e2ap_RICaction_FailedToBeRemovedForModification_ItemIEs));
}

#if 0
void asn1Free_e2ap_RICaction_FailedToBeRemovedForModification_ItemIEs (OSCTXT* pctxt, e2ap_RICaction_FailedToBeRemovedForModification_ItemIEs* pvalue)
{
   if (!pvalue) return;
   if (pvalue->extElem1) {
      rtxMemFreeArray (pctxt, pvalue->extElem1);
      pvalue->extElem1 = 0;
      pvalue->extElem1_n = 0;
   }
}
#endif
void asn1Free_e2ap_RICaction_FailedToBeRemovedForModification_ItemIEs (OSCTXT* pctxt, e2ap_RICaction_FailedToBeRemovedForModification_ItemIEs* pvalue)
{
   if(0==pvalue) return;
   switch(pvalue->value.t){
      case T_E2AP_PDU_Contents_e2ap_RICaction_FailedToBeRemovedForModification_ItemIEs_id_RICaction_FailedToBeRemovedForModification_Item:
         asn1Free_e2ap_RICaction_FailedToBeRemovedForModification_Item (pctxt, pvalue->value.u._e2apRICaction_FailedToBeRemovedForModification_ItemIEs_id_RICaction_FailedToBeRemovedForModification_Item);
         rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2apRICaction_FailedToBeRemovedForModification_ItemIEs_id_RICaction_FailedToBeRemovedForModification_Item);
         pvalue->value.u._e2apRICaction_FailedToBeRemovedForModification_ItemIEs_id_RICaction_FailedToBeRemovedForModification_Item = 0;
         break;
      case T_E2AP_PDU_Contents_e2ap_RICaction_FailedToBeRemovedForModification_ItemIEs_UNDEF_:
         if(0!=pvalue->value.u.extElem1){
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1->data);
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
             pvalue->value.u.extElem1 =0;
         }
         break;
         default:;
   }
}

int  asn1PrtToStr_e2ap_RICaction_FailedToBeRemovedForModification_ItemIEs (const char * name, e2ap_RICaction_FailedToBeRemovedForModification_ItemIEs* pvalue, char * buffer, OSSIZE bufSize){
   if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
       return -1;

      if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
         return -1;

      if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
         return -1;
      if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
         return -1;
      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_RICaction_FailedToBeRemovedForModification_ItemIEs_id_RICaction_FailedToBeRemovedForModification_Item:
         if(asn1PrtToStr_e2ap_RICaction_FailedToBeRemovedForModification_Item("RICaction-FailedToBeRemovedForModification-Item",
                pvalue->value.u._e2apRICaction_FailedToBeRemovedForModification_ItemIEs_id_RICaction_FailedToBeRemovedForModification_Item, buffer, bufSize)<0)// dungnm23 check lai nhe xem la
            return -1;
         break;
      default:
         if(0!=pvalue -> value.u.extElem1){
             rtPrintToStringIndent(buffer, bufSize);
             rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

         }
      }
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

      return 0;

}
 

/*****************************************/
/*           RICactions_FailedToBeRemovedForModification_List                */
/*****************************************/
//seq_of_single_container


int asn1PE_e2ap_RICactions_FailedToBeRemovedForModification_List (OSCTXT* pctxt, e2ap_RICactions_FailedToBeRemovedForModification_List* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_RICaction_FailedToBeRemovedForModification_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "RICactions-FailedToBeRemovedForModification-List");

   /* encode length determinant */
   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(16), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;
   for (xx1 = 0; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next, xx1++) {
      pdata = (e2ap_RICaction_FailedToBeRemovedForModification_ItemIEs*) pnode->data;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_e2ap_RICaction_FailedToBeRemovedForModification_ItemIEs (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      //xx1++;
      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}

int asn1PD_e2ap_RICactions_FailedToBeRemovedForModification_List (OSCTXT* pctxt, e2ap_RICactions_FailedToBeRemovedForModification_List* ppvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_RICaction_FailedToBeRemovedForModification_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "RICactions-FailedToBeRemovedForModification-List");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(16), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (ppvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      pdata = rtxMemAllocType (pctxt, e2ap_RICaction_FailedToBeRemovedForModification_ItemIEs);
      if (!pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);
      asn1Init_e2ap_RICaction_FailedToBeRemovedForModification_ItemIEs (pdata);
      stat = asn1PD_e2ap_RICaction_FailedToBeRemovedForModification_ItemIEs (pctxt, pdata);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         return LOG_RTERR (pctxt, stat);
      }

      rtxDListAppendNode (ppvalue, pdata);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

void asn1Init_e2ap_RICactions_FailedToBeRemovedForModification_List (e2ap_RICactions_FailedToBeRemovedForModification_List* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
}

void asn1Free_e2ap_RICactions_FailedToBeRemovedForModification_List (OSCTXT* pctxt, e2ap_RICactions_FailedToBeRemovedForModification_List* pvalue)
{
   if(pvalue==0) return;
   OSRTDListNode* pnode = pvalue->head;
   while (pnode) {
      e2ap_RICaction_FailedToBeRemovedForModification_ItemIEs* pdata = (e2ap_RICaction_FailedToBeRemovedForModification_ItemIEs*) pnode->data;
      if (pdata) {
         asn1Free_e2ap_RICaction_FailedToBeRemovedForModification_ItemIEs (pctxt, pdata);
         rtxMemFreePtr (pctxt, pdata);
      }
      pnode = pnode->next;
   }
      rtxDListFreeAll(pctxt, pvalue);
}

#if 0
void asn1Free_e2ap_RICactions_FailedToBeRemovedForModification_List (OSCTXT* pctxt, e2ap_RICactions_FailedToBeRemovedForModification_List* pvalue){
   if(0==pvalue ) return;
   {
      e2ap_RICaction_FailedToBeRemovedForModification_ItemIEs * pdata;
      OSRTDListNode *pnode = pvalue->head;
      while(0!=pnode){
         pdata = (e2ap_RICaction_FailedToBeRemovedForModification_ItemIEs*)pnode->data;
         asn1Free_e2ap_RICaction_FailedToBeRemovedForModification_ItemIEs(pctxt, pdata);
         pnode = pnode->next;
      }
      rtxDListFreeAll(pctxt, pvalue);
   }
}
#endif


int asn1PrtToStr_e2ap_RICactions_FailedToBeRemovedForModification_List(const char* name, e2ap_RICactions_FailedToBeRemovedForModification_List* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_RICaction_FailedToBeRemovedForModification_ItemIEs* pdata;
    OSRTDListNode* pnode;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode = pvalue->head;  xx1 < pvalue->count && pnode != 0; pnode = pnode->next, xx1++){
        pdata = (e2ap_RICaction_FailedToBeRemovedForModification_ItemIEs*)pnode->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 1
        if(asn1PrtToStr_e2ap_RICaction_FailedToBeRemovedForModification_ItemIEs(nameBuf, pdata, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}
/*****************************************/
/*           RICaction-ModifiedForModification-Item                */
/*****************************************/
//sequence normal
// Các nội dung cần thiết cho template seq_normal.c.j2

// Các phần còn lại của template seq_normal.c.j2
//contain extensition bit -> theo mau cua GlobalgNB-ID
int asn1PE_e2ap_RICaction_ModifiedForModification_Item (OSCTXT* pctxt, e2ap_RICaction_ModifiedForModification_Item* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RICaction-ModifiedForModification-Item");

   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field ricActionID - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "ricActionID");
   stat = asn1PE_e2ap_RICactionID (pctxt, pvalue->ricActionID);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);



   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RICaction_ModifiedForModification_Item (OSCTXT* pctxt, e2ap_RICaction_ModifiedForModification_Item* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME(pctxt, "RICaction-ModifiedForModification-Item");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field ricActionID */
   RTXCTXTPUSHELEMNAME(pctxt, "ricActionID");
      stat = asn1PD_e2ap_RICactionID (pctxt, &pvalue->ricActionID);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RICaction_ModifiedForModification_Item (e2ap_RICaction_ModifiedForModification_Item* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RICactionID (&pvalue->ricActionID);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RICaction_ModifiedForModification_Item (OSCTXT* pctxt, e2ap_RICaction_ModifiedForModification_Item* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_RICactionID (pctxt, &pvalue->ricActionID);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RICaction_ModifiedForModification_Item (const char* name, e2ap_RICaction_ModifiedForModification_Item* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }
   if(asn1PrtToStr_e2ap_RICactionID ("ricActionID", &pvalue->ricActionID, buffer, bufSize) < 0)
   {
      return -1;
   }



   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           RICaction_ModifiedForModification_ItemIEs                */
/*****************************************/
/* ie.c.j2 */
/*ie thường*/
int asn1PE_e2ap_RICaction_ModifiedForModification_ItemIEs (OSCTXT* pctxt, e2ap_RICaction_ModifiedForModification_ItemIEs* pvalue)
{
   int stat = 0;
   //RTXCTXTPUSHTYPENAME (pctxt, "RICaction-ModifiedForModification-ItemIEs");

   /* encode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");
   stat = asn1PE_e2ap_ProtocolIE_ID (pctxt, pvalue->id);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");
   stat = asn1PE_e2ap_Criticality (pctxt, pvalue->criticality);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   {
      OSCTXT ictxt;
      OSOCTET* pDynamicEncodeBuffer;
      ASN1OpenType openType;
      OSBOOL  encoded = TRUE;

      openType.numocts = 0;
      openType.data = 0;

      rtxCopyContext (&ictxt, pctxt);
      pctxt->pStream = 0;

      stat = rtxInitContextBuffer (pctxt, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_RICaction_ModifiedForModification_ItemIEs_id_RICaction_ModifiedForModification_Item:
         
        // RTXCTXTPUSHELEMNAME (pctxt, "RICaction_ModifiedForModification_ItemIEs_id_RICaction_ModifiedForModification_Item");
         RTXCTXTPUSHELEMNAME (pctxt, "RICaction-ModifiedForModification-Item");
         stat = asn1PE_e2ap_RICaction_ModifiedForModification_Item (pctxt, pvalue->value.u._e2apRICaction_ModifiedForModification_ItemIEs_id_RICaction_ModifiedForModification_Item);
         RTXCTXTPOPELEMNAME (pctxt);
      
         break;

      case T_E2AP_PDU_Contents_e2ap_RICaction_ModifiedForModification_ItemIEs_UNDEF_:
      {
          if(0!=pvalue->value.u.extElem1){
              openType.numocts = pvalue->value.u.extElem1->numocts;
              openType.data = pvalue->value.u.extElem1->data;
          } else {
              /* No extension element to encode */
          }
          encoded = FALSE;
          break;
      }
      default:
         encoded = FALSE;
         stat = RTERR_INVOPT;
      }

      if (encoded) {
         openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
         openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
      }
      rtxCopyContext (pctxt, &ictxt);
      if(stat ==0) stat = pe_OpenType(pctxt, openType.numocts, openType.data);
      /*free dynamic encode buffer*/
      if(encoded){
          rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
      }
   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);
   //RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

int asn1PD_e2ap_RICaction_ModifiedForModification_ItemIEs (OSCTXT* pctxt, e2ap_RICaction_ModifiedForModification_ItemIEs* pvalue)
{
   int stat =0;
   /*deode root element id*/
   RTXCTXTPUSHELEMNAME(pctxt, "id");
   stat = asn1PD_e2ap_ProtocolIE_ID (pctxt, &pvalue->id);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*decode root element criticality*/
   RTXCTXTPUSHELEMNAME(pctxt, "criticality");
   stat = asn1PD_e2ap_Criticality (pctxt, &pvalue->criticality);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   /*decode root element value*/
   RTXCTXTPUSHELEMNAME(pctxt, "value");
   {
      OSUINT32 openTypeLen;
      size_t bitStartOffset, bitLength;
      stat = pd_UnconsLength(pctxt, &openTypeLen);
      if(stat <0) return LOG_RTERR(pctxt, stat);
      else if(stat == RT_OK_FRAG){
         rtxErrAddStrParm(pctxt, "open type with fragmented length use - perindef");
         return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
      }
      bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
      bitLength = openTypeLen * 8;
      switch (pvalue->id){
         case T_E2AP_PDU_Contents_e2ap_RICaction_ModifiedForModification_ItemIEs_id_RICaction_ModifiedForModification_Item:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICaction_ModifiedForModification_ItemIEs_id_RICaction_ModifiedForModification_Item;
            RTXCTXTPUSHELEMNAME(pctxt, "RICaction-ModifiedForModification-Item");
            //pvalue->value.u._e2ap_RICaction_ModifiedForModification_ItemIEs_id_id_RICaction_ModifiedForModification_Item 
             pvalue->value.u._e2apRICaction_ModifiedForModification_ItemIEs_id_RICaction_ModifiedForModification_Item 
                    = rtxMemAllocType(pctxt, e2ap_RICaction_ModifiedForModification_Item);
            //asn1Init_e2ap_RICaction_ModifiedForModification_Item(pvalue->value.u._e2ap_RICaction_ModifiedForModification_ItemIEs_id_id_RICaction_ModifiedForModification_Item);
            asn1Init_e2ap_RICaction_ModifiedForModification_Item(pvalue->value.u._e2apRICaction_ModifiedForModification_ItemIEs_id_RICaction_ModifiedForModification_Item);
            stat = asn1PD_e2ap_RICaction_ModifiedForModification_Item (pctxt,
                    (e2ap_RICaction_ModifiedForModification_Item*)pvalue->value.
                    u._e2apRICaction_ModifiedForModification_ItemIEs_id_RICaction_ModifiedForModification_Item);
            if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICaction_ModifiedForModification_ItemIEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*)rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
      }
      {
      size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
      size_t bitsConsumed = bitEndOffset - bitStartOffset;
      if(bitsConsumed < bitLength){
         stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
      } else {
         stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
      }
      }
   }
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   return stat;
}

void asn1Init_e2ap_RICaction_ModifiedForModification_ItemIEs (e2ap_RICaction_ModifiedForModification_ItemIEs* pvalue)
{
   if (!pvalue) return;
   OSCRTLMEMSET (pvalue, 0, sizeof(e2ap_RICaction_ModifiedForModification_ItemIEs));
}

#if 0
void asn1Free_e2ap_RICaction_ModifiedForModification_ItemIEs (OSCTXT* pctxt, e2ap_RICaction_ModifiedForModification_ItemIEs* pvalue)
{
   if (!pvalue) return;
   if (pvalue->extElem1) {
      rtxMemFreeArray (pctxt, pvalue->extElem1);
      pvalue->extElem1 = 0;
      pvalue->extElem1_n = 0;
   }
}
#endif
void asn1Free_e2ap_RICaction_ModifiedForModification_ItemIEs (OSCTXT* pctxt, e2ap_RICaction_ModifiedForModification_ItemIEs* pvalue)
{
   if(0==pvalue) return;
   switch(pvalue->value.t){
      case T_E2AP_PDU_Contents_e2ap_RICaction_ModifiedForModification_ItemIEs_id_RICaction_ModifiedForModification_Item:
         asn1Free_e2ap_RICaction_ModifiedForModification_Item (pctxt, pvalue->value.u._e2apRICaction_ModifiedForModification_ItemIEs_id_RICaction_ModifiedForModification_Item);
         rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2apRICaction_ModifiedForModification_ItemIEs_id_RICaction_ModifiedForModification_Item);
         pvalue->value.u._e2apRICaction_ModifiedForModification_ItemIEs_id_RICaction_ModifiedForModification_Item = 0;
         break;
      case T_E2AP_PDU_Contents_e2ap_RICaction_ModifiedForModification_ItemIEs_UNDEF_:
         if(0!=pvalue->value.u.extElem1){
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1->data);
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
             pvalue->value.u.extElem1 =0;
         }
         break;
         default:;
   }
}

int  asn1PrtToStr_e2ap_RICaction_ModifiedForModification_ItemIEs (const char * name, e2ap_RICaction_ModifiedForModification_ItemIEs* pvalue, char * buffer, OSSIZE bufSize){
   if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
       return -1;

      if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
         return -1;

      if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
         return -1;
      if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
         return -1;
      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_RICaction_ModifiedForModification_ItemIEs_id_RICaction_ModifiedForModification_Item:
         if(asn1PrtToStr_e2ap_RICaction_ModifiedForModification_Item("RICaction-ModifiedForModification-Item",
                pvalue->value.u._e2apRICaction_ModifiedForModification_ItemIEs_id_RICaction_ModifiedForModification_Item, buffer, bufSize)<0)// dungnm23 check lai nhe xem la
            return -1;
         break;
      default:
         if(0!=pvalue -> value.u.extElem1){
             rtPrintToStringIndent(buffer, bufSize);
             rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

         }
      }
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

      return 0;

}
 

/*****************************************/
/*           RICactions_ModifiedForModification_List                */
/*****************************************/
//seq_of_single_container


int asn1PE_e2ap_RICactions_ModifiedForModification_List (OSCTXT* pctxt, e2ap_RICactions_ModifiedForModification_List* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_RICaction_ModifiedForModification_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "RICactions-ModifiedForModification-List");

   /* encode length determinant */
   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(16), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;
   for (xx1 = 0; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next, xx1++) {
      pdata = (e2ap_RICaction_ModifiedForModification_ItemIEs*) pnode->data;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_e2ap_RICaction_ModifiedForModification_ItemIEs (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      //xx1++;
      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}

int asn1PD_e2ap_RICactions_ModifiedForModification_List (OSCTXT* pctxt, e2ap_RICactions_ModifiedForModification_List* ppvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_RICaction_ModifiedForModification_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "RICactions-ModifiedForModification-List");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(16), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (ppvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      pdata = rtxMemAllocType (pctxt, e2ap_RICaction_ModifiedForModification_ItemIEs);
      if (!pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);
      asn1Init_e2ap_RICaction_ModifiedForModification_ItemIEs (pdata);
      stat = asn1PD_e2ap_RICaction_ModifiedForModification_ItemIEs (pctxt, pdata);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         return LOG_RTERR (pctxt, stat);
      }

      rtxDListAppendNode (ppvalue, pdata);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

void asn1Init_e2ap_RICactions_ModifiedForModification_List (e2ap_RICactions_ModifiedForModification_List* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
}

void asn1Free_e2ap_RICactions_ModifiedForModification_List (OSCTXT* pctxt, e2ap_RICactions_ModifiedForModification_List* pvalue)
{
   if(pvalue==0) return;
   OSRTDListNode* pnode = pvalue->head;
   while (pnode) {
      e2ap_RICaction_ModifiedForModification_ItemIEs* pdata = (e2ap_RICaction_ModifiedForModification_ItemIEs*) pnode->data;
      if (pdata) {
         asn1Free_e2ap_RICaction_ModifiedForModification_ItemIEs (pctxt, pdata);
         rtxMemFreePtr (pctxt, pdata);
      }
      pnode = pnode->next;
   }
      rtxDListFreeAll(pctxt, pvalue);
}

#if 0
void asn1Free_e2ap_RICactions_ModifiedForModification_List (OSCTXT* pctxt, e2ap_RICactions_ModifiedForModification_List* pvalue){
   if(0==pvalue ) return;
   {
      e2ap_RICaction_ModifiedForModification_ItemIEs * pdata;
      OSRTDListNode *pnode = pvalue->head;
      while(0!=pnode){
         pdata = (e2ap_RICaction_ModifiedForModification_ItemIEs*)pnode->data;
         asn1Free_e2ap_RICaction_ModifiedForModification_ItemIEs(pctxt, pdata);
         pnode = pnode->next;
      }
      rtxDListFreeAll(pctxt, pvalue);
   }
}
#endif


int asn1PrtToStr_e2ap_RICactions_ModifiedForModification_List(const char* name, e2ap_RICactions_ModifiedForModification_List* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_RICaction_ModifiedForModification_ItemIEs* pdata;
    OSRTDListNode* pnode;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode = pvalue->head;  xx1 < pvalue->count && pnode != 0; pnode = pnode->next, xx1++){
        pdata = (e2ap_RICaction_ModifiedForModification_ItemIEs*)pnode->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 1
        if(asn1PrtToStr_e2ap_RICaction_ModifiedForModification_ItemIEs(nameBuf, pdata, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}
/*****************************************/
/*           RICaction-FailedToBeModifiedForModification-Item                */
/*****************************************/
//sequence normal
// Các nội dung cần thiết cho template seq_normal.c.j2

// Các phần còn lại của template seq_normal.c.j2
//contain extensition bit -> theo mau cua GlobalgNB-ID
int asn1PE_e2ap_RICaction_FailedToBeModifiedForModification_Item (OSCTXT* pctxt, e2ap_RICaction_FailedToBeModifiedForModification_Item* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RICaction-FailedToBeModifiedForModification-Item");

   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field ricActionID - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "ricActionID");
   stat = asn1PE_e2ap_RICactionID (pctxt, pvalue->ricActionID);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /* encode field cause - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "cause");
   stat = asn1PE_e2ap_Cause (pctxt, pvalue->cause);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);



   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RICaction_FailedToBeModifiedForModification_Item (OSCTXT* pctxt, e2ap_RICaction_FailedToBeModifiedForModification_Item* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME(pctxt, "RICaction-FailedToBeModifiedForModification-Item");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field ricActionID */
   RTXCTXTPUSHELEMNAME(pctxt, "ricActionID");
      stat = asn1PD_e2ap_RICactionID (pctxt, &pvalue->ricActionID);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field cause */
   RTXCTXTPUSHELEMNAME(pctxt, "cause");
      stat = asn1PD_e2ap_Cause (pctxt, &pvalue->cause);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RICaction_FailedToBeModifiedForModification_Item (e2ap_RICaction_FailedToBeModifiedForModification_Item* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RICactionID (&pvalue->ricActionID);
   asn1Init_e2ap_Cause (&pvalue->cause);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RICaction_FailedToBeModifiedForModification_Item (OSCTXT* pctxt, e2ap_RICaction_FailedToBeModifiedForModification_Item* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_RICactionID (pctxt, &pvalue->ricActionID);
   asn1Free_e2ap_Cause (pctxt, &pvalue->cause);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RICaction_FailedToBeModifiedForModification_Item (const char* name, e2ap_RICaction_FailedToBeModifiedForModification_Item* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }
   if(asn1PrtToStr_e2ap_RICactionID ("ricActionID", &pvalue->ricActionID, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_Cause ("cause", &pvalue->cause, buffer, bufSize) < 0)
   {
      return -1;
   }



   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           RICaction_FailedToBeModifiedForModification_ItemIEs                */
/*****************************************/
/* ie.c.j2 */
/*ie thường*/
int asn1PE_e2ap_RICaction_FailedToBeModifiedForModification_ItemIEs (OSCTXT* pctxt, e2ap_RICaction_FailedToBeModifiedForModification_ItemIEs* pvalue)
{
   int stat = 0;
   //RTXCTXTPUSHTYPENAME (pctxt, "RICaction-FailedToBeModifiedForModification-ItemIEs");

   /* encode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");
   stat = asn1PE_e2ap_ProtocolIE_ID (pctxt, pvalue->id);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");
   stat = asn1PE_e2ap_Criticality (pctxt, pvalue->criticality);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   {
      OSCTXT ictxt;
      OSOCTET* pDynamicEncodeBuffer;
      ASN1OpenType openType;
      OSBOOL  encoded = TRUE;

      openType.numocts = 0;
      openType.data = 0;

      rtxCopyContext (&ictxt, pctxt);
      pctxt->pStream = 0;

      stat = rtxInitContextBuffer (pctxt, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_RICaction_FailedToBeModifiedForModification_ItemIEs_id_RICaction_FailedToBeModifiedForModification_Item:
         
        // RTXCTXTPUSHELEMNAME (pctxt, "RICaction_FailedToBeModifiedForModification_ItemIEs_id_RICaction_FailedToBeModifiedForModification_Item");
         RTXCTXTPUSHELEMNAME (pctxt, "RICaction-FailedToBeModifiedForModification-Item");
         stat = asn1PE_e2ap_RICaction_FailedToBeModifiedForModification_Item (pctxt, pvalue->value.u._e2apRICaction_FailedToBeModifiedForModification_ItemIEs_id_RICaction_FailedToBeModifiedForModification_Item);
         RTXCTXTPOPELEMNAME (pctxt);
      
         break;

      case T_E2AP_PDU_Contents_e2ap_RICaction_FailedToBeModifiedForModification_ItemIEs_UNDEF_:
      {
          if(0!=pvalue->value.u.extElem1){
              openType.numocts = pvalue->value.u.extElem1->numocts;
              openType.data = pvalue->value.u.extElem1->data;
          } else {
              /* No extension element to encode */
          }
          encoded = FALSE;
          break;
      }
      default:
         encoded = FALSE;
         stat = RTERR_INVOPT;
      }

      if (encoded) {
         openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
         openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
      }
      rtxCopyContext (pctxt, &ictxt);
      if(stat ==0) stat = pe_OpenType(pctxt, openType.numocts, openType.data);
      /*free dynamic encode buffer*/
      if(encoded){
          rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
      }
   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);
   //RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

int asn1PD_e2ap_RICaction_FailedToBeModifiedForModification_ItemIEs (OSCTXT* pctxt, e2ap_RICaction_FailedToBeModifiedForModification_ItemIEs* pvalue)
{
   int stat =0;
   /*deode root element id*/
   RTXCTXTPUSHELEMNAME(pctxt, "id");
   stat = asn1PD_e2ap_ProtocolIE_ID (pctxt, &pvalue->id);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*decode root element criticality*/
   RTXCTXTPUSHELEMNAME(pctxt, "criticality");
   stat = asn1PD_e2ap_Criticality (pctxt, &pvalue->criticality);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   /*decode root element value*/
   RTXCTXTPUSHELEMNAME(pctxt, "value");
   {
      OSUINT32 openTypeLen;
      size_t bitStartOffset, bitLength;
      stat = pd_UnconsLength(pctxt, &openTypeLen);
      if(stat <0) return LOG_RTERR(pctxt, stat);
      else if(stat == RT_OK_FRAG){
         rtxErrAddStrParm(pctxt, "open type with fragmented length use - perindef");
         return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
      }
      bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
      bitLength = openTypeLen * 8;
      switch (pvalue->id){
         case T_E2AP_PDU_Contents_e2ap_RICaction_FailedToBeModifiedForModification_ItemIEs_id_RICaction_FailedToBeModifiedForModification_Item:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICaction_FailedToBeModifiedForModification_ItemIEs_id_RICaction_FailedToBeModifiedForModification_Item;
            RTXCTXTPUSHELEMNAME(pctxt, "RICaction-FailedToBeModifiedForModification-Item");
            //pvalue->value.u._e2ap_RICaction_FailedToBeModifiedForModification_ItemIEs_id_id_RICaction_FailedToBeModifiedForModification_Item 
             pvalue->value.u._e2apRICaction_FailedToBeModifiedForModification_ItemIEs_id_RICaction_FailedToBeModifiedForModification_Item 
                    = rtxMemAllocType(pctxt, e2ap_RICaction_FailedToBeModifiedForModification_Item);
            //asn1Init_e2ap_RICaction_FailedToBeModifiedForModification_Item(pvalue->value.u._e2ap_RICaction_FailedToBeModifiedForModification_ItemIEs_id_id_RICaction_FailedToBeModifiedForModification_Item);
            asn1Init_e2ap_RICaction_FailedToBeModifiedForModification_Item(pvalue->value.u._e2apRICaction_FailedToBeModifiedForModification_ItemIEs_id_RICaction_FailedToBeModifiedForModification_Item);
            stat = asn1PD_e2ap_RICaction_FailedToBeModifiedForModification_Item (pctxt,
                    (e2ap_RICaction_FailedToBeModifiedForModification_Item*)pvalue->value.
                    u._e2apRICaction_FailedToBeModifiedForModification_ItemIEs_id_RICaction_FailedToBeModifiedForModification_Item);
            if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICaction_FailedToBeModifiedForModification_ItemIEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*)rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
      }
      {
      size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
      size_t bitsConsumed = bitEndOffset - bitStartOffset;
      if(bitsConsumed < bitLength){
         stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
      } else {
         stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
      }
      }
   }
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   return stat;
}

void asn1Init_e2ap_RICaction_FailedToBeModifiedForModification_ItemIEs (e2ap_RICaction_FailedToBeModifiedForModification_ItemIEs* pvalue)
{
   if (!pvalue) return;
   OSCRTLMEMSET (pvalue, 0, sizeof(e2ap_RICaction_FailedToBeModifiedForModification_ItemIEs));
}

#if 0
void asn1Free_e2ap_RICaction_FailedToBeModifiedForModification_ItemIEs (OSCTXT* pctxt, e2ap_RICaction_FailedToBeModifiedForModification_ItemIEs* pvalue)
{
   if (!pvalue) return;
   if (pvalue->extElem1) {
      rtxMemFreeArray (pctxt, pvalue->extElem1);
      pvalue->extElem1 = 0;
      pvalue->extElem1_n = 0;
   }
}
#endif
void asn1Free_e2ap_RICaction_FailedToBeModifiedForModification_ItemIEs (OSCTXT* pctxt, e2ap_RICaction_FailedToBeModifiedForModification_ItemIEs* pvalue)
{
   if(0==pvalue) return;
   switch(pvalue->value.t){
      case T_E2AP_PDU_Contents_e2ap_RICaction_FailedToBeModifiedForModification_ItemIEs_id_RICaction_FailedToBeModifiedForModification_Item:
         asn1Free_e2ap_RICaction_FailedToBeModifiedForModification_Item (pctxt, pvalue->value.u._e2apRICaction_FailedToBeModifiedForModification_ItemIEs_id_RICaction_FailedToBeModifiedForModification_Item);
         rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2apRICaction_FailedToBeModifiedForModification_ItemIEs_id_RICaction_FailedToBeModifiedForModification_Item);
         pvalue->value.u._e2apRICaction_FailedToBeModifiedForModification_ItemIEs_id_RICaction_FailedToBeModifiedForModification_Item = 0;
         break;
      case T_E2AP_PDU_Contents_e2ap_RICaction_FailedToBeModifiedForModification_ItemIEs_UNDEF_:
         if(0!=pvalue->value.u.extElem1){
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1->data);
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
             pvalue->value.u.extElem1 =0;
         }
         break;
         default:;
   }
}

int  asn1PrtToStr_e2ap_RICaction_FailedToBeModifiedForModification_ItemIEs (const char * name, e2ap_RICaction_FailedToBeModifiedForModification_ItemIEs* pvalue, char * buffer, OSSIZE bufSize){
   if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
       return -1;

      if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
         return -1;

      if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
         return -1;
      if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
         return -1;
      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_RICaction_FailedToBeModifiedForModification_ItemIEs_id_RICaction_FailedToBeModifiedForModification_Item:
         if(asn1PrtToStr_e2ap_RICaction_FailedToBeModifiedForModification_Item("RICaction-FailedToBeModifiedForModification-Item",
                pvalue->value.u._e2apRICaction_FailedToBeModifiedForModification_ItemIEs_id_RICaction_FailedToBeModifiedForModification_Item, buffer, bufSize)<0)// dungnm23 check lai nhe xem la
            return -1;
         break;
      default:
         if(0!=pvalue -> value.u.extElem1){
             rtPrintToStringIndent(buffer, bufSize);
             rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

         }
      }
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

      return 0;

}
 

/*****************************************/
/*           RICactions_FailedToBeModifiedForModification_List                */
/*****************************************/
//seq_of_single_container


int asn1PE_e2ap_RICactions_FailedToBeModifiedForModification_List (OSCTXT* pctxt, e2ap_RICactions_FailedToBeModifiedForModification_List* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_RICaction_FailedToBeModifiedForModification_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "RICactions-FailedToBeModifiedForModification-List");

   /* encode length determinant */
   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(16), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;
   for (xx1 = 0; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next, xx1++) {
      pdata = (e2ap_RICaction_FailedToBeModifiedForModification_ItemIEs*) pnode->data;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_e2ap_RICaction_FailedToBeModifiedForModification_ItemIEs (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      //xx1++;
      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}

int asn1PD_e2ap_RICactions_FailedToBeModifiedForModification_List (OSCTXT* pctxt, e2ap_RICactions_FailedToBeModifiedForModification_List* ppvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_RICaction_FailedToBeModifiedForModification_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "RICactions-FailedToBeModifiedForModification-List");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(16), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (ppvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      pdata = rtxMemAllocType (pctxt, e2ap_RICaction_FailedToBeModifiedForModification_ItemIEs);
      if (!pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);
      asn1Init_e2ap_RICaction_FailedToBeModifiedForModification_ItemIEs (pdata);
      stat = asn1PD_e2ap_RICaction_FailedToBeModifiedForModification_ItemIEs (pctxt, pdata);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         return LOG_RTERR (pctxt, stat);
      }

      rtxDListAppendNode (ppvalue, pdata);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

void asn1Init_e2ap_RICactions_FailedToBeModifiedForModification_List (e2ap_RICactions_FailedToBeModifiedForModification_List* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
}

void asn1Free_e2ap_RICactions_FailedToBeModifiedForModification_List (OSCTXT* pctxt, e2ap_RICactions_FailedToBeModifiedForModification_List* pvalue)
{
   if(pvalue==0) return;
   OSRTDListNode* pnode = pvalue->head;
   while (pnode) {
      e2ap_RICaction_FailedToBeModifiedForModification_ItemIEs* pdata = (e2ap_RICaction_FailedToBeModifiedForModification_ItemIEs*) pnode->data;
      if (pdata) {
         asn1Free_e2ap_RICaction_FailedToBeModifiedForModification_ItemIEs (pctxt, pdata);
         rtxMemFreePtr (pctxt, pdata);
      }
      pnode = pnode->next;
   }
      rtxDListFreeAll(pctxt, pvalue);
}

#if 0
void asn1Free_e2ap_RICactions_FailedToBeModifiedForModification_List (OSCTXT* pctxt, e2ap_RICactions_FailedToBeModifiedForModification_List* pvalue){
   if(0==pvalue ) return;
   {
      e2ap_RICaction_FailedToBeModifiedForModification_ItemIEs * pdata;
      OSRTDListNode *pnode = pvalue->head;
      while(0!=pnode){
         pdata = (e2ap_RICaction_FailedToBeModifiedForModification_ItemIEs*)pnode->data;
         asn1Free_e2ap_RICaction_FailedToBeModifiedForModification_ItemIEs(pctxt, pdata);
         pnode = pnode->next;
      }
      rtxDListFreeAll(pctxt, pvalue);
   }
}
#endif


int asn1PrtToStr_e2ap_RICactions_FailedToBeModifiedForModification_List(const char* name, e2ap_RICactions_FailedToBeModifiedForModification_List* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_RICaction_FailedToBeModifiedForModification_ItemIEs* pdata;
    OSRTDListNode* pnode;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode = pvalue->head;  xx1 < pvalue->count && pnode != 0; pnode = pnode->next, xx1++){
        pdata = (e2ap_RICaction_FailedToBeModifiedForModification_ItemIEs*)pnode->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 1
        if(asn1PrtToStr_e2ap_RICaction_FailedToBeModifiedForModification_ItemIEs(nameBuf, pdata, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}
/*****************************************/
/*           RICaction-AddedForModification-Item                */
/*****************************************/
//sequence normal
// Các nội dung cần thiết cho template seq_normal.c.j2

// Các phần còn lại của template seq_normal.c.j2
//contain extensition bit -> theo mau cua GlobalgNB-ID
int asn1PE_e2ap_RICaction_AddedForModification_Item (OSCTXT* pctxt, e2ap_RICaction_AddedForModification_Item* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RICaction-AddedForModification-Item");

   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field ricActionID - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "ricActionID");
   stat = asn1PE_e2ap_RICactionID (pctxt, pvalue->ricActionID);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);



   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RICaction_AddedForModification_Item (OSCTXT* pctxt, e2ap_RICaction_AddedForModification_Item* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME(pctxt, "RICaction-AddedForModification-Item");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field ricActionID */
   RTXCTXTPUSHELEMNAME(pctxt, "ricActionID");
      stat = asn1PD_e2ap_RICactionID (pctxt, &pvalue->ricActionID);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RICaction_AddedForModification_Item (e2ap_RICaction_AddedForModification_Item* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RICactionID (&pvalue->ricActionID);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RICaction_AddedForModification_Item (OSCTXT* pctxt, e2ap_RICaction_AddedForModification_Item* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_RICactionID (pctxt, &pvalue->ricActionID);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RICaction_AddedForModification_Item (const char* name, e2ap_RICaction_AddedForModification_Item* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }
   if(asn1PrtToStr_e2ap_RICactionID ("ricActionID", &pvalue->ricActionID, buffer, bufSize) < 0)
   {
      return -1;
   }



   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           RICaction_AddedForModification_ItemIEs                */
/*****************************************/
/* ie.c.j2 */
/*ie thường*/
int asn1PE_e2ap_RICaction_AddedForModification_ItemIEs (OSCTXT* pctxt, e2ap_RICaction_AddedForModification_ItemIEs* pvalue)
{
   int stat = 0;
   //RTXCTXTPUSHTYPENAME (pctxt, "RICaction-AddedForModification-ItemIEs");

   /* encode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");
   stat = asn1PE_e2ap_ProtocolIE_ID (pctxt, pvalue->id);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");
   stat = asn1PE_e2ap_Criticality (pctxt, pvalue->criticality);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   {
      OSCTXT ictxt;
      OSOCTET* pDynamicEncodeBuffer;
      ASN1OpenType openType;
      OSBOOL  encoded = TRUE;

      openType.numocts = 0;
      openType.data = 0;

      rtxCopyContext (&ictxt, pctxt);
      pctxt->pStream = 0;

      stat = rtxInitContextBuffer (pctxt, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_RICaction_AddedForModification_ItemIEs_id_RICaction_AddedForModification_Item:
         
        // RTXCTXTPUSHELEMNAME (pctxt, "RICaction_AddedForModification_ItemIEs_id_RICaction_AddedForModification_Item");
         RTXCTXTPUSHELEMNAME (pctxt, "RICaction-AddedForModification-Item");
         stat = asn1PE_e2ap_RICaction_AddedForModification_Item (pctxt, pvalue->value.u._e2apRICaction_AddedForModification_ItemIEs_id_RICaction_AddedForModification_Item);
         RTXCTXTPOPELEMNAME (pctxt);
      
         break;

      case T_E2AP_PDU_Contents_e2ap_RICaction_AddedForModification_ItemIEs_UNDEF_:
      {
          if(0!=pvalue->value.u.extElem1){
              openType.numocts = pvalue->value.u.extElem1->numocts;
              openType.data = pvalue->value.u.extElem1->data;
          } else {
              /* No extension element to encode */
          }
          encoded = FALSE;
          break;
      }
      default:
         encoded = FALSE;
         stat = RTERR_INVOPT;
      }

      if (encoded) {
         openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
         openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
      }
      rtxCopyContext (pctxt, &ictxt);
      if(stat ==0) stat = pe_OpenType(pctxt, openType.numocts, openType.data);
      /*free dynamic encode buffer*/
      if(encoded){
          rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
      }
   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);
   //RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

int asn1PD_e2ap_RICaction_AddedForModification_ItemIEs (OSCTXT* pctxt, e2ap_RICaction_AddedForModification_ItemIEs* pvalue)
{
   int stat =0;
   /*deode root element id*/
   RTXCTXTPUSHELEMNAME(pctxt, "id");
   stat = asn1PD_e2ap_ProtocolIE_ID (pctxt, &pvalue->id);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*decode root element criticality*/
   RTXCTXTPUSHELEMNAME(pctxt, "criticality");
   stat = asn1PD_e2ap_Criticality (pctxt, &pvalue->criticality);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   /*decode root element value*/
   RTXCTXTPUSHELEMNAME(pctxt, "value");
   {
      OSUINT32 openTypeLen;
      size_t bitStartOffset, bitLength;
      stat = pd_UnconsLength(pctxt, &openTypeLen);
      if(stat <0) return LOG_RTERR(pctxt, stat);
      else if(stat == RT_OK_FRAG){
         rtxErrAddStrParm(pctxt, "open type with fragmented length use - perindef");
         return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
      }
      bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
      bitLength = openTypeLen * 8;
      switch (pvalue->id){
         case T_E2AP_PDU_Contents_e2ap_RICaction_AddedForModification_ItemIEs_id_RICaction_AddedForModification_Item:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICaction_AddedForModification_ItemIEs_id_RICaction_AddedForModification_Item;
            RTXCTXTPUSHELEMNAME(pctxt, "RICaction-AddedForModification-Item");
            //pvalue->value.u._e2ap_RICaction_AddedForModification_ItemIEs_id_id_RICaction_AddedForModification_Item 
             pvalue->value.u._e2apRICaction_AddedForModification_ItemIEs_id_RICaction_AddedForModification_Item 
                    = rtxMemAllocType(pctxt, e2ap_RICaction_AddedForModification_Item);
            //asn1Init_e2ap_RICaction_AddedForModification_Item(pvalue->value.u._e2ap_RICaction_AddedForModification_ItemIEs_id_id_RICaction_AddedForModification_Item);
            asn1Init_e2ap_RICaction_AddedForModification_Item(pvalue->value.u._e2apRICaction_AddedForModification_ItemIEs_id_RICaction_AddedForModification_Item);
            stat = asn1PD_e2ap_RICaction_AddedForModification_Item (pctxt,
                    (e2ap_RICaction_AddedForModification_Item*)pvalue->value.
                    u._e2apRICaction_AddedForModification_ItemIEs_id_RICaction_AddedForModification_Item);
            if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICaction_AddedForModification_ItemIEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*)rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
      }
      {
      size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
      size_t bitsConsumed = bitEndOffset - bitStartOffset;
      if(bitsConsumed < bitLength){
         stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
      } else {
         stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
      }
      }
   }
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   return stat;
}

void asn1Init_e2ap_RICaction_AddedForModification_ItemIEs (e2ap_RICaction_AddedForModification_ItemIEs* pvalue)
{
   if (!pvalue) return;
   OSCRTLMEMSET (pvalue, 0, sizeof(e2ap_RICaction_AddedForModification_ItemIEs));
}

#if 0
void asn1Free_e2ap_RICaction_AddedForModification_ItemIEs (OSCTXT* pctxt, e2ap_RICaction_AddedForModification_ItemIEs* pvalue)
{
   if (!pvalue) return;
   if (pvalue->extElem1) {
      rtxMemFreeArray (pctxt, pvalue->extElem1);
      pvalue->extElem1 = 0;
      pvalue->extElem1_n = 0;
   }
}
#endif
void asn1Free_e2ap_RICaction_AddedForModification_ItemIEs (OSCTXT* pctxt, e2ap_RICaction_AddedForModification_ItemIEs* pvalue)
{
   if(0==pvalue) return;
   switch(pvalue->value.t){
      case T_E2AP_PDU_Contents_e2ap_RICaction_AddedForModification_ItemIEs_id_RICaction_AddedForModification_Item:
         asn1Free_e2ap_RICaction_AddedForModification_Item (pctxt, pvalue->value.u._e2apRICaction_AddedForModification_ItemIEs_id_RICaction_AddedForModification_Item);
         rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2apRICaction_AddedForModification_ItemIEs_id_RICaction_AddedForModification_Item);
         pvalue->value.u._e2apRICaction_AddedForModification_ItemIEs_id_RICaction_AddedForModification_Item = 0;
         break;
      case T_E2AP_PDU_Contents_e2ap_RICaction_AddedForModification_ItemIEs_UNDEF_:
         if(0!=pvalue->value.u.extElem1){
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1->data);
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
             pvalue->value.u.extElem1 =0;
         }
         break;
         default:;
   }
}

int  asn1PrtToStr_e2ap_RICaction_AddedForModification_ItemIEs (const char * name, e2ap_RICaction_AddedForModification_ItemIEs* pvalue, char * buffer, OSSIZE bufSize){
   if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
       return -1;

      if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
         return -1;

      if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
         return -1;
      if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
         return -1;
      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_RICaction_AddedForModification_ItemIEs_id_RICaction_AddedForModification_Item:
         if(asn1PrtToStr_e2ap_RICaction_AddedForModification_Item("RICaction-AddedForModification-Item",
                pvalue->value.u._e2apRICaction_AddedForModification_ItemIEs_id_RICaction_AddedForModification_Item, buffer, bufSize)<0)// dungnm23 check lai nhe xem la
            return -1;
         break;
      default:
         if(0!=pvalue -> value.u.extElem1){
             rtPrintToStringIndent(buffer, bufSize);
             rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

         }
      }
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

      return 0;

}
 

/*****************************************/
/*           RICactions_AddedForModification_List                */
/*****************************************/
//seq_of_single_container


int asn1PE_e2ap_RICactions_AddedForModification_List (OSCTXT* pctxt, e2ap_RICactions_AddedForModification_List* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_RICaction_AddedForModification_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "RICactions-AddedForModification-List");

   /* encode length determinant */
   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(16), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;
   for (xx1 = 0; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next, xx1++) {
      pdata = (e2ap_RICaction_AddedForModification_ItemIEs*) pnode->data;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_e2ap_RICaction_AddedForModification_ItemIEs (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      //xx1++;
      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}

int asn1PD_e2ap_RICactions_AddedForModification_List (OSCTXT* pctxt, e2ap_RICactions_AddedForModification_List* ppvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_RICaction_AddedForModification_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "RICactions-AddedForModification-List");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(16), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (ppvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      pdata = rtxMemAllocType (pctxt, e2ap_RICaction_AddedForModification_ItemIEs);
      if (!pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);
      asn1Init_e2ap_RICaction_AddedForModification_ItemIEs (pdata);
      stat = asn1PD_e2ap_RICaction_AddedForModification_ItemIEs (pctxt, pdata);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         return LOG_RTERR (pctxt, stat);
      }

      rtxDListAppendNode (ppvalue, pdata);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

void asn1Init_e2ap_RICactions_AddedForModification_List (e2ap_RICactions_AddedForModification_List* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
}

void asn1Free_e2ap_RICactions_AddedForModification_List (OSCTXT* pctxt, e2ap_RICactions_AddedForModification_List* pvalue)
{
   if(pvalue==0) return;
   OSRTDListNode* pnode = pvalue->head;
   while (pnode) {
      e2ap_RICaction_AddedForModification_ItemIEs* pdata = (e2ap_RICaction_AddedForModification_ItemIEs*) pnode->data;
      if (pdata) {
         asn1Free_e2ap_RICaction_AddedForModification_ItemIEs (pctxt, pdata);
         rtxMemFreePtr (pctxt, pdata);
      }
      pnode = pnode->next;
   }
      rtxDListFreeAll(pctxt, pvalue);
}

#if 0
void asn1Free_e2ap_RICactions_AddedForModification_List (OSCTXT* pctxt, e2ap_RICactions_AddedForModification_List* pvalue){
   if(0==pvalue ) return;
   {
      e2ap_RICaction_AddedForModification_ItemIEs * pdata;
      OSRTDListNode *pnode = pvalue->head;
      while(0!=pnode){
         pdata = (e2ap_RICaction_AddedForModification_ItemIEs*)pnode->data;
         asn1Free_e2ap_RICaction_AddedForModification_ItemIEs(pctxt, pdata);
         pnode = pnode->next;
      }
      rtxDListFreeAll(pctxt, pvalue);
   }
}
#endif


int asn1PrtToStr_e2ap_RICactions_AddedForModification_List(const char* name, e2ap_RICactions_AddedForModification_List* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_RICaction_AddedForModification_ItemIEs* pdata;
    OSRTDListNode* pnode;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode = pvalue->head;  xx1 < pvalue->count && pnode != 0; pnode = pnode->next, xx1++){
        pdata = (e2ap_RICaction_AddedForModification_ItemIEs*)pnode->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 1
        if(asn1PrtToStr_e2ap_RICaction_AddedForModification_ItemIEs(nameBuf, pdata, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}
/*****************************************/
/*           RICaction-FailedToBeAddedForModification-Item                */
/*****************************************/
//sequence normal
// Các nội dung cần thiết cho template seq_normal.c.j2

// Các phần còn lại của template seq_normal.c.j2
//contain extensition bit -> theo mau cua GlobalgNB-ID
int asn1PE_e2ap_RICaction_FailedToBeAddedForModification_Item (OSCTXT* pctxt, e2ap_RICaction_FailedToBeAddedForModification_Item* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RICaction-FailedToBeAddedForModification-Item");

   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field ricActionID - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "ricActionID");
   stat = asn1PE_e2ap_RICactionID (pctxt, pvalue->ricActionID);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /* encode field cause - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "cause");
   stat = asn1PE_e2ap_Cause (pctxt, pvalue->cause);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);



   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RICaction_FailedToBeAddedForModification_Item (OSCTXT* pctxt, e2ap_RICaction_FailedToBeAddedForModification_Item* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME(pctxt, "RICaction-FailedToBeAddedForModification-Item");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field ricActionID */
   RTXCTXTPUSHELEMNAME(pctxt, "ricActionID");
      stat = asn1PD_e2ap_RICactionID (pctxt, &pvalue->ricActionID);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field cause */
   RTXCTXTPUSHELEMNAME(pctxt, "cause");
      stat = asn1PD_e2ap_Cause (pctxt, &pvalue->cause);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RICaction_FailedToBeAddedForModification_Item (e2ap_RICaction_FailedToBeAddedForModification_Item* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RICactionID (&pvalue->ricActionID);
   asn1Init_e2ap_Cause (&pvalue->cause);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RICaction_FailedToBeAddedForModification_Item (OSCTXT* pctxt, e2ap_RICaction_FailedToBeAddedForModification_Item* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_RICactionID (pctxt, &pvalue->ricActionID);
   asn1Free_e2ap_Cause (pctxt, &pvalue->cause);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RICaction_FailedToBeAddedForModification_Item (const char* name, e2ap_RICaction_FailedToBeAddedForModification_Item* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }
   if(asn1PrtToStr_e2ap_RICactionID ("ricActionID", &pvalue->ricActionID, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_Cause ("cause", &pvalue->cause, buffer, bufSize) < 0)
   {
      return -1;
   }



   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           RICaction_FailedToBeAddedForModification_ItemIEs                */
/*****************************************/
/* ie.c.j2 */
/*ie thường*/
int asn1PE_e2ap_RICaction_FailedToBeAddedForModification_ItemIEs (OSCTXT* pctxt, e2ap_RICaction_FailedToBeAddedForModification_ItemIEs* pvalue)
{
   int stat = 0;
   //RTXCTXTPUSHTYPENAME (pctxt, "RICaction-FailedToBeAddedForModification-ItemIEs");

   /* encode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");
   stat = asn1PE_e2ap_ProtocolIE_ID (pctxt, pvalue->id);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");
   stat = asn1PE_e2ap_Criticality (pctxt, pvalue->criticality);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   {
      OSCTXT ictxt;
      OSOCTET* pDynamicEncodeBuffer;
      ASN1OpenType openType;
      OSBOOL  encoded = TRUE;

      openType.numocts = 0;
      openType.data = 0;

      rtxCopyContext (&ictxt, pctxt);
      pctxt->pStream = 0;

      stat = rtxInitContextBuffer (pctxt, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_RICaction_FailedToBeAddedForModification_ItemIEs_id_RICaction_FailedToBeAddedForModification_Item:
         
        // RTXCTXTPUSHELEMNAME (pctxt, "RICaction_FailedToBeAddedForModification_ItemIEs_id_RICaction_FailedToBeAddedForModification_Item");
         RTXCTXTPUSHELEMNAME (pctxt, "RICaction-FailedToBeAddedForModification-Item");
         stat = asn1PE_e2ap_RICaction_FailedToBeAddedForModification_Item (pctxt, pvalue->value.u._e2apRICaction_FailedToBeAddedForModification_ItemIEs_id_RICaction_FailedToBeAddedForModification_Item);
         RTXCTXTPOPELEMNAME (pctxt);
      
         break;

      case T_E2AP_PDU_Contents_e2ap_RICaction_FailedToBeAddedForModification_ItemIEs_UNDEF_:
      {
          if(0!=pvalue->value.u.extElem1){
              openType.numocts = pvalue->value.u.extElem1->numocts;
              openType.data = pvalue->value.u.extElem1->data;
          } else {
              /* No extension element to encode */
          }
          encoded = FALSE;
          break;
      }
      default:
         encoded = FALSE;
         stat = RTERR_INVOPT;
      }

      if (encoded) {
         openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
         openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
      }
      rtxCopyContext (pctxt, &ictxt);
      if(stat ==0) stat = pe_OpenType(pctxt, openType.numocts, openType.data);
      /*free dynamic encode buffer*/
      if(encoded){
          rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
      }
   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);
   //RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

int asn1PD_e2ap_RICaction_FailedToBeAddedForModification_ItemIEs (OSCTXT* pctxt, e2ap_RICaction_FailedToBeAddedForModification_ItemIEs* pvalue)
{
   int stat =0;
   /*deode root element id*/
   RTXCTXTPUSHELEMNAME(pctxt, "id");
   stat = asn1PD_e2ap_ProtocolIE_ID (pctxt, &pvalue->id);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*decode root element criticality*/
   RTXCTXTPUSHELEMNAME(pctxt, "criticality");
   stat = asn1PD_e2ap_Criticality (pctxt, &pvalue->criticality);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   /*decode root element value*/
   RTXCTXTPUSHELEMNAME(pctxt, "value");
   {
      OSUINT32 openTypeLen;
      size_t bitStartOffset, bitLength;
      stat = pd_UnconsLength(pctxt, &openTypeLen);
      if(stat <0) return LOG_RTERR(pctxt, stat);
      else if(stat == RT_OK_FRAG){
         rtxErrAddStrParm(pctxt, "open type with fragmented length use - perindef");
         return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
      }
      bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
      bitLength = openTypeLen * 8;
      switch (pvalue->id){
         case T_E2AP_PDU_Contents_e2ap_RICaction_FailedToBeAddedForModification_ItemIEs_id_RICaction_FailedToBeAddedForModification_Item:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICaction_FailedToBeAddedForModification_ItemIEs_id_RICaction_FailedToBeAddedForModification_Item;
            RTXCTXTPUSHELEMNAME(pctxt, "RICaction-FailedToBeAddedForModification-Item");
            //pvalue->value.u._e2ap_RICaction_FailedToBeAddedForModification_ItemIEs_id_id_RICaction_FailedToBeAddedForModification_Item 
             pvalue->value.u._e2apRICaction_FailedToBeAddedForModification_ItemIEs_id_RICaction_FailedToBeAddedForModification_Item 
                    = rtxMemAllocType(pctxt, e2ap_RICaction_FailedToBeAddedForModification_Item);
            //asn1Init_e2ap_RICaction_FailedToBeAddedForModification_Item(pvalue->value.u._e2ap_RICaction_FailedToBeAddedForModification_ItemIEs_id_id_RICaction_FailedToBeAddedForModification_Item);
            asn1Init_e2ap_RICaction_FailedToBeAddedForModification_Item(pvalue->value.u._e2apRICaction_FailedToBeAddedForModification_ItemIEs_id_RICaction_FailedToBeAddedForModification_Item);
            stat = asn1PD_e2ap_RICaction_FailedToBeAddedForModification_Item (pctxt,
                    (e2ap_RICaction_FailedToBeAddedForModification_Item*)pvalue->value.
                    u._e2apRICaction_FailedToBeAddedForModification_ItemIEs_id_RICaction_FailedToBeAddedForModification_Item);
            if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICaction_FailedToBeAddedForModification_ItemIEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*)rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
      }
      {
      size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
      size_t bitsConsumed = bitEndOffset - bitStartOffset;
      if(bitsConsumed < bitLength){
         stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
      } else {
         stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
      }
      }
   }
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   return stat;
}

void asn1Init_e2ap_RICaction_FailedToBeAddedForModification_ItemIEs (e2ap_RICaction_FailedToBeAddedForModification_ItemIEs* pvalue)
{
   if (!pvalue) return;
   OSCRTLMEMSET (pvalue, 0, sizeof(e2ap_RICaction_FailedToBeAddedForModification_ItemIEs));
}

#if 0
void asn1Free_e2ap_RICaction_FailedToBeAddedForModification_ItemIEs (OSCTXT* pctxt, e2ap_RICaction_FailedToBeAddedForModification_ItemIEs* pvalue)
{
   if (!pvalue) return;
   if (pvalue->extElem1) {
      rtxMemFreeArray (pctxt, pvalue->extElem1);
      pvalue->extElem1 = 0;
      pvalue->extElem1_n = 0;
   }
}
#endif
void asn1Free_e2ap_RICaction_FailedToBeAddedForModification_ItemIEs (OSCTXT* pctxt, e2ap_RICaction_FailedToBeAddedForModification_ItemIEs* pvalue)
{
   if(0==pvalue) return;
   switch(pvalue->value.t){
      case T_E2AP_PDU_Contents_e2ap_RICaction_FailedToBeAddedForModification_ItemIEs_id_RICaction_FailedToBeAddedForModification_Item:
         asn1Free_e2ap_RICaction_FailedToBeAddedForModification_Item (pctxt, pvalue->value.u._e2apRICaction_FailedToBeAddedForModification_ItemIEs_id_RICaction_FailedToBeAddedForModification_Item);
         rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2apRICaction_FailedToBeAddedForModification_ItemIEs_id_RICaction_FailedToBeAddedForModification_Item);
         pvalue->value.u._e2apRICaction_FailedToBeAddedForModification_ItemIEs_id_RICaction_FailedToBeAddedForModification_Item = 0;
         break;
      case T_E2AP_PDU_Contents_e2ap_RICaction_FailedToBeAddedForModification_ItemIEs_UNDEF_:
         if(0!=pvalue->value.u.extElem1){
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1->data);
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
             pvalue->value.u.extElem1 =0;
         }
         break;
         default:;
   }
}

int  asn1PrtToStr_e2ap_RICaction_FailedToBeAddedForModification_ItemIEs (const char * name, e2ap_RICaction_FailedToBeAddedForModification_ItemIEs* pvalue, char * buffer, OSSIZE bufSize){
   if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
       return -1;

      if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
         return -1;

      if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
         return -1;
      if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
         return -1;
      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_RICaction_FailedToBeAddedForModification_ItemIEs_id_RICaction_FailedToBeAddedForModification_Item:
         if(asn1PrtToStr_e2ap_RICaction_FailedToBeAddedForModification_Item("RICaction-FailedToBeAddedForModification-Item",
                pvalue->value.u._e2apRICaction_FailedToBeAddedForModification_ItemIEs_id_RICaction_FailedToBeAddedForModification_Item, buffer, bufSize)<0)// dungnm23 check lai nhe xem la
            return -1;
         break;
      default:
         if(0!=pvalue -> value.u.extElem1){
             rtPrintToStringIndent(buffer, bufSize);
             rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

         }
      }
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

      return 0;

}
 

/*****************************************/
/*           RICactions_FailedToBeAddedForModification_List                */
/*****************************************/
//seq_of_single_container


int asn1PE_e2ap_RICactions_FailedToBeAddedForModification_List (OSCTXT* pctxt, e2ap_RICactions_FailedToBeAddedForModification_List* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_RICaction_FailedToBeAddedForModification_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "RICactions-FailedToBeAddedForModification-List");

   /* encode length determinant */
   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(16), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;
   for (xx1 = 0; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next, xx1++) {
      pdata = (e2ap_RICaction_FailedToBeAddedForModification_ItemIEs*) pnode->data;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_e2ap_RICaction_FailedToBeAddedForModification_ItemIEs (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      //xx1++;
      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}

int asn1PD_e2ap_RICactions_FailedToBeAddedForModification_List (OSCTXT* pctxt, e2ap_RICactions_FailedToBeAddedForModification_List* ppvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_RICaction_FailedToBeAddedForModification_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "RICactions-FailedToBeAddedForModification-List");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(16), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (ppvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      pdata = rtxMemAllocType (pctxt, e2ap_RICaction_FailedToBeAddedForModification_ItemIEs);
      if (!pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);
      asn1Init_e2ap_RICaction_FailedToBeAddedForModification_ItemIEs (pdata);
      stat = asn1PD_e2ap_RICaction_FailedToBeAddedForModification_ItemIEs (pctxt, pdata);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         return LOG_RTERR (pctxt, stat);
      }

      rtxDListAppendNode (ppvalue, pdata);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

void asn1Init_e2ap_RICactions_FailedToBeAddedForModification_List (e2ap_RICactions_FailedToBeAddedForModification_List* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
}

void asn1Free_e2ap_RICactions_FailedToBeAddedForModification_List (OSCTXT* pctxt, e2ap_RICactions_FailedToBeAddedForModification_List* pvalue)
{
   if(pvalue==0) return;
   OSRTDListNode* pnode = pvalue->head;
   while (pnode) {
      e2ap_RICaction_FailedToBeAddedForModification_ItemIEs* pdata = (e2ap_RICaction_FailedToBeAddedForModification_ItemIEs*) pnode->data;
      if (pdata) {
         asn1Free_e2ap_RICaction_FailedToBeAddedForModification_ItemIEs (pctxt, pdata);
         rtxMemFreePtr (pctxt, pdata);
      }
      pnode = pnode->next;
   }
      rtxDListFreeAll(pctxt, pvalue);
}

#if 0
void asn1Free_e2ap_RICactions_FailedToBeAddedForModification_List (OSCTXT* pctxt, e2ap_RICactions_FailedToBeAddedForModification_List* pvalue){
   if(0==pvalue ) return;
   {
      e2ap_RICaction_FailedToBeAddedForModification_ItemIEs * pdata;
      OSRTDListNode *pnode = pvalue->head;
      while(0!=pnode){
         pdata = (e2ap_RICaction_FailedToBeAddedForModification_ItemIEs*)pnode->data;
         asn1Free_e2ap_RICaction_FailedToBeAddedForModification_ItemIEs(pctxt, pdata);
         pnode = pnode->next;
      }
      rtxDListFreeAll(pctxt, pvalue);
   }
}
#endif


int asn1PrtToStr_e2ap_RICactions_FailedToBeAddedForModification_List(const char* name, e2ap_RICactions_FailedToBeAddedForModification_List* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_RICaction_FailedToBeAddedForModification_ItemIEs* pdata;
    OSRTDListNode* pnode;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode = pvalue->head;  xx1 < pvalue->count && pnode != 0; pnode = pnode->next, xx1++){
        pdata = (e2ap_RICaction_FailedToBeAddedForModification_ItemIEs*)pnode->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 1
        if(asn1PrtToStr_e2ap_RICaction_FailedToBeAddedForModification_ItemIEs(nameBuf, pdata, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}/*****************************************/
/*           RICsubscriptionModificationResponse_IEs                */
/*****************************************/
/* ie.c.j2 */
 /* d là con của msg */
EXTERN int asn1PE_e2ap_RICsubscriptionModificationResponse_protocolIEs_element (OSCTXT* pctxt, e2ap_RICsubscriptionModificationResponse_protocolIEs_element* pvalue)
{
    int stat =0;

    /*encode id*/

    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PE_e2ap_ProtocolIE_ID(pctxt, pvalue->id);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PE_e2ap_Criticality(pctxt, pvalue->criticality);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
    {
        OSCTXT lctxt;
        OSOCTET *pDynamicEncodeBuffer;
        ASN1OpenType openType;
        OSBOOL encoded = TRUE;

        openType.numocts = 0;
        openType.data =0;

        rtxCopyContext(&lctxt, pctxt);
        pctxt->pStream =0;

        stat = rtxInitContextBuffer(pctxt, 0, 0);
        if(stat!=0) return LOG_RTERR(pctxt, stat);

        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationResponse_IEs_id_RICrequestID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICrequestID");
                    stat = asn1PE_e2ap_RICrequestID (pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_RICrequestID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationResponse_IEs_id_RANfunctionID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RANfunctionID");
                    stat = asn1PE_e2ap_RANfunctionID (pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_RANfunctionID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsRemovedForModification_List:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICactionsRemovedForModification-List");
                    stat = asn1PE_e2ap_RICactions_RemovedForModification_List (pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsRemovedForModification_List);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsFailedToBeRemovedForModification_List:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICactionsFailedToBeRemovedForModification-List");
                    stat = asn1PE_e2ap_RICactions_FailedToBeRemovedForModification_List (pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsFailedToBeRemovedForModification_List);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsModifiedForModification_List:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICactionsModifiedForModification-List");
                    stat = asn1PE_e2ap_RICactions_ModifiedForModification_List (pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsModifiedForModification_List);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsFailedToBeModifiedForModification_List:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICactionsFailedToBeModifiedForModification-List");
                    stat = asn1PE_e2ap_RICactions_FailedToBeModifiedForModification_List (pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsFailedToBeModifiedForModification_List);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsAddedForModification_List:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICactionsAddedForModification-List");
                    stat = asn1PE_e2ap_RICactions_AddedForModification_List (pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsAddedForModification_List);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsFailedToBeAddedForModification_List:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICactionsFailedToBeAddedForModification-List");
                    stat = asn1PE_e2ap_RICactions_FailedToBeAddedForModification_List (pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsFailedToBeAddedForModification_List);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationResponse_IEs_UNDEF_:
            {
                if(0!=pvalue->value.u.extElem1){
                    openType.numocts = pvalue->value.u.extElem1->numocts;
                    openType.data = pvalue->value.u.extElem1->data;
                } else {
                    /* No extension element to encode */
                }
                encoded = FALSE;
                break;
            }

            default:
                encoded = FALSE;
                stat = RTERR_INVOPT;
                break;
        } 

        if(encoded){
            openType.numocts = (OSUINT32)pe_GetMsgLen(pctxt);
            openType.data = pDynamicEncodeBuffer = pctxt -> buffer.data;
        }
        rtxCopyContext(pctxt, &lctxt);

        if(stat == 0) {
            stat = pe_OpenType (pctxt, openType.numocts, openType.data);
        }
    #if 1
        if(encoded){//dungnm23 check lai nhe
            rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
        }
    #endif

    }

    if(stat!=0) return LOG_RTERR(pctxt, stat);  
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}

EXTERN int  asn1PD_e2ap_RICsubscriptionModificationResponse_protocolIEs_element (OSCTXT* pctxt, e2ap_RICsubscriptionModificationResponse_protocolIEs_element* pvalue){
    int stat =0;

    /*decode id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PD_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PD_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");

    {
        OSUINT32 openTypeLen;
        size_t bitStartOffset, bitLength;

        stat = pd_UnconsLength(pctxt, &openTypeLen);
        if(stat<0) return LOG_RTERR(pctxt, stat);
        else if(stat == RT_OK_FRAG){
            rtxErrAddStrParm(pctxt, "open type with fragment length");
            return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
        }
        bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
        bitLength = openTypeLen * 8;

        switch(pvalue->id){//dungnm23 check case lai nhe
        
            case ASN1V_e2ap_id_RICrequestID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationResponse_IEs_id_RICrequestID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICrequestID");
                pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_RICrequestID 
                    = rtxMemAllocType(pctxt, e2ap_RICrequestID);

                asn1Init_e2ap_RICrequestID(pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_RICrequestID);

                stat = asn1PD_e2ap_RICrequestID (pctxt,
                        (e2ap_RICrequestID*)pvalue->value.
                        u._e2ap_RICsubscriptionModificationResponse_IEs_id_RICrequestID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RANfunctionID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationResponse_IEs_id_RANfunctionID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RANfunctionID");
                pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_RANfunctionID 
                    = rtxMemAllocType(pctxt, e2ap_RANfunctionID);

                asn1Init_e2ap_RANfunctionID(pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_RANfunctionID);

                stat = asn1PD_e2ap_RANfunctionID (pctxt,
                        (e2ap_RANfunctionID*)pvalue->value.
                        u._e2ap_RICsubscriptionModificationResponse_IEs_id_RANfunctionID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RICactionsRemovedForModification_List:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsRemovedForModification_List;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICactionsRemovedForModification-List");
                pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsRemovedForModification_List 
                    = rtxMemAllocType(pctxt, e2ap_RICactions_RemovedForModification_List);

                asn1Init_e2ap_RICactions_RemovedForModification_List(pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsRemovedForModification_List);

                stat = asn1PD_e2ap_RICactions_RemovedForModification_List (pctxt,
                        (e2ap_RICactions_RemovedForModification_List*)pvalue->value.
                        u._e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsRemovedForModification_List);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RICactionsFailedToBeRemovedForModification_List:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsFailedToBeRemovedForModification_List;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICactionsFailedToBeRemovedForModification-List");
                pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsFailedToBeRemovedForModification_List 
                    = rtxMemAllocType(pctxt, e2ap_RICactions_FailedToBeRemovedForModification_List);

                asn1Init_e2ap_RICactions_FailedToBeRemovedForModification_List(pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsFailedToBeRemovedForModification_List);

                stat = asn1PD_e2ap_RICactions_FailedToBeRemovedForModification_List (pctxt,
                        (e2ap_RICactions_FailedToBeRemovedForModification_List*)pvalue->value.
                        u._e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsFailedToBeRemovedForModification_List);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RICactionsModifiedForModification_List:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsModifiedForModification_List;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICactionsModifiedForModification-List");
                pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsModifiedForModification_List 
                    = rtxMemAllocType(pctxt, e2ap_RICactions_ModifiedForModification_List);

                asn1Init_e2ap_RICactions_ModifiedForModification_List(pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsModifiedForModification_List);

                stat = asn1PD_e2ap_RICactions_ModifiedForModification_List (pctxt,
                        (e2ap_RICactions_ModifiedForModification_List*)pvalue->value.
                        u._e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsModifiedForModification_List);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RICactionsFailedToBeModifiedForModification_List:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsFailedToBeModifiedForModification_List;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICactionsFailedToBeModifiedForModification-List");
                pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsFailedToBeModifiedForModification_List 
                    = rtxMemAllocType(pctxt, e2ap_RICactions_FailedToBeModifiedForModification_List);

                asn1Init_e2ap_RICactions_FailedToBeModifiedForModification_List(pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsFailedToBeModifiedForModification_List);

                stat = asn1PD_e2ap_RICactions_FailedToBeModifiedForModification_List (pctxt,
                        (e2ap_RICactions_FailedToBeModifiedForModification_List*)pvalue->value.
                        u._e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsFailedToBeModifiedForModification_List);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RICactionsAddedForModification_List:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsAddedForModification_List;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICactionsAddedForModification-List");
                pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsAddedForModification_List 
                    = rtxMemAllocType(pctxt, e2ap_RICactions_AddedForModification_List);

                asn1Init_e2ap_RICactions_AddedForModification_List(pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsAddedForModification_List);

                stat = asn1PD_e2ap_RICactions_AddedForModification_List (pctxt,
                        (e2ap_RICactions_AddedForModification_List*)pvalue->value.
                        u._e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsAddedForModification_List);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RICactionsFailedToBeAddedForModification_List:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsFailedToBeAddedForModification_List;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICactionsFailedToBeAddedForModification-List");
                pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsFailedToBeAddedForModification_List 
                    = rtxMemAllocType(pctxt, e2ap_RICactions_FailedToBeAddedForModification_List);

                asn1Init_e2ap_RICactions_FailedToBeAddedForModification_List(pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsFailedToBeAddedForModification_List);

                stat = asn1PD_e2ap_RICactions_FailedToBeAddedForModification_List (pctxt,
                        (e2ap_RICactions_FailedToBeAddedForModification_List*)pvalue->value.
                        u._e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsFailedToBeAddedForModification_List);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationResponse_IEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*) rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
    }
    {
    size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
    size_t bitsConsumed = bitEndOffset-bitStartOffset;
    if(bitsConsumed<bitLength){
        stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
    }
    else stat =(bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
    }}
    if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}


int asn1Init_e2ap_RICsubscriptionModificationResponse_protocolIEs_element(e2ap_RICsubscriptionModificationResponse_protocolIEs_element* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    OSCRTLMEMSET (&pvalue->value, 0, sizeof(pvalue->value));
    return 0;
}


//-----> chuaw có template rtxFreeASN1OpenType

#if 0
void asn1Free_e2ap_RICsubscriptionModificationResponse_protocolIEs_element(OSCTXT* pctxt, e2ap_RICsubscriptionModificationResponse_protocolIEs_element* pvalue)
{
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationResponse_IEs_id_id_RICrequestID:
            // rtxFreeE2ap_RICrequestID(pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_id_RICrequestID);

            if(pvalue->value.i._e2ap_RICsubscriptionModificationResponse_id_RICrequestID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICrequestID(pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_id_RICrequestID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_id_RICrequestID);
           // pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_id_RICrequestID = NULL;
           pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_RICrequestID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationResponse_IEs_id_id_RANfunctionID:
            // rtxFreeE2ap_RANfunctionID(pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_id_RANfunctionID);

            if(pvalue->value.i._e2ap_RICsubscriptionModificationResponse_id_RANfunctionID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RANfunctionID(pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_id_RANfunctionID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_id_RANfunctionID);
           // pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_id_RANfunctionID = NULL;
           pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_RANfunctionID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationResponse_IEs_id_id_RICactionsRemovedForModification_List:
            // rtxFreeE2ap_RICactions_RemovedForModification_List(pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_id_RICactionsRemovedForModification_List);

            if(pvalue->value.i._e2ap_RICsubscriptionModificationResponse_id_RICactions_RemovedForModification_List!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICactions_RemovedForModification_List(pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_id_RICactionsRemovedForModification_List);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_id_RICactionsRemovedForModification_List);
           // pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_id_RICactionsRemovedForModification_List = NULL;
           pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsRemovedForModification_List = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationResponse_IEs_id_id_RICactionsFailedToBeRemovedForModification_List:
            // rtxFreeE2ap_RICactions_FailedToBeRemovedForModification_List(pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_id_RICactionsFailedToBeRemovedForModification_List);

            if(pvalue->value.i._e2ap_RICsubscriptionModificationResponse_id_RICactions_FailedToBeRemovedForModification_List!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICactions_FailedToBeRemovedForModification_List(pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_id_RICactionsFailedToBeRemovedForModification_List);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_id_RICactionsFailedToBeRemovedForModification_List);
           // pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_id_RICactionsFailedToBeRemovedForModification_List = NULL;
           pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsFailedToBeRemovedForModification_List = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationResponse_IEs_id_id_RICactionsModifiedForModification_List:
            // rtxFreeE2ap_RICactions_ModifiedForModification_List(pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_id_RICactionsModifiedForModification_List);

            if(pvalue->value.i._e2ap_RICsubscriptionModificationResponse_id_RICactions_ModifiedForModification_List!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICactions_ModifiedForModification_List(pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_id_RICactionsModifiedForModification_List);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_id_RICactionsModifiedForModification_List);
           // pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_id_RICactionsModifiedForModification_List = NULL;
           pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsModifiedForModification_List = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationResponse_IEs_id_id_RICactionsFailedToBeModifiedForModification_List:
            // rtxFreeE2ap_RICactions_FailedToBeModifiedForModification_List(pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_id_RICactionsFailedToBeModifiedForModification_List);

            if(pvalue->value.i._e2ap_RICsubscriptionModificationResponse_id_RICactions_FailedToBeModifiedForModification_List!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICactions_FailedToBeModifiedForModification_List(pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_id_RICactionsFailedToBeModifiedForModification_List);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_id_RICactionsFailedToBeModifiedForModification_List);
           // pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_id_RICactionsFailedToBeModifiedForModification_List = NULL;
           pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsFailedToBeModifiedForModification_List = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationResponse_IEs_id_id_RICactionsAddedForModification_List:
            // rtxFreeE2ap_RICactions_AddedForModification_List(pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_id_RICactionsAddedForModification_List);

            if(pvalue->value.i._e2ap_RICsubscriptionModificationResponse_id_RICactions_AddedForModification_List!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICactions_AddedForModification_List(pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_id_RICactionsAddedForModification_List);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_id_RICactionsAddedForModification_List);
           // pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_id_RICactionsAddedForModification_List = NULL;
           pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsAddedForModification_List = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationResponse_IEs_id_id_RICactionsFailedToBeAddedForModification_List:
            // rtxFreeE2ap_RICactions_FailedToBeAddedForModification_List(pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_id_RICactionsFailedToBeAddedForModification_List);

            if(pvalue->value.i._e2ap_RICsubscriptionModificationResponse_id_RICactions_FailedToBeAddedForModification_List!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICactions_FailedToBeAddedForModification_List(pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_id_RICactionsFailedToBeAddedForModification_List);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_id_RICactionsFailedToBeAddedForModification_List);
           // pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_id_RICactionsFailedToBeAddedForModification_List = NULL;
           pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsFailedToBeAddedForModification_List = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationResponse_IEs_UNDEF_:
            rtxFreeASN1OpenType(pvalue->value.u.extElem1);
            break;
        default:
            break;
    }
}

int asn1PrtToStr_e2ap_RICsubscriptionModificationResponse_protocolIEs_element(OSCTXT* pctxt, e2ap_RICsubscriptionModificationResponse_protocolIEs_element* pvalue)
{
    int stat =0;
    RTXCTXTPUSHELEMNAME(pctxt, "e2ap_RICsubscriptionModificationResponse_protocolIEs_element");

    /*print id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PrtToStr_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PrtToStr_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationResponse_IEs_id_id_RICrequestID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICrequestID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICrequestID (pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_id_RICrequestID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationResponse_IEs_id_id_RANfunctionID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RANfunctionID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RANfunctionID (pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_id_RANfunctionID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationResponse_IEs_id_id_RICactionsRemovedForModification_List:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICactions-RemovedForModification-List");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICactions_RemovedForModification_List (pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_id_RICactionsRemovedForModification_List);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationResponse_IEs_id_id_RICactionsFailedToBeRemovedForModification_List:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICactions-FailedToBeRemovedForModification-List");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICactions_FailedToBeRemovedForModification_List (pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_id_RICactionsFailedToBeRemovedForModification_List);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationResponse_IEs_id_id_RICactionsModifiedForModification_List:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICactions-ModifiedForModification-List");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICactions_ModifiedForModification_List (pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_id_RICactionsModifiedForModification_List);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationResponse_IEs_id_id_RICactionsFailedToBeModifiedForModification_List:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICactions-FailedToBeModifiedForModification-List");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICactions_FailedToBeModifiedForModification_List (pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_id_RICactionsFailedToBeModifiedForModification_List);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationResponse_IEs_id_id_RICactionsAddedForModification_List:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICactions-AddedForModification-List");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICactions_AddedForModification_List (pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_id_RICactionsAddedForModification_List);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationResponse_IEs_id_id_RICactionsFailedToBeAddedForModification_List:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICactions-FailedToBeAddedForModification-List");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICactions_FailedToBeAddedForModification_List (pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_id_RICactionsFailedToBeAddedForModification_List);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationResponse_IEs_UNDEF_:
            {
                rtxPLogMsg(pctxt, "Extension element present - raw data not printed.\n");
                break;
            }

            default:
                stat = RTERR_INVOPT;
                return LOG_RTERR(pctxt, stat);
        }
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);
}
#endif


int asn1PrtToStr_e2ap_RICsubscriptionModificationResponse_protocolIEs_element (const char * name,
 e2ap_RICsubscriptionModificationResponse_protocolIEs_element* pvalue, 
 char * buffer, OSSIZE bufSize){
    if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
        return -1;
    if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
        return -1;

    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationResponse_IEs_id_RICrequestID:
            if(asn1PrtToStr_e2ap_RICrequestID("RICrequestID", 
                    pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_RICrequestID, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationResponse_IEs_id_RANfunctionID:
            if(asn1PrtToStr_e2ap_RANfunctionID("RANfunctionID", 
                    pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_RANfunctionID, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsRemovedForModification_List:
            if(asn1PrtToStr_e2ap_RICactions_RemovedForModification_List("RICactions-RemovedForModification-List", 
                    pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsRemovedForModification_List, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsFailedToBeRemovedForModification_List:
            if(asn1PrtToStr_e2ap_RICactions_FailedToBeRemovedForModification_List("RICactions-FailedToBeRemovedForModification-List", 
                    pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsFailedToBeRemovedForModification_List, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsModifiedForModification_List:
            if(asn1PrtToStr_e2ap_RICactions_ModifiedForModification_List("RICactions-ModifiedForModification-List", 
                    pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsModifiedForModification_List, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsFailedToBeModifiedForModification_List:
            if(asn1PrtToStr_e2ap_RICactions_FailedToBeModifiedForModification_List("RICactions-FailedToBeModifiedForModification-List", 
                    pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsFailedToBeModifiedForModification_List, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsAddedForModification_List:
            if(asn1PrtToStr_e2ap_RICactions_AddedForModification_List("RICactions-AddedForModification-List", 
                    pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsAddedForModification_List, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsFailedToBeAddedForModification_List:
            if(asn1PrtToStr_e2ap_RICactions_FailedToBeAddedForModification_List("RICactions-FailedToBeAddedForModification-List", 
                    pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsFailedToBeAddedForModification_List, buffer, bufSize)<0)
                return -1;
            break;    
        default:
        if(0!=pvalue -> value.u.extElem1){
            rtPrintToStringIndent(buffer, bufSize);
            rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

        }
        }
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

    return 0;

 }

 void asn1Free_e2ap_RICsubscriptionModificationResponse_protocolIEs_element(OSCTXT* pctxt, e2ap_RICsubscriptionModificationResponse_protocolIEs_element* pvalue){
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationResponse_IEs_id_RICrequestID:
            if(pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_RICrequestID!=NULL){
            asn1Free_e2ap_RICrequestID(pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_RICrequestID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_RICrequestID);
            pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_RICrequestID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationResponse_IEs_id_RANfunctionID:
            if(pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_RANfunctionID!=NULL){
            asn1Free_e2ap_RANfunctionID(pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_RANfunctionID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_RANfunctionID);
            pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_RANfunctionID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsRemovedForModification_List:
            if(pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsRemovedForModification_List!=NULL){
            asn1Free_e2ap_RICactions_RemovedForModification_List(pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsRemovedForModification_List);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsRemovedForModification_List);
            pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsRemovedForModification_List = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsFailedToBeRemovedForModification_List:
            if(pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsFailedToBeRemovedForModification_List!=NULL){
            asn1Free_e2ap_RICactions_FailedToBeRemovedForModification_List(pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsFailedToBeRemovedForModification_List);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsFailedToBeRemovedForModification_List);
            pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsFailedToBeRemovedForModification_List = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsModifiedForModification_List:
            if(pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsModifiedForModification_List!=NULL){
            asn1Free_e2ap_RICactions_ModifiedForModification_List(pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsModifiedForModification_List);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsModifiedForModification_List);
            pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsModifiedForModification_List = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsFailedToBeModifiedForModification_List:
            if(pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsFailedToBeModifiedForModification_List!=NULL){
            asn1Free_e2ap_RICactions_FailedToBeModifiedForModification_List(pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsFailedToBeModifiedForModification_List);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsFailedToBeModifiedForModification_List);
            pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsFailedToBeModifiedForModification_List = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsAddedForModification_List:
            if(pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsAddedForModification_List!=NULL){
            asn1Free_e2ap_RICactions_AddedForModification_List(pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsAddedForModification_List);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsAddedForModification_List);
            pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsAddedForModification_List = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsFailedToBeAddedForModification_List:
            if(pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsFailedToBeAddedForModification_List!=NULL){
            asn1Free_e2ap_RICactions_FailedToBeAddedForModification_List(pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsFailedToBeAddedForModification_List);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsFailedToBeAddedForModification_List);
            pvalue->value.u._e2ap_RICsubscriptionModificationResponse_IEs_id_RICactionsFailedToBeAddedForModification_List = NULL;
            }
            break;
        default:
            break;


    }
 }

 

/*****************************************/
/*           RICsubscriptionModificationResponse                */
/*****************************************/
//2_container.c
/* 1. xxx_ProtocolIE -> mẫu cũ ở ie_big_msg */
EXTERN int asn1PE_e2ap_RICsubscriptionModificationResponse_protocolIEs (OSCTXT* pctxt, e2ap_RICsubscriptionModificationResponse_protocolIEs* pvalue)
{
    int stat =0;
    OSRTDListNode* pnode;
    OSUINT32 xx1;

    /*encode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pe_Length(pctxt, pvalue->count);
    if(stat<0) return LOG_RTERR(pctxt, stat);

    /*encode each element*/
    xx1 =0;
    for(pnode = pvalue->head; pnode != 0 && xx1<pvalue->count; pnode = pnode->next){
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE", xx1);
        stat = asn1PE_e2ap_RICsubscriptionModificationResponse_protocolIEs_element (pctxt, ((e2ap_RICsubscriptionModificationResponse_protocolIEs_element*)pnode->data));
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        xx1++;
        RTXCTXTPOPARRAYELEMNAME(pctxt);
    }

    return (stat);
}

EXTERN int  asn1PD_e2ap_RICsubscriptionModificationResponse_protocolIEs(OSCTXT* pctxt, e2ap_RICsubscriptionModificationResponse_protocolIEs* pvalue)
{
     int stat =0;
     OSRTDListNode* pnode;
     OSSIZE count =0;
     OSSIZE xx1=0;


     /*decode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pd_Length64(pctxt, &count); //tai sao lai 64
    if(stat!=0) return LOG_RTERR(pctxt, stat);

    /*decode each element*/
    rtxDListInit(pvalue);

    for(xx1=0; xx1 < count; xx1++){
        e2ap_RICsubscriptionModificationResponse_protocolIEs_element* pdata;
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE",xx1);

        if(pnode == NULL) return LOG_RTERR(pctxt, RTERR_NOMEM);

        asn1Init_e2ap_RICsubscriptionModificationResponse_protocolIEs_element(pdata);
        rtxDListAppendNode(pvalue, pnode);
        stat = asn1PD_e2ap_RICsubscriptionModificationResponse_protocolIEs_element (pctxt, pdata);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        RTXCTXTPOPARRAYELEMNAME(pctxt);

    }
    return (stat);
}


int asn1Init_e2ap_RICsubscriptionModificationResponse_protocolIEs(e2ap_RICsubscriptionModificationResponse_protocolIEs* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    rtxDListFastInit (pvalue);
    return 0;
}
#if 1 //ao that day
void asn1Free_e2ap_RICsubscriptionModificationResponse_protocolIEs(OSCTXT* pctxt, e2ap_RICsubscriptionModificationResponse_protocolIEs* pvalue)
{
    if(0==pvalue) return;   
    e2ap_RICsubscriptionModificationResponse_protocolIEs_element* pdata;
    OSRTDListNode* pnode=pvalue->head;
    while(0!=pnode){
        pdata = (e2ap_RICsubscriptionModificationResponse_protocolIEs_element*)pnode->data;
       // asn1Free_e2ap_RICsubscriptionModificationResponse_protocolIEs_element(pctxt, pdata);
        pnode = pnode->next;
    }
    rtxDListFreeAll(pctxt, pvalue);
}
#endif


EXTERN int asn1PrtToStr_e2ap_RICsubscriptionModificationResponse_protocolIEs(const char* name, e2ap_RICsubscriptionModificationResponse_protocolIEs* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_RICsubscriptionModificationResponse_protocolIEs_element* pdata0;
    OSRTDListNode* pnode0;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode0 = pvalue->head;  xx1 < pvalue->count && pnode0 != 0; pnode0 = pnode0->next, xx1++){
        pdata0 = (e2ap_RICsubscriptionModificationResponse_protocolIEs_element*)pnode0->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 0
        if(asn1PrtToStr_e2ap_RICsubscriptionModificationResponse_protocolIEs_element(nameBuf, pdata0, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}


/*2 . RICsubscriptionModificationResponse -> mẫu cũ ở seq_normal*/

int asn1PE_e2ap_RICsubscriptionModificationResponse (OSCTXT* pctxt, e2ap_RICsubscriptionModificationResponse* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RICsubscriptionModificationResponse");
   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field protocolIEs - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
   stat = asn1PE_e2ap_RICsubscriptionModificationResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
   if(stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RICsubscriptionModificationResponse (OSCTXT* pctxt, e2ap_RICsubscriptionModificationResponse* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME(pctxt, "RICsubscriptionModificationResponse");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field protocolIEs */
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
      stat = asn1PD_e2ap_RICsubscriptionModificationResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RICsubscriptionModificationResponse (e2ap_RICsubscriptionModificationResponse* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RICsubscriptionModificationResponse_protocolIEs(&pvalue->protocolIEs);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RICsubscriptionModificationResponse (OSCTXT* pctxt, e2ap_RICsubscriptionModificationResponse* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_RICsubscriptionModificationResponse_protocolIEs(pctxt, &pvalue->protocolIEs);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RICsubscriptionModificationResponse (const char* name, e2ap_RICsubscriptionModificationResponse* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }

   if(asn1PrtToStr_e2ap_RICsubscriptionModificationResponse_protocolIEs("protocolIEs", &pvalue->protocolIEs, buffer, bufSize) <0){
      return -1;
   }

   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           RICsubscriptionModificationFailure_IEs                */
/*****************************************/
/* ie.c.j2 */
 /* d là con của msg */
EXTERN int asn1PE_e2ap_RICsubscriptionModificationFailure_protocolIEs_element (OSCTXT* pctxt, e2ap_RICsubscriptionModificationFailure_protocolIEs_element* pvalue)
{
    int stat =0;

    /*encode id*/

    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PE_e2ap_ProtocolIE_ID(pctxt, pvalue->id);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PE_e2ap_Criticality(pctxt, pvalue->criticality);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
    {
        OSCTXT lctxt;
        OSOCTET *pDynamicEncodeBuffer;
        ASN1OpenType openType;
        OSBOOL encoded = TRUE;

        openType.numocts = 0;
        openType.data =0;

        rtxCopyContext(&lctxt, pctxt);
        pctxt->pStream =0;

        stat = rtxInitContextBuffer(pctxt, 0, 0);
        if(stat!=0) return LOG_RTERR(pctxt, stat);

        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationFailure_IEs_id_RICrequestID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICrequestID");
                    stat = asn1PE_e2ap_RICrequestID (pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationFailure_IEs_id_RICrequestID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationFailure_IEs_id_RANfunctionID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RANfunctionID");
                    stat = asn1PE_e2ap_RANfunctionID (pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationFailure_IEs_id_RANfunctionID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationFailure_IEs_id_Cause:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-Cause");
                    stat = asn1PE_e2ap_Cause (pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationFailure_IEs_id_Cause);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationFailure_IEs_id_CriticalityDiagnostics:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-CriticalityDiagnostics");
                    stat = asn1PE_e2ap_CriticalityDiagnostics (pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationFailure_IEs_id_CriticalityDiagnostics);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationFailure_IEs_UNDEF_:
            {
                if(0!=pvalue->value.u.extElem1){
                    openType.numocts = pvalue->value.u.extElem1->numocts;
                    openType.data = pvalue->value.u.extElem1->data;
                } else {
                    /* No extension element to encode */
                }
                encoded = FALSE;
                break;
            }

            default:
                encoded = FALSE;
                stat = RTERR_INVOPT;
                break;
        } 

        if(encoded){
            openType.numocts = (OSUINT32)pe_GetMsgLen(pctxt);
            openType.data = pDynamicEncodeBuffer = pctxt -> buffer.data;
        }
        rtxCopyContext(pctxt, &lctxt);

        if(stat == 0) {
            stat = pe_OpenType (pctxt, openType.numocts, openType.data);
        }
    #if 1
        if(encoded){//dungnm23 check lai nhe
            rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
        }
    #endif

    }

    if(stat!=0) return LOG_RTERR(pctxt, stat);  
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}

EXTERN int  asn1PD_e2ap_RICsubscriptionModificationFailure_protocolIEs_element (OSCTXT* pctxt, e2ap_RICsubscriptionModificationFailure_protocolIEs_element* pvalue){
    int stat =0;

    /*decode id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PD_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PD_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");

    {
        OSUINT32 openTypeLen;
        size_t bitStartOffset, bitLength;

        stat = pd_UnconsLength(pctxt, &openTypeLen);
        if(stat<0) return LOG_RTERR(pctxt, stat);
        else if(stat == RT_OK_FRAG){
            rtxErrAddStrParm(pctxt, "open type with fragment length");
            return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
        }
        bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
        bitLength = openTypeLen * 8;

        switch(pvalue->id){//dungnm23 check case lai nhe
        
            case ASN1V_e2ap_id_RICrequestID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationFailure_IEs_id_RICrequestID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICrequestID");
                pvalue->value.u._e2ap_RICsubscriptionModificationFailure_IEs_id_RICrequestID 
                    = rtxMemAllocType(pctxt, e2ap_RICrequestID);

                asn1Init_e2ap_RICrequestID(pvalue->value.u._e2ap_RICsubscriptionModificationFailure_IEs_id_RICrequestID);

                stat = asn1PD_e2ap_RICrequestID (pctxt,
                        (e2ap_RICrequestID*)pvalue->value.
                        u._e2ap_RICsubscriptionModificationFailure_IEs_id_RICrequestID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RANfunctionID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationFailure_IEs_id_RANfunctionID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RANfunctionID");
                pvalue->value.u._e2ap_RICsubscriptionModificationFailure_IEs_id_RANfunctionID 
                    = rtxMemAllocType(pctxt, e2ap_RANfunctionID);

                asn1Init_e2ap_RANfunctionID(pvalue->value.u._e2ap_RICsubscriptionModificationFailure_IEs_id_RANfunctionID);

                stat = asn1PD_e2ap_RANfunctionID (pctxt,
                        (e2ap_RANfunctionID*)pvalue->value.
                        u._e2ap_RICsubscriptionModificationFailure_IEs_id_RANfunctionID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_Cause:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationFailure_IEs_id_Cause;
            RTXCTXTPUSHELEMNAME(pctxt, "id-Cause");
                pvalue->value.u._e2ap_RICsubscriptionModificationFailure_IEs_id_Cause 
                    = rtxMemAllocType(pctxt, e2ap_Cause);

                asn1Init_e2ap_Cause(pvalue->value.u._e2ap_RICsubscriptionModificationFailure_IEs_id_Cause);

                stat = asn1PD_e2ap_Cause (pctxt,
                        (e2ap_Cause*)pvalue->value.
                        u._e2ap_RICsubscriptionModificationFailure_IEs_id_Cause);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_CriticalityDiagnostics:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationFailure_IEs_id_CriticalityDiagnostics;
            RTXCTXTPUSHELEMNAME(pctxt, "id-CriticalityDiagnostics");
                pvalue->value.u._e2ap_RICsubscriptionModificationFailure_IEs_id_CriticalityDiagnostics 
                    = rtxMemAllocType(pctxt, e2ap_CriticalityDiagnostics);

                asn1Init_e2ap_CriticalityDiagnostics(pvalue->value.u._e2ap_RICsubscriptionModificationFailure_IEs_id_CriticalityDiagnostics);

                stat = asn1PD_e2ap_CriticalityDiagnostics (pctxt,
                        (e2ap_CriticalityDiagnostics*)pvalue->value.
                        u._e2ap_RICsubscriptionModificationFailure_IEs_id_CriticalityDiagnostics);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationFailure_IEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*) rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
    }
    {
    size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
    size_t bitsConsumed = bitEndOffset-bitStartOffset;
    if(bitsConsumed<bitLength){
        stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
    }
    else stat =(bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
    }}
    if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}


int asn1Init_e2ap_RICsubscriptionModificationFailure_protocolIEs_element(e2ap_RICsubscriptionModificationFailure_protocolIEs_element* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    OSCRTLMEMSET (&pvalue->value, 0, sizeof(pvalue->value));
    return 0;
}


//-----> chuaw có template rtxFreeASN1OpenType

#if 0
void asn1Free_e2ap_RICsubscriptionModificationFailure_protocolIEs_element(OSCTXT* pctxt, e2ap_RICsubscriptionModificationFailure_protocolIEs_element* pvalue)
{
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationFailure_IEs_id_id_RICrequestID:
            // rtxFreeE2ap_RICrequestID(pvalue->value.u._e2ap_RICsubscriptionModificationFailure_IEs_id_id_RICrequestID);

            if(pvalue->value.i._e2ap_RICsubscriptionModificationFailure_id_RICrequestID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICrequestID(pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationFailure_IEs_id_id_RICrequestID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionModificationFailure_IEs_id_id_RICrequestID);
           // pvalue->value.u._e2ap_RICsubscriptionModificationFailure_IEs_id_id_RICrequestID = NULL;
           pvalue->value.u._e2ap_RICsubscriptionModificationFailure_IEs_id_RICrequestID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationFailure_IEs_id_id_RANfunctionID:
            // rtxFreeE2ap_RANfunctionID(pvalue->value.u._e2ap_RICsubscriptionModificationFailure_IEs_id_id_RANfunctionID);

            if(pvalue->value.i._e2ap_RICsubscriptionModificationFailure_id_RANfunctionID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RANfunctionID(pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationFailure_IEs_id_id_RANfunctionID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionModificationFailure_IEs_id_id_RANfunctionID);
           // pvalue->value.u._e2ap_RICsubscriptionModificationFailure_IEs_id_id_RANfunctionID = NULL;
           pvalue->value.u._e2ap_RICsubscriptionModificationFailure_IEs_id_RANfunctionID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationFailure_IEs_id_id_Cause:
            // rtxFreeE2ap_Cause(pvalue->value.u._e2ap_RICsubscriptionModificationFailure_IEs_id_id_Cause);

            if(pvalue->value.i._e2ap_RICsubscriptionModificationFailure_id_Cause!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_Cause(pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationFailure_IEs_id_id_Cause);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionModificationFailure_IEs_id_id_Cause);
           // pvalue->value.u._e2ap_RICsubscriptionModificationFailure_IEs_id_id_Cause = NULL;
           pvalue->value.u._e2ap_RICsubscriptionModificationFailure_IEs_id_Cause = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationFailure_IEs_id_id_CriticalityDiagnostics:
            // rtxFreeE2ap_CriticalityDiagnostics(pvalue->value.u._e2ap_RICsubscriptionModificationFailure_IEs_id_id_CriticalityDiagnostics);

            if(pvalue->value.i._e2ap_RICsubscriptionModificationFailure_id_CriticalityDiagnostics!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_CriticalityDiagnostics(pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationFailure_IEs_id_id_CriticalityDiagnostics);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionModificationFailure_IEs_id_id_CriticalityDiagnostics);
           // pvalue->value.u._e2ap_RICsubscriptionModificationFailure_IEs_id_id_CriticalityDiagnostics = NULL;
           pvalue->value.u._e2ap_RICsubscriptionModificationFailure_IEs_id_CriticalityDiagnostics = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationFailure_IEs_UNDEF_:
            rtxFreeASN1OpenType(pvalue->value.u.extElem1);
            break;
        default:
            break;
    }
}

int asn1PrtToStr_e2ap_RICsubscriptionModificationFailure_protocolIEs_element(OSCTXT* pctxt, e2ap_RICsubscriptionModificationFailure_protocolIEs_element* pvalue)
{
    int stat =0;
    RTXCTXTPUSHELEMNAME(pctxt, "e2ap_RICsubscriptionModificationFailure_protocolIEs_element");

    /*print id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PrtToStr_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PrtToStr_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationFailure_IEs_id_id_RICrequestID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICrequestID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICrequestID (pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationFailure_IEs_id_id_RICrequestID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationFailure_IEs_id_id_RANfunctionID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RANfunctionID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RANfunctionID (pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationFailure_IEs_id_id_RANfunctionID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationFailure_IEs_id_id_Cause:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "Cause");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_Cause (pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationFailure_IEs_id_id_Cause);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationFailure_IEs_id_id_CriticalityDiagnostics:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "CriticalityDiagnostics");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_CriticalityDiagnostics (pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationFailure_IEs_id_id_CriticalityDiagnostics);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationFailure_IEs_UNDEF_:
            {
                rtxPLogMsg(pctxt, "Extension element present - raw data not printed.\n");
                break;
            }

            default:
                stat = RTERR_INVOPT;
                return LOG_RTERR(pctxt, stat);
        }
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);
}
#endif


int asn1PrtToStr_e2ap_RICsubscriptionModificationFailure_protocolIEs_element (const char * name,
 e2ap_RICsubscriptionModificationFailure_protocolIEs_element* pvalue, 
 char * buffer, OSSIZE bufSize){
    if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
        return -1;
    if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
        return -1;

    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationFailure_IEs_id_RICrequestID:
            if(asn1PrtToStr_e2ap_RICrequestID("RICrequestID", 
                    pvalue->value.u._e2ap_RICsubscriptionModificationFailure_IEs_id_RICrequestID, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationFailure_IEs_id_RANfunctionID:
            if(asn1PrtToStr_e2ap_RANfunctionID("RANfunctionID", 
                    pvalue->value.u._e2ap_RICsubscriptionModificationFailure_IEs_id_RANfunctionID, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationFailure_IEs_id_Cause:
            if(asn1PrtToStr_e2ap_Cause("Cause", 
                    pvalue->value.u._e2ap_RICsubscriptionModificationFailure_IEs_id_Cause, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationFailure_IEs_id_CriticalityDiagnostics:
            if(asn1PrtToStr_e2ap_CriticalityDiagnostics("CriticalityDiagnostics", 
                    pvalue->value.u._e2ap_RICsubscriptionModificationFailure_IEs_id_CriticalityDiagnostics, buffer, bufSize)<0)
                return -1;
            break;    
        default:
        if(0!=pvalue -> value.u.extElem1){
            rtPrintToStringIndent(buffer, bufSize);
            rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

        }
        }
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

    return 0;

 }

 void asn1Free_e2ap_RICsubscriptionModificationFailure_protocolIEs_element(OSCTXT* pctxt, e2ap_RICsubscriptionModificationFailure_protocolIEs_element* pvalue){
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationFailure_IEs_id_RICrequestID:
            if(pvalue->value.u._e2ap_RICsubscriptionModificationFailure_IEs_id_RICrequestID!=NULL){
            asn1Free_e2ap_RICrequestID(pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationFailure_IEs_id_RICrequestID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionModificationFailure_IEs_id_RICrequestID);
            pvalue->value.u._e2ap_RICsubscriptionModificationFailure_IEs_id_RICrequestID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationFailure_IEs_id_RANfunctionID:
            if(pvalue->value.u._e2ap_RICsubscriptionModificationFailure_IEs_id_RANfunctionID!=NULL){
            asn1Free_e2ap_RANfunctionID(pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationFailure_IEs_id_RANfunctionID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionModificationFailure_IEs_id_RANfunctionID);
            pvalue->value.u._e2ap_RICsubscriptionModificationFailure_IEs_id_RANfunctionID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationFailure_IEs_id_Cause:
            if(pvalue->value.u._e2ap_RICsubscriptionModificationFailure_IEs_id_Cause!=NULL){
            asn1Free_e2ap_Cause(pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationFailure_IEs_id_Cause);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionModificationFailure_IEs_id_Cause);
            pvalue->value.u._e2ap_RICsubscriptionModificationFailure_IEs_id_Cause = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationFailure_IEs_id_CriticalityDiagnostics:
            if(pvalue->value.u._e2ap_RICsubscriptionModificationFailure_IEs_id_CriticalityDiagnostics!=NULL){
            asn1Free_e2ap_CriticalityDiagnostics(pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationFailure_IEs_id_CriticalityDiagnostics);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionModificationFailure_IEs_id_CriticalityDiagnostics);
            pvalue->value.u._e2ap_RICsubscriptionModificationFailure_IEs_id_CriticalityDiagnostics = NULL;
            }
            break;
        default:
            break;


    }
 }

 

/*****************************************/
/*           RICsubscriptionModificationFailure                */
/*****************************************/
//2_container.c
/* 1. xxx_ProtocolIE -> mẫu cũ ở ie_big_msg */
EXTERN int asn1PE_e2ap_RICsubscriptionModificationFailure_protocolIEs (OSCTXT* pctxt, e2ap_RICsubscriptionModificationFailure_protocolIEs* pvalue)
{
    int stat =0;
    OSRTDListNode* pnode;
    OSUINT32 xx1;

    /*encode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pe_Length(pctxt, pvalue->count);
    if(stat<0) return LOG_RTERR(pctxt, stat);

    /*encode each element*/
    xx1 =0;
    for(pnode = pvalue->head; pnode != 0 && xx1<pvalue->count; pnode = pnode->next){
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE", xx1);
        stat = asn1PE_e2ap_RICsubscriptionModificationFailure_protocolIEs_element (pctxt, ((e2ap_RICsubscriptionModificationFailure_protocolIEs_element*)pnode->data));
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        xx1++;
        RTXCTXTPOPARRAYELEMNAME(pctxt);
    }

    return (stat);
}

EXTERN int  asn1PD_e2ap_RICsubscriptionModificationFailure_protocolIEs(OSCTXT* pctxt, e2ap_RICsubscriptionModificationFailure_protocolIEs* pvalue)
{
     int stat =0;
     OSRTDListNode* pnode;
     OSSIZE count =0;
     OSSIZE xx1=0;


     /*decode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pd_Length64(pctxt, &count); //tai sao lai 64
    if(stat!=0) return LOG_RTERR(pctxt, stat);

    /*decode each element*/
    rtxDListInit(pvalue);

    for(xx1=0; xx1 < count; xx1++){
        e2ap_RICsubscriptionModificationFailure_protocolIEs_element* pdata;
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE",xx1);

        if(pnode == NULL) return LOG_RTERR(pctxt, RTERR_NOMEM);

        asn1Init_e2ap_RICsubscriptionModificationFailure_protocolIEs_element(pdata);
        rtxDListAppendNode(pvalue, pnode);
        stat = asn1PD_e2ap_RICsubscriptionModificationFailure_protocolIEs_element (pctxt, pdata);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        RTXCTXTPOPARRAYELEMNAME(pctxt);

    }
    return (stat);
}


int asn1Init_e2ap_RICsubscriptionModificationFailure_protocolIEs(e2ap_RICsubscriptionModificationFailure_protocolIEs* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    rtxDListFastInit (pvalue);
    return 0;
}
#if 1 //ao that day
void asn1Free_e2ap_RICsubscriptionModificationFailure_protocolIEs(OSCTXT* pctxt, e2ap_RICsubscriptionModificationFailure_protocolIEs* pvalue)
{
    if(0==pvalue) return;   
    e2ap_RICsubscriptionModificationFailure_protocolIEs_element* pdata;
    OSRTDListNode* pnode=pvalue->head;
    while(0!=pnode){
        pdata = (e2ap_RICsubscriptionModificationFailure_protocolIEs_element*)pnode->data;
       // asn1Free_e2ap_RICsubscriptionModificationFailure_protocolIEs_element(pctxt, pdata);
        pnode = pnode->next;
    }
    rtxDListFreeAll(pctxt, pvalue);
}
#endif


EXTERN int asn1PrtToStr_e2ap_RICsubscriptionModificationFailure_protocolIEs(const char* name, e2ap_RICsubscriptionModificationFailure_protocolIEs* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_RICsubscriptionModificationFailure_protocolIEs_element* pdata0;
    OSRTDListNode* pnode0;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode0 = pvalue->head;  xx1 < pvalue->count && pnode0 != 0; pnode0 = pnode0->next, xx1++){
        pdata0 = (e2ap_RICsubscriptionModificationFailure_protocolIEs_element*)pnode0->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 0
        if(asn1PrtToStr_e2ap_RICsubscriptionModificationFailure_protocolIEs_element(nameBuf, pdata0, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}


/*2 . RICsubscriptionModificationFailure -> mẫu cũ ở seq_normal*/

int asn1PE_e2ap_RICsubscriptionModificationFailure (OSCTXT* pctxt, e2ap_RICsubscriptionModificationFailure* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RICsubscriptionModificationFailure");
   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field protocolIEs - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
   stat = asn1PE_e2ap_RICsubscriptionModificationFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
   if(stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RICsubscriptionModificationFailure (OSCTXT* pctxt, e2ap_RICsubscriptionModificationFailure* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME(pctxt, "RICsubscriptionModificationFailure");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field protocolIEs */
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
      stat = asn1PD_e2ap_RICsubscriptionModificationFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RICsubscriptionModificationFailure (e2ap_RICsubscriptionModificationFailure* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RICsubscriptionModificationFailure_protocolIEs(&pvalue->protocolIEs);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RICsubscriptionModificationFailure (OSCTXT* pctxt, e2ap_RICsubscriptionModificationFailure* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_RICsubscriptionModificationFailure_protocolIEs(pctxt, &pvalue->protocolIEs);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RICsubscriptionModificationFailure (const char* name, e2ap_RICsubscriptionModificationFailure* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }

   if(asn1PrtToStr_e2ap_RICsubscriptionModificationFailure_protocolIEs("protocolIEs", &pvalue->protocolIEs, buffer, bufSize) <0){
      return -1;
   }

   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}
/*****************************************/
/*           RICaction-RequiredToBeModified-Item                */
/*****************************************/
//sequence normal
// Các nội dung cần thiết cho template seq_normal.c.j2

// Các phần còn lại của template seq_normal.c.j2
//contain extensition bit -> theo mau cua GlobalgNB-ID
int asn1PE_e2ap_RICaction_RequiredToBeModified_Item (OSCTXT* pctxt, e2ap_RICaction_RequiredToBeModified_Item* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RICaction-RequiredToBeModified-Item");

   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field ricActionID - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "ricActionID");
   stat = asn1PE_e2ap_RICactionID (pctxt, pvalue->ricActionID);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /* encode field ricTimeToWait - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "ricTimeToWait");
   stat = asn1PE_e2ap_RICtimeToWait (pctxt, pvalue->ricTimeToWait);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);



   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RICaction_RequiredToBeModified_Item (OSCTXT* pctxt, e2ap_RICaction_RequiredToBeModified_Item* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME(pctxt, "RICaction-RequiredToBeModified-Item");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field ricActionID */
   RTXCTXTPUSHELEMNAME(pctxt, "ricActionID");
      stat = asn1PD_e2ap_RICactionID (pctxt, &pvalue->ricActionID);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field ricTimeToWait */
   RTXCTXTPUSHELEMNAME(pctxt, "ricTimeToWait");
      stat = asn1PD_e2ap_RICtimeToWait (pctxt, &pvalue->ricTimeToWait);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RICaction_RequiredToBeModified_Item (e2ap_RICaction_RequiredToBeModified_Item* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RICactionID (&pvalue->ricActionID);
   asn1Init_e2ap_RICtimeToWait (&pvalue->ricTimeToWait);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RICaction_RequiredToBeModified_Item (OSCTXT* pctxt, e2ap_RICaction_RequiredToBeModified_Item* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_RICactionID (pctxt, &pvalue->ricActionID);
   asn1Free_e2ap_RICtimeToWait (pctxt, &pvalue->ricTimeToWait);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RICaction_RequiredToBeModified_Item (const char* name, e2ap_RICaction_RequiredToBeModified_Item* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }
   if(asn1PrtToStr_e2ap_RICactionID ("ricActionID", &pvalue->ricActionID, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_RICtimeToWait ("ricTimeToWait", &pvalue->ricTimeToWait, buffer, bufSize) < 0)
   {
      return -1;
   }



   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           RICaction_RequiredToBeModified_ItemIEs                */
/*****************************************/
/* ie.c.j2 */
/*ie thường*/
int asn1PE_e2ap_RICaction_RequiredToBeModified_ItemIEs (OSCTXT* pctxt, e2ap_RICaction_RequiredToBeModified_ItemIEs* pvalue)
{
   int stat = 0;
   //RTXCTXTPUSHTYPENAME (pctxt, "RICaction-RequiredToBeModified-ItemIEs");

   /* encode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");
   stat = asn1PE_e2ap_ProtocolIE_ID (pctxt, pvalue->id);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");
   stat = asn1PE_e2ap_Criticality (pctxt, pvalue->criticality);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   {
      OSCTXT ictxt;
      OSOCTET* pDynamicEncodeBuffer;
      ASN1OpenType openType;
      OSBOOL  encoded = TRUE;

      openType.numocts = 0;
      openType.data = 0;

      rtxCopyContext (&ictxt, pctxt);
      pctxt->pStream = 0;

      stat = rtxInitContextBuffer (pctxt, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_RICaction_RequiredToBeModified_ItemIEs_id_RICaction_RequiredToBeModified_Item:
         
        // RTXCTXTPUSHELEMNAME (pctxt, "RICaction_RequiredToBeModified_ItemIEs_id_RICaction_RequiredToBeModified_Item");
         RTXCTXTPUSHELEMNAME (pctxt, "RICaction-RequiredToBeModified-Item");
         stat = asn1PE_e2ap_RICaction_RequiredToBeModified_Item (pctxt, pvalue->value.u._e2apRICaction_RequiredToBeModified_ItemIEs_id_RICaction_RequiredToBeModified_Item);
         RTXCTXTPOPELEMNAME (pctxt);
      
         break;

      case T_E2AP_PDU_Contents_e2ap_RICaction_RequiredToBeModified_ItemIEs_UNDEF_:
      {
          if(0!=pvalue->value.u.extElem1){
              openType.numocts = pvalue->value.u.extElem1->numocts;
              openType.data = pvalue->value.u.extElem1->data;
          } else {
              /* No extension element to encode */
          }
          encoded = FALSE;
          break;
      }
      default:
         encoded = FALSE;
         stat = RTERR_INVOPT;
      }

      if (encoded) {
         openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
         openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
      }
      rtxCopyContext (pctxt, &ictxt);
      if(stat ==0) stat = pe_OpenType(pctxt, openType.numocts, openType.data);
      /*free dynamic encode buffer*/
      if(encoded){
          rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
      }
   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);
   //RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

int asn1PD_e2ap_RICaction_RequiredToBeModified_ItemIEs (OSCTXT* pctxt, e2ap_RICaction_RequiredToBeModified_ItemIEs* pvalue)
{
   int stat =0;
   /*deode root element id*/
   RTXCTXTPUSHELEMNAME(pctxt, "id");
   stat = asn1PD_e2ap_ProtocolIE_ID (pctxt, &pvalue->id);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*decode root element criticality*/
   RTXCTXTPUSHELEMNAME(pctxt, "criticality");
   stat = asn1PD_e2ap_Criticality (pctxt, &pvalue->criticality);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   /*decode root element value*/
   RTXCTXTPUSHELEMNAME(pctxt, "value");
   {
      OSUINT32 openTypeLen;
      size_t bitStartOffset, bitLength;
      stat = pd_UnconsLength(pctxt, &openTypeLen);
      if(stat <0) return LOG_RTERR(pctxt, stat);
      else if(stat == RT_OK_FRAG){
         rtxErrAddStrParm(pctxt, "open type with fragmented length use - perindef");
         return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
      }
      bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
      bitLength = openTypeLen * 8;
      switch (pvalue->id){
         case T_E2AP_PDU_Contents_e2ap_RICaction_RequiredToBeModified_ItemIEs_id_RICaction_RequiredToBeModified_Item:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICaction_RequiredToBeModified_ItemIEs_id_RICaction_RequiredToBeModified_Item;
            RTXCTXTPUSHELEMNAME(pctxt, "RICaction-RequiredToBeModified-Item");
            //pvalue->value.u._e2ap_RICaction_RequiredToBeModified_ItemIEs_id_id_RICaction_RequiredToBeModified_Item 
             pvalue->value.u._e2apRICaction_RequiredToBeModified_ItemIEs_id_RICaction_RequiredToBeModified_Item 
                    = rtxMemAllocType(pctxt, e2ap_RICaction_RequiredToBeModified_Item);
            //asn1Init_e2ap_RICaction_RequiredToBeModified_Item(pvalue->value.u._e2ap_RICaction_RequiredToBeModified_ItemIEs_id_id_RICaction_RequiredToBeModified_Item);
            asn1Init_e2ap_RICaction_RequiredToBeModified_Item(pvalue->value.u._e2apRICaction_RequiredToBeModified_ItemIEs_id_RICaction_RequiredToBeModified_Item);
            stat = asn1PD_e2ap_RICaction_RequiredToBeModified_Item (pctxt,
                    (e2ap_RICaction_RequiredToBeModified_Item*)pvalue->value.
                    u._e2apRICaction_RequiredToBeModified_ItemIEs_id_RICaction_RequiredToBeModified_Item);
            if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICaction_RequiredToBeModified_ItemIEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*)rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
      }
      {
      size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
      size_t bitsConsumed = bitEndOffset - bitStartOffset;
      if(bitsConsumed < bitLength){
         stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
      } else {
         stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
      }
      }
   }
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   return stat;
}

void asn1Init_e2ap_RICaction_RequiredToBeModified_ItemIEs (e2ap_RICaction_RequiredToBeModified_ItemIEs* pvalue)
{
   if (!pvalue) return;
   OSCRTLMEMSET (pvalue, 0, sizeof(e2ap_RICaction_RequiredToBeModified_ItemIEs));
}

#if 0
void asn1Free_e2ap_RICaction_RequiredToBeModified_ItemIEs (OSCTXT* pctxt, e2ap_RICaction_RequiredToBeModified_ItemIEs* pvalue)
{
   if (!pvalue) return;
   if (pvalue->extElem1) {
      rtxMemFreeArray (pctxt, pvalue->extElem1);
      pvalue->extElem1 = 0;
      pvalue->extElem1_n = 0;
   }
}
#endif
void asn1Free_e2ap_RICaction_RequiredToBeModified_ItemIEs (OSCTXT* pctxt, e2ap_RICaction_RequiredToBeModified_ItemIEs* pvalue)
{
   if(0==pvalue) return;
   switch(pvalue->value.t){
      case T_E2AP_PDU_Contents_e2ap_RICaction_RequiredToBeModified_ItemIEs_id_RICaction_RequiredToBeModified_Item:
         asn1Free_e2ap_RICaction_RequiredToBeModified_Item (pctxt, pvalue->value.u._e2apRICaction_RequiredToBeModified_ItemIEs_id_RICaction_RequiredToBeModified_Item);
         rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2apRICaction_RequiredToBeModified_ItemIEs_id_RICaction_RequiredToBeModified_Item);
         pvalue->value.u._e2apRICaction_RequiredToBeModified_ItemIEs_id_RICaction_RequiredToBeModified_Item = 0;
         break;
      case T_E2AP_PDU_Contents_e2ap_RICaction_RequiredToBeModified_ItemIEs_UNDEF_:
         if(0!=pvalue->value.u.extElem1){
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1->data);
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
             pvalue->value.u.extElem1 =0;
         }
         break;
         default:;
   }
}

int  asn1PrtToStr_e2ap_RICaction_RequiredToBeModified_ItemIEs (const char * name, e2ap_RICaction_RequiredToBeModified_ItemIEs* pvalue, char * buffer, OSSIZE bufSize){
   if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
       return -1;

      if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
         return -1;

      if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
         return -1;
      if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
         return -1;
      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_RICaction_RequiredToBeModified_ItemIEs_id_RICaction_RequiredToBeModified_Item:
         if(asn1PrtToStr_e2ap_RICaction_RequiredToBeModified_Item("RICaction-RequiredToBeModified-Item",
                pvalue->value.u._e2apRICaction_RequiredToBeModified_ItemIEs_id_RICaction_RequiredToBeModified_Item, buffer, bufSize)<0)// dungnm23 check lai nhe xem la
            return -1;
         break;
      default:
         if(0!=pvalue -> value.u.extElem1){
             rtPrintToStringIndent(buffer, bufSize);
             rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

         }
      }
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

      return 0;

}
 

/*****************************************/
/*           RICactions_RequiredToBeModified_List                */
/*****************************************/
//seq_of_single_container


int asn1PE_e2ap_RICactions_RequiredToBeModified_List (OSCTXT* pctxt, e2ap_RICactions_RequiredToBeModified_List* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_RICaction_RequiredToBeModified_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "RICactions-RequiredToBeModified-List");

   /* encode length determinant */
   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(16), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;
   for (xx1 = 0; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next, xx1++) {
      pdata = (e2ap_RICaction_RequiredToBeModified_ItemIEs*) pnode->data;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_e2ap_RICaction_RequiredToBeModified_ItemIEs (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      //xx1++;
      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}

int asn1PD_e2ap_RICactions_RequiredToBeModified_List (OSCTXT* pctxt, e2ap_RICactions_RequiredToBeModified_List* ppvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_RICaction_RequiredToBeModified_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "RICactions-RequiredToBeModified-List");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(16), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (ppvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      pdata = rtxMemAllocType (pctxt, e2ap_RICaction_RequiredToBeModified_ItemIEs);
      if (!pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);
      asn1Init_e2ap_RICaction_RequiredToBeModified_ItemIEs (pdata);
      stat = asn1PD_e2ap_RICaction_RequiredToBeModified_ItemIEs (pctxt, pdata);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         return LOG_RTERR (pctxt, stat);
      }

      rtxDListAppendNode (ppvalue, pdata);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

void asn1Init_e2ap_RICactions_RequiredToBeModified_List (e2ap_RICactions_RequiredToBeModified_List* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
}

void asn1Free_e2ap_RICactions_RequiredToBeModified_List (OSCTXT* pctxt, e2ap_RICactions_RequiredToBeModified_List* pvalue)
{
   if(pvalue==0) return;
   OSRTDListNode* pnode = pvalue->head;
   while (pnode) {
      e2ap_RICaction_RequiredToBeModified_ItemIEs* pdata = (e2ap_RICaction_RequiredToBeModified_ItemIEs*) pnode->data;
      if (pdata) {
         asn1Free_e2ap_RICaction_RequiredToBeModified_ItemIEs (pctxt, pdata);
         rtxMemFreePtr (pctxt, pdata);
      }
      pnode = pnode->next;
   }
      rtxDListFreeAll(pctxt, pvalue);
}

#if 0
void asn1Free_e2ap_RICactions_RequiredToBeModified_List (OSCTXT* pctxt, e2ap_RICactions_RequiredToBeModified_List* pvalue){
   if(0==pvalue ) return;
   {
      e2ap_RICaction_RequiredToBeModified_ItemIEs * pdata;
      OSRTDListNode *pnode = pvalue->head;
      while(0!=pnode){
         pdata = (e2ap_RICaction_RequiredToBeModified_ItemIEs*)pnode->data;
         asn1Free_e2ap_RICaction_RequiredToBeModified_ItemIEs(pctxt, pdata);
         pnode = pnode->next;
      }
      rtxDListFreeAll(pctxt, pvalue);
   }
}
#endif


int asn1PrtToStr_e2ap_RICactions_RequiredToBeModified_List(const char* name, e2ap_RICactions_RequiredToBeModified_List* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_RICaction_RequiredToBeModified_ItemIEs* pdata;
    OSRTDListNode* pnode;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode = pvalue->head;  xx1 < pvalue->count && pnode != 0; pnode = pnode->next, xx1++){
        pdata = (e2ap_RICaction_RequiredToBeModified_ItemIEs*)pnode->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 1
        if(asn1PrtToStr_e2ap_RICaction_RequiredToBeModified_ItemIEs(nameBuf, pdata, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}
/*****************************************/
/*           RICaction-RequiredToBeRemoved-Item                */
/*****************************************/
//sequence normal
// Các nội dung cần thiết cho template seq_normal.c.j2

// Các phần còn lại của template seq_normal.c.j2
//contain extensition bit -> theo mau cua GlobalgNB-ID
int asn1PE_e2ap_RICaction_RequiredToBeRemoved_Item (OSCTXT* pctxt, e2ap_RICaction_RequiredToBeRemoved_Item* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RICaction-RequiredToBeRemoved-Item");

   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field ricActionID - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "ricActionID");
   stat = asn1PE_e2ap_RICactionID (pctxt, pvalue->ricActionID);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /* encode field cause - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "cause");
   stat = asn1PE_e2ap_Cause (pctxt, pvalue->cause);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);



   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RICaction_RequiredToBeRemoved_Item (OSCTXT* pctxt, e2ap_RICaction_RequiredToBeRemoved_Item* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME(pctxt, "RICaction-RequiredToBeRemoved-Item");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field ricActionID */
   RTXCTXTPUSHELEMNAME(pctxt, "ricActionID");
      stat = asn1PD_e2ap_RICactionID (pctxt, &pvalue->ricActionID);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field cause */
   RTXCTXTPUSHELEMNAME(pctxt, "cause");
      stat = asn1PD_e2ap_Cause (pctxt, &pvalue->cause);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RICaction_RequiredToBeRemoved_Item (e2ap_RICaction_RequiredToBeRemoved_Item* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RICactionID (&pvalue->ricActionID);
   asn1Init_e2ap_Cause (&pvalue->cause);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RICaction_RequiredToBeRemoved_Item (OSCTXT* pctxt, e2ap_RICaction_RequiredToBeRemoved_Item* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_RICactionID (pctxt, &pvalue->ricActionID);
   asn1Free_e2ap_Cause (pctxt, &pvalue->cause);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RICaction_RequiredToBeRemoved_Item (const char* name, e2ap_RICaction_RequiredToBeRemoved_Item* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }
   if(asn1PrtToStr_e2ap_RICactionID ("ricActionID", &pvalue->ricActionID, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_Cause ("cause", &pvalue->cause, buffer, bufSize) < 0)
   {
      return -1;
   }



   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           RICaction_RequiredToBeRemoved_ItemIEs                */
/*****************************************/
/* ie.c.j2 */
/*ie thường*/
int asn1PE_e2ap_RICaction_RequiredToBeRemoved_ItemIEs (OSCTXT* pctxt, e2ap_RICaction_RequiredToBeRemoved_ItemIEs* pvalue)
{
   int stat = 0;
   //RTXCTXTPUSHTYPENAME (pctxt, "RICaction-RequiredToBeRemoved-ItemIEs");

   /* encode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");
   stat = asn1PE_e2ap_ProtocolIE_ID (pctxt, pvalue->id);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");
   stat = asn1PE_e2ap_Criticality (pctxt, pvalue->criticality);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   {
      OSCTXT ictxt;
      OSOCTET* pDynamicEncodeBuffer;
      ASN1OpenType openType;
      OSBOOL  encoded = TRUE;

      openType.numocts = 0;
      openType.data = 0;

      rtxCopyContext (&ictxt, pctxt);
      pctxt->pStream = 0;

      stat = rtxInitContextBuffer (pctxt, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_RICaction_RequiredToBeRemoved_ItemIEs_id_RICaction_RequiredToBeRemoved_Item:
         
        // RTXCTXTPUSHELEMNAME (pctxt, "RICaction_RequiredToBeRemoved_ItemIEs_id_RICaction_RequiredToBeRemoved_Item");
         RTXCTXTPUSHELEMNAME (pctxt, "RICaction-RequiredToBeRemoved-Item");
         stat = asn1PE_e2ap_RICaction_RequiredToBeRemoved_Item (pctxt, pvalue->value.u._e2apRICaction_RequiredToBeRemoved_ItemIEs_id_RICaction_RequiredToBeRemoved_Item);
         RTXCTXTPOPELEMNAME (pctxt);
      
         break;

      case T_E2AP_PDU_Contents_e2ap_RICaction_RequiredToBeRemoved_ItemIEs_UNDEF_:
      {
          if(0!=pvalue->value.u.extElem1){
              openType.numocts = pvalue->value.u.extElem1->numocts;
              openType.data = pvalue->value.u.extElem1->data;
          } else {
              /* No extension element to encode */
          }
          encoded = FALSE;
          break;
      }
      default:
         encoded = FALSE;
         stat = RTERR_INVOPT;
      }

      if (encoded) {
         openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
         openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
      }
      rtxCopyContext (pctxt, &ictxt);
      if(stat ==0) stat = pe_OpenType(pctxt, openType.numocts, openType.data);
      /*free dynamic encode buffer*/
      if(encoded){
          rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
      }
   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);
   //RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

int asn1PD_e2ap_RICaction_RequiredToBeRemoved_ItemIEs (OSCTXT* pctxt, e2ap_RICaction_RequiredToBeRemoved_ItemIEs* pvalue)
{
   int stat =0;
   /*deode root element id*/
   RTXCTXTPUSHELEMNAME(pctxt, "id");
   stat = asn1PD_e2ap_ProtocolIE_ID (pctxt, &pvalue->id);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*decode root element criticality*/
   RTXCTXTPUSHELEMNAME(pctxt, "criticality");
   stat = asn1PD_e2ap_Criticality (pctxt, &pvalue->criticality);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   /*decode root element value*/
   RTXCTXTPUSHELEMNAME(pctxt, "value");
   {
      OSUINT32 openTypeLen;
      size_t bitStartOffset, bitLength;
      stat = pd_UnconsLength(pctxt, &openTypeLen);
      if(stat <0) return LOG_RTERR(pctxt, stat);
      else if(stat == RT_OK_FRAG){
         rtxErrAddStrParm(pctxt, "open type with fragmented length use - perindef");
         return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
      }
      bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
      bitLength = openTypeLen * 8;
      switch (pvalue->id){
         case T_E2AP_PDU_Contents_e2ap_RICaction_RequiredToBeRemoved_ItemIEs_id_RICaction_RequiredToBeRemoved_Item:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICaction_RequiredToBeRemoved_ItemIEs_id_RICaction_RequiredToBeRemoved_Item;
            RTXCTXTPUSHELEMNAME(pctxt, "RICaction-RequiredToBeRemoved-Item");
            //pvalue->value.u._e2ap_RICaction_RequiredToBeRemoved_ItemIEs_id_id_RICaction_RequiredToBeRemoved_Item 
             pvalue->value.u._e2apRICaction_RequiredToBeRemoved_ItemIEs_id_RICaction_RequiredToBeRemoved_Item 
                    = rtxMemAllocType(pctxt, e2ap_RICaction_RequiredToBeRemoved_Item);
            //asn1Init_e2ap_RICaction_RequiredToBeRemoved_Item(pvalue->value.u._e2ap_RICaction_RequiredToBeRemoved_ItemIEs_id_id_RICaction_RequiredToBeRemoved_Item);
            asn1Init_e2ap_RICaction_RequiredToBeRemoved_Item(pvalue->value.u._e2apRICaction_RequiredToBeRemoved_ItemIEs_id_RICaction_RequiredToBeRemoved_Item);
            stat = asn1PD_e2ap_RICaction_RequiredToBeRemoved_Item (pctxt,
                    (e2ap_RICaction_RequiredToBeRemoved_Item*)pvalue->value.
                    u._e2apRICaction_RequiredToBeRemoved_ItemIEs_id_RICaction_RequiredToBeRemoved_Item);
            if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICaction_RequiredToBeRemoved_ItemIEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*)rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
      }
      {
      size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
      size_t bitsConsumed = bitEndOffset - bitStartOffset;
      if(bitsConsumed < bitLength){
         stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
      } else {
         stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
      }
      }
   }
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   return stat;
}

void asn1Init_e2ap_RICaction_RequiredToBeRemoved_ItemIEs (e2ap_RICaction_RequiredToBeRemoved_ItemIEs* pvalue)
{
   if (!pvalue) return;
   OSCRTLMEMSET (pvalue, 0, sizeof(e2ap_RICaction_RequiredToBeRemoved_ItemIEs));
}

#if 0
void asn1Free_e2ap_RICaction_RequiredToBeRemoved_ItemIEs (OSCTXT* pctxt, e2ap_RICaction_RequiredToBeRemoved_ItemIEs* pvalue)
{
   if (!pvalue) return;
   if (pvalue->extElem1) {
      rtxMemFreeArray (pctxt, pvalue->extElem1);
      pvalue->extElem1 = 0;
      pvalue->extElem1_n = 0;
   }
}
#endif
void asn1Free_e2ap_RICaction_RequiredToBeRemoved_ItemIEs (OSCTXT* pctxt, e2ap_RICaction_RequiredToBeRemoved_ItemIEs* pvalue)
{
   if(0==pvalue) return;
   switch(pvalue->value.t){
      case T_E2AP_PDU_Contents_e2ap_RICaction_RequiredToBeRemoved_ItemIEs_id_RICaction_RequiredToBeRemoved_Item:
         asn1Free_e2ap_RICaction_RequiredToBeRemoved_Item (pctxt, pvalue->value.u._e2apRICaction_RequiredToBeRemoved_ItemIEs_id_RICaction_RequiredToBeRemoved_Item);
         rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2apRICaction_RequiredToBeRemoved_ItemIEs_id_RICaction_RequiredToBeRemoved_Item);
         pvalue->value.u._e2apRICaction_RequiredToBeRemoved_ItemIEs_id_RICaction_RequiredToBeRemoved_Item = 0;
         break;
      case T_E2AP_PDU_Contents_e2ap_RICaction_RequiredToBeRemoved_ItemIEs_UNDEF_:
         if(0!=pvalue->value.u.extElem1){
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1->data);
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
             pvalue->value.u.extElem1 =0;
         }
         break;
         default:;
   }
}

int  asn1PrtToStr_e2ap_RICaction_RequiredToBeRemoved_ItemIEs (const char * name, e2ap_RICaction_RequiredToBeRemoved_ItemIEs* pvalue, char * buffer, OSSIZE bufSize){
   if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
       return -1;

      if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
         return -1;

      if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
         return -1;
      if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
         return -1;
      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_RICaction_RequiredToBeRemoved_ItemIEs_id_RICaction_RequiredToBeRemoved_Item:
         if(asn1PrtToStr_e2ap_RICaction_RequiredToBeRemoved_Item("RICaction-RequiredToBeRemoved-Item",
                pvalue->value.u._e2apRICaction_RequiredToBeRemoved_ItemIEs_id_RICaction_RequiredToBeRemoved_Item, buffer, bufSize)<0)// dungnm23 check lai nhe xem la
            return -1;
         break;
      default:
         if(0!=pvalue -> value.u.extElem1){
             rtPrintToStringIndent(buffer, bufSize);
             rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

         }
      }
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

      return 0;

}
 

/*****************************************/
/*           RICactions_RequiredToBeRemoved_List                */
/*****************************************/
//seq_of_single_container


int asn1PE_e2ap_RICactions_RequiredToBeRemoved_List (OSCTXT* pctxt, e2ap_RICactions_RequiredToBeRemoved_List* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_RICaction_RequiredToBeRemoved_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "RICactions-RequiredToBeRemoved-List");

   /* encode length determinant */
   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(16), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;
   for (xx1 = 0; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next, xx1++) {
      pdata = (e2ap_RICaction_RequiredToBeRemoved_ItemIEs*) pnode->data;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_e2ap_RICaction_RequiredToBeRemoved_ItemIEs (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      //xx1++;
      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}

int asn1PD_e2ap_RICactions_RequiredToBeRemoved_List (OSCTXT* pctxt, e2ap_RICactions_RequiredToBeRemoved_List* ppvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_RICaction_RequiredToBeRemoved_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "RICactions-RequiredToBeRemoved-List");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(16), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (ppvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      pdata = rtxMemAllocType (pctxt, e2ap_RICaction_RequiredToBeRemoved_ItemIEs);
      if (!pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);
      asn1Init_e2ap_RICaction_RequiredToBeRemoved_ItemIEs (pdata);
      stat = asn1PD_e2ap_RICaction_RequiredToBeRemoved_ItemIEs (pctxt, pdata);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         return LOG_RTERR (pctxt, stat);
      }

      rtxDListAppendNode (ppvalue, pdata);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

void asn1Init_e2ap_RICactions_RequiredToBeRemoved_List (e2ap_RICactions_RequiredToBeRemoved_List* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
}

void asn1Free_e2ap_RICactions_RequiredToBeRemoved_List (OSCTXT* pctxt, e2ap_RICactions_RequiredToBeRemoved_List* pvalue)
{
   if(pvalue==0) return;
   OSRTDListNode* pnode = pvalue->head;
   while (pnode) {
      e2ap_RICaction_RequiredToBeRemoved_ItemIEs* pdata = (e2ap_RICaction_RequiredToBeRemoved_ItemIEs*) pnode->data;
      if (pdata) {
         asn1Free_e2ap_RICaction_RequiredToBeRemoved_ItemIEs (pctxt, pdata);
         rtxMemFreePtr (pctxt, pdata);
      }
      pnode = pnode->next;
   }
      rtxDListFreeAll(pctxt, pvalue);
}

#if 0
void asn1Free_e2ap_RICactions_RequiredToBeRemoved_List (OSCTXT* pctxt, e2ap_RICactions_RequiredToBeRemoved_List* pvalue){
   if(0==pvalue ) return;
   {
      e2ap_RICaction_RequiredToBeRemoved_ItemIEs * pdata;
      OSRTDListNode *pnode = pvalue->head;
      while(0!=pnode){
         pdata = (e2ap_RICaction_RequiredToBeRemoved_ItemIEs*)pnode->data;
         asn1Free_e2ap_RICaction_RequiredToBeRemoved_ItemIEs(pctxt, pdata);
         pnode = pnode->next;
      }
      rtxDListFreeAll(pctxt, pvalue);
   }
}
#endif


int asn1PrtToStr_e2ap_RICactions_RequiredToBeRemoved_List(const char* name, e2ap_RICactions_RequiredToBeRemoved_List* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_RICaction_RequiredToBeRemoved_ItemIEs* pdata;
    OSRTDListNode* pnode;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode = pvalue->head;  xx1 < pvalue->count && pnode != 0; pnode = pnode->next, xx1++){
        pdata = (e2ap_RICaction_RequiredToBeRemoved_ItemIEs*)pnode->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 1
        if(asn1PrtToStr_e2ap_RICaction_RequiredToBeRemoved_ItemIEs(nameBuf, pdata, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}/*****************************************/
/*           RICsubscriptionModificationRequired_IEs                */
/*****************************************/
/* ie.c.j2 */
 /* d là con của msg */
EXTERN int asn1PE_e2ap_RICsubscriptionModificationRequired_protocolIEs_element (OSCTXT* pctxt, e2ap_RICsubscriptionModificationRequired_protocolIEs_element* pvalue)
{
    int stat =0;

    /*encode id*/

    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PE_e2ap_ProtocolIE_ID(pctxt, pvalue->id);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PE_e2ap_Criticality(pctxt, pvalue->criticality);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
    {
        OSCTXT lctxt;
        OSOCTET *pDynamicEncodeBuffer;
        ASN1OpenType openType;
        OSBOOL encoded = TRUE;

        openType.numocts = 0;
        openType.data =0;

        rtxCopyContext(&lctxt, pctxt);
        pctxt->pStream =0;

        stat = rtxInitContextBuffer(pctxt, 0, 0);
        if(stat!=0) return LOG_RTERR(pctxt, stat);

        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRequired_IEs_id_RICrequestID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICrequestID");
                    stat = asn1PE_e2ap_RICrequestID (pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationRequired_IEs_id_RICrequestID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRequired_IEs_id_RANfunctionID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RANfunctionID");
                    stat = asn1PE_e2ap_RANfunctionID (pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationRequired_IEs_id_RANfunctionID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRequired_IEs_id_RICactionsRequiredToBeModified_List:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICactionsRequiredToBeModified-List");
                    stat = asn1PE_e2ap_RICactions_RequiredToBeModified_List (pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationRequired_IEs_id_RICactionsRequiredToBeModified_List);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRequired_IEs_id_RICactionsRequiredToBeRemoved_List:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICactionsRequiredToBeRemoved-List");
                    stat = asn1PE_e2ap_RICactions_RequiredToBeRemoved_List (pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationRequired_IEs_id_RICactionsRequiredToBeRemoved_List);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRequired_IEs_UNDEF_:
            {
                if(0!=pvalue->value.u.extElem1){
                    openType.numocts = pvalue->value.u.extElem1->numocts;
                    openType.data = pvalue->value.u.extElem1->data;
                } else {
                    /* No extension element to encode */
                }
                encoded = FALSE;
                break;
            }

            default:
                encoded = FALSE;
                stat = RTERR_INVOPT;
                break;
        } 

        if(encoded){
            openType.numocts = (OSUINT32)pe_GetMsgLen(pctxt);
            openType.data = pDynamicEncodeBuffer = pctxt -> buffer.data;
        }
        rtxCopyContext(pctxt, &lctxt);

        if(stat == 0) {
            stat = pe_OpenType (pctxt, openType.numocts, openType.data);
        }
    #if 1
        if(encoded){//dungnm23 check lai nhe
            rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
        }
    #endif

    }

    if(stat!=0) return LOG_RTERR(pctxt, stat);  
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}

EXTERN int  asn1PD_e2ap_RICsubscriptionModificationRequired_protocolIEs_element (OSCTXT* pctxt, e2ap_RICsubscriptionModificationRequired_protocolIEs_element* pvalue){
    int stat =0;

    /*decode id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PD_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PD_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");

    {
        OSUINT32 openTypeLen;
        size_t bitStartOffset, bitLength;

        stat = pd_UnconsLength(pctxt, &openTypeLen);
        if(stat<0) return LOG_RTERR(pctxt, stat);
        else if(stat == RT_OK_FRAG){
            rtxErrAddStrParm(pctxt, "open type with fragment length");
            return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
        }
        bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
        bitLength = openTypeLen * 8;

        switch(pvalue->id){//dungnm23 check case lai nhe
        
            case ASN1V_e2ap_id_RICrequestID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRequired_IEs_id_RICrequestID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICrequestID");
                pvalue->value.u._e2ap_RICsubscriptionModificationRequired_IEs_id_RICrequestID 
                    = rtxMemAllocType(pctxt, e2ap_RICrequestID);

                asn1Init_e2ap_RICrequestID(pvalue->value.u._e2ap_RICsubscriptionModificationRequired_IEs_id_RICrequestID);

                stat = asn1PD_e2ap_RICrequestID (pctxt,
                        (e2ap_RICrequestID*)pvalue->value.
                        u._e2ap_RICsubscriptionModificationRequired_IEs_id_RICrequestID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RANfunctionID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRequired_IEs_id_RANfunctionID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RANfunctionID");
                pvalue->value.u._e2ap_RICsubscriptionModificationRequired_IEs_id_RANfunctionID 
                    = rtxMemAllocType(pctxt, e2ap_RANfunctionID);

                asn1Init_e2ap_RANfunctionID(pvalue->value.u._e2ap_RICsubscriptionModificationRequired_IEs_id_RANfunctionID);

                stat = asn1PD_e2ap_RANfunctionID (pctxt,
                        (e2ap_RANfunctionID*)pvalue->value.
                        u._e2ap_RICsubscriptionModificationRequired_IEs_id_RANfunctionID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RICactionsRequiredToBeModified_List:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRequired_IEs_id_RICactionsRequiredToBeModified_List;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICactionsRequiredToBeModified-List");
                pvalue->value.u._e2ap_RICsubscriptionModificationRequired_IEs_id_RICactionsRequiredToBeModified_List 
                    = rtxMemAllocType(pctxt, e2ap_RICactions_RequiredToBeModified_List);

                asn1Init_e2ap_RICactions_RequiredToBeModified_List(pvalue->value.u._e2ap_RICsubscriptionModificationRequired_IEs_id_RICactionsRequiredToBeModified_List);

                stat = asn1PD_e2ap_RICactions_RequiredToBeModified_List (pctxt,
                        (e2ap_RICactions_RequiredToBeModified_List*)pvalue->value.
                        u._e2ap_RICsubscriptionModificationRequired_IEs_id_RICactionsRequiredToBeModified_List);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RICactionsRequiredToBeRemoved_List:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRequired_IEs_id_RICactionsRequiredToBeRemoved_List;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICactionsRequiredToBeRemoved-List");
                pvalue->value.u._e2ap_RICsubscriptionModificationRequired_IEs_id_RICactionsRequiredToBeRemoved_List 
                    = rtxMemAllocType(pctxt, e2ap_RICactions_RequiredToBeRemoved_List);

                asn1Init_e2ap_RICactions_RequiredToBeRemoved_List(pvalue->value.u._e2ap_RICsubscriptionModificationRequired_IEs_id_RICactionsRequiredToBeRemoved_List);

                stat = asn1PD_e2ap_RICactions_RequiredToBeRemoved_List (pctxt,
                        (e2ap_RICactions_RequiredToBeRemoved_List*)pvalue->value.
                        u._e2ap_RICsubscriptionModificationRequired_IEs_id_RICactionsRequiredToBeRemoved_List);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRequired_IEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*) rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
    }
    {
    size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
    size_t bitsConsumed = bitEndOffset-bitStartOffset;
    if(bitsConsumed<bitLength){
        stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
    }
    else stat =(bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
    }}
    if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}


int asn1Init_e2ap_RICsubscriptionModificationRequired_protocolIEs_element(e2ap_RICsubscriptionModificationRequired_protocolIEs_element* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    OSCRTLMEMSET (&pvalue->value, 0, sizeof(pvalue->value));
    return 0;
}


//-----> chuaw có template rtxFreeASN1OpenType

#if 0
void asn1Free_e2ap_RICsubscriptionModificationRequired_protocolIEs_element(OSCTXT* pctxt, e2ap_RICsubscriptionModificationRequired_protocolIEs_element* pvalue)
{
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRequired_IEs_id_id_RICrequestID:
            // rtxFreeE2ap_RICrequestID(pvalue->value.u._e2ap_RICsubscriptionModificationRequired_IEs_id_id_RICrequestID);

            if(pvalue->value.i._e2ap_RICsubscriptionModificationRequired_id_RICrequestID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICrequestID(pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationRequired_IEs_id_id_RICrequestID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionModificationRequired_IEs_id_id_RICrequestID);
           // pvalue->value.u._e2ap_RICsubscriptionModificationRequired_IEs_id_id_RICrequestID = NULL;
           pvalue->value.u._e2ap_RICsubscriptionModificationRequired_IEs_id_RICrequestID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRequired_IEs_id_id_RANfunctionID:
            // rtxFreeE2ap_RANfunctionID(pvalue->value.u._e2ap_RICsubscriptionModificationRequired_IEs_id_id_RANfunctionID);

            if(pvalue->value.i._e2ap_RICsubscriptionModificationRequired_id_RANfunctionID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RANfunctionID(pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationRequired_IEs_id_id_RANfunctionID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionModificationRequired_IEs_id_id_RANfunctionID);
           // pvalue->value.u._e2ap_RICsubscriptionModificationRequired_IEs_id_id_RANfunctionID = NULL;
           pvalue->value.u._e2ap_RICsubscriptionModificationRequired_IEs_id_RANfunctionID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRequired_IEs_id_id_RICactionsRequiredToBeModified_List:
            // rtxFreeE2ap_RICactions_RequiredToBeModified_List(pvalue->value.u._e2ap_RICsubscriptionModificationRequired_IEs_id_id_RICactionsRequiredToBeModified_List);

            if(pvalue->value.i._e2ap_RICsubscriptionModificationRequired_id_RICactions_RequiredToBeModified_List!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICactions_RequiredToBeModified_List(pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationRequired_IEs_id_id_RICactionsRequiredToBeModified_List);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionModificationRequired_IEs_id_id_RICactionsRequiredToBeModified_List);
           // pvalue->value.u._e2ap_RICsubscriptionModificationRequired_IEs_id_id_RICactionsRequiredToBeModified_List = NULL;
           pvalue->value.u._e2ap_RICsubscriptionModificationRequired_IEs_id_RICactionsRequiredToBeModified_List = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRequired_IEs_id_id_RICactionsRequiredToBeRemoved_List:
            // rtxFreeE2ap_RICactions_RequiredToBeRemoved_List(pvalue->value.u._e2ap_RICsubscriptionModificationRequired_IEs_id_id_RICactionsRequiredToBeRemoved_List);

            if(pvalue->value.i._e2ap_RICsubscriptionModificationRequired_id_RICactions_RequiredToBeRemoved_List!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICactions_RequiredToBeRemoved_List(pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationRequired_IEs_id_id_RICactionsRequiredToBeRemoved_List);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionModificationRequired_IEs_id_id_RICactionsRequiredToBeRemoved_List);
           // pvalue->value.u._e2ap_RICsubscriptionModificationRequired_IEs_id_id_RICactionsRequiredToBeRemoved_List = NULL;
           pvalue->value.u._e2ap_RICsubscriptionModificationRequired_IEs_id_RICactionsRequiredToBeRemoved_List = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRequired_IEs_UNDEF_:
            rtxFreeASN1OpenType(pvalue->value.u.extElem1);
            break;
        default:
            break;
    }
}

int asn1PrtToStr_e2ap_RICsubscriptionModificationRequired_protocolIEs_element(OSCTXT* pctxt, e2ap_RICsubscriptionModificationRequired_protocolIEs_element* pvalue)
{
    int stat =0;
    RTXCTXTPUSHELEMNAME(pctxt, "e2ap_RICsubscriptionModificationRequired_protocolIEs_element");

    /*print id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PrtToStr_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PrtToStr_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRequired_IEs_id_id_RICrequestID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICrequestID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICrequestID (pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationRequired_IEs_id_id_RICrequestID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRequired_IEs_id_id_RANfunctionID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RANfunctionID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RANfunctionID (pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationRequired_IEs_id_id_RANfunctionID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRequired_IEs_id_id_RICactionsRequiredToBeModified_List:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICactions-RequiredToBeModified-List");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICactions_RequiredToBeModified_List (pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationRequired_IEs_id_id_RICactionsRequiredToBeModified_List);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRequired_IEs_id_id_RICactionsRequiredToBeRemoved_List:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICactions-RequiredToBeRemoved-List");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICactions_RequiredToBeRemoved_List (pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationRequired_IEs_id_id_RICactionsRequiredToBeRemoved_List);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRequired_IEs_UNDEF_:
            {
                rtxPLogMsg(pctxt, "Extension element present - raw data not printed.\n");
                break;
            }

            default:
                stat = RTERR_INVOPT;
                return LOG_RTERR(pctxt, stat);
        }
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);
}
#endif


int asn1PrtToStr_e2ap_RICsubscriptionModificationRequired_protocolIEs_element (const char * name,
 e2ap_RICsubscriptionModificationRequired_protocolIEs_element* pvalue, 
 char * buffer, OSSIZE bufSize){
    if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
        return -1;
    if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
        return -1;

    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRequired_IEs_id_RICrequestID:
            if(asn1PrtToStr_e2ap_RICrequestID("RICrequestID", 
                    pvalue->value.u._e2ap_RICsubscriptionModificationRequired_IEs_id_RICrequestID, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRequired_IEs_id_RANfunctionID:
            if(asn1PrtToStr_e2ap_RANfunctionID("RANfunctionID", 
                    pvalue->value.u._e2ap_RICsubscriptionModificationRequired_IEs_id_RANfunctionID, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRequired_IEs_id_RICactionsRequiredToBeModified_List:
            if(asn1PrtToStr_e2ap_RICactions_RequiredToBeModified_List("RICactions-RequiredToBeModified-List", 
                    pvalue->value.u._e2ap_RICsubscriptionModificationRequired_IEs_id_RICactionsRequiredToBeModified_List, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRequired_IEs_id_RICactionsRequiredToBeRemoved_List:
            if(asn1PrtToStr_e2ap_RICactions_RequiredToBeRemoved_List("RICactions-RequiredToBeRemoved-List", 
                    pvalue->value.u._e2ap_RICsubscriptionModificationRequired_IEs_id_RICactionsRequiredToBeRemoved_List, buffer, bufSize)<0)
                return -1;
            break;    
        default:
        if(0!=pvalue -> value.u.extElem1){
            rtPrintToStringIndent(buffer, bufSize);
            rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

        }
        }
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

    return 0;

 }

 void asn1Free_e2ap_RICsubscriptionModificationRequired_protocolIEs_element(OSCTXT* pctxt, e2ap_RICsubscriptionModificationRequired_protocolIEs_element* pvalue){
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRequired_IEs_id_RICrequestID:
            if(pvalue->value.u._e2ap_RICsubscriptionModificationRequired_IEs_id_RICrequestID!=NULL){
            asn1Free_e2ap_RICrequestID(pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationRequired_IEs_id_RICrequestID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionModificationRequired_IEs_id_RICrequestID);
            pvalue->value.u._e2ap_RICsubscriptionModificationRequired_IEs_id_RICrequestID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRequired_IEs_id_RANfunctionID:
            if(pvalue->value.u._e2ap_RICsubscriptionModificationRequired_IEs_id_RANfunctionID!=NULL){
            asn1Free_e2ap_RANfunctionID(pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationRequired_IEs_id_RANfunctionID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionModificationRequired_IEs_id_RANfunctionID);
            pvalue->value.u._e2ap_RICsubscriptionModificationRequired_IEs_id_RANfunctionID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRequired_IEs_id_RICactionsRequiredToBeModified_List:
            if(pvalue->value.u._e2ap_RICsubscriptionModificationRequired_IEs_id_RICactionsRequiredToBeModified_List!=NULL){
            asn1Free_e2ap_RICactions_RequiredToBeModified_List(pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationRequired_IEs_id_RICactionsRequiredToBeModified_List);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionModificationRequired_IEs_id_RICactionsRequiredToBeModified_List);
            pvalue->value.u._e2ap_RICsubscriptionModificationRequired_IEs_id_RICactionsRequiredToBeModified_List = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRequired_IEs_id_RICactionsRequiredToBeRemoved_List:
            if(pvalue->value.u._e2ap_RICsubscriptionModificationRequired_IEs_id_RICactionsRequiredToBeRemoved_List!=NULL){
            asn1Free_e2ap_RICactions_RequiredToBeRemoved_List(pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationRequired_IEs_id_RICactionsRequiredToBeRemoved_List);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionModificationRequired_IEs_id_RICactionsRequiredToBeRemoved_List);
            pvalue->value.u._e2ap_RICsubscriptionModificationRequired_IEs_id_RICactionsRequiredToBeRemoved_List = NULL;
            }
            break;
        default:
            break;


    }
 }

 

/*****************************************/
/*           RICsubscriptionModificationRequired                */
/*****************************************/
//2_container.c
/* 1. xxx_ProtocolIE -> mẫu cũ ở ie_big_msg */
EXTERN int asn1PE_e2ap_RICsubscriptionModificationRequired_protocolIEs (OSCTXT* pctxt, e2ap_RICsubscriptionModificationRequired_protocolIEs* pvalue)
{
    int stat =0;
    OSRTDListNode* pnode;
    OSUINT32 xx1;

    /*encode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pe_Length(pctxt, pvalue->count);
    if(stat<0) return LOG_RTERR(pctxt, stat);

    /*encode each element*/
    xx1 =0;
    for(pnode = pvalue->head; pnode != 0 && xx1<pvalue->count; pnode = pnode->next){
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE", xx1);
        stat = asn1PE_e2ap_RICsubscriptionModificationRequired_protocolIEs_element (pctxt, ((e2ap_RICsubscriptionModificationRequired_protocolIEs_element*)pnode->data));
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        xx1++;
        RTXCTXTPOPARRAYELEMNAME(pctxt);
    }

    return (stat);
}

EXTERN int  asn1PD_e2ap_RICsubscriptionModificationRequired_protocolIEs(OSCTXT* pctxt, e2ap_RICsubscriptionModificationRequired_protocolIEs* pvalue)
{
     int stat =0;
     OSRTDListNode* pnode;
     OSSIZE count =0;
     OSSIZE xx1=0;


     /*decode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pd_Length64(pctxt, &count); //tai sao lai 64
    if(stat!=0) return LOG_RTERR(pctxt, stat);

    /*decode each element*/
    rtxDListInit(pvalue);

    for(xx1=0; xx1 < count; xx1++){
        e2ap_RICsubscriptionModificationRequired_protocolIEs_element* pdata;
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE",xx1);

        if(pnode == NULL) return LOG_RTERR(pctxt, RTERR_NOMEM);

        asn1Init_e2ap_RICsubscriptionModificationRequired_protocolIEs_element(pdata);
        rtxDListAppendNode(pvalue, pnode);
        stat = asn1PD_e2ap_RICsubscriptionModificationRequired_protocolIEs_element (pctxt, pdata);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        RTXCTXTPOPARRAYELEMNAME(pctxt);

    }
    return (stat);
}


int asn1Init_e2ap_RICsubscriptionModificationRequired_protocolIEs(e2ap_RICsubscriptionModificationRequired_protocolIEs* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    rtxDListFastInit (pvalue);
    return 0;
}
#if 1 //ao that day
void asn1Free_e2ap_RICsubscriptionModificationRequired_protocolIEs(OSCTXT* pctxt, e2ap_RICsubscriptionModificationRequired_protocolIEs* pvalue)
{
    if(0==pvalue) return;   
    e2ap_RICsubscriptionModificationRequired_protocolIEs_element* pdata;
    OSRTDListNode* pnode=pvalue->head;
    while(0!=pnode){
        pdata = (e2ap_RICsubscriptionModificationRequired_protocolIEs_element*)pnode->data;
       // asn1Free_e2ap_RICsubscriptionModificationRequired_protocolIEs_element(pctxt, pdata);
        pnode = pnode->next;
    }
    rtxDListFreeAll(pctxt, pvalue);
}
#endif


EXTERN int asn1PrtToStr_e2ap_RICsubscriptionModificationRequired_protocolIEs(const char* name, e2ap_RICsubscriptionModificationRequired_protocolIEs* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_RICsubscriptionModificationRequired_protocolIEs_element* pdata0;
    OSRTDListNode* pnode0;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode0 = pvalue->head;  xx1 < pvalue->count && pnode0 != 0; pnode0 = pnode0->next, xx1++){
        pdata0 = (e2ap_RICsubscriptionModificationRequired_protocolIEs_element*)pnode0->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 0
        if(asn1PrtToStr_e2ap_RICsubscriptionModificationRequired_protocolIEs_element(nameBuf, pdata0, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}


/*2 . RICsubscriptionModificationRequired -> mẫu cũ ở seq_normal*/

int asn1PE_e2ap_RICsubscriptionModificationRequired (OSCTXT* pctxt, e2ap_RICsubscriptionModificationRequired* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RICsubscriptionModificationRequired");
   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field protocolIEs - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
   stat = asn1PE_e2ap_RICsubscriptionModificationRequired_protocolIEs (pctxt, &pvalue->protocolIEs);
   if(stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RICsubscriptionModificationRequired (OSCTXT* pctxt, e2ap_RICsubscriptionModificationRequired* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME(pctxt, "RICsubscriptionModificationRequired");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field protocolIEs */
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
      stat = asn1PD_e2ap_RICsubscriptionModificationRequired_protocolIEs (pctxt, &pvalue->protocolIEs);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RICsubscriptionModificationRequired (e2ap_RICsubscriptionModificationRequired* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RICsubscriptionModificationRequired_protocolIEs(&pvalue->protocolIEs);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RICsubscriptionModificationRequired (OSCTXT* pctxt, e2ap_RICsubscriptionModificationRequired* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_RICsubscriptionModificationRequired_protocolIEs(pctxt, &pvalue->protocolIEs);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RICsubscriptionModificationRequired (const char* name, e2ap_RICsubscriptionModificationRequired* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }

   if(asn1PrtToStr_e2ap_RICsubscriptionModificationRequired_protocolIEs("protocolIEs", &pvalue->protocolIEs, buffer, bufSize) <0){
      return -1;
   }

   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}
/*****************************************/
/*           RICaction-ConfirmedForModification-Item                */
/*****************************************/
//sequence normal
// Các nội dung cần thiết cho template seq_normal.c.j2

// Các phần còn lại của template seq_normal.c.j2
//contain extensition bit -> theo mau cua GlobalgNB-ID
int asn1PE_e2ap_RICaction_ConfirmedForModification_Item (OSCTXT* pctxt, e2ap_RICaction_ConfirmedForModification_Item* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RICaction-ConfirmedForModification-Item");

   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field ricActionID - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "ricActionID");
   stat = asn1PE_e2ap_RICactionID (pctxt, pvalue->ricActionID);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);



   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RICaction_ConfirmedForModification_Item (OSCTXT* pctxt, e2ap_RICaction_ConfirmedForModification_Item* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME(pctxt, "RICaction-ConfirmedForModification-Item");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field ricActionID */
   RTXCTXTPUSHELEMNAME(pctxt, "ricActionID");
      stat = asn1PD_e2ap_RICactionID (pctxt, &pvalue->ricActionID);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RICaction_ConfirmedForModification_Item (e2ap_RICaction_ConfirmedForModification_Item* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RICactionID (&pvalue->ricActionID);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RICaction_ConfirmedForModification_Item (OSCTXT* pctxt, e2ap_RICaction_ConfirmedForModification_Item* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_RICactionID (pctxt, &pvalue->ricActionID);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RICaction_ConfirmedForModification_Item (const char* name, e2ap_RICaction_ConfirmedForModification_Item* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }
   if(asn1PrtToStr_e2ap_RICactionID ("ricActionID", &pvalue->ricActionID, buffer, bufSize) < 0)
   {
      return -1;
   }



   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           RICaction_ConfirmedForModification_ItemIEs                */
/*****************************************/
/* ie.c.j2 */
/*ie thường*/
int asn1PE_e2ap_RICaction_ConfirmedForModification_ItemIEs (OSCTXT* pctxt, e2ap_RICaction_ConfirmedForModification_ItemIEs* pvalue)
{
   int stat = 0;
   //RTXCTXTPUSHTYPENAME (pctxt, "RICaction-ConfirmedForModification-ItemIEs");

   /* encode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");
   stat = asn1PE_e2ap_ProtocolIE_ID (pctxt, pvalue->id);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");
   stat = asn1PE_e2ap_Criticality (pctxt, pvalue->criticality);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   {
      OSCTXT ictxt;
      OSOCTET* pDynamicEncodeBuffer;
      ASN1OpenType openType;
      OSBOOL  encoded = TRUE;

      openType.numocts = 0;
      openType.data = 0;

      rtxCopyContext (&ictxt, pctxt);
      pctxt->pStream = 0;

      stat = rtxInitContextBuffer (pctxt, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_RICaction_ConfirmedForModification_ItemIEs_id_RICaction_ConfirmedForModification_Item:
         
        // RTXCTXTPUSHELEMNAME (pctxt, "RICaction_ConfirmedForModification_ItemIEs_id_RICaction_ConfirmedForModification_Item");
         RTXCTXTPUSHELEMNAME (pctxt, "RICaction-ConfirmedForModification-Item");
         stat = asn1PE_e2ap_RICaction_ConfirmedForModification_Item (pctxt, pvalue->value.u._e2apRICaction_ConfirmedForModification_ItemIEs_id_RICaction_ConfirmedForModification_Item);
         RTXCTXTPOPELEMNAME (pctxt);
      
         break;

      case T_E2AP_PDU_Contents_e2ap_RICaction_ConfirmedForModification_ItemIEs_UNDEF_:
      {
          if(0!=pvalue->value.u.extElem1){
              openType.numocts = pvalue->value.u.extElem1->numocts;
              openType.data = pvalue->value.u.extElem1->data;
          } else {
              /* No extension element to encode */
          }
          encoded = FALSE;
          break;
      }
      default:
         encoded = FALSE;
         stat = RTERR_INVOPT;
      }

      if (encoded) {
         openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
         openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
      }
      rtxCopyContext (pctxt, &ictxt);
      if(stat ==0) stat = pe_OpenType(pctxt, openType.numocts, openType.data);
      /*free dynamic encode buffer*/
      if(encoded){
          rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
      }
   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);
   //RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

int asn1PD_e2ap_RICaction_ConfirmedForModification_ItemIEs (OSCTXT* pctxt, e2ap_RICaction_ConfirmedForModification_ItemIEs* pvalue)
{
   int stat =0;
   /*deode root element id*/
   RTXCTXTPUSHELEMNAME(pctxt, "id");
   stat = asn1PD_e2ap_ProtocolIE_ID (pctxt, &pvalue->id);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*decode root element criticality*/
   RTXCTXTPUSHELEMNAME(pctxt, "criticality");
   stat = asn1PD_e2ap_Criticality (pctxt, &pvalue->criticality);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   /*decode root element value*/
   RTXCTXTPUSHELEMNAME(pctxt, "value");
   {
      OSUINT32 openTypeLen;
      size_t bitStartOffset, bitLength;
      stat = pd_UnconsLength(pctxt, &openTypeLen);
      if(stat <0) return LOG_RTERR(pctxt, stat);
      else if(stat == RT_OK_FRAG){
         rtxErrAddStrParm(pctxt, "open type with fragmented length use - perindef");
         return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
      }
      bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
      bitLength = openTypeLen * 8;
      switch (pvalue->id){
         case T_E2AP_PDU_Contents_e2ap_RICaction_ConfirmedForModification_ItemIEs_id_RICaction_ConfirmedForModification_Item:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICaction_ConfirmedForModification_ItemIEs_id_RICaction_ConfirmedForModification_Item;
            RTXCTXTPUSHELEMNAME(pctxt, "RICaction-ConfirmedForModification-Item");
            //pvalue->value.u._e2ap_RICaction_ConfirmedForModification_ItemIEs_id_id_RICaction_ConfirmedForModification_Item 
             pvalue->value.u._e2apRICaction_ConfirmedForModification_ItemIEs_id_RICaction_ConfirmedForModification_Item 
                    = rtxMemAllocType(pctxt, e2ap_RICaction_ConfirmedForModification_Item);
            //asn1Init_e2ap_RICaction_ConfirmedForModification_Item(pvalue->value.u._e2ap_RICaction_ConfirmedForModification_ItemIEs_id_id_RICaction_ConfirmedForModification_Item);
            asn1Init_e2ap_RICaction_ConfirmedForModification_Item(pvalue->value.u._e2apRICaction_ConfirmedForModification_ItemIEs_id_RICaction_ConfirmedForModification_Item);
            stat = asn1PD_e2ap_RICaction_ConfirmedForModification_Item (pctxt,
                    (e2ap_RICaction_ConfirmedForModification_Item*)pvalue->value.
                    u._e2apRICaction_ConfirmedForModification_ItemIEs_id_RICaction_ConfirmedForModification_Item);
            if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICaction_ConfirmedForModification_ItemIEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*)rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
      }
      {
      size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
      size_t bitsConsumed = bitEndOffset - bitStartOffset;
      if(bitsConsumed < bitLength){
         stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
      } else {
         stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
      }
      }
   }
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   return stat;
}

void asn1Init_e2ap_RICaction_ConfirmedForModification_ItemIEs (e2ap_RICaction_ConfirmedForModification_ItemIEs* pvalue)
{
   if (!pvalue) return;
   OSCRTLMEMSET (pvalue, 0, sizeof(e2ap_RICaction_ConfirmedForModification_ItemIEs));
}

#if 0
void asn1Free_e2ap_RICaction_ConfirmedForModification_ItemIEs (OSCTXT* pctxt, e2ap_RICaction_ConfirmedForModification_ItemIEs* pvalue)
{
   if (!pvalue) return;
   if (pvalue->extElem1) {
      rtxMemFreeArray (pctxt, pvalue->extElem1);
      pvalue->extElem1 = 0;
      pvalue->extElem1_n = 0;
   }
}
#endif
void asn1Free_e2ap_RICaction_ConfirmedForModification_ItemIEs (OSCTXT* pctxt, e2ap_RICaction_ConfirmedForModification_ItemIEs* pvalue)
{
   if(0==pvalue) return;
   switch(pvalue->value.t){
      case T_E2AP_PDU_Contents_e2ap_RICaction_ConfirmedForModification_ItemIEs_id_RICaction_ConfirmedForModification_Item:
         asn1Free_e2ap_RICaction_ConfirmedForModification_Item (pctxt, pvalue->value.u._e2apRICaction_ConfirmedForModification_ItemIEs_id_RICaction_ConfirmedForModification_Item);
         rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2apRICaction_ConfirmedForModification_ItemIEs_id_RICaction_ConfirmedForModification_Item);
         pvalue->value.u._e2apRICaction_ConfirmedForModification_ItemIEs_id_RICaction_ConfirmedForModification_Item = 0;
         break;
      case T_E2AP_PDU_Contents_e2ap_RICaction_ConfirmedForModification_ItemIEs_UNDEF_:
         if(0!=pvalue->value.u.extElem1){
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1->data);
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
             pvalue->value.u.extElem1 =0;
         }
         break;
         default:;
   }
}

int  asn1PrtToStr_e2ap_RICaction_ConfirmedForModification_ItemIEs (const char * name, e2ap_RICaction_ConfirmedForModification_ItemIEs* pvalue, char * buffer, OSSIZE bufSize){
   if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
       return -1;

      if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
         return -1;

      if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
         return -1;
      if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
         return -1;
      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_RICaction_ConfirmedForModification_ItemIEs_id_RICaction_ConfirmedForModification_Item:
         if(asn1PrtToStr_e2ap_RICaction_ConfirmedForModification_Item("RICaction-ConfirmedForModification-Item",
                pvalue->value.u._e2apRICaction_ConfirmedForModification_ItemIEs_id_RICaction_ConfirmedForModification_Item, buffer, bufSize)<0)// dungnm23 check lai nhe xem la
            return -1;
         break;
      default:
         if(0!=pvalue -> value.u.extElem1){
             rtPrintToStringIndent(buffer, bufSize);
             rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

         }
      }
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

      return 0;

}
 

/*****************************************/
/*           RICactions_ConfirmedForModification_List                */
/*****************************************/
//seq_of_single_container


int asn1PE_e2ap_RICactions_ConfirmedForModification_List (OSCTXT* pctxt, e2ap_RICactions_ConfirmedForModification_List* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_RICaction_ConfirmedForModification_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "RICactions-ConfirmedForModification-List");

   /* encode length determinant */
   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(16), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;
   for (xx1 = 0; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next, xx1++) {
      pdata = (e2ap_RICaction_ConfirmedForModification_ItemIEs*) pnode->data;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_e2ap_RICaction_ConfirmedForModification_ItemIEs (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      //xx1++;
      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}

int asn1PD_e2ap_RICactions_ConfirmedForModification_List (OSCTXT* pctxt, e2ap_RICactions_ConfirmedForModification_List* ppvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_RICaction_ConfirmedForModification_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "RICactions-ConfirmedForModification-List");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(16), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (ppvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      pdata = rtxMemAllocType (pctxt, e2ap_RICaction_ConfirmedForModification_ItemIEs);
      if (!pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);
      asn1Init_e2ap_RICaction_ConfirmedForModification_ItemIEs (pdata);
      stat = asn1PD_e2ap_RICaction_ConfirmedForModification_ItemIEs (pctxt, pdata);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         return LOG_RTERR (pctxt, stat);
      }

      rtxDListAppendNode (ppvalue, pdata);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

void asn1Init_e2ap_RICactions_ConfirmedForModification_List (e2ap_RICactions_ConfirmedForModification_List* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
}

void asn1Free_e2ap_RICactions_ConfirmedForModification_List (OSCTXT* pctxt, e2ap_RICactions_ConfirmedForModification_List* pvalue)
{
   if(pvalue==0) return;
   OSRTDListNode* pnode = pvalue->head;
   while (pnode) {
      e2ap_RICaction_ConfirmedForModification_ItemIEs* pdata = (e2ap_RICaction_ConfirmedForModification_ItemIEs*) pnode->data;
      if (pdata) {
         asn1Free_e2ap_RICaction_ConfirmedForModification_ItemIEs (pctxt, pdata);
         rtxMemFreePtr (pctxt, pdata);
      }
      pnode = pnode->next;
   }
      rtxDListFreeAll(pctxt, pvalue);
}

#if 0
void asn1Free_e2ap_RICactions_ConfirmedForModification_List (OSCTXT* pctxt, e2ap_RICactions_ConfirmedForModification_List* pvalue){
   if(0==pvalue ) return;
   {
      e2ap_RICaction_ConfirmedForModification_ItemIEs * pdata;
      OSRTDListNode *pnode = pvalue->head;
      while(0!=pnode){
         pdata = (e2ap_RICaction_ConfirmedForModification_ItemIEs*)pnode->data;
         asn1Free_e2ap_RICaction_ConfirmedForModification_ItemIEs(pctxt, pdata);
         pnode = pnode->next;
      }
      rtxDListFreeAll(pctxt, pvalue);
   }
}
#endif


int asn1PrtToStr_e2ap_RICactions_ConfirmedForModification_List(const char* name, e2ap_RICactions_ConfirmedForModification_List* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_RICaction_ConfirmedForModification_ItemIEs* pdata;
    OSRTDListNode* pnode;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode = pvalue->head;  xx1 < pvalue->count && pnode != 0; pnode = pnode->next, xx1++){
        pdata = (e2ap_RICaction_ConfirmedForModification_ItemIEs*)pnode->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 1
        if(asn1PrtToStr_e2ap_RICaction_ConfirmedForModification_ItemIEs(nameBuf, pdata, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}
/*****************************************/
/*           RICaction-RefusedToBeModified-Item                */
/*****************************************/
//sequence normal
// Các nội dung cần thiết cho template seq_normal.c.j2

// Các phần còn lại của template seq_normal.c.j2
//contain extensition bit -> theo mau cua GlobalgNB-ID
int asn1PE_e2ap_RICaction_RefusedToBeModified_Item (OSCTXT* pctxt, e2ap_RICaction_RefusedToBeModified_Item* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RICaction-RefusedToBeModified-Item");

   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field ricActionID - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "ricActionID");
   stat = asn1PE_e2ap_RICactionID (pctxt, pvalue->ricActionID);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /* encode field cause - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "cause");
   stat = asn1PE_e2ap_Cause (pctxt, pvalue->cause);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);



   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RICaction_RefusedToBeModified_Item (OSCTXT* pctxt, e2ap_RICaction_RefusedToBeModified_Item* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME(pctxt, "RICaction-RefusedToBeModified-Item");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field ricActionID */
   RTXCTXTPUSHELEMNAME(pctxt, "ricActionID");
      stat = asn1PD_e2ap_RICactionID (pctxt, &pvalue->ricActionID);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field cause */
   RTXCTXTPUSHELEMNAME(pctxt, "cause");
      stat = asn1PD_e2ap_Cause (pctxt, &pvalue->cause);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RICaction_RefusedToBeModified_Item (e2ap_RICaction_RefusedToBeModified_Item* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RICactionID (&pvalue->ricActionID);
   asn1Init_e2ap_Cause (&pvalue->cause);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RICaction_RefusedToBeModified_Item (OSCTXT* pctxt, e2ap_RICaction_RefusedToBeModified_Item* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_RICactionID (pctxt, &pvalue->ricActionID);
   asn1Free_e2ap_Cause (pctxt, &pvalue->cause);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RICaction_RefusedToBeModified_Item (const char* name, e2ap_RICaction_RefusedToBeModified_Item* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }
   if(asn1PrtToStr_e2ap_RICactionID ("ricActionID", &pvalue->ricActionID, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_Cause ("cause", &pvalue->cause, buffer, bufSize) < 0)
   {
      return -1;
   }



   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           RICaction_RefusedToBeModified_ItemIEs                */
/*****************************************/
/* ie.c.j2 */
/*ie thường*/
int asn1PE_e2ap_RICaction_RefusedToBeModified_ItemIEs (OSCTXT* pctxt, e2ap_RICaction_RefusedToBeModified_ItemIEs* pvalue)
{
   int stat = 0;
   //RTXCTXTPUSHTYPENAME (pctxt, "RICaction-RefusedToBeModified-ItemIEs");

   /* encode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");
   stat = asn1PE_e2ap_ProtocolIE_ID (pctxt, pvalue->id);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");
   stat = asn1PE_e2ap_Criticality (pctxt, pvalue->criticality);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   {
      OSCTXT ictxt;
      OSOCTET* pDynamicEncodeBuffer;
      ASN1OpenType openType;
      OSBOOL  encoded = TRUE;

      openType.numocts = 0;
      openType.data = 0;

      rtxCopyContext (&ictxt, pctxt);
      pctxt->pStream = 0;

      stat = rtxInitContextBuffer (pctxt, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_RICaction_RefusedToBeModified_ItemIEs_id_RICaction_RefusedToBeModified_Item:
         
        // RTXCTXTPUSHELEMNAME (pctxt, "RICaction_RefusedToBeModified_ItemIEs_id_RICaction_RefusedToBeModified_Item");
         RTXCTXTPUSHELEMNAME (pctxt, "RICaction-RefusedToBeModified-Item");
         stat = asn1PE_e2ap_RICaction_RefusedToBeModified_Item (pctxt, pvalue->value.u._e2apRICaction_RefusedToBeModified_ItemIEs_id_RICaction_RefusedToBeModified_Item);
         RTXCTXTPOPELEMNAME (pctxt);
      
         break;

      case T_E2AP_PDU_Contents_e2ap_RICaction_RefusedToBeModified_ItemIEs_UNDEF_:
      {
          if(0!=pvalue->value.u.extElem1){
              openType.numocts = pvalue->value.u.extElem1->numocts;
              openType.data = pvalue->value.u.extElem1->data;
          } else {
              /* No extension element to encode */
          }
          encoded = FALSE;
          break;
      }
      default:
         encoded = FALSE;
         stat = RTERR_INVOPT;
      }

      if (encoded) {
         openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
         openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
      }
      rtxCopyContext (pctxt, &ictxt);
      if(stat ==0) stat = pe_OpenType(pctxt, openType.numocts, openType.data);
      /*free dynamic encode buffer*/
      if(encoded){
          rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
      }
   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);
   //RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

int asn1PD_e2ap_RICaction_RefusedToBeModified_ItemIEs (OSCTXT* pctxt, e2ap_RICaction_RefusedToBeModified_ItemIEs* pvalue)
{
   int stat =0;
   /*deode root element id*/
   RTXCTXTPUSHELEMNAME(pctxt, "id");
   stat = asn1PD_e2ap_ProtocolIE_ID (pctxt, &pvalue->id);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*decode root element criticality*/
   RTXCTXTPUSHELEMNAME(pctxt, "criticality");
   stat = asn1PD_e2ap_Criticality (pctxt, &pvalue->criticality);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   /*decode root element value*/
   RTXCTXTPUSHELEMNAME(pctxt, "value");
   {
      OSUINT32 openTypeLen;
      size_t bitStartOffset, bitLength;
      stat = pd_UnconsLength(pctxt, &openTypeLen);
      if(stat <0) return LOG_RTERR(pctxt, stat);
      else if(stat == RT_OK_FRAG){
         rtxErrAddStrParm(pctxt, "open type with fragmented length use - perindef");
         return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
      }
      bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
      bitLength = openTypeLen * 8;
      switch (pvalue->id){
         case T_E2AP_PDU_Contents_e2ap_RICaction_RefusedToBeModified_ItemIEs_id_RICaction_RefusedToBeModified_Item:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICaction_RefusedToBeModified_ItemIEs_id_RICaction_RefusedToBeModified_Item;
            RTXCTXTPUSHELEMNAME(pctxt, "RICaction-RefusedToBeModified-Item");
            //pvalue->value.u._e2ap_RICaction_RefusedToBeModified_ItemIEs_id_id_RICaction_RefusedToBeModified_Item 
             pvalue->value.u._e2apRICaction_RefusedToBeModified_ItemIEs_id_RICaction_RefusedToBeModified_Item 
                    = rtxMemAllocType(pctxt, e2ap_RICaction_RefusedToBeModified_Item);
            //asn1Init_e2ap_RICaction_RefusedToBeModified_Item(pvalue->value.u._e2ap_RICaction_RefusedToBeModified_ItemIEs_id_id_RICaction_RefusedToBeModified_Item);
            asn1Init_e2ap_RICaction_RefusedToBeModified_Item(pvalue->value.u._e2apRICaction_RefusedToBeModified_ItemIEs_id_RICaction_RefusedToBeModified_Item);
            stat = asn1PD_e2ap_RICaction_RefusedToBeModified_Item (pctxt,
                    (e2ap_RICaction_RefusedToBeModified_Item*)pvalue->value.
                    u._e2apRICaction_RefusedToBeModified_ItemIEs_id_RICaction_RefusedToBeModified_Item);
            if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICaction_RefusedToBeModified_ItemIEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*)rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
      }
      {
      size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
      size_t bitsConsumed = bitEndOffset - bitStartOffset;
      if(bitsConsumed < bitLength){
         stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
      } else {
         stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
      }
      }
   }
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   return stat;
}

void asn1Init_e2ap_RICaction_RefusedToBeModified_ItemIEs (e2ap_RICaction_RefusedToBeModified_ItemIEs* pvalue)
{
   if (!pvalue) return;
   OSCRTLMEMSET (pvalue, 0, sizeof(e2ap_RICaction_RefusedToBeModified_ItemIEs));
}

#if 0
void asn1Free_e2ap_RICaction_RefusedToBeModified_ItemIEs (OSCTXT* pctxt, e2ap_RICaction_RefusedToBeModified_ItemIEs* pvalue)
{
   if (!pvalue) return;
   if (pvalue->extElem1) {
      rtxMemFreeArray (pctxt, pvalue->extElem1);
      pvalue->extElem1 = 0;
      pvalue->extElem1_n = 0;
   }
}
#endif
void asn1Free_e2ap_RICaction_RefusedToBeModified_ItemIEs (OSCTXT* pctxt, e2ap_RICaction_RefusedToBeModified_ItemIEs* pvalue)
{
   if(0==pvalue) return;
   switch(pvalue->value.t){
      case T_E2AP_PDU_Contents_e2ap_RICaction_RefusedToBeModified_ItemIEs_id_RICaction_RefusedToBeModified_Item:
         asn1Free_e2ap_RICaction_RefusedToBeModified_Item (pctxt, pvalue->value.u._e2apRICaction_RefusedToBeModified_ItemIEs_id_RICaction_RefusedToBeModified_Item);
         rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2apRICaction_RefusedToBeModified_ItemIEs_id_RICaction_RefusedToBeModified_Item);
         pvalue->value.u._e2apRICaction_RefusedToBeModified_ItemIEs_id_RICaction_RefusedToBeModified_Item = 0;
         break;
      case T_E2AP_PDU_Contents_e2ap_RICaction_RefusedToBeModified_ItemIEs_UNDEF_:
         if(0!=pvalue->value.u.extElem1){
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1->data);
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
             pvalue->value.u.extElem1 =0;
         }
         break;
         default:;
   }
}

int  asn1PrtToStr_e2ap_RICaction_RefusedToBeModified_ItemIEs (const char * name, e2ap_RICaction_RefusedToBeModified_ItemIEs* pvalue, char * buffer, OSSIZE bufSize){
   if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
       return -1;

      if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
         return -1;

      if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
         return -1;
      if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
         return -1;
      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_RICaction_RefusedToBeModified_ItemIEs_id_RICaction_RefusedToBeModified_Item:
         if(asn1PrtToStr_e2ap_RICaction_RefusedToBeModified_Item("RICaction-RefusedToBeModified-Item",
                pvalue->value.u._e2apRICaction_RefusedToBeModified_ItemIEs_id_RICaction_RefusedToBeModified_Item, buffer, bufSize)<0)// dungnm23 check lai nhe xem la
            return -1;
         break;
      default:
         if(0!=pvalue -> value.u.extElem1){
             rtPrintToStringIndent(buffer, bufSize);
             rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

         }
      }
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

      return 0;

}
 

/*****************************************/
/*           RICactions_RefusedToBeModified_List                */
/*****************************************/
//seq_of_single_container


int asn1PE_e2ap_RICactions_RefusedToBeModified_List (OSCTXT* pctxt, e2ap_RICactions_RefusedToBeModified_List* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_RICaction_RefusedToBeModified_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "RICactions-RefusedToBeModified-List");

   /* encode length determinant */
   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(16), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;
   for (xx1 = 0; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next, xx1++) {
      pdata = (e2ap_RICaction_RefusedToBeModified_ItemIEs*) pnode->data;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_e2ap_RICaction_RefusedToBeModified_ItemIEs (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      //xx1++;
      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}

int asn1PD_e2ap_RICactions_RefusedToBeModified_List (OSCTXT* pctxt, e2ap_RICactions_RefusedToBeModified_List* ppvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_RICaction_RefusedToBeModified_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "RICactions-RefusedToBeModified-List");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(16), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (ppvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      pdata = rtxMemAllocType (pctxt, e2ap_RICaction_RefusedToBeModified_ItemIEs);
      if (!pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);
      asn1Init_e2ap_RICaction_RefusedToBeModified_ItemIEs (pdata);
      stat = asn1PD_e2ap_RICaction_RefusedToBeModified_ItemIEs (pctxt, pdata);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         return LOG_RTERR (pctxt, stat);
      }

      rtxDListAppendNode (ppvalue, pdata);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

void asn1Init_e2ap_RICactions_RefusedToBeModified_List (e2ap_RICactions_RefusedToBeModified_List* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
}

void asn1Free_e2ap_RICactions_RefusedToBeModified_List (OSCTXT* pctxt, e2ap_RICactions_RefusedToBeModified_List* pvalue)
{
   if(pvalue==0) return;
   OSRTDListNode* pnode = pvalue->head;
   while (pnode) {
      e2ap_RICaction_RefusedToBeModified_ItemIEs* pdata = (e2ap_RICaction_RefusedToBeModified_ItemIEs*) pnode->data;
      if (pdata) {
         asn1Free_e2ap_RICaction_RefusedToBeModified_ItemIEs (pctxt, pdata);
         rtxMemFreePtr (pctxt, pdata);
      }
      pnode = pnode->next;
   }
      rtxDListFreeAll(pctxt, pvalue);
}

#if 0
void asn1Free_e2ap_RICactions_RefusedToBeModified_List (OSCTXT* pctxt, e2ap_RICactions_RefusedToBeModified_List* pvalue){
   if(0==pvalue ) return;
   {
      e2ap_RICaction_RefusedToBeModified_ItemIEs * pdata;
      OSRTDListNode *pnode = pvalue->head;
      while(0!=pnode){
         pdata = (e2ap_RICaction_RefusedToBeModified_ItemIEs*)pnode->data;
         asn1Free_e2ap_RICaction_RefusedToBeModified_ItemIEs(pctxt, pdata);
         pnode = pnode->next;
      }
      rtxDListFreeAll(pctxt, pvalue);
   }
}
#endif


int asn1PrtToStr_e2ap_RICactions_RefusedToBeModified_List(const char* name, e2ap_RICactions_RefusedToBeModified_List* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_RICaction_RefusedToBeModified_ItemIEs* pdata;
    OSRTDListNode* pnode;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode = pvalue->head;  xx1 < pvalue->count && pnode != 0; pnode = pnode->next, xx1++){
        pdata = (e2ap_RICaction_RefusedToBeModified_ItemIEs*)pnode->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 1
        if(asn1PrtToStr_e2ap_RICaction_RefusedToBeModified_ItemIEs(nameBuf, pdata, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}
/*****************************************/
/*           RICaction-ConfirmedForRemoval-Item                */
/*****************************************/
//sequence normal
// Các nội dung cần thiết cho template seq_normal.c.j2

// Các phần còn lại của template seq_normal.c.j2
//contain extensition bit -> theo mau cua GlobalgNB-ID
int asn1PE_e2ap_RICaction_ConfirmedForRemoval_Item (OSCTXT* pctxt, e2ap_RICaction_ConfirmedForRemoval_Item* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RICaction-ConfirmedForRemoval-Item");

   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field ricActionID - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "ricActionID");
   stat = asn1PE_e2ap_RICactionID (pctxt, pvalue->ricActionID);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);



   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RICaction_ConfirmedForRemoval_Item (OSCTXT* pctxt, e2ap_RICaction_ConfirmedForRemoval_Item* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME(pctxt, "RICaction-ConfirmedForRemoval-Item");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field ricActionID */
   RTXCTXTPUSHELEMNAME(pctxt, "ricActionID");
      stat = asn1PD_e2ap_RICactionID (pctxt, &pvalue->ricActionID);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RICaction_ConfirmedForRemoval_Item (e2ap_RICaction_ConfirmedForRemoval_Item* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RICactionID (&pvalue->ricActionID);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RICaction_ConfirmedForRemoval_Item (OSCTXT* pctxt, e2ap_RICaction_ConfirmedForRemoval_Item* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_RICactionID (pctxt, &pvalue->ricActionID);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RICaction_ConfirmedForRemoval_Item (const char* name, e2ap_RICaction_ConfirmedForRemoval_Item* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }
   if(asn1PrtToStr_e2ap_RICactionID ("ricActionID", &pvalue->ricActionID, buffer, bufSize) < 0)
   {
      return -1;
   }



   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           RICaction_ConfirmedForRemoval_ItemIEs                */
/*****************************************/
/* ie.c.j2 */
/*ie thường*/
int asn1PE_e2ap_RICaction_ConfirmedForRemoval_ItemIEs (OSCTXT* pctxt, e2ap_RICaction_ConfirmedForRemoval_ItemIEs* pvalue)
{
   int stat = 0;
   //RTXCTXTPUSHTYPENAME (pctxt, "RICaction-ConfirmedForRemoval-ItemIEs");

   /* encode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");
   stat = asn1PE_e2ap_ProtocolIE_ID (pctxt, pvalue->id);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");
   stat = asn1PE_e2ap_Criticality (pctxt, pvalue->criticality);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   {
      OSCTXT ictxt;
      OSOCTET* pDynamicEncodeBuffer;
      ASN1OpenType openType;
      OSBOOL  encoded = TRUE;

      openType.numocts = 0;
      openType.data = 0;

      rtxCopyContext (&ictxt, pctxt);
      pctxt->pStream = 0;

      stat = rtxInitContextBuffer (pctxt, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_RICaction_ConfirmedForRemoval_ItemIEs_id_RICaction_ConfirmedForRemoval_Item:
         
        // RTXCTXTPUSHELEMNAME (pctxt, "RICaction_ConfirmedForRemoval_ItemIEs_id_RICaction_ConfirmedForRemoval_Item");
         RTXCTXTPUSHELEMNAME (pctxt, "RICaction-ConfirmedForRemoval-Item");
         stat = asn1PE_e2ap_RICaction_ConfirmedForRemoval_Item (pctxt, pvalue->value.u._e2apRICaction_ConfirmedForRemoval_ItemIEs_id_RICaction_ConfirmedForRemoval_Item);
         RTXCTXTPOPELEMNAME (pctxt);
      
         break;

      case T_E2AP_PDU_Contents_e2ap_RICaction_ConfirmedForRemoval_ItemIEs_UNDEF_:
      {
          if(0!=pvalue->value.u.extElem1){
              openType.numocts = pvalue->value.u.extElem1->numocts;
              openType.data = pvalue->value.u.extElem1->data;
          } else {
              /* No extension element to encode */
          }
          encoded = FALSE;
          break;
      }
      default:
         encoded = FALSE;
         stat = RTERR_INVOPT;
      }

      if (encoded) {
         openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
         openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
      }
      rtxCopyContext (pctxt, &ictxt);
      if(stat ==0) stat = pe_OpenType(pctxt, openType.numocts, openType.data);
      /*free dynamic encode buffer*/
      if(encoded){
          rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
      }
   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);
   //RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

int asn1PD_e2ap_RICaction_ConfirmedForRemoval_ItemIEs (OSCTXT* pctxt, e2ap_RICaction_ConfirmedForRemoval_ItemIEs* pvalue)
{
   int stat =0;
   /*deode root element id*/
   RTXCTXTPUSHELEMNAME(pctxt, "id");
   stat = asn1PD_e2ap_ProtocolIE_ID (pctxt, &pvalue->id);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*decode root element criticality*/
   RTXCTXTPUSHELEMNAME(pctxt, "criticality");
   stat = asn1PD_e2ap_Criticality (pctxt, &pvalue->criticality);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   /*decode root element value*/
   RTXCTXTPUSHELEMNAME(pctxt, "value");
   {
      OSUINT32 openTypeLen;
      size_t bitStartOffset, bitLength;
      stat = pd_UnconsLength(pctxt, &openTypeLen);
      if(stat <0) return LOG_RTERR(pctxt, stat);
      else if(stat == RT_OK_FRAG){
         rtxErrAddStrParm(pctxt, "open type with fragmented length use - perindef");
         return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
      }
      bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
      bitLength = openTypeLen * 8;
      switch (pvalue->id){
         case T_E2AP_PDU_Contents_e2ap_RICaction_ConfirmedForRemoval_ItemIEs_id_RICaction_ConfirmedForRemoval_Item:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICaction_ConfirmedForRemoval_ItemIEs_id_RICaction_ConfirmedForRemoval_Item;
            RTXCTXTPUSHELEMNAME(pctxt, "RICaction-ConfirmedForRemoval-Item");
            //pvalue->value.u._e2ap_RICaction_ConfirmedForRemoval_ItemIEs_id_id_RICaction_ConfirmedForRemoval_Item 
             pvalue->value.u._e2apRICaction_ConfirmedForRemoval_ItemIEs_id_RICaction_ConfirmedForRemoval_Item 
                    = rtxMemAllocType(pctxt, e2ap_RICaction_ConfirmedForRemoval_Item);
            //asn1Init_e2ap_RICaction_ConfirmedForRemoval_Item(pvalue->value.u._e2ap_RICaction_ConfirmedForRemoval_ItemIEs_id_id_RICaction_ConfirmedForRemoval_Item);
            asn1Init_e2ap_RICaction_ConfirmedForRemoval_Item(pvalue->value.u._e2apRICaction_ConfirmedForRemoval_ItemIEs_id_RICaction_ConfirmedForRemoval_Item);
            stat = asn1PD_e2ap_RICaction_ConfirmedForRemoval_Item (pctxt,
                    (e2ap_RICaction_ConfirmedForRemoval_Item*)pvalue->value.
                    u._e2apRICaction_ConfirmedForRemoval_ItemIEs_id_RICaction_ConfirmedForRemoval_Item);
            if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICaction_ConfirmedForRemoval_ItemIEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*)rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
      }
      {
      size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
      size_t bitsConsumed = bitEndOffset - bitStartOffset;
      if(bitsConsumed < bitLength){
         stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
      } else {
         stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
      }
      }
   }
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   return stat;
}

void asn1Init_e2ap_RICaction_ConfirmedForRemoval_ItemIEs (e2ap_RICaction_ConfirmedForRemoval_ItemIEs* pvalue)
{
   if (!pvalue) return;
   OSCRTLMEMSET (pvalue, 0, sizeof(e2ap_RICaction_ConfirmedForRemoval_ItemIEs));
}

#if 0
void asn1Free_e2ap_RICaction_ConfirmedForRemoval_ItemIEs (OSCTXT* pctxt, e2ap_RICaction_ConfirmedForRemoval_ItemIEs* pvalue)
{
   if (!pvalue) return;
   if (pvalue->extElem1) {
      rtxMemFreeArray (pctxt, pvalue->extElem1);
      pvalue->extElem1 = 0;
      pvalue->extElem1_n = 0;
   }
}
#endif
void asn1Free_e2ap_RICaction_ConfirmedForRemoval_ItemIEs (OSCTXT* pctxt, e2ap_RICaction_ConfirmedForRemoval_ItemIEs* pvalue)
{
   if(0==pvalue) return;
   switch(pvalue->value.t){
      case T_E2AP_PDU_Contents_e2ap_RICaction_ConfirmedForRemoval_ItemIEs_id_RICaction_ConfirmedForRemoval_Item:
         asn1Free_e2ap_RICaction_ConfirmedForRemoval_Item (pctxt, pvalue->value.u._e2apRICaction_ConfirmedForRemoval_ItemIEs_id_RICaction_ConfirmedForRemoval_Item);
         rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2apRICaction_ConfirmedForRemoval_ItemIEs_id_RICaction_ConfirmedForRemoval_Item);
         pvalue->value.u._e2apRICaction_ConfirmedForRemoval_ItemIEs_id_RICaction_ConfirmedForRemoval_Item = 0;
         break;
      case T_E2AP_PDU_Contents_e2ap_RICaction_ConfirmedForRemoval_ItemIEs_UNDEF_:
         if(0!=pvalue->value.u.extElem1){
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1->data);
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
             pvalue->value.u.extElem1 =0;
         }
         break;
         default:;
   }
}

int  asn1PrtToStr_e2ap_RICaction_ConfirmedForRemoval_ItemIEs (const char * name, e2ap_RICaction_ConfirmedForRemoval_ItemIEs* pvalue, char * buffer, OSSIZE bufSize){
   if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
       return -1;

      if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
         return -1;

      if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
         return -1;
      if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
         return -1;
      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_RICaction_ConfirmedForRemoval_ItemIEs_id_RICaction_ConfirmedForRemoval_Item:
         if(asn1PrtToStr_e2ap_RICaction_ConfirmedForRemoval_Item("RICaction-ConfirmedForRemoval-Item",
                pvalue->value.u._e2apRICaction_ConfirmedForRemoval_ItemIEs_id_RICaction_ConfirmedForRemoval_Item, buffer, bufSize)<0)// dungnm23 check lai nhe xem la
            return -1;
         break;
      default:
         if(0!=pvalue -> value.u.extElem1){
             rtPrintToStringIndent(buffer, bufSize);
             rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

         }
      }
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

      return 0;

}
 

/*****************************************/
/*           RICactions_ConfirmedForRemoval_List                */
/*****************************************/
//seq_of_single_container


int asn1PE_e2ap_RICactions_ConfirmedForRemoval_List (OSCTXT* pctxt, e2ap_RICactions_ConfirmedForRemoval_List* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_RICaction_ConfirmedForRemoval_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "RICactions-ConfirmedForRemoval-List");

   /* encode length determinant */
   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(16), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;
   for (xx1 = 0; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next, xx1++) {
      pdata = (e2ap_RICaction_ConfirmedForRemoval_ItemIEs*) pnode->data;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_e2ap_RICaction_ConfirmedForRemoval_ItemIEs (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      //xx1++;
      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}

int asn1PD_e2ap_RICactions_ConfirmedForRemoval_List (OSCTXT* pctxt, e2ap_RICactions_ConfirmedForRemoval_List* ppvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_RICaction_ConfirmedForRemoval_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "RICactions-ConfirmedForRemoval-List");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(16), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (ppvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      pdata = rtxMemAllocType (pctxt, e2ap_RICaction_ConfirmedForRemoval_ItemIEs);
      if (!pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);
      asn1Init_e2ap_RICaction_ConfirmedForRemoval_ItemIEs (pdata);
      stat = asn1PD_e2ap_RICaction_ConfirmedForRemoval_ItemIEs (pctxt, pdata);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         return LOG_RTERR (pctxt, stat);
      }

      rtxDListAppendNode (ppvalue, pdata);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

void asn1Init_e2ap_RICactions_ConfirmedForRemoval_List (e2ap_RICactions_ConfirmedForRemoval_List* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
}

void asn1Free_e2ap_RICactions_ConfirmedForRemoval_List (OSCTXT* pctxt, e2ap_RICactions_ConfirmedForRemoval_List* pvalue)
{
   if(pvalue==0) return;
   OSRTDListNode* pnode = pvalue->head;
   while (pnode) {
      e2ap_RICaction_ConfirmedForRemoval_ItemIEs* pdata = (e2ap_RICaction_ConfirmedForRemoval_ItemIEs*) pnode->data;
      if (pdata) {
         asn1Free_e2ap_RICaction_ConfirmedForRemoval_ItemIEs (pctxt, pdata);
         rtxMemFreePtr (pctxt, pdata);
      }
      pnode = pnode->next;
   }
      rtxDListFreeAll(pctxt, pvalue);
}

#if 0
void asn1Free_e2ap_RICactions_ConfirmedForRemoval_List (OSCTXT* pctxt, e2ap_RICactions_ConfirmedForRemoval_List* pvalue){
   if(0==pvalue ) return;
   {
      e2ap_RICaction_ConfirmedForRemoval_ItemIEs * pdata;
      OSRTDListNode *pnode = pvalue->head;
      while(0!=pnode){
         pdata = (e2ap_RICaction_ConfirmedForRemoval_ItemIEs*)pnode->data;
         asn1Free_e2ap_RICaction_ConfirmedForRemoval_ItemIEs(pctxt, pdata);
         pnode = pnode->next;
      }
      rtxDListFreeAll(pctxt, pvalue);
   }
}
#endif


int asn1PrtToStr_e2ap_RICactions_ConfirmedForRemoval_List(const char* name, e2ap_RICactions_ConfirmedForRemoval_List* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_RICaction_ConfirmedForRemoval_ItemIEs* pdata;
    OSRTDListNode* pnode;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode = pvalue->head;  xx1 < pvalue->count && pnode != 0; pnode = pnode->next, xx1++){
        pdata = (e2ap_RICaction_ConfirmedForRemoval_ItemIEs*)pnode->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 1
        if(asn1PrtToStr_e2ap_RICaction_ConfirmedForRemoval_ItemIEs(nameBuf, pdata, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}
/*****************************************/
/*           RICaction-RefusedToBeRemoved-Item                */
/*****************************************/
//sequence normal
// Các nội dung cần thiết cho template seq_normal.c.j2

// Các phần còn lại của template seq_normal.c.j2
//contain extensition bit -> theo mau cua GlobalgNB-ID
int asn1PE_e2ap_RICaction_RefusedToBeRemoved_Item (OSCTXT* pctxt, e2ap_RICaction_RefusedToBeRemoved_Item* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RICaction-RefusedToBeRemoved-Item");

   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field ricActionID - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "ricActionID");
   stat = asn1PE_e2ap_RICactionID (pctxt, pvalue->ricActionID);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /* encode field cause - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "cause");
   stat = asn1PE_e2ap_Cause (pctxt, pvalue->cause);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);



   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RICaction_RefusedToBeRemoved_Item (OSCTXT* pctxt, e2ap_RICaction_RefusedToBeRemoved_Item* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME(pctxt, "RICaction-RefusedToBeRemoved-Item");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field ricActionID */
   RTXCTXTPUSHELEMNAME(pctxt, "ricActionID");
      stat = asn1PD_e2ap_RICactionID (pctxt, &pvalue->ricActionID);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field cause */
   RTXCTXTPUSHELEMNAME(pctxt, "cause");
      stat = asn1PD_e2ap_Cause (pctxt, &pvalue->cause);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RICaction_RefusedToBeRemoved_Item (e2ap_RICaction_RefusedToBeRemoved_Item* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RICactionID (&pvalue->ricActionID);
   asn1Init_e2ap_Cause (&pvalue->cause);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RICaction_RefusedToBeRemoved_Item (OSCTXT* pctxt, e2ap_RICaction_RefusedToBeRemoved_Item* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_RICactionID (pctxt, &pvalue->ricActionID);
   asn1Free_e2ap_Cause (pctxt, &pvalue->cause);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RICaction_RefusedToBeRemoved_Item (const char* name, e2ap_RICaction_RefusedToBeRemoved_Item* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }
   if(asn1PrtToStr_e2ap_RICactionID ("ricActionID", &pvalue->ricActionID, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_Cause ("cause", &pvalue->cause, buffer, bufSize) < 0)
   {
      return -1;
   }



   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           RICaction_RefusedToBeRemoved_ItemIEs                */
/*****************************************/
/* ie.c.j2 */
/*ie thường*/
int asn1PE_e2ap_RICaction_RefusedToBeRemoved_ItemIEs (OSCTXT* pctxt, e2ap_RICaction_RefusedToBeRemoved_ItemIEs* pvalue)
{
   int stat = 0;
   //RTXCTXTPUSHTYPENAME (pctxt, "RICaction-RefusedToBeRemoved-ItemIEs");

   /* encode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");
   stat = asn1PE_e2ap_ProtocolIE_ID (pctxt, pvalue->id);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");
   stat = asn1PE_e2ap_Criticality (pctxt, pvalue->criticality);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   {
      OSCTXT ictxt;
      OSOCTET* pDynamicEncodeBuffer;
      ASN1OpenType openType;
      OSBOOL  encoded = TRUE;

      openType.numocts = 0;
      openType.data = 0;

      rtxCopyContext (&ictxt, pctxt);
      pctxt->pStream = 0;

      stat = rtxInitContextBuffer (pctxt, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_RICaction_RefusedToBeRemoved_ItemIEs_id_RICaction_RefusedToBeRemoved_Item:
         
        // RTXCTXTPUSHELEMNAME (pctxt, "RICaction_RefusedToBeRemoved_ItemIEs_id_RICaction_RefusedToBeRemoved_Item");
         RTXCTXTPUSHELEMNAME (pctxt, "RICaction-RefusedToBeRemoved-Item");
         stat = asn1PE_e2ap_RICaction_RefusedToBeRemoved_Item (pctxt, pvalue->value.u._e2apRICaction_RefusedToBeRemoved_ItemIEs_id_RICaction_RefusedToBeRemoved_Item);
         RTXCTXTPOPELEMNAME (pctxt);
      
         break;

      case T_E2AP_PDU_Contents_e2ap_RICaction_RefusedToBeRemoved_ItemIEs_UNDEF_:
      {
          if(0!=pvalue->value.u.extElem1){
              openType.numocts = pvalue->value.u.extElem1->numocts;
              openType.data = pvalue->value.u.extElem1->data;
          } else {
              /* No extension element to encode */
          }
          encoded = FALSE;
          break;
      }
      default:
         encoded = FALSE;
         stat = RTERR_INVOPT;
      }

      if (encoded) {
         openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
         openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
      }
      rtxCopyContext (pctxt, &ictxt);
      if(stat ==0) stat = pe_OpenType(pctxt, openType.numocts, openType.data);
      /*free dynamic encode buffer*/
      if(encoded){
          rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
      }
   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);
   //RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

int asn1PD_e2ap_RICaction_RefusedToBeRemoved_ItemIEs (OSCTXT* pctxt, e2ap_RICaction_RefusedToBeRemoved_ItemIEs* pvalue)
{
   int stat =0;
   /*deode root element id*/
   RTXCTXTPUSHELEMNAME(pctxt, "id");
   stat = asn1PD_e2ap_ProtocolIE_ID (pctxt, &pvalue->id);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*decode root element criticality*/
   RTXCTXTPUSHELEMNAME(pctxt, "criticality");
   stat = asn1PD_e2ap_Criticality (pctxt, &pvalue->criticality);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   /*decode root element value*/
   RTXCTXTPUSHELEMNAME(pctxt, "value");
   {
      OSUINT32 openTypeLen;
      size_t bitStartOffset, bitLength;
      stat = pd_UnconsLength(pctxt, &openTypeLen);
      if(stat <0) return LOG_RTERR(pctxt, stat);
      else if(stat == RT_OK_FRAG){
         rtxErrAddStrParm(pctxt, "open type with fragmented length use - perindef");
         return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
      }
      bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
      bitLength = openTypeLen * 8;
      switch (pvalue->id){
         case T_E2AP_PDU_Contents_e2ap_RICaction_RefusedToBeRemoved_ItemIEs_id_RICaction_RefusedToBeRemoved_Item:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICaction_RefusedToBeRemoved_ItemIEs_id_RICaction_RefusedToBeRemoved_Item;
            RTXCTXTPUSHELEMNAME(pctxt, "RICaction-RefusedToBeRemoved-Item");
            //pvalue->value.u._e2ap_RICaction_RefusedToBeRemoved_ItemIEs_id_id_RICaction_RefusedToBeRemoved_Item 
             pvalue->value.u._e2apRICaction_RefusedToBeRemoved_ItemIEs_id_RICaction_RefusedToBeRemoved_Item 
                    = rtxMemAllocType(pctxt, e2ap_RICaction_RefusedToBeRemoved_Item);
            //asn1Init_e2ap_RICaction_RefusedToBeRemoved_Item(pvalue->value.u._e2ap_RICaction_RefusedToBeRemoved_ItemIEs_id_id_RICaction_RefusedToBeRemoved_Item);
            asn1Init_e2ap_RICaction_RefusedToBeRemoved_Item(pvalue->value.u._e2apRICaction_RefusedToBeRemoved_ItemIEs_id_RICaction_RefusedToBeRemoved_Item);
            stat = asn1PD_e2ap_RICaction_RefusedToBeRemoved_Item (pctxt,
                    (e2ap_RICaction_RefusedToBeRemoved_Item*)pvalue->value.
                    u._e2apRICaction_RefusedToBeRemoved_ItemIEs_id_RICaction_RefusedToBeRemoved_Item);
            if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICaction_RefusedToBeRemoved_ItemIEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*)rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
      }
      {
      size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
      size_t bitsConsumed = bitEndOffset - bitStartOffset;
      if(bitsConsumed < bitLength){
         stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
      } else {
         stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
      }
      }
   }
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   return stat;
}

void asn1Init_e2ap_RICaction_RefusedToBeRemoved_ItemIEs (e2ap_RICaction_RefusedToBeRemoved_ItemIEs* pvalue)
{
   if (!pvalue) return;
   OSCRTLMEMSET (pvalue, 0, sizeof(e2ap_RICaction_RefusedToBeRemoved_ItemIEs));
}

#if 0
void asn1Free_e2ap_RICaction_RefusedToBeRemoved_ItemIEs (OSCTXT* pctxt, e2ap_RICaction_RefusedToBeRemoved_ItemIEs* pvalue)
{
   if (!pvalue) return;
   if (pvalue->extElem1) {
      rtxMemFreeArray (pctxt, pvalue->extElem1);
      pvalue->extElem1 = 0;
      pvalue->extElem1_n = 0;
   }
}
#endif
void asn1Free_e2ap_RICaction_RefusedToBeRemoved_ItemIEs (OSCTXT* pctxt, e2ap_RICaction_RefusedToBeRemoved_ItemIEs* pvalue)
{
   if(0==pvalue) return;
   switch(pvalue->value.t){
      case T_E2AP_PDU_Contents_e2ap_RICaction_RefusedToBeRemoved_ItemIEs_id_RICaction_RefusedToBeRemoved_Item:
         asn1Free_e2ap_RICaction_RefusedToBeRemoved_Item (pctxt, pvalue->value.u._e2apRICaction_RefusedToBeRemoved_ItemIEs_id_RICaction_RefusedToBeRemoved_Item);
         rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2apRICaction_RefusedToBeRemoved_ItemIEs_id_RICaction_RefusedToBeRemoved_Item);
         pvalue->value.u._e2apRICaction_RefusedToBeRemoved_ItemIEs_id_RICaction_RefusedToBeRemoved_Item = 0;
         break;
      case T_E2AP_PDU_Contents_e2ap_RICaction_RefusedToBeRemoved_ItemIEs_UNDEF_:
         if(0!=pvalue->value.u.extElem1){
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1->data);
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
             pvalue->value.u.extElem1 =0;
         }
         break;
         default:;
   }
}

int  asn1PrtToStr_e2ap_RICaction_RefusedToBeRemoved_ItemIEs (const char * name, e2ap_RICaction_RefusedToBeRemoved_ItemIEs* pvalue, char * buffer, OSSIZE bufSize){
   if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
       return -1;

      if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
         return -1;

      if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
         return -1;
      if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
         return -1;
      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_RICaction_RefusedToBeRemoved_ItemIEs_id_RICaction_RefusedToBeRemoved_Item:
         if(asn1PrtToStr_e2ap_RICaction_RefusedToBeRemoved_Item("RICaction-RefusedToBeRemoved-Item",
                pvalue->value.u._e2apRICaction_RefusedToBeRemoved_ItemIEs_id_RICaction_RefusedToBeRemoved_Item, buffer, bufSize)<0)// dungnm23 check lai nhe xem la
            return -1;
         break;
      default:
         if(0!=pvalue -> value.u.extElem1){
             rtPrintToStringIndent(buffer, bufSize);
             rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

         }
      }
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

      return 0;

}
 

/*****************************************/
/*           RICactions_RefusedToBeRemoved_List                */
/*****************************************/
//seq_of_single_container


int asn1PE_e2ap_RICactions_RefusedToBeRemoved_List (OSCTXT* pctxt, e2ap_RICactions_RefusedToBeRemoved_List* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_RICaction_RefusedToBeRemoved_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "RICactions-RefusedToBeRemoved-List");

   /* encode length determinant */
   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(16), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;
   for (xx1 = 0; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next, xx1++) {
      pdata = (e2ap_RICaction_RefusedToBeRemoved_ItemIEs*) pnode->data;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_e2ap_RICaction_RefusedToBeRemoved_ItemIEs (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      //xx1++;
      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}

int asn1PD_e2ap_RICactions_RefusedToBeRemoved_List (OSCTXT* pctxt, e2ap_RICactions_RefusedToBeRemoved_List* ppvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_RICaction_RefusedToBeRemoved_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "RICactions-RefusedToBeRemoved-List");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(16), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (ppvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      pdata = rtxMemAllocType (pctxt, e2ap_RICaction_RefusedToBeRemoved_ItemIEs);
      if (!pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);
      asn1Init_e2ap_RICaction_RefusedToBeRemoved_ItemIEs (pdata);
      stat = asn1PD_e2ap_RICaction_RefusedToBeRemoved_ItemIEs (pctxt, pdata);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         return LOG_RTERR (pctxt, stat);
      }

      rtxDListAppendNode (ppvalue, pdata);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

void asn1Init_e2ap_RICactions_RefusedToBeRemoved_List (e2ap_RICactions_RefusedToBeRemoved_List* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
}

void asn1Free_e2ap_RICactions_RefusedToBeRemoved_List (OSCTXT* pctxt, e2ap_RICactions_RefusedToBeRemoved_List* pvalue)
{
   if(pvalue==0) return;
   OSRTDListNode* pnode = pvalue->head;
   while (pnode) {
      e2ap_RICaction_RefusedToBeRemoved_ItemIEs* pdata = (e2ap_RICaction_RefusedToBeRemoved_ItemIEs*) pnode->data;
      if (pdata) {
         asn1Free_e2ap_RICaction_RefusedToBeRemoved_ItemIEs (pctxt, pdata);
         rtxMemFreePtr (pctxt, pdata);
      }
      pnode = pnode->next;
   }
      rtxDListFreeAll(pctxt, pvalue);
}

#if 0
void asn1Free_e2ap_RICactions_RefusedToBeRemoved_List (OSCTXT* pctxt, e2ap_RICactions_RefusedToBeRemoved_List* pvalue){
   if(0==pvalue ) return;
   {
      e2ap_RICaction_RefusedToBeRemoved_ItemIEs * pdata;
      OSRTDListNode *pnode = pvalue->head;
      while(0!=pnode){
         pdata = (e2ap_RICaction_RefusedToBeRemoved_ItemIEs*)pnode->data;
         asn1Free_e2ap_RICaction_RefusedToBeRemoved_ItemIEs(pctxt, pdata);
         pnode = pnode->next;
      }
      rtxDListFreeAll(pctxt, pvalue);
   }
}
#endif


int asn1PrtToStr_e2ap_RICactions_RefusedToBeRemoved_List(const char* name, e2ap_RICactions_RefusedToBeRemoved_List* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_RICaction_RefusedToBeRemoved_ItemIEs* pdata;
    OSRTDListNode* pnode;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode = pvalue->head;  xx1 < pvalue->count && pnode != 0; pnode = pnode->next, xx1++){
        pdata = (e2ap_RICaction_RefusedToBeRemoved_ItemIEs*)pnode->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 1
        if(asn1PrtToStr_e2ap_RICaction_RefusedToBeRemoved_ItemIEs(nameBuf, pdata, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}/*****************************************/
/*           RICsubscriptionModificationConfirm_IEs                */
/*****************************************/
/* ie.c.j2 */
 /* d là con của msg */
EXTERN int asn1PE_e2ap_RICsubscriptionModificationConfirm_protocolIEs_element (OSCTXT* pctxt, e2ap_RICsubscriptionModificationConfirm_protocolIEs_element* pvalue)
{
    int stat =0;

    /*encode id*/

    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PE_e2ap_ProtocolIE_ID(pctxt, pvalue->id);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PE_e2ap_Criticality(pctxt, pvalue->criticality);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
    {
        OSCTXT lctxt;
        OSOCTET *pDynamicEncodeBuffer;
        ASN1OpenType openType;
        OSBOOL encoded = TRUE;

        openType.numocts = 0;
        openType.data =0;

        rtxCopyContext(&lctxt, pctxt);
        pctxt->pStream =0;

        stat = rtxInitContextBuffer(pctxt, 0, 0);
        if(stat!=0) return LOG_RTERR(pctxt, stat);

        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationConfirm_IEs_id_RICrequestID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICrequestID");
                    stat = asn1PE_e2ap_RICrequestID (pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_RICrequestID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationConfirm_IEs_id_RANfunctionID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RANfunctionID");
                    stat = asn1PE_e2ap_RANfunctionID (pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_RANfunctionID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationConfirm_IEs_id_RICactionsConfirmedForModification_List:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICactionsConfirmedForModification-List");
                    stat = asn1PE_e2ap_RICactions_ConfirmedForModification_List (pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_RICactionsConfirmedForModification_List);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationConfirm_IEs_id_RICactionsRefusedToBeModified_List:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICactionsRefusedToBeModified-List");
                    stat = asn1PE_e2ap_RICactions_RefusedToBeModified_List (pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_RICactionsRefusedToBeModified_List);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationConfirm_IEs_id_RICactionsConfirmedForRemoval_List:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICactionsConfirmedForRemoval-List");
                    stat = asn1PE_e2ap_RICactions_ConfirmedForRemoval_List (pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_RICactionsConfirmedForRemoval_List);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationConfirm_IEs_id_RICactionsRefusedToBeRemoved_List:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICactionsRefusedToBeRemoved-List");
                    stat = asn1PE_e2ap_RICactions_RefusedToBeRemoved_List (pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_RICactionsRefusedToBeRemoved_List);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationConfirm_IEs_UNDEF_:
            {
                if(0!=pvalue->value.u.extElem1){
                    openType.numocts = pvalue->value.u.extElem1->numocts;
                    openType.data = pvalue->value.u.extElem1->data;
                } else {
                    /* No extension element to encode */
                }
                encoded = FALSE;
                break;
            }

            default:
                encoded = FALSE;
                stat = RTERR_INVOPT;
                break;
        } 

        if(encoded){
            openType.numocts = (OSUINT32)pe_GetMsgLen(pctxt);
            openType.data = pDynamicEncodeBuffer = pctxt -> buffer.data;
        }
        rtxCopyContext(pctxt, &lctxt);

        if(stat == 0) {
            stat = pe_OpenType (pctxt, openType.numocts, openType.data);
        }
    #if 1
        if(encoded){//dungnm23 check lai nhe
            rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
        }
    #endif

    }

    if(stat!=0) return LOG_RTERR(pctxt, stat);  
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}

EXTERN int  asn1PD_e2ap_RICsubscriptionModificationConfirm_protocolIEs_element (OSCTXT* pctxt, e2ap_RICsubscriptionModificationConfirm_protocolIEs_element* pvalue){
    int stat =0;

    /*decode id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PD_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PD_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");

    {
        OSUINT32 openTypeLen;
        size_t bitStartOffset, bitLength;

        stat = pd_UnconsLength(pctxt, &openTypeLen);
        if(stat<0) return LOG_RTERR(pctxt, stat);
        else if(stat == RT_OK_FRAG){
            rtxErrAddStrParm(pctxt, "open type with fragment length");
            return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
        }
        bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
        bitLength = openTypeLen * 8;

        switch(pvalue->id){//dungnm23 check case lai nhe
        
            case ASN1V_e2ap_id_RICrequestID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationConfirm_IEs_id_RICrequestID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICrequestID");
                pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_RICrequestID 
                    = rtxMemAllocType(pctxt, e2ap_RICrequestID);

                asn1Init_e2ap_RICrequestID(pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_RICrequestID);

                stat = asn1PD_e2ap_RICrequestID (pctxt,
                        (e2ap_RICrequestID*)pvalue->value.
                        u._e2ap_RICsubscriptionModificationConfirm_IEs_id_RICrequestID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RANfunctionID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationConfirm_IEs_id_RANfunctionID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RANfunctionID");
                pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_RANfunctionID 
                    = rtxMemAllocType(pctxt, e2ap_RANfunctionID);

                asn1Init_e2ap_RANfunctionID(pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_RANfunctionID);

                stat = asn1PD_e2ap_RANfunctionID (pctxt,
                        (e2ap_RANfunctionID*)pvalue->value.
                        u._e2ap_RICsubscriptionModificationConfirm_IEs_id_RANfunctionID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RICactionsConfirmedForModification_List:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationConfirm_IEs_id_RICactionsConfirmedForModification_List;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICactionsConfirmedForModification-List");
                pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_RICactionsConfirmedForModification_List 
                    = rtxMemAllocType(pctxt, e2ap_RICactions_ConfirmedForModification_List);

                asn1Init_e2ap_RICactions_ConfirmedForModification_List(pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_RICactionsConfirmedForModification_List);

                stat = asn1PD_e2ap_RICactions_ConfirmedForModification_List (pctxt,
                        (e2ap_RICactions_ConfirmedForModification_List*)pvalue->value.
                        u._e2ap_RICsubscriptionModificationConfirm_IEs_id_RICactionsConfirmedForModification_List);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RICactionsRefusedToBeModified_List:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationConfirm_IEs_id_RICactionsRefusedToBeModified_List;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICactionsRefusedToBeModified-List");
                pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_RICactionsRefusedToBeModified_List 
                    = rtxMemAllocType(pctxt, e2ap_RICactions_RefusedToBeModified_List);

                asn1Init_e2ap_RICactions_RefusedToBeModified_List(pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_RICactionsRefusedToBeModified_List);

                stat = asn1PD_e2ap_RICactions_RefusedToBeModified_List (pctxt,
                        (e2ap_RICactions_RefusedToBeModified_List*)pvalue->value.
                        u._e2ap_RICsubscriptionModificationConfirm_IEs_id_RICactionsRefusedToBeModified_List);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RICactionsConfirmedForRemoval_List:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationConfirm_IEs_id_RICactionsConfirmedForRemoval_List;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICactionsConfirmedForRemoval-List");
                pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_RICactionsConfirmedForRemoval_List 
                    = rtxMemAllocType(pctxt, e2ap_RICactions_ConfirmedForRemoval_List);

                asn1Init_e2ap_RICactions_ConfirmedForRemoval_List(pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_RICactionsConfirmedForRemoval_List);

                stat = asn1PD_e2ap_RICactions_ConfirmedForRemoval_List (pctxt,
                        (e2ap_RICactions_ConfirmedForRemoval_List*)pvalue->value.
                        u._e2ap_RICsubscriptionModificationConfirm_IEs_id_RICactionsConfirmedForRemoval_List);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RICactionsRefusedToBeRemoved_List:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationConfirm_IEs_id_RICactionsRefusedToBeRemoved_List;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICactionsRefusedToBeRemoved-List");
                pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_RICactionsRefusedToBeRemoved_List 
                    = rtxMemAllocType(pctxt, e2ap_RICactions_RefusedToBeRemoved_List);

                asn1Init_e2ap_RICactions_RefusedToBeRemoved_List(pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_RICactionsRefusedToBeRemoved_List);

                stat = asn1PD_e2ap_RICactions_RefusedToBeRemoved_List (pctxt,
                        (e2ap_RICactions_RefusedToBeRemoved_List*)pvalue->value.
                        u._e2ap_RICsubscriptionModificationConfirm_IEs_id_RICactionsRefusedToBeRemoved_List);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationConfirm_IEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*) rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
    }
    {
    size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
    size_t bitsConsumed = bitEndOffset-bitStartOffset;
    if(bitsConsumed<bitLength){
        stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
    }
    else stat =(bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
    }}
    if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}


int asn1Init_e2ap_RICsubscriptionModificationConfirm_protocolIEs_element(e2ap_RICsubscriptionModificationConfirm_protocolIEs_element* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    OSCRTLMEMSET (&pvalue->value, 0, sizeof(pvalue->value));
    return 0;
}


//-----> chuaw có template rtxFreeASN1OpenType

#if 0
void asn1Free_e2ap_RICsubscriptionModificationConfirm_protocolIEs_element(OSCTXT* pctxt, e2ap_RICsubscriptionModificationConfirm_protocolIEs_element* pvalue)
{
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationConfirm_IEs_id_id_RICrequestID:
            // rtxFreeE2ap_RICrequestID(pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_id_RICrequestID);

            if(pvalue->value.i._e2ap_RICsubscriptionModificationConfirm_id_RICrequestID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICrequestID(pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_id_RICrequestID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_id_RICrequestID);
           // pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_id_RICrequestID = NULL;
           pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_RICrequestID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationConfirm_IEs_id_id_RANfunctionID:
            // rtxFreeE2ap_RANfunctionID(pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_id_RANfunctionID);

            if(pvalue->value.i._e2ap_RICsubscriptionModificationConfirm_id_RANfunctionID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RANfunctionID(pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_id_RANfunctionID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_id_RANfunctionID);
           // pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_id_RANfunctionID = NULL;
           pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_RANfunctionID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationConfirm_IEs_id_id_RICactionsConfirmedForModification_List:
            // rtxFreeE2ap_RICactions_ConfirmedForModification_List(pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_id_RICactionsConfirmedForModification_List);

            if(pvalue->value.i._e2ap_RICsubscriptionModificationConfirm_id_RICactions_ConfirmedForModification_List!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICactions_ConfirmedForModification_List(pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_id_RICactionsConfirmedForModification_List);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_id_RICactionsConfirmedForModification_List);
           // pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_id_RICactionsConfirmedForModification_List = NULL;
           pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_RICactionsConfirmedForModification_List = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationConfirm_IEs_id_id_RICactionsRefusedToBeModified_List:
            // rtxFreeE2ap_RICactions_RefusedToBeModified_List(pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_id_RICactionsRefusedToBeModified_List);

            if(pvalue->value.i._e2ap_RICsubscriptionModificationConfirm_id_RICactions_RefusedToBeModified_List!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICactions_RefusedToBeModified_List(pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_id_RICactionsRefusedToBeModified_List);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_id_RICactionsRefusedToBeModified_List);
           // pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_id_RICactionsRefusedToBeModified_List = NULL;
           pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_RICactionsRefusedToBeModified_List = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationConfirm_IEs_id_id_RICactionsConfirmedForRemoval_List:
            // rtxFreeE2ap_RICactions_ConfirmedForRemoval_List(pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_id_RICactionsConfirmedForRemoval_List);

            if(pvalue->value.i._e2ap_RICsubscriptionModificationConfirm_id_RICactions_ConfirmedForRemoval_List!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICactions_ConfirmedForRemoval_List(pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_id_RICactionsConfirmedForRemoval_List);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_id_RICactionsConfirmedForRemoval_List);
           // pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_id_RICactionsConfirmedForRemoval_List = NULL;
           pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_RICactionsConfirmedForRemoval_List = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationConfirm_IEs_id_id_RICactionsRefusedToBeRemoved_List:
            // rtxFreeE2ap_RICactions_RefusedToBeRemoved_List(pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_id_RICactionsRefusedToBeRemoved_List);

            if(pvalue->value.i._e2ap_RICsubscriptionModificationConfirm_id_RICactions_RefusedToBeRemoved_List!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICactions_RefusedToBeRemoved_List(pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_id_RICactionsRefusedToBeRemoved_List);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_id_RICactionsRefusedToBeRemoved_List);
           // pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_id_RICactionsRefusedToBeRemoved_List = NULL;
           pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_RICactionsRefusedToBeRemoved_List = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationConfirm_IEs_UNDEF_:
            rtxFreeASN1OpenType(pvalue->value.u.extElem1);
            break;
        default:
            break;
    }
}

int asn1PrtToStr_e2ap_RICsubscriptionModificationConfirm_protocolIEs_element(OSCTXT* pctxt, e2ap_RICsubscriptionModificationConfirm_protocolIEs_element* pvalue)
{
    int stat =0;
    RTXCTXTPUSHELEMNAME(pctxt, "e2ap_RICsubscriptionModificationConfirm_protocolIEs_element");

    /*print id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PrtToStr_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PrtToStr_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationConfirm_IEs_id_id_RICrequestID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICrequestID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICrequestID (pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_id_RICrequestID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationConfirm_IEs_id_id_RANfunctionID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RANfunctionID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RANfunctionID (pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_id_RANfunctionID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationConfirm_IEs_id_id_RICactionsConfirmedForModification_List:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICactions-ConfirmedForModification-List");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICactions_ConfirmedForModification_List (pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_id_RICactionsConfirmedForModification_List);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationConfirm_IEs_id_id_RICactionsRefusedToBeModified_List:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICactions-RefusedToBeModified-List");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICactions_RefusedToBeModified_List (pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_id_RICactionsRefusedToBeModified_List);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationConfirm_IEs_id_id_RICactionsConfirmedForRemoval_List:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICactions-ConfirmedForRemoval-List");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICactions_ConfirmedForRemoval_List (pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_id_RICactionsConfirmedForRemoval_List);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationConfirm_IEs_id_id_RICactionsRefusedToBeRemoved_List:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICactions-RefusedToBeRemoved-List");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICactions_RefusedToBeRemoved_List (pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_id_RICactionsRefusedToBeRemoved_List);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationConfirm_IEs_UNDEF_:
            {
                rtxPLogMsg(pctxt, "Extension element present - raw data not printed.\n");
                break;
            }

            default:
                stat = RTERR_INVOPT;
                return LOG_RTERR(pctxt, stat);
        }
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);
}
#endif


int asn1PrtToStr_e2ap_RICsubscriptionModificationConfirm_protocolIEs_element (const char * name,
 e2ap_RICsubscriptionModificationConfirm_protocolIEs_element* pvalue, 
 char * buffer, OSSIZE bufSize){
    if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
        return -1;
    if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
        return -1;

    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationConfirm_IEs_id_RICrequestID:
            if(asn1PrtToStr_e2ap_RICrequestID("RICrequestID", 
                    pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_RICrequestID, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationConfirm_IEs_id_RANfunctionID:
            if(asn1PrtToStr_e2ap_RANfunctionID("RANfunctionID", 
                    pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_RANfunctionID, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationConfirm_IEs_id_RICactionsConfirmedForModification_List:
            if(asn1PrtToStr_e2ap_RICactions_ConfirmedForModification_List("RICactions-ConfirmedForModification-List", 
                    pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_RICactionsConfirmedForModification_List, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationConfirm_IEs_id_RICactionsRefusedToBeModified_List:
            if(asn1PrtToStr_e2ap_RICactions_RefusedToBeModified_List("RICactions-RefusedToBeModified-List", 
                    pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_RICactionsRefusedToBeModified_List, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationConfirm_IEs_id_RICactionsConfirmedForRemoval_List:
            if(asn1PrtToStr_e2ap_RICactions_ConfirmedForRemoval_List("RICactions-ConfirmedForRemoval-List", 
                    pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_RICactionsConfirmedForRemoval_List, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationConfirm_IEs_id_RICactionsRefusedToBeRemoved_List:
            if(asn1PrtToStr_e2ap_RICactions_RefusedToBeRemoved_List("RICactions-RefusedToBeRemoved-List", 
                    pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_RICactionsRefusedToBeRemoved_List, buffer, bufSize)<0)
                return -1;
            break;    
        default:
        if(0!=pvalue -> value.u.extElem1){
            rtPrintToStringIndent(buffer, bufSize);
            rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

        }
        }
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

    return 0;

 }

 void asn1Free_e2ap_RICsubscriptionModificationConfirm_protocolIEs_element(OSCTXT* pctxt, e2ap_RICsubscriptionModificationConfirm_protocolIEs_element* pvalue){
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationConfirm_IEs_id_RICrequestID:
            if(pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_RICrequestID!=NULL){
            asn1Free_e2ap_RICrequestID(pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_RICrequestID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_RICrequestID);
            pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_RICrequestID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationConfirm_IEs_id_RANfunctionID:
            if(pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_RANfunctionID!=NULL){
            asn1Free_e2ap_RANfunctionID(pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_RANfunctionID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_RANfunctionID);
            pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_RANfunctionID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationConfirm_IEs_id_RICactionsConfirmedForModification_List:
            if(pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_RICactionsConfirmedForModification_List!=NULL){
            asn1Free_e2ap_RICactions_ConfirmedForModification_List(pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_RICactionsConfirmedForModification_List);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_RICactionsConfirmedForModification_List);
            pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_RICactionsConfirmedForModification_List = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationConfirm_IEs_id_RICactionsRefusedToBeModified_List:
            if(pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_RICactionsRefusedToBeModified_List!=NULL){
            asn1Free_e2ap_RICactions_RefusedToBeModified_List(pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_RICactionsRefusedToBeModified_List);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_RICactionsRefusedToBeModified_List);
            pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_RICactionsRefusedToBeModified_List = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationConfirm_IEs_id_RICactionsConfirmedForRemoval_List:
            if(pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_RICactionsConfirmedForRemoval_List!=NULL){
            asn1Free_e2ap_RICactions_ConfirmedForRemoval_List(pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_RICactionsConfirmedForRemoval_List);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_RICactionsConfirmedForRemoval_List);
            pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_RICactionsConfirmedForRemoval_List = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationConfirm_IEs_id_RICactionsRefusedToBeRemoved_List:
            if(pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_RICactionsRefusedToBeRemoved_List!=NULL){
            asn1Free_e2ap_RICactions_RefusedToBeRemoved_List(pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_RICactionsRefusedToBeRemoved_List);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_RICactionsRefusedToBeRemoved_List);
            pvalue->value.u._e2ap_RICsubscriptionModificationConfirm_IEs_id_RICactionsRefusedToBeRemoved_List = NULL;
            }
            break;
        default:
            break;


    }
 }

 

/*****************************************/
/*           RICsubscriptionModificationConfirm                */
/*****************************************/
//2_container.c
/* 1. xxx_ProtocolIE -> mẫu cũ ở ie_big_msg */
EXTERN int asn1PE_e2ap_RICsubscriptionModificationConfirm_protocolIEs (OSCTXT* pctxt, e2ap_RICsubscriptionModificationConfirm_protocolIEs* pvalue)
{
    int stat =0;
    OSRTDListNode* pnode;
    OSUINT32 xx1;

    /*encode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pe_Length(pctxt, pvalue->count);
    if(stat<0) return LOG_RTERR(pctxt, stat);

    /*encode each element*/
    xx1 =0;
    for(pnode = pvalue->head; pnode != 0 && xx1<pvalue->count; pnode = pnode->next){
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE", xx1);
        stat = asn1PE_e2ap_RICsubscriptionModificationConfirm_protocolIEs_element (pctxt, ((e2ap_RICsubscriptionModificationConfirm_protocolIEs_element*)pnode->data));
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        xx1++;
        RTXCTXTPOPARRAYELEMNAME(pctxt);
    }

    return (stat);
}

EXTERN int  asn1PD_e2ap_RICsubscriptionModificationConfirm_protocolIEs(OSCTXT* pctxt, e2ap_RICsubscriptionModificationConfirm_protocolIEs* pvalue)
{
     int stat =0;
     OSRTDListNode* pnode;
     OSSIZE count =0;
     OSSIZE xx1=0;


     /*decode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pd_Length64(pctxt, &count); //tai sao lai 64
    if(stat!=0) return LOG_RTERR(pctxt, stat);

    /*decode each element*/
    rtxDListInit(pvalue);

    for(xx1=0; xx1 < count; xx1++){
        e2ap_RICsubscriptionModificationConfirm_protocolIEs_element* pdata;
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE",xx1);

        if(pnode == NULL) return LOG_RTERR(pctxt, RTERR_NOMEM);

        asn1Init_e2ap_RICsubscriptionModificationConfirm_protocolIEs_element(pdata);
        rtxDListAppendNode(pvalue, pnode);
        stat = asn1PD_e2ap_RICsubscriptionModificationConfirm_protocolIEs_element (pctxt, pdata);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        RTXCTXTPOPARRAYELEMNAME(pctxt);

    }
    return (stat);
}


int asn1Init_e2ap_RICsubscriptionModificationConfirm_protocolIEs(e2ap_RICsubscriptionModificationConfirm_protocolIEs* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    rtxDListFastInit (pvalue);
    return 0;
}
#if 1 //ao that day
void asn1Free_e2ap_RICsubscriptionModificationConfirm_protocolIEs(OSCTXT* pctxt, e2ap_RICsubscriptionModificationConfirm_protocolIEs* pvalue)
{
    if(0==pvalue) return;   
    e2ap_RICsubscriptionModificationConfirm_protocolIEs_element* pdata;
    OSRTDListNode* pnode=pvalue->head;
    while(0!=pnode){
        pdata = (e2ap_RICsubscriptionModificationConfirm_protocolIEs_element*)pnode->data;
       // asn1Free_e2ap_RICsubscriptionModificationConfirm_protocolIEs_element(pctxt, pdata);
        pnode = pnode->next;
    }
    rtxDListFreeAll(pctxt, pvalue);
}
#endif


EXTERN int asn1PrtToStr_e2ap_RICsubscriptionModificationConfirm_protocolIEs(const char* name, e2ap_RICsubscriptionModificationConfirm_protocolIEs* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_RICsubscriptionModificationConfirm_protocolIEs_element* pdata0;
    OSRTDListNode* pnode0;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode0 = pvalue->head;  xx1 < pvalue->count && pnode0 != 0; pnode0 = pnode0->next, xx1++){
        pdata0 = (e2ap_RICsubscriptionModificationConfirm_protocolIEs_element*)pnode0->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 0
        if(asn1PrtToStr_e2ap_RICsubscriptionModificationConfirm_protocolIEs_element(nameBuf, pdata0, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}


/*2 . RICsubscriptionModificationConfirm -> mẫu cũ ở seq_normal*/

int asn1PE_e2ap_RICsubscriptionModificationConfirm (OSCTXT* pctxt, e2ap_RICsubscriptionModificationConfirm* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RICsubscriptionModificationConfirm");
   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field protocolIEs - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
   stat = asn1PE_e2ap_RICsubscriptionModificationConfirm_protocolIEs (pctxt, &pvalue->protocolIEs);
   if(stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RICsubscriptionModificationConfirm (OSCTXT* pctxt, e2ap_RICsubscriptionModificationConfirm* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME(pctxt, "RICsubscriptionModificationConfirm");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field protocolIEs */
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
      stat = asn1PD_e2ap_RICsubscriptionModificationConfirm_protocolIEs (pctxt, &pvalue->protocolIEs);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RICsubscriptionModificationConfirm (e2ap_RICsubscriptionModificationConfirm* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RICsubscriptionModificationConfirm_protocolIEs(&pvalue->protocolIEs);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RICsubscriptionModificationConfirm (OSCTXT* pctxt, e2ap_RICsubscriptionModificationConfirm* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_RICsubscriptionModificationConfirm_protocolIEs(pctxt, &pvalue->protocolIEs);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RICsubscriptionModificationConfirm (const char* name, e2ap_RICsubscriptionModificationConfirm* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }

   if(asn1PrtToStr_e2ap_RICsubscriptionModificationConfirm_protocolIEs("protocolIEs", &pvalue->protocolIEs, buffer, bufSize) <0){
      return -1;
   }

   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           RICsubscriptionModificationRefuse_IEs                */
/*****************************************/
/* ie.c.j2 */
 /* d là con của msg */
EXTERN int asn1PE_e2ap_RICsubscriptionModificationRefuse_protocolIEs_element (OSCTXT* pctxt, e2ap_RICsubscriptionModificationRefuse_protocolIEs_element* pvalue)
{
    int stat =0;

    /*encode id*/

    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PE_e2ap_ProtocolIE_ID(pctxt, pvalue->id);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PE_e2ap_Criticality(pctxt, pvalue->criticality);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
    {
        OSCTXT lctxt;
        OSOCTET *pDynamicEncodeBuffer;
        ASN1OpenType openType;
        OSBOOL encoded = TRUE;

        openType.numocts = 0;
        openType.data =0;

        rtxCopyContext(&lctxt, pctxt);
        pctxt->pStream =0;

        stat = rtxInitContextBuffer(pctxt, 0, 0);
        if(stat!=0) return LOG_RTERR(pctxt, stat);

        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRefuse_IEs_id_RICrequestID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICrequestID");
                    stat = asn1PE_e2ap_RICrequestID (pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationRefuse_IEs_id_RICrequestID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRefuse_IEs_id_RANfunctionID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RANfunctionID");
                    stat = asn1PE_e2ap_RANfunctionID (pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationRefuse_IEs_id_RANfunctionID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRefuse_IEs_id_Cause:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-Cause");
                    stat = asn1PE_e2ap_Cause (pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationRefuse_IEs_id_Cause);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRefuse_IEs_id_CriticalityDiagnostics:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-CriticalityDiagnostics");
                    stat = asn1PE_e2ap_CriticalityDiagnostics (pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationRefuse_IEs_id_CriticalityDiagnostics);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRefuse_IEs_UNDEF_:
            {
                if(0!=pvalue->value.u.extElem1){
                    openType.numocts = pvalue->value.u.extElem1->numocts;
                    openType.data = pvalue->value.u.extElem1->data;
                } else {
                    /* No extension element to encode */
                }
                encoded = FALSE;
                break;
            }

            default:
                encoded = FALSE;
                stat = RTERR_INVOPT;
                break;
        } 

        if(encoded){
            openType.numocts = (OSUINT32)pe_GetMsgLen(pctxt);
            openType.data = pDynamicEncodeBuffer = pctxt -> buffer.data;
        }
        rtxCopyContext(pctxt, &lctxt);

        if(stat == 0) {
            stat = pe_OpenType (pctxt, openType.numocts, openType.data);
        }
    #if 1
        if(encoded){//dungnm23 check lai nhe
            rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
        }
    #endif

    }

    if(stat!=0) return LOG_RTERR(pctxt, stat);  
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}

EXTERN int  asn1PD_e2ap_RICsubscriptionModificationRefuse_protocolIEs_element (OSCTXT* pctxt, e2ap_RICsubscriptionModificationRefuse_protocolIEs_element* pvalue){
    int stat =0;

    /*decode id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PD_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PD_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");

    {
        OSUINT32 openTypeLen;
        size_t bitStartOffset, bitLength;

        stat = pd_UnconsLength(pctxt, &openTypeLen);
        if(stat<0) return LOG_RTERR(pctxt, stat);
        else if(stat == RT_OK_FRAG){
            rtxErrAddStrParm(pctxt, "open type with fragment length");
            return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
        }
        bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
        bitLength = openTypeLen * 8;

        switch(pvalue->id){//dungnm23 check case lai nhe
        
            case ASN1V_e2ap_id_RICrequestID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRefuse_IEs_id_RICrequestID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICrequestID");
                pvalue->value.u._e2ap_RICsubscriptionModificationRefuse_IEs_id_RICrequestID 
                    = rtxMemAllocType(pctxt, e2ap_RICrequestID);

                asn1Init_e2ap_RICrequestID(pvalue->value.u._e2ap_RICsubscriptionModificationRefuse_IEs_id_RICrequestID);

                stat = asn1PD_e2ap_RICrequestID (pctxt,
                        (e2ap_RICrequestID*)pvalue->value.
                        u._e2ap_RICsubscriptionModificationRefuse_IEs_id_RICrequestID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RANfunctionID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRefuse_IEs_id_RANfunctionID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RANfunctionID");
                pvalue->value.u._e2ap_RICsubscriptionModificationRefuse_IEs_id_RANfunctionID 
                    = rtxMemAllocType(pctxt, e2ap_RANfunctionID);

                asn1Init_e2ap_RANfunctionID(pvalue->value.u._e2ap_RICsubscriptionModificationRefuse_IEs_id_RANfunctionID);

                stat = asn1PD_e2ap_RANfunctionID (pctxt,
                        (e2ap_RANfunctionID*)pvalue->value.
                        u._e2ap_RICsubscriptionModificationRefuse_IEs_id_RANfunctionID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_Cause:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRefuse_IEs_id_Cause;
            RTXCTXTPUSHELEMNAME(pctxt, "id-Cause");
                pvalue->value.u._e2ap_RICsubscriptionModificationRefuse_IEs_id_Cause 
                    = rtxMemAllocType(pctxt, e2ap_Cause);

                asn1Init_e2ap_Cause(pvalue->value.u._e2ap_RICsubscriptionModificationRefuse_IEs_id_Cause);

                stat = asn1PD_e2ap_Cause (pctxt,
                        (e2ap_Cause*)pvalue->value.
                        u._e2ap_RICsubscriptionModificationRefuse_IEs_id_Cause);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_CriticalityDiagnostics:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRefuse_IEs_id_CriticalityDiagnostics;
            RTXCTXTPUSHELEMNAME(pctxt, "id-CriticalityDiagnostics");
                pvalue->value.u._e2ap_RICsubscriptionModificationRefuse_IEs_id_CriticalityDiagnostics 
                    = rtxMemAllocType(pctxt, e2ap_CriticalityDiagnostics);

                asn1Init_e2ap_CriticalityDiagnostics(pvalue->value.u._e2ap_RICsubscriptionModificationRefuse_IEs_id_CriticalityDiagnostics);

                stat = asn1PD_e2ap_CriticalityDiagnostics (pctxt,
                        (e2ap_CriticalityDiagnostics*)pvalue->value.
                        u._e2ap_RICsubscriptionModificationRefuse_IEs_id_CriticalityDiagnostics);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRefuse_IEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*) rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
    }
    {
    size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
    size_t bitsConsumed = bitEndOffset-bitStartOffset;
    if(bitsConsumed<bitLength){
        stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
    }
    else stat =(bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
    }}
    if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}


int asn1Init_e2ap_RICsubscriptionModificationRefuse_protocolIEs_element(e2ap_RICsubscriptionModificationRefuse_protocolIEs_element* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    OSCRTLMEMSET (&pvalue->value, 0, sizeof(pvalue->value));
    return 0;
}


//-----> chuaw có template rtxFreeASN1OpenType

#if 0
void asn1Free_e2ap_RICsubscriptionModificationRefuse_protocolIEs_element(OSCTXT* pctxt, e2ap_RICsubscriptionModificationRefuse_protocolIEs_element* pvalue)
{
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRefuse_IEs_id_id_RICrequestID:
            // rtxFreeE2ap_RICrequestID(pvalue->value.u._e2ap_RICsubscriptionModificationRefuse_IEs_id_id_RICrequestID);

            if(pvalue->value.i._e2ap_RICsubscriptionModificationRefuse_id_RICrequestID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICrequestID(pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationRefuse_IEs_id_id_RICrequestID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionModificationRefuse_IEs_id_id_RICrequestID);
           // pvalue->value.u._e2ap_RICsubscriptionModificationRefuse_IEs_id_id_RICrequestID = NULL;
           pvalue->value.u._e2ap_RICsubscriptionModificationRefuse_IEs_id_RICrequestID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRefuse_IEs_id_id_RANfunctionID:
            // rtxFreeE2ap_RANfunctionID(pvalue->value.u._e2ap_RICsubscriptionModificationRefuse_IEs_id_id_RANfunctionID);

            if(pvalue->value.i._e2ap_RICsubscriptionModificationRefuse_id_RANfunctionID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RANfunctionID(pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationRefuse_IEs_id_id_RANfunctionID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionModificationRefuse_IEs_id_id_RANfunctionID);
           // pvalue->value.u._e2ap_RICsubscriptionModificationRefuse_IEs_id_id_RANfunctionID = NULL;
           pvalue->value.u._e2ap_RICsubscriptionModificationRefuse_IEs_id_RANfunctionID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRefuse_IEs_id_id_Cause:
            // rtxFreeE2ap_Cause(pvalue->value.u._e2ap_RICsubscriptionModificationRefuse_IEs_id_id_Cause);

            if(pvalue->value.i._e2ap_RICsubscriptionModificationRefuse_id_Cause!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_Cause(pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationRefuse_IEs_id_id_Cause);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionModificationRefuse_IEs_id_id_Cause);
           // pvalue->value.u._e2ap_RICsubscriptionModificationRefuse_IEs_id_id_Cause = NULL;
           pvalue->value.u._e2ap_RICsubscriptionModificationRefuse_IEs_id_Cause = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRefuse_IEs_id_id_CriticalityDiagnostics:
            // rtxFreeE2ap_CriticalityDiagnostics(pvalue->value.u._e2ap_RICsubscriptionModificationRefuse_IEs_id_id_CriticalityDiagnostics);

            if(pvalue->value.i._e2ap_RICsubscriptionModificationRefuse_id_CriticalityDiagnostics!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_CriticalityDiagnostics(pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationRefuse_IEs_id_id_CriticalityDiagnostics);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionModificationRefuse_IEs_id_id_CriticalityDiagnostics);
           // pvalue->value.u._e2ap_RICsubscriptionModificationRefuse_IEs_id_id_CriticalityDiagnostics = NULL;
           pvalue->value.u._e2ap_RICsubscriptionModificationRefuse_IEs_id_CriticalityDiagnostics = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRefuse_IEs_UNDEF_:
            rtxFreeASN1OpenType(pvalue->value.u.extElem1);
            break;
        default:
            break;
    }
}

int asn1PrtToStr_e2ap_RICsubscriptionModificationRefuse_protocolIEs_element(OSCTXT* pctxt, e2ap_RICsubscriptionModificationRefuse_protocolIEs_element* pvalue)
{
    int stat =0;
    RTXCTXTPUSHELEMNAME(pctxt, "e2ap_RICsubscriptionModificationRefuse_protocolIEs_element");

    /*print id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PrtToStr_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PrtToStr_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRefuse_IEs_id_id_RICrequestID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICrequestID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICrequestID (pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationRefuse_IEs_id_id_RICrequestID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRefuse_IEs_id_id_RANfunctionID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RANfunctionID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RANfunctionID (pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationRefuse_IEs_id_id_RANfunctionID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRefuse_IEs_id_id_Cause:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "Cause");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_Cause (pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationRefuse_IEs_id_id_Cause);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRefuse_IEs_id_id_CriticalityDiagnostics:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "CriticalityDiagnostics");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_CriticalityDiagnostics (pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationRefuse_IEs_id_id_CriticalityDiagnostics);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRefuse_IEs_UNDEF_:
            {
                rtxPLogMsg(pctxt, "Extension element present - raw data not printed.\n");
                break;
            }

            default:
                stat = RTERR_INVOPT;
                return LOG_RTERR(pctxt, stat);
        }
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);
}
#endif


int asn1PrtToStr_e2ap_RICsubscriptionModificationRefuse_protocolIEs_element (const char * name,
 e2ap_RICsubscriptionModificationRefuse_protocolIEs_element* pvalue, 
 char * buffer, OSSIZE bufSize){
    if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
        return -1;
    if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
        return -1;

    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRefuse_IEs_id_RICrequestID:
            if(asn1PrtToStr_e2ap_RICrequestID("RICrequestID", 
                    pvalue->value.u._e2ap_RICsubscriptionModificationRefuse_IEs_id_RICrequestID, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRefuse_IEs_id_RANfunctionID:
            if(asn1PrtToStr_e2ap_RANfunctionID("RANfunctionID", 
                    pvalue->value.u._e2ap_RICsubscriptionModificationRefuse_IEs_id_RANfunctionID, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRefuse_IEs_id_Cause:
            if(asn1PrtToStr_e2ap_Cause("Cause", 
                    pvalue->value.u._e2ap_RICsubscriptionModificationRefuse_IEs_id_Cause, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRefuse_IEs_id_CriticalityDiagnostics:
            if(asn1PrtToStr_e2ap_CriticalityDiagnostics("CriticalityDiagnostics", 
                    pvalue->value.u._e2ap_RICsubscriptionModificationRefuse_IEs_id_CriticalityDiagnostics, buffer, bufSize)<0)
                return -1;
            break;    
        default:
        if(0!=pvalue -> value.u.extElem1){
            rtPrintToStringIndent(buffer, bufSize);
            rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

        }
        }
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

    return 0;

 }

 void asn1Free_e2ap_RICsubscriptionModificationRefuse_protocolIEs_element(OSCTXT* pctxt, e2ap_RICsubscriptionModificationRefuse_protocolIEs_element* pvalue){
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRefuse_IEs_id_RICrequestID:
            if(pvalue->value.u._e2ap_RICsubscriptionModificationRefuse_IEs_id_RICrequestID!=NULL){
            asn1Free_e2ap_RICrequestID(pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationRefuse_IEs_id_RICrequestID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionModificationRefuse_IEs_id_RICrequestID);
            pvalue->value.u._e2ap_RICsubscriptionModificationRefuse_IEs_id_RICrequestID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRefuse_IEs_id_RANfunctionID:
            if(pvalue->value.u._e2ap_RICsubscriptionModificationRefuse_IEs_id_RANfunctionID!=NULL){
            asn1Free_e2ap_RANfunctionID(pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationRefuse_IEs_id_RANfunctionID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionModificationRefuse_IEs_id_RANfunctionID);
            pvalue->value.u._e2ap_RICsubscriptionModificationRefuse_IEs_id_RANfunctionID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRefuse_IEs_id_Cause:
            if(pvalue->value.u._e2ap_RICsubscriptionModificationRefuse_IEs_id_Cause!=NULL){
            asn1Free_e2ap_Cause(pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationRefuse_IEs_id_Cause);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionModificationRefuse_IEs_id_Cause);
            pvalue->value.u._e2ap_RICsubscriptionModificationRefuse_IEs_id_Cause = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionModificationRefuse_IEs_id_CriticalityDiagnostics:
            if(pvalue->value.u._e2ap_RICsubscriptionModificationRefuse_IEs_id_CriticalityDiagnostics!=NULL){
            asn1Free_e2ap_CriticalityDiagnostics(pctxt, pvalue->value.u._e2ap_RICsubscriptionModificationRefuse_IEs_id_CriticalityDiagnostics);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionModificationRefuse_IEs_id_CriticalityDiagnostics);
            pvalue->value.u._e2ap_RICsubscriptionModificationRefuse_IEs_id_CriticalityDiagnostics = NULL;
            }
            break;
        default:
            break;


    }
 }

 

/*****************************************/
/*           RICsubscriptionModificationRefuse                */
/*****************************************/
//2_container.c
/* 1. xxx_ProtocolIE -> mẫu cũ ở ie_big_msg */
EXTERN int asn1PE_e2ap_RICsubscriptionModificationRefuse_protocolIEs (OSCTXT* pctxt, e2ap_RICsubscriptionModificationRefuse_protocolIEs* pvalue)
{
    int stat =0;
    OSRTDListNode* pnode;
    OSUINT32 xx1;

    /*encode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pe_Length(pctxt, pvalue->count);
    if(stat<0) return LOG_RTERR(pctxt, stat);

    /*encode each element*/
    xx1 =0;
    for(pnode = pvalue->head; pnode != 0 && xx1<pvalue->count; pnode = pnode->next){
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE", xx1);
        stat = asn1PE_e2ap_RICsubscriptionModificationRefuse_protocolIEs_element (pctxt, ((e2ap_RICsubscriptionModificationRefuse_protocolIEs_element*)pnode->data));
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        xx1++;
        RTXCTXTPOPARRAYELEMNAME(pctxt);
    }

    return (stat);
}

EXTERN int  asn1PD_e2ap_RICsubscriptionModificationRefuse_protocolIEs(OSCTXT* pctxt, e2ap_RICsubscriptionModificationRefuse_protocolIEs* pvalue)
{
     int stat =0;
     OSRTDListNode* pnode;
     OSSIZE count =0;
     OSSIZE xx1=0;


     /*decode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pd_Length64(pctxt, &count); //tai sao lai 64
    if(stat!=0) return LOG_RTERR(pctxt, stat);

    /*decode each element*/
    rtxDListInit(pvalue);

    for(xx1=0; xx1 < count; xx1++){
        e2ap_RICsubscriptionModificationRefuse_protocolIEs_element* pdata;
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE",xx1);

        if(pnode == NULL) return LOG_RTERR(pctxt, RTERR_NOMEM);

        asn1Init_e2ap_RICsubscriptionModificationRefuse_protocolIEs_element(pdata);
        rtxDListAppendNode(pvalue, pnode);
        stat = asn1PD_e2ap_RICsubscriptionModificationRefuse_protocolIEs_element (pctxt, pdata);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        RTXCTXTPOPARRAYELEMNAME(pctxt);

    }
    return (stat);
}


int asn1Init_e2ap_RICsubscriptionModificationRefuse_protocolIEs(e2ap_RICsubscriptionModificationRefuse_protocolIEs* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    rtxDListFastInit (pvalue);
    return 0;
}
#if 1 //ao that day
void asn1Free_e2ap_RICsubscriptionModificationRefuse_protocolIEs(OSCTXT* pctxt, e2ap_RICsubscriptionModificationRefuse_protocolIEs* pvalue)
{
    if(0==pvalue) return;   
    e2ap_RICsubscriptionModificationRefuse_protocolIEs_element* pdata;
    OSRTDListNode* pnode=pvalue->head;
    while(0!=pnode){
        pdata = (e2ap_RICsubscriptionModificationRefuse_protocolIEs_element*)pnode->data;
       // asn1Free_e2ap_RICsubscriptionModificationRefuse_protocolIEs_element(pctxt, pdata);
        pnode = pnode->next;
    }
    rtxDListFreeAll(pctxt, pvalue);
}
#endif


EXTERN int asn1PrtToStr_e2ap_RICsubscriptionModificationRefuse_protocolIEs(const char* name, e2ap_RICsubscriptionModificationRefuse_protocolIEs* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_RICsubscriptionModificationRefuse_protocolIEs_element* pdata0;
    OSRTDListNode* pnode0;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode0 = pvalue->head;  xx1 < pvalue->count && pnode0 != 0; pnode0 = pnode0->next, xx1++){
        pdata0 = (e2ap_RICsubscriptionModificationRefuse_protocolIEs_element*)pnode0->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 0
        if(asn1PrtToStr_e2ap_RICsubscriptionModificationRefuse_protocolIEs_element(nameBuf, pdata0, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}


/*2 . RICsubscriptionModificationRefuse -> mẫu cũ ở seq_normal*/

int asn1PE_e2ap_RICsubscriptionModificationRefuse (OSCTXT* pctxt, e2ap_RICsubscriptionModificationRefuse* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RICsubscriptionModificationRefuse");
   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field protocolIEs - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
   stat = asn1PE_e2ap_RICsubscriptionModificationRefuse_protocolIEs (pctxt, &pvalue->protocolIEs);
   if(stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RICsubscriptionModificationRefuse (OSCTXT* pctxt, e2ap_RICsubscriptionModificationRefuse* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME(pctxt, "RICsubscriptionModificationRefuse");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field protocolIEs */
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
      stat = asn1PD_e2ap_RICsubscriptionModificationRefuse_protocolIEs (pctxt, &pvalue->protocolIEs);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RICsubscriptionModificationRefuse (e2ap_RICsubscriptionModificationRefuse* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RICsubscriptionModificationRefuse_protocolIEs(&pvalue->protocolIEs);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RICsubscriptionModificationRefuse (OSCTXT* pctxt, e2ap_RICsubscriptionModificationRefuse* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_RICsubscriptionModificationRefuse_protocolIEs(pctxt, &pvalue->protocolIEs);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RICsubscriptionModificationRefuse (const char* name, e2ap_RICsubscriptionModificationRefuse* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }

   if(asn1PrtToStr_e2ap_RICsubscriptionModificationRefuse_protocolIEs("protocolIEs", &pvalue->protocolIEs, buffer, bufSize) <0){
      return -1;
   }

   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}
/*****************************************/
/*           RICactionList-Item                */
/*****************************************/
//sequence normal
// Các nội dung cần thiết cho template seq_normal.c.j2

// Các phần còn lại của template seq_normal.c.j2
//contain extensition bit -> theo mau cua GlobalgNB-ID
int asn1PE_e2ap_RICactionList_Item (OSCTXT* pctxt, e2ap_RICactionList_Item* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RICactionList-Item");

   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field ricActionID - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "ricActionID");
   stat = asn1PE_e2ap_RICactionID (pctxt, pvalue->ricActionID);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);



   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RICactionList_Item (OSCTXT* pctxt, e2ap_RICactionList_Item* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME(pctxt, "RICactionList-Item");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field ricActionID */
   RTXCTXTPUSHELEMNAME(pctxt, "ricActionID");
      stat = asn1PD_e2ap_RICactionID (pctxt, &pvalue->ricActionID);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RICactionList_Item (e2ap_RICactionList_Item* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RICactionID (&pvalue->ricActionID);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RICactionList_Item (OSCTXT* pctxt, e2ap_RICactionList_Item* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_RICactionID (pctxt, &pvalue->ricActionID);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RICactionList_Item (const char* name, e2ap_RICactionList_Item* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }
   if(asn1PrtToStr_e2ap_RICactionID ("ricActionID", &pvalue->ricActionID, buffer, bufSize) < 0)
   {
      return -1;
   }



   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           RICaction_ItemIEs                */
/*****************************************/
/* ie.c.j2 */
/*ie thường*/
int asn1PE_e2ap_RICaction_ItemIEs (OSCTXT* pctxt, e2ap_RICaction_ItemIEs* pvalue)
{
   int stat = 0;
   //RTXCTXTPUSHTYPENAME (pctxt, "RICaction-ItemIEs");

   /* encode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");
   stat = asn1PE_e2ap_ProtocolIE_ID (pctxt, pvalue->id);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");
   stat = asn1PE_e2ap_Criticality (pctxt, pvalue->criticality);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   {
      OSCTXT ictxt;
      OSOCTET* pDynamicEncodeBuffer;
      ASN1OpenType openType;
      OSBOOL  encoded = TRUE;

      openType.numocts = 0;
      openType.data = 0;

      rtxCopyContext (&ictxt, pctxt);
      pctxt->pStream = 0;

      stat = rtxInitContextBuffer (pctxt, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_RICaction_ItemIEs_id_RICactionList_Item:
         
        // RTXCTXTPUSHELEMNAME (pctxt, "RICaction_ItemIEs_id_RICactionList_Item");
         RTXCTXTPUSHELEMNAME (pctxt, "RICactionList-Item");
         stat = asn1PE_e2ap_RICactionList_Item (pctxt, pvalue->value.u._e2apRICaction_ItemIEs_id_RICactionList_Item);
         RTXCTXTPOPELEMNAME (pctxt);
      
         break;

      case T_E2AP_PDU_Contents_e2ap_RICaction_ItemIEs_UNDEF_:
      {
          if(0!=pvalue->value.u.extElem1){
              openType.numocts = pvalue->value.u.extElem1->numocts;
              openType.data = pvalue->value.u.extElem1->data;
          } else {
              /* No extension element to encode */
          }
          encoded = FALSE;
          break;
      }
      default:
         encoded = FALSE;
         stat = RTERR_INVOPT;
      }

      if (encoded) {
         openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
         openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
      }
      rtxCopyContext (pctxt, &ictxt);
      if(stat ==0) stat = pe_OpenType(pctxt, openType.numocts, openType.data);
      /*free dynamic encode buffer*/
      if(encoded){
          rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
      }
   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);
   //RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

int asn1PD_e2ap_RICaction_ItemIEs (OSCTXT* pctxt, e2ap_RICaction_ItemIEs* pvalue)
{
   int stat =0;
   /*deode root element id*/
   RTXCTXTPUSHELEMNAME(pctxt, "id");
   stat = asn1PD_e2ap_ProtocolIE_ID (pctxt, &pvalue->id);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*decode root element criticality*/
   RTXCTXTPUSHELEMNAME(pctxt, "criticality");
   stat = asn1PD_e2ap_Criticality (pctxt, &pvalue->criticality);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   /*decode root element value*/
   RTXCTXTPUSHELEMNAME(pctxt, "value");
   {
      OSUINT32 openTypeLen;
      size_t bitStartOffset, bitLength;
      stat = pd_UnconsLength(pctxt, &openTypeLen);
      if(stat <0) return LOG_RTERR(pctxt, stat);
      else if(stat == RT_OK_FRAG){
         rtxErrAddStrParm(pctxt, "open type with fragmented length use - perindef");
         return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
      }
      bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
      bitLength = openTypeLen * 8;
      switch (pvalue->id){
         case T_E2AP_PDU_Contents_e2ap_RICaction_ItemIEs_id_RICactionList_Item:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICaction_ItemIEs_id_RICactionList_Item;
            RTXCTXTPUSHELEMNAME(pctxt, "RICactionList-Item");
            //pvalue->value.u._e2ap_RICaction_ItemIEs_id_id_RICactionList_Item 
             pvalue->value.u._e2apRICaction_ItemIEs_id_RICactionList_Item 
                    = rtxMemAllocType(pctxt, e2ap_RICactionList_Item);
            //asn1Init_e2ap_RICactionList_Item(pvalue->value.u._e2ap_RICaction_ItemIEs_id_id_RICactionList_Item);
            asn1Init_e2ap_RICactionList_Item(pvalue->value.u._e2apRICaction_ItemIEs_id_RICactionList_Item);
            stat = asn1PD_e2ap_RICactionList_Item (pctxt,
                    (e2ap_RICactionList_Item*)pvalue->value.
                    u._e2apRICaction_ItemIEs_id_RICactionList_Item);
            if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICaction_ItemIEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*)rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
      }
      {
      size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
      size_t bitsConsumed = bitEndOffset - bitStartOffset;
      if(bitsConsumed < bitLength){
         stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
      } else {
         stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
      }
      }
   }
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   return stat;
}

void asn1Init_e2ap_RICaction_ItemIEs (e2ap_RICaction_ItemIEs* pvalue)
{
   if (!pvalue) return;
   OSCRTLMEMSET (pvalue, 0, sizeof(e2ap_RICaction_ItemIEs));
}

#if 0
void asn1Free_e2ap_RICaction_ItemIEs (OSCTXT* pctxt, e2ap_RICaction_ItemIEs* pvalue)
{
   if (!pvalue) return;
   if (pvalue->extElem1) {
      rtxMemFreeArray (pctxt, pvalue->extElem1);
      pvalue->extElem1 = 0;
      pvalue->extElem1_n = 0;
   }
}
#endif
void asn1Free_e2ap_RICaction_ItemIEs (OSCTXT* pctxt, e2ap_RICaction_ItemIEs* pvalue)
{
   if(0==pvalue) return;
   switch(pvalue->value.t){
      case T_E2AP_PDU_Contents_e2ap_RICaction_ItemIEs_id_RICactionList_Item:
         asn1Free_e2ap_RICactionList_Item (pctxt, pvalue->value.u._e2apRICaction_ItemIEs_id_RICactionList_Item);
         rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2apRICaction_ItemIEs_id_RICactionList_Item);
         pvalue->value.u._e2apRICaction_ItemIEs_id_RICactionList_Item = 0;
         break;
      case T_E2AP_PDU_Contents_e2ap_RICaction_ItemIEs_UNDEF_:
         if(0!=pvalue->value.u.extElem1){
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1->data);
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
             pvalue->value.u.extElem1 =0;
         }
         break;
         default:;
   }
}

int  asn1PrtToStr_e2ap_RICaction_ItemIEs (const char * name, e2ap_RICaction_ItemIEs* pvalue, char * buffer, OSSIZE bufSize){
   if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
       return -1;

      if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
         return -1;

      if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
         return -1;
      if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
         return -1;
      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_RICaction_ItemIEs_id_RICactionList_Item:
         if(asn1PrtToStr_e2ap_RICactionList_Item("RICactionList-Item",
                pvalue->value.u._e2apRICaction_ItemIEs_id_RICactionList_Item, buffer, bufSize)<0)// dungnm23 check lai nhe xem la
            return -1;
         break;
      default:
         if(0!=pvalue -> value.u.extElem1){
             rtPrintToStringIndent(buffer, bufSize);
             rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

         }
      }
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

      return 0;

}
 

/*****************************************/
/*           RICaction_List                */
/*****************************************/
//seq_of_single_container


int asn1PE_e2ap_RICaction_List (OSCTXT* pctxt, e2ap_RICaction_List* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_RICaction_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "RICaction-List");

   /* encode length determinant */
   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;
   for (xx1 = 0; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next, xx1++) {
      pdata = (e2ap_RICaction_ItemIEs*) pnode->data;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_e2ap_RICaction_ItemIEs (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      //xx1++;
      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}

int asn1PD_e2ap_RICaction_List (OSCTXT* pctxt, e2ap_RICaction_List* ppvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_RICaction_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "RICaction-List");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (ppvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      pdata = rtxMemAllocType (pctxt, e2ap_RICaction_ItemIEs);
      if (!pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);
      asn1Init_e2ap_RICaction_ItemIEs (pdata);
      stat = asn1PD_e2ap_RICaction_ItemIEs (pctxt, pdata);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         return LOG_RTERR (pctxt, stat);
      }

      rtxDListAppendNode (ppvalue, pdata);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

void asn1Init_e2ap_RICaction_List (e2ap_RICaction_List* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
}

void asn1Free_e2ap_RICaction_List (OSCTXT* pctxt, e2ap_RICaction_List* pvalue)
{
   if(pvalue==0) return;
   OSRTDListNode* pnode = pvalue->head;
   while (pnode) {
      e2ap_RICaction_ItemIEs* pdata = (e2ap_RICaction_ItemIEs*) pnode->data;
      if (pdata) {
         asn1Free_e2ap_RICaction_ItemIEs (pctxt, pdata);
         rtxMemFreePtr (pctxt, pdata);
      }
      pnode = pnode->next;
   }
      rtxDListFreeAll(pctxt, pvalue);
}

#if 0
void asn1Free_e2ap_RICaction_List (OSCTXT* pctxt, e2ap_RICaction_List* pvalue){
   if(0==pvalue ) return;
   {
      e2ap_RICaction_ItemIEs * pdata;
      OSRTDListNode *pnode = pvalue->head;
      while(0!=pnode){
         pdata = (e2ap_RICaction_ItemIEs*)pnode->data;
         asn1Free_e2ap_RICaction_ItemIEs(pctxt, pdata);
         pnode = pnode->next;
      }
      rtxDListFreeAll(pctxt, pvalue);
   }
}
#endif


int asn1PrtToStr_e2ap_RICaction_List(const char* name, e2ap_RICaction_List* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_RICaction_ItemIEs* pdata;
    OSRTDListNode* pnode;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode = pvalue->head;  xx1 < pvalue->count && pnode != 0; pnode = pnode->next, xx1++){
        pdata = (e2ap_RICaction_ItemIEs*)pnode->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 1
        if(asn1PrtToStr_e2ap_RICaction_ItemIEs(nameBuf, pdata, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}
/*****************************************/
/*           RICsubscriptionList-Item                */
/*****************************************/
//sequence normal
// Các nội dung cần thiết cho template seq_normal.c.j2

// Các phần còn lại của template seq_normal.c.j2
//contain extensition bit -> theo mau cua GlobalgNB-ID
int asn1PE_e2ap_RICsubscriptionList_Item (OSCTXT* pctxt, e2ap_RICsubscriptionList_Item* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RICsubscriptionList-Item");

   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);

   /*optional bit for field ricAction_list*/
   stat = rtxEncBit (pctxt, pvalue->m_ricAction_listPresent);
   if (stat != 0) return LOG_RTERR(pctxt, stat);

   /*encode root elements*/   
   /* encode field ricRequestID - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "ricRequestID");
   stat = asn1PE_e2ap_RICrequestID (pctxt, pvalue->ricRequestID);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /* encode field ricAction_list - id = -1*/  
   if (pvalue->m_ricAction_listPresent) {//OPTIONAL FIELD
   RTXCTXTPUSHELEMNAME(pctxt, "ricAction-list");
   stat = asn1PE_e2ap_RICaction_List (pctxt, pvalue->ricAction_list);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   }


   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RICsubscriptionList_Item (OSCTXT* pctxt, e2ap_RICsubscriptionList_Item* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME(pctxt, "RICsubscriptionList-Item");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field ricRequestID */
   RTXCTXTPUSHELEMNAME(pctxt, "ricRequestID");
      stat = asn1PD_e2ap_RICrequestID (pctxt, &pvalue->ricRequestID);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field ricAction_list */
   RTXCTXTPUSHELEMNAME(pctxt, "ricAction-list");
   if (optbits[0]) {
      pvalue->m_ricAction_listPresent = TRUE;
      stat = asn1PD_e2ap_RICaction_List (pctxt, &pvalue->ricAction_list);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   } else {
      pvalue->m_ricAction_listPresent = FALSE;
   }
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RICsubscriptionList_Item (e2ap_RICsubscriptionList_Item* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RICrequestID (&pvalue->ricRequestID);
   asn1Init_e2ap_RICaction_List (&pvalue->ricAction_list);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RICsubscriptionList_Item (OSCTXT* pctxt, e2ap_RICsubscriptionList_Item* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_RICrequestID (pctxt, &pvalue->ricRequestID);
   asn1Free_e2ap_RICaction_List (pctxt, &pvalue->ricAction_list);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RICsubscriptionList_Item (const char* name, e2ap_RICsubscriptionList_Item* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }
   if(asn1PrtToStr_e2ap_RICrequestID ("ricRequestID", &pvalue->ricRequestID, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_RICaction_List ("ricAction_list", &pvalue->ricAction_list, buffer, bufSize) < 0)
   {
      return -1;
   }



   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           RICsubscriptionList_ItemIEs                */
/*****************************************/
/* ie.c.j2 */
/*ie thường*/
int asn1PE_e2ap_RICsubscriptionList_ItemIEs (OSCTXT* pctxt, e2ap_RICsubscriptionList_ItemIEs* pvalue)
{
   int stat = 0;
   //RTXCTXTPUSHTYPENAME (pctxt, "RICsubscriptionList-ItemIEs");

   /* encode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");
   stat = asn1PE_e2ap_ProtocolIE_ID (pctxt, pvalue->id);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");
   stat = asn1PE_e2ap_Criticality (pctxt, pvalue->criticality);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   {
      OSCTXT ictxt;
      OSOCTET* pDynamicEncodeBuffer;
      ASN1OpenType openType;
      OSBOOL  encoded = TRUE;

      openType.numocts = 0;
      openType.data = 0;

      rtxCopyContext (&ictxt, pctxt);
      pctxt->pStream = 0;

      stat = rtxInitContextBuffer (pctxt, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_RICsubscriptionList_ItemIEs_id_RICsubscriptionList_Item:
         
        // RTXCTXTPUSHELEMNAME (pctxt, "RICsubscriptionList_ItemIEs_id_RICsubscriptionList_Item");
         RTXCTXTPUSHELEMNAME (pctxt, "RICsubscriptionList-Item");
         stat = asn1PE_e2ap_RICsubscriptionList_Item (pctxt, pvalue->value.u._e2apRICsubscriptionList_ItemIEs_id_RICsubscriptionList_Item);
         RTXCTXTPOPELEMNAME (pctxt);
      
         break;

      case T_E2AP_PDU_Contents_e2ap_RICsubscriptionList_ItemIEs_UNDEF_:
      {
          if(0!=pvalue->value.u.extElem1){
              openType.numocts = pvalue->value.u.extElem1->numocts;
              openType.data = pvalue->value.u.extElem1->data;
          } else {
              /* No extension element to encode */
          }
          encoded = FALSE;
          break;
      }
      default:
         encoded = FALSE;
         stat = RTERR_INVOPT;
      }

      if (encoded) {
         openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
         openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
      }
      rtxCopyContext (pctxt, &ictxt);
      if(stat ==0) stat = pe_OpenType(pctxt, openType.numocts, openType.data);
      /*free dynamic encode buffer*/
      if(encoded){
          rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
      }
   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);
   //RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

int asn1PD_e2ap_RICsubscriptionList_ItemIEs (OSCTXT* pctxt, e2ap_RICsubscriptionList_ItemIEs* pvalue)
{
   int stat =0;
   /*deode root element id*/
   RTXCTXTPUSHELEMNAME(pctxt, "id");
   stat = asn1PD_e2ap_ProtocolIE_ID (pctxt, &pvalue->id);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*decode root element criticality*/
   RTXCTXTPUSHELEMNAME(pctxt, "criticality");
   stat = asn1PD_e2ap_Criticality (pctxt, &pvalue->criticality);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   /*decode root element value*/
   RTXCTXTPUSHELEMNAME(pctxt, "value");
   {
      OSUINT32 openTypeLen;
      size_t bitStartOffset, bitLength;
      stat = pd_UnconsLength(pctxt, &openTypeLen);
      if(stat <0) return LOG_RTERR(pctxt, stat);
      else if(stat == RT_OK_FRAG){
         rtxErrAddStrParm(pctxt, "open type with fragmented length use - perindef");
         return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
      }
      bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
      bitLength = openTypeLen * 8;
      switch (pvalue->id){
         case T_E2AP_PDU_Contents_e2ap_RICsubscriptionList_ItemIEs_id_RICsubscriptionList_Item:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionList_ItemIEs_id_RICsubscriptionList_Item;
            RTXCTXTPUSHELEMNAME(pctxt, "RICsubscriptionList-Item");
            //pvalue->value.u._e2ap_RICsubscriptionList_ItemIEs_id_id_RICsubscriptionList_Item 
             pvalue->value.u._e2apRICsubscriptionList_ItemIEs_id_RICsubscriptionList_Item 
                    = rtxMemAllocType(pctxt, e2ap_RICsubscriptionList_Item);
            //asn1Init_e2ap_RICsubscriptionList_Item(pvalue->value.u._e2ap_RICsubscriptionList_ItemIEs_id_id_RICsubscriptionList_Item);
            asn1Init_e2ap_RICsubscriptionList_Item(pvalue->value.u._e2apRICsubscriptionList_ItemIEs_id_RICsubscriptionList_Item);
            stat = asn1PD_e2ap_RICsubscriptionList_Item (pctxt,
                    (e2ap_RICsubscriptionList_Item*)pvalue->value.
                    u._e2apRICsubscriptionList_ItemIEs_id_RICsubscriptionList_Item);
            if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionList_ItemIEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*)rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
      }
      {
      size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
      size_t bitsConsumed = bitEndOffset - bitStartOffset;
      if(bitsConsumed < bitLength){
         stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
      } else {
         stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
      }
      }
   }
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   return stat;
}

void asn1Init_e2ap_RICsubscriptionList_ItemIEs (e2ap_RICsubscriptionList_ItemIEs* pvalue)
{
   if (!pvalue) return;
   OSCRTLMEMSET (pvalue, 0, sizeof(e2ap_RICsubscriptionList_ItemIEs));
}

#if 0
void asn1Free_e2ap_RICsubscriptionList_ItemIEs (OSCTXT* pctxt, e2ap_RICsubscriptionList_ItemIEs* pvalue)
{
   if (!pvalue) return;
   if (pvalue->extElem1) {
      rtxMemFreeArray (pctxt, pvalue->extElem1);
      pvalue->extElem1 = 0;
      pvalue->extElem1_n = 0;
   }
}
#endif
void asn1Free_e2ap_RICsubscriptionList_ItemIEs (OSCTXT* pctxt, e2ap_RICsubscriptionList_ItemIEs* pvalue)
{
   if(0==pvalue) return;
   switch(pvalue->value.t){
      case T_E2AP_PDU_Contents_e2ap_RICsubscriptionList_ItemIEs_id_RICsubscriptionList_Item:
         asn1Free_e2ap_RICsubscriptionList_Item (pctxt, pvalue->value.u._e2apRICsubscriptionList_ItemIEs_id_RICsubscriptionList_Item);
         rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2apRICsubscriptionList_ItemIEs_id_RICsubscriptionList_Item);
         pvalue->value.u._e2apRICsubscriptionList_ItemIEs_id_RICsubscriptionList_Item = 0;
         break;
      case T_E2AP_PDU_Contents_e2ap_RICsubscriptionList_ItemIEs_UNDEF_:
         if(0!=pvalue->value.u.extElem1){
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1->data);
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
             pvalue->value.u.extElem1 =0;
         }
         break;
         default:;
   }
}

int  asn1PrtToStr_e2ap_RICsubscriptionList_ItemIEs (const char * name, e2ap_RICsubscriptionList_ItemIEs* pvalue, char * buffer, OSSIZE bufSize){
   if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
       return -1;

      if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
         return -1;

      if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
         return -1;
      if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
         return -1;
      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_RICsubscriptionList_ItemIEs_id_RICsubscriptionList_Item:
         if(asn1PrtToStr_e2ap_RICsubscriptionList_Item("RICsubscriptionList-Item",
                pvalue->value.u._e2apRICsubscriptionList_ItemIEs_id_RICsubscriptionList_Item, buffer, bufSize)<0)// dungnm23 check lai nhe xem la
            return -1;
         break;
      default:
         if(0!=pvalue -> value.u.extElem1){
             rtPrintToStringIndent(buffer, bufSize);
             rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

         }
      }
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

      return 0;

}
 

/*****************************************/
/*           RICsubscriptionToBeSuspended_List                */
/*****************************************/
//seq_of_single_container


int asn1PE_e2ap_RICsubscriptionToBeSuspended_List (OSCTXT* pctxt, e2ap_RICsubscriptionToBeSuspended_List* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_RICsubscriptionList_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "RICsubscriptionToBeSuspended-List");

   /* encode length determinant */
   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1024), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;
   for (xx1 = 0; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next, xx1++) {
      pdata = (e2ap_RICsubscriptionList_ItemIEs*) pnode->data;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_e2ap_RICsubscriptionList_ItemIEs (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      //xx1++;
      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}

int asn1PD_e2ap_RICsubscriptionToBeSuspended_List (OSCTXT* pctxt, e2ap_RICsubscriptionToBeSuspended_List* ppvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_RICsubscriptionList_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "RICsubscriptionToBeSuspended-List");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1024), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (ppvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      pdata = rtxMemAllocType (pctxt, e2ap_RICsubscriptionList_ItemIEs);
      if (!pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);
      asn1Init_e2ap_RICsubscriptionList_ItemIEs (pdata);
      stat = asn1PD_e2ap_RICsubscriptionList_ItemIEs (pctxt, pdata);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         return LOG_RTERR (pctxt, stat);
      }

      rtxDListAppendNode (ppvalue, pdata);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

void asn1Init_e2ap_RICsubscriptionToBeSuspended_List (e2ap_RICsubscriptionToBeSuspended_List* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
}

void asn1Free_e2ap_RICsubscriptionToBeSuspended_List (OSCTXT* pctxt, e2ap_RICsubscriptionToBeSuspended_List* pvalue)
{
   if(pvalue==0) return;
   OSRTDListNode* pnode = pvalue->head;
   while (pnode) {
      e2ap_RICsubscriptionList_ItemIEs* pdata = (e2ap_RICsubscriptionList_ItemIEs*) pnode->data;
      if (pdata) {
         asn1Free_e2ap_RICsubscriptionList_ItemIEs (pctxt, pdata);
         rtxMemFreePtr (pctxt, pdata);
      }
      pnode = pnode->next;
   }
      rtxDListFreeAll(pctxt, pvalue);
}

#if 0
void asn1Free_e2ap_RICsubscriptionToBeSuspended_List (OSCTXT* pctxt, e2ap_RICsubscriptionToBeSuspended_List* pvalue){
   if(0==pvalue ) return;
   {
      e2ap_RICsubscriptionList_ItemIEs * pdata;
      OSRTDListNode *pnode = pvalue->head;
      while(0!=pnode){
         pdata = (e2ap_RICsubscriptionList_ItemIEs*)pnode->data;
         asn1Free_e2ap_RICsubscriptionList_ItemIEs(pctxt, pdata);
         pnode = pnode->next;
      }
      rtxDListFreeAll(pctxt, pvalue);
   }
}
#endif


int asn1PrtToStr_e2ap_RICsubscriptionToBeSuspended_List(const char* name, e2ap_RICsubscriptionToBeSuspended_List* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_RICsubscriptionList_ItemIEs* pdata;
    OSRTDListNode* pnode;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode = pvalue->head;  xx1 < pvalue->count && pnode != 0; pnode = pnode->next, xx1++){
        pdata = (e2ap_RICsubscriptionList_ItemIEs*)pnode->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 1
        if(asn1PrtToStr_e2ap_RICsubscriptionList_ItemIEs(nameBuf, pdata, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}/*****************************************/
/*           RICsubscriptionToBeResumed_List                */
/*****************************************/
//seq_of_single_container


int asn1PE_e2ap_RICsubscriptionToBeResumed_List (OSCTXT* pctxt, e2ap_RICsubscriptionToBeResumed_List* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_RICsubscriptionList_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "RICsubscriptionToBeResumed-List");

   /* encode length determinant */
   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1024), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;
   for (xx1 = 0; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next, xx1++) {
      pdata = (e2ap_RICsubscriptionList_ItemIEs*) pnode->data;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_e2ap_RICsubscriptionList_ItemIEs (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      //xx1++;
      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}

int asn1PD_e2ap_RICsubscriptionToBeResumed_List (OSCTXT* pctxt, e2ap_RICsubscriptionToBeResumed_List* ppvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_RICsubscriptionList_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "RICsubscriptionToBeResumed-List");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1024), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (ppvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      pdata = rtxMemAllocType (pctxt, e2ap_RICsubscriptionList_ItemIEs);
      if (!pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);
      asn1Init_e2ap_RICsubscriptionList_ItemIEs (pdata);
      stat = asn1PD_e2ap_RICsubscriptionList_ItemIEs (pctxt, pdata);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         return LOG_RTERR (pctxt, stat);
      }

      rtxDListAppendNode (ppvalue, pdata);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

void asn1Init_e2ap_RICsubscriptionToBeResumed_List (e2ap_RICsubscriptionToBeResumed_List* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
}

void asn1Free_e2ap_RICsubscriptionToBeResumed_List (OSCTXT* pctxt, e2ap_RICsubscriptionToBeResumed_List* pvalue)
{
   if(pvalue==0) return;
   OSRTDListNode* pnode = pvalue->head;
   while (pnode) {
      e2ap_RICsubscriptionList_ItemIEs* pdata = (e2ap_RICsubscriptionList_ItemIEs*) pnode->data;
      if (pdata) {
         asn1Free_e2ap_RICsubscriptionList_ItemIEs (pctxt, pdata);
         rtxMemFreePtr (pctxt, pdata);
      }
      pnode = pnode->next;
   }
      rtxDListFreeAll(pctxt, pvalue);
}

#if 0
void asn1Free_e2ap_RICsubscriptionToBeResumed_List (OSCTXT* pctxt, e2ap_RICsubscriptionToBeResumed_List* pvalue){
   if(0==pvalue ) return;
   {
      e2ap_RICsubscriptionList_ItemIEs * pdata;
      OSRTDListNode *pnode = pvalue->head;
      while(0!=pnode){
         pdata = (e2ap_RICsubscriptionList_ItemIEs*)pnode->data;
         asn1Free_e2ap_RICsubscriptionList_ItemIEs(pctxt, pdata);
         pnode = pnode->next;
      }
      rtxDListFreeAll(pctxt, pvalue);
   }
}
#endif


int asn1PrtToStr_e2ap_RICsubscriptionToBeResumed_List(const char* name, e2ap_RICsubscriptionToBeResumed_List* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_RICsubscriptionList_ItemIEs* pdata;
    OSRTDListNode* pnode;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode = pvalue->head;  xx1 < pvalue->count && pnode != 0; pnode = pnode->next, xx1++){
        pdata = (e2ap_RICsubscriptionList_ItemIEs*)pnode->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 1
        if(asn1PrtToStr_e2ap_RICsubscriptionList_ItemIEs(nameBuf, pdata, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}
/*****************************************/
/*           RANfunctionStateControl-Item                */
/*****************************************/
//sequence normal
// Các nội dung cần thiết cho template seq_normal.c.j2

// Các phần còn lại của template seq_normal.c.j2
//contain extensition bit -> theo mau cua GlobalgNB-ID
int asn1PE_e2ap_RANfunctionStateControl_Item (OSCTXT* pctxt, e2ap_RANfunctionStateControl_Item* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RANfunctionStateControl-Item");

   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);

   /*optional bit for field ricSubscriptionToBeSuspended_list*/
   stat = rtxEncBit (pctxt, pvalue->m_ricSubscriptionToBeSuspended_listPresent);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   /*optional bit for field ricSubscriptionToBeResumed_list*/
   stat = rtxEncBit (pctxt, pvalue->m_ricSubscriptionToBeResumed_listPresent);
   if (stat != 0) return LOG_RTERR(pctxt, stat);

   /*encode root elements*/   
   /* encode field ranFunctionID - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "ranFunctionID");
   stat = asn1PE_e2ap_RANfunctionID (pctxt, pvalue->ranFunctionID);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /* encode field ricSubscriptionToBeSuspended_list - id = -1*/  
   if (pvalue->m_ricSubscriptionToBeSuspended_listPresent) {//OPTIONAL FIELD
   RTXCTXTPUSHELEMNAME(pctxt, "ricSubscriptionToBeSuspended-list");
   stat = asn1PE_e2ap_RICsubscriptionToBeSuspended_List (pctxt, pvalue->ricSubscriptionToBeSuspended_list);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   }

   /* encode field ricSubscriptionToBeResumed_list - id = -1*/  
   if (pvalue->m_ricSubscriptionToBeResumed_listPresent) {//OPTIONAL FIELD
   RTXCTXTPUSHELEMNAME(pctxt, "ricSubscriptionToBeResumed-list");
   stat = asn1PE_e2ap_RICsubscriptionToBeResumed_List (pctxt, pvalue->ricSubscriptionToBeResumed_list);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   }


   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RANfunctionStateControl_Item (OSCTXT* pctxt, e2ap_RANfunctionStateControl_Item* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[3];

   RTXCTXTPUSHTYPENAME(pctxt, "RANfunctionStateControl-Item");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field ranFunctionID */
   RTXCTXTPUSHELEMNAME(pctxt, "ranFunctionID");
      stat = asn1PD_e2ap_RANfunctionID (pctxt, &pvalue->ranFunctionID);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field ricSubscriptionToBeSuspended_list */
   RTXCTXTPUSHELEMNAME(pctxt, "ricSubscriptionToBeSuspended-list");
   if (optbits[0]) {
      pvalue->m_ricSubscriptionToBeSuspended_listPresent = TRUE;
      stat = asn1PD_e2ap_RICsubscriptionToBeSuspended_List (pctxt, &pvalue->ricSubscriptionToBeSuspended_list);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   } else {
      pvalue->m_ricSubscriptionToBeSuspended_listPresent = FALSE;
   }
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field ricSubscriptionToBeResumed_list */
   RTXCTXTPUSHELEMNAME(pctxt, "ricSubscriptionToBeResumed-list");
   if (optbits[0]) {
      pvalue->m_ricSubscriptionToBeResumed_listPresent = TRUE;
      stat = asn1PD_e2ap_RICsubscriptionToBeResumed_List (pctxt, &pvalue->ricSubscriptionToBeResumed_list);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   } else {
      pvalue->m_ricSubscriptionToBeResumed_listPresent = FALSE;
   }
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RANfunctionStateControl_Item (e2ap_RANfunctionStateControl_Item* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RANfunctionID (&pvalue->ranFunctionID);
   asn1Init_e2ap_RICsubscriptionToBeSuspended_List (&pvalue->ricSubscriptionToBeSuspended_list);
   asn1Init_e2ap_RICsubscriptionToBeResumed_List (&pvalue->ricSubscriptionToBeResumed_list);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RANfunctionStateControl_Item (OSCTXT* pctxt, e2ap_RANfunctionStateControl_Item* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_RANfunctionID (pctxt, &pvalue->ranFunctionID);
   asn1Free_e2ap_RICsubscriptionToBeSuspended_List (pctxt, &pvalue->ricSubscriptionToBeSuspended_list);
   asn1Free_e2ap_RICsubscriptionToBeResumed_List (pctxt, &pvalue->ricSubscriptionToBeResumed_list);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RANfunctionStateControl_Item (const char* name, e2ap_RANfunctionStateControl_Item* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }
   if(asn1PrtToStr_e2ap_RANfunctionID ("ranFunctionID", &pvalue->ranFunctionID, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_RICsubscriptionToBeSuspended_List ("ricSubscriptionToBeSuspended_list", &pvalue->ricSubscriptionToBeSuspended_list, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_RICsubscriptionToBeResumed_List ("ricSubscriptionToBeResumed_list", &pvalue->ricSubscriptionToBeResumed_list, buffer, bufSize) < 0)
   {
      return -1;
   }



   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           RANfunctionStateControl_ItemIEs                */
/*****************************************/
/* ie.c.j2 */
/*ie thường*/
int asn1PE_e2ap_RANfunctionStateControl_ItemIEs (OSCTXT* pctxt, e2ap_RANfunctionStateControl_ItemIEs* pvalue)
{
   int stat = 0;
   //RTXCTXTPUSHTYPENAME (pctxt, "RANfunctionStateControl-ItemIEs");

   /* encode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");
   stat = asn1PE_e2ap_ProtocolIE_ID (pctxt, pvalue->id);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");
   stat = asn1PE_e2ap_Criticality (pctxt, pvalue->criticality);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   {
      OSCTXT ictxt;
      OSOCTET* pDynamicEncodeBuffer;
      ASN1OpenType openType;
      OSBOOL  encoded = TRUE;

      openType.numocts = 0;
      openType.data = 0;

      rtxCopyContext (&ictxt, pctxt);
      pctxt->pStream = 0;

      stat = rtxInitContextBuffer (pctxt, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_RANfunctionStateControl_ItemIEs_id_RANfunctionStateControl_Item:
         
        // RTXCTXTPUSHELEMNAME (pctxt, "RANfunctionStateControl_ItemIEs_id_RANfunctionStateControl_Item");
         RTXCTXTPUSHELEMNAME (pctxt, "RANfunctionStateControl-Item");
         stat = asn1PE_e2ap_RANfunctionStateControl_Item (pctxt, pvalue->value.u._e2apRANfunctionStateControl_ItemIEs_id_RANfunctionStateControl_Item);
         RTXCTXTPOPELEMNAME (pctxt);
      
         break;

      case T_E2AP_PDU_Contents_e2ap_RANfunctionStateControl_ItemIEs_UNDEF_:
      {
          if(0!=pvalue->value.u.extElem1){
              openType.numocts = pvalue->value.u.extElem1->numocts;
              openType.data = pvalue->value.u.extElem1->data;
          } else {
              /* No extension element to encode */
          }
          encoded = FALSE;
          break;
      }
      default:
         encoded = FALSE;
         stat = RTERR_INVOPT;
      }

      if (encoded) {
         openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
         openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
      }
      rtxCopyContext (pctxt, &ictxt);
      if(stat ==0) stat = pe_OpenType(pctxt, openType.numocts, openType.data);
      /*free dynamic encode buffer*/
      if(encoded){
          rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
      }
   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);
   //RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

int asn1PD_e2ap_RANfunctionStateControl_ItemIEs (OSCTXT* pctxt, e2ap_RANfunctionStateControl_ItemIEs* pvalue)
{
   int stat =0;
   /*deode root element id*/
   RTXCTXTPUSHELEMNAME(pctxt, "id");
   stat = asn1PD_e2ap_ProtocolIE_ID (pctxt, &pvalue->id);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*decode root element criticality*/
   RTXCTXTPUSHELEMNAME(pctxt, "criticality");
   stat = asn1PD_e2ap_Criticality (pctxt, &pvalue->criticality);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   /*decode root element value*/
   RTXCTXTPUSHELEMNAME(pctxt, "value");
   {
      OSUINT32 openTypeLen;
      size_t bitStartOffset, bitLength;
      stat = pd_UnconsLength(pctxt, &openTypeLen);
      if(stat <0) return LOG_RTERR(pctxt, stat);
      else if(stat == RT_OK_FRAG){
         rtxErrAddStrParm(pctxt, "open type with fragmented length use - perindef");
         return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
      }
      bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
      bitLength = openTypeLen * 8;
      switch (pvalue->id){
         case T_E2AP_PDU_Contents_e2ap_RANfunctionStateControl_ItemIEs_id_RANfunctionStateControl_Item:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RANfunctionStateControl_ItemIEs_id_RANfunctionStateControl_Item;
            RTXCTXTPUSHELEMNAME(pctxt, "RANfunctionStateControl-Item");
            //pvalue->value.u._e2ap_RANfunctionStateControl_ItemIEs_id_id_RANfunctionStateControl_Item 
             pvalue->value.u._e2apRANfunctionStateControl_ItemIEs_id_RANfunctionStateControl_Item 
                    = rtxMemAllocType(pctxt, e2ap_RANfunctionStateControl_Item);
            //asn1Init_e2ap_RANfunctionStateControl_Item(pvalue->value.u._e2ap_RANfunctionStateControl_ItemIEs_id_id_RANfunctionStateControl_Item);
            asn1Init_e2ap_RANfunctionStateControl_Item(pvalue->value.u._e2apRANfunctionStateControl_ItemIEs_id_RANfunctionStateControl_Item);
            stat = asn1PD_e2ap_RANfunctionStateControl_Item (pctxt,
                    (e2ap_RANfunctionStateControl_Item*)pvalue->value.
                    u._e2apRANfunctionStateControl_ItemIEs_id_RANfunctionStateControl_Item);
            if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RANfunctionStateControl_ItemIEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*)rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
      }
      {
      size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
      size_t bitsConsumed = bitEndOffset - bitStartOffset;
      if(bitsConsumed < bitLength){
         stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
      } else {
         stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
      }
      }
   }
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   return stat;
}

void asn1Init_e2ap_RANfunctionStateControl_ItemIEs (e2ap_RANfunctionStateControl_ItemIEs* pvalue)
{
   if (!pvalue) return;
   OSCRTLMEMSET (pvalue, 0, sizeof(e2ap_RANfunctionStateControl_ItemIEs));
}

#if 0
void asn1Free_e2ap_RANfunctionStateControl_ItemIEs (OSCTXT* pctxt, e2ap_RANfunctionStateControl_ItemIEs* pvalue)
{
   if (!pvalue) return;
   if (pvalue->extElem1) {
      rtxMemFreeArray (pctxt, pvalue->extElem1);
      pvalue->extElem1 = 0;
      pvalue->extElem1_n = 0;
   }
}
#endif
void asn1Free_e2ap_RANfunctionStateControl_ItemIEs (OSCTXT* pctxt, e2ap_RANfunctionStateControl_ItemIEs* pvalue)
{
   if(0==pvalue) return;
   switch(pvalue->value.t){
      case T_E2AP_PDU_Contents_e2ap_RANfunctionStateControl_ItemIEs_id_RANfunctionStateControl_Item:
         asn1Free_e2ap_RANfunctionStateControl_Item (pctxt, pvalue->value.u._e2apRANfunctionStateControl_ItemIEs_id_RANfunctionStateControl_Item);
         rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2apRANfunctionStateControl_ItemIEs_id_RANfunctionStateControl_Item);
         pvalue->value.u._e2apRANfunctionStateControl_ItemIEs_id_RANfunctionStateControl_Item = 0;
         break;
      case T_E2AP_PDU_Contents_e2ap_RANfunctionStateControl_ItemIEs_UNDEF_:
         if(0!=pvalue->value.u.extElem1){
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1->data);
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
             pvalue->value.u.extElem1 =0;
         }
         break;
         default:;
   }
}

int  asn1PrtToStr_e2ap_RANfunctionStateControl_ItemIEs (const char * name, e2ap_RANfunctionStateControl_ItemIEs* pvalue, char * buffer, OSSIZE bufSize){
   if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
       return -1;

      if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
         return -1;

      if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
         return -1;
      if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
         return -1;
      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_RANfunctionStateControl_ItemIEs_id_RANfunctionStateControl_Item:
         if(asn1PrtToStr_e2ap_RANfunctionStateControl_Item("RANfunctionStateControl-Item",
                pvalue->value.u._e2apRANfunctionStateControl_ItemIEs_id_RANfunctionStateControl_Item, buffer, bufSize)<0)// dungnm23 check lai nhe xem la
            return -1;
         break;
      default:
         if(0!=pvalue -> value.u.extElem1){
             rtPrintToStringIndent(buffer, bufSize);
             rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

         }
      }
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

      return 0;

}
 

/*****************************************/
/*           RANfunctionStateControl_List                */
/*****************************************/
//seq_of_single_container


int asn1PE_e2ap_RANfunctionStateControl_List (OSCTXT* pctxt, e2ap_RANfunctionStateControl_List* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_RANfunctionStateControl_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "RANfunctionStateControl-List");

   /* encode length determinant */
   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(256), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;
   for (xx1 = 0; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next, xx1++) {
      pdata = (e2ap_RANfunctionStateControl_ItemIEs*) pnode->data;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_e2ap_RANfunctionStateControl_ItemIEs (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      //xx1++;
      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}

int asn1PD_e2ap_RANfunctionStateControl_List (OSCTXT* pctxt, e2ap_RANfunctionStateControl_List* ppvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_RANfunctionStateControl_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "RANfunctionStateControl-List");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(256), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (ppvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      pdata = rtxMemAllocType (pctxt, e2ap_RANfunctionStateControl_ItemIEs);
      if (!pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);
      asn1Init_e2ap_RANfunctionStateControl_ItemIEs (pdata);
      stat = asn1PD_e2ap_RANfunctionStateControl_ItemIEs (pctxt, pdata);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         return LOG_RTERR (pctxt, stat);
      }

      rtxDListAppendNode (ppvalue, pdata);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

void asn1Init_e2ap_RANfunctionStateControl_List (e2ap_RANfunctionStateControl_List* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
}

void asn1Free_e2ap_RANfunctionStateControl_List (OSCTXT* pctxt, e2ap_RANfunctionStateControl_List* pvalue)
{
   if(pvalue==0) return;
   OSRTDListNode* pnode = pvalue->head;
   while (pnode) {
      e2ap_RANfunctionStateControl_ItemIEs* pdata = (e2ap_RANfunctionStateControl_ItemIEs*) pnode->data;
      if (pdata) {
         asn1Free_e2ap_RANfunctionStateControl_ItemIEs (pctxt, pdata);
         rtxMemFreePtr (pctxt, pdata);
      }
      pnode = pnode->next;
   }
      rtxDListFreeAll(pctxt, pvalue);
}

#if 0
void asn1Free_e2ap_RANfunctionStateControl_List (OSCTXT* pctxt, e2ap_RANfunctionStateControl_List* pvalue){
   if(0==pvalue ) return;
   {
      e2ap_RANfunctionStateControl_ItemIEs * pdata;
      OSRTDListNode *pnode = pvalue->head;
      while(0!=pnode){
         pdata = (e2ap_RANfunctionStateControl_ItemIEs*)pnode->data;
         asn1Free_e2ap_RANfunctionStateControl_ItemIEs(pctxt, pdata);
         pnode = pnode->next;
      }
      rtxDListFreeAll(pctxt, pvalue);
   }
}
#endif


int asn1PrtToStr_e2ap_RANfunctionStateControl_List(const char* name, e2ap_RANfunctionStateControl_List* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_RANfunctionStateControl_ItemIEs* pdata;
    OSRTDListNode* pnode;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode = pvalue->head;  xx1 < pvalue->count && pnode != 0; pnode = pnode->next, xx1++){
        pdata = (e2ap_RANfunctionStateControl_ItemIEs*)pnode->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 1
        if(asn1PrtToStr_e2ap_RANfunctionStateControl_ItemIEs(nameBuf, pdata, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}/*****************************************/
/*           RICsubscriptionStateControlRequest_IEs                */
/*****************************************/
/* ie.c.j2 */
 /* d là con của msg */
EXTERN int asn1PE_e2ap_RICsubscriptionStateControlRequest_protocolIEs_element (OSCTXT* pctxt, e2ap_RICsubscriptionStateControlRequest_protocolIEs_element* pvalue)
{
    int stat =0;

    /*encode id*/

    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PE_e2ap_ProtocolIE_ID(pctxt, pvalue->id);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PE_e2ap_Criticality(pctxt, pvalue->criticality);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
    {
        OSCTXT lctxt;
        OSOCTET *pDynamicEncodeBuffer;
        ASN1OpenType openType;
        OSBOOL encoded = TRUE;

        openType.numocts = 0;
        openType.data =0;

        rtxCopyContext(&lctxt, pctxt);
        pctxt->pStream =0;

        stat = rtxInitContextBuffer(pctxt, 0, 0);
        if(stat!=0) return LOG_RTERR(pctxt, stat);

        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionStateControlRequest_IEs_id_RICrequestID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICrequestID");
                    stat = asn1PE_e2ap_RICrequestID (pctxt, pvalue->value.u._e2ap_RICsubscriptionStateControlRequest_IEs_id_RICrequestID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionStateControlRequest_IEs_id_RANfunctionStateControl_List:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RANfunctionStateControl-List");
                    stat = asn1PE_e2ap_RANfunctionStateControl_List (pctxt, pvalue->value.u._e2ap_RICsubscriptionStateControlRequest_IEs_id_RANfunctionStateControl_List);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionStateControlRequest_IEs_UNDEF_:
            {
                if(0!=pvalue->value.u.extElem1){
                    openType.numocts = pvalue->value.u.extElem1->numocts;
                    openType.data = pvalue->value.u.extElem1->data;
                } else {
                    /* No extension element to encode */
                }
                encoded = FALSE;
                break;
            }

            default:
                encoded = FALSE;
                stat = RTERR_INVOPT;
                break;
        } 

        if(encoded){
            openType.numocts = (OSUINT32)pe_GetMsgLen(pctxt);
            openType.data = pDynamicEncodeBuffer = pctxt -> buffer.data;
        }
        rtxCopyContext(pctxt, &lctxt);

        if(stat == 0) {
            stat = pe_OpenType (pctxt, openType.numocts, openType.data);
        }
    #if 1
        if(encoded){//dungnm23 check lai nhe
            rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
        }
    #endif

    }

    if(stat!=0) return LOG_RTERR(pctxt, stat);  
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}

EXTERN int  asn1PD_e2ap_RICsubscriptionStateControlRequest_protocolIEs_element (OSCTXT* pctxt, e2ap_RICsubscriptionStateControlRequest_protocolIEs_element* pvalue){
    int stat =0;

    /*decode id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PD_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PD_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");

    {
        OSUINT32 openTypeLen;
        size_t bitStartOffset, bitLength;

        stat = pd_UnconsLength(pctxt, &openTypeLen);
        if(stat<0) return LOG_RTERR(pctxt, stat);
        else if(stat == RT_OK_FRAG){
            rtxErrAddStrParm(pctxt, "open type with fragment length");
            return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
        }
        bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
        bitLength = openTypeLen * 8;

        switch(pvalue->id){//dungnm23 check case lai nhe
        
            case ASN1V_e2ap_id_RICrequestID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionStateControlRequest_IEs_id_RICrequestID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICrequestID");
                pvalue->value.u._e2ap_RICsubscriptionStateControlRequest_IEs_id_RICrequestID 
                    = rtxMemAllocType(pctxt, e2ap_RICrequestID);

                asn1Init_e2ap_RICrequestID(pvalue->value.u._e2ap_RICsubscriptionStateControlRequest_IEs_id_RICrequestID);

                stat = asn1PD_e2ap_RICrequestID (pctxt,
                        (e2ap_RICrequestID*)pvalue->value.
                        u._e2ap_RICsubscriptionStateControlRequest_IEs_id_RICrequestID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RANfunctionStateControl_List:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionStateControlRequest_IEs_id_RANfunctionStateControl_List;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RANfunctionStateControl-List");
                pvalue->value.u._e2ap_RICsubscriptionStateControlRequest_IEs_id_RANfunctionStateControl_List 
                    = rtxMemAllocType(pctxt, e2ap_RANfunctionStateControl_List);

                asn1Init_e2ap_RANfunctionStateControl_List(pvalue->value.u._e2ap_RICsubscriptionStateControlRequest_IEs_id_RANfunctionStateControl_List);

                stat = asn1PD_e2ap_RANfunctionStateControl_List (pctxt,
                        (e2ap_RANfunctionStateControl_List*)pvalue->value.
                        u._e2ap_RICsubscriptionStateControlRequest_IEs_id_RANfunctionStateControl_List);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionStateControlRequest_IEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*) rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
    }
    {
    size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
    size_t bitsConsumed = bitEndOffset-bitStartOffset;
    if(bitsConsumed<bitLength){
        stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
    }
    else stat =(bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
    }}
    if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}


int asn1Init_e2ap_RICsubscriptionStateControlRequest_protocolIEs_element(e2ap_RICsubscriptionStateControlRequest_protocolIEs_element* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    OSCRTLMEMSET (&pvalue->value, 0, sizeof(pvalue->value));
    return 0;
}


//-----> chuaw có template rtxFreeASN1OpenType

#if 0
void asn1Free_e2ap_RICsubscriptionStateControlRequest_protocolIEs_element(OSCTXT* pctxt, e2ap_RICsubscriptionStateControlRequest_protocolIEs_element* pvalue)
{
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionStateControlRequest_IEs_id_id_RICrequestID:
            // rtxFreeE2ap_RICrequestID(pvalue->value.u._e2ap_RICsubscriptionStateControlRequest_IEs_id_id_RICrequestID);

            if(pvalue->value.i._e2ap_RICsubscriptionStateControlRequest_id_RICrequestID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICrequestID(pctxt, pvalue->value.u._e2ap_RICsubscriptionStateControlRequest_IEs_id_id_RICrequestID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionStateControlRequest_IEs_id_id_RICrequestID);
           // pvalue->value.u._e2ap_RICsubscriptionStateControlRequest_IEs_id_id_RICrequestID = NULL;
           pvalue->value.u._e2ap_RICsubscriptionStateControlRequest_IEs_id_RICrequestID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionStateControlRequest_IEs_id_id_RANfunctionStateControl_List:
            // rtxFreeE2ap_RANfunctionStateControl_List(pvalue->value.u._e2ap_RICsubscriptionStateControlRequest_IEs_id_id_RANfunctionStateControl_List);

            if(pvalue->value.i._e2ap_RICsubscriptionStateControlRequest_id_RANfunctionStateControl_List!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RANfunctionStateControl_List(pctxt, pvalue->value.u._e2ap_RICsubscriptionStateControlRequest_IEs_id_id_RANfunctionStateControl_List);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionStateControlRequest_IEs_id_id_RANfunctionStateControl_List);
           // pvalue->value.u._e2ap_RICsubscriptionStateControlRequest_IEs_id_id_RANfunctionStateControl_List = NULL;
           pvalue->value.u._e2ap_RICsubscriptionStateControlRequest_IEs_id_RANfunctionStateControl_List = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionStateControlRequest_IEs_UNDEF_:
            rtxFreeASN1OpenType(pvalue->value.u.extElem1);
            break;
        default:
            break;
    }
}

int asn1PrtToStr_e2ap_RICsubscriptionStateControlRequest_protocolIEs_element(OSCTXT* pctxt, e2ap_RICsubscriptionStateControlRequest_protocolIEs_element* pvalue)
{
    int stat =0;
    RTXCTXTPUSHELEMNAME(pctxt, "e2ap_RICsubscriptionStateControlRequest_protocolIEs_element");

    /*print id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PrtToStr_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PrtToStr_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionStateControlRequest_IEs_id_id_RICrequestID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICrequestID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICrequestID (pctxt, pvalue->value.u._e2ap_RICsubscriptionStateControlRequest_IEs_id_id_RICrequestID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionStateControlRequest_IEs_id_id_RANfunctionStateControl_List:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RANfunctionStateControl-List");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RANfunctionStateControl_List (pctxt, pvalue->value.u._e2ap_RICsubscriptionStateControlRequest_IEs_id_id_RANfunctionStateControl_List);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionStateControlRequest_IEs_UNDEF_:
            {
                rtxPLogMsg(pctxt, "Extension element present - raw data not printed.\n");
                break;
            }

            default:
                stat = RTERR_INVOPT;
                return LOG_RTERR(pctxt, stat);
        }
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);
}
#endif


int asn1PrtToStr_e2ap_RICsubscriptionStateControlRequest_protocolIEs_element (const char * name,
 e2ap_RICsubscriptionStateControlRequest_protocolIEs_element* pvalue, 
 char * buffer, OSSIZE bufSize){
    if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
        return -1;
    if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
        return -1;

    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionStateControlRequest_IEs_id_RICrequestID:
            if(asn1PrtToStr_e2ap_RICrequestID("RICrequestID", 
                    pvalue->value.u._e2ap_RICsubscriptionStateControlRequest_IEs_id_RICrequestID, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionStateControlRequest_IEs_id_RANfunctionStateControl_List:
            if(asn1PrtToStr_e2ap_RANfunctionStateControl_List("RANfunctionStateControl-List", 
                    pvalue->value.u._e2ap_RICsubscriptionStateControlRequest_IEs_id_RANfunctionStateControl_List, buffer, bufSize)<0)
                return -1;
            break;    
        default:
        if(0!=pvalue -> value.u.extElem1){
            rtPrintToStringIndent(buffer, bufSize);
            rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

        }
        }
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

    return 0;

 }

 void asn1Free_e2ap_RICsubscriptionStateControlRequest_protocolIEs_element(OSCTXT* pctxt, e2ap_RICsubscriptionStateControlRequest_protocolIEs_element* pvalue){
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionStateControlRequest_IEs_id_RICrequestID:
            if(pvalue->value.u._e2ap_RICsubscriptionStateControlRequest_IEs_id_RICrequestID!=NULL){
            asn1Free_e2ap_RICrequestID(pctxt, pvalue->value.u._e2ap_RICsubscriptionStateControlRequest_IEs_id_RICrequestID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionStateControlRequest_IEs_id_RICrequestID);
            pvalue->value.u._e2ap_RICsubscriptionStateControlRequest_IEs_id_RICrequestID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionStateControlRequest_IEs_id_RANfunctionStateControl_List:
            if(pvalue->value.u._e2ap_RICsubscriptionStateControlRequest_IEs_id_RANfunctionStateControl_List!=NULL){
            asn1Free_e2ap_RANfunctionStateControl_List(pctxt, pvalue->value.u._e2ap_RICsubscriptionStateControlRequest_IEs_id_RANfunctionStateControl_List);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionStateControlRequest_IEs_id_RANfunctionStateControl_List);
            pvalue->value.u._e2ap_RICsubscriptionStateControlRequest_IEs_id_RANfunctionStateControl_List = NULL;
            }
            break;
        default:
            break;


    }
 }

 

/*****************************************/
/*           RICsubscriptionStateControlRequest                */
/*****************************************/
//2_container.c
/* 1. xxx_ProtocolIE -> mẫu cũ ở ie_big_msg */
EXTERN int asn1PE_e2ap_RICsubscriptionStateControlRequest_protocolIEs (OSCTXT* pctxt, e2ap_RICsubscriptionStateControlRequest_protocolIEs* pvalue)
{
    int stat =0;
    OSRTDListNode* pnode;
    OSUINT32 xx1;

    /*encode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pe_Length(pctxt, pvalue->count);
    if(stat<0) return LOG_RTERR(pctxt, stat);

    /*encode each element*/
    xx1 =0;
    for(pnode = pvalue->head; pnode != 0 && xx1<pvalue->count; pnode = pnode->next){
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE", xx1);
        stat = asn1PE_e2ap_RICsubscriptionStateControlRequest_protocolIEs_element (pctxt, ((e2ap_RICsubscriptionStateControlRequest_protocolIEs_element*)pnode->data));
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        xx1++;
        RTXCTXTPOPARRAYELEMNAME(pctxt);
    }

    return (stat);
}

EXTERN int  asn1PD_e2ap_RICsubscriptionStateControlRequest_protocolIEs(OSCTXT* pctxt, e2ap_RICsubscriptionStateControlRequest_protocolIEs* pvalue)
{
     int stat =0;
     OSRTDListNode* pnode;
     OSSIZE count =0;
     OSSIZE xx1=0;


     /*decode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pd_Length64(pctxt, &count); //tai sao lai 64
    if(stat!=0) return LOG_RTERR(pctxt, stat);

    /*decode each element*/
    rtxDListInit(pvalue);

    for(xx1=0; xx1 < count; xx1++){
        e2ap_RICsubscriptionStateControlRequest_protocolIEs_element* pdata;
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE",xx1);

        if(pnode == NULL) return LOG_RTERR(pctxt, RTERR_NOMEM);

        asn1Init_e2ap_RICsubscriptionStateControlRequest_protocolIEs_element(pdata);
        rtxDListAppendNode(pvalue, pnode);
        stat = asn1PD_e2ap_RICsubscriptionStateControlRequest_protocolIEs_element (pctxt, pdata);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        RTXCTXTPOPARRAYELEMNAME(pctxt);

    }
    return (stat);
}


int asn1Init_e2ap_RICsubscriptionStateControlRequest_protocolIEs(e2ap_RICsubscriptionStateControlRequest_protocolIEs* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    rtxDListFastInit (pvalue);
    return 0;
}
#if 1 //ao that day
void asn1Free_e2ap_RICsubscriptionStateControlRequest_protocolIEs(OSCTXT* pctxt, e2ap_RICsubscriptionStateControlRequest_protocolIEs* pvalue)
{
    if(0==pvalue) return;   
    e2ap_RICsubscriptionStateControlRequest_protocolIEs_element* pdata;
    OSRTDListNode* pnode=pvalue->head;
    while(0!=pnode){
        pdata = (e2ap_RICsubscriptionStateControlRequest_protocolIEs_element*)pnode->data;
       // asn1Free_e2ap_RICsubscriptionStateControlRequest_protocolIEs_element(pctxt, pdata);
        pnode = pnode->next;
    }
    rtxDListFreeAll(pctxt, pvalue);
}
#endif


EXTERN int asn1PrtToStr_e2ap_RICsubscriptionStateControlRequest_protocolIEs(const char* name, e2ap_RICsubscriptionStateControlRequest_protocolIEs* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_RICsubscriptionStateControlRequest_protocolIEs_element* pdata0;
    OSRTDListNode* pnode0;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode0 = pvalue->head;  xx1 < pvalue->count && pnode0 != 0; pnode0 = pnode0->next, xx1++){
        pdata0 = (e2ap_RICsubscriptionStateControlRequest_protocolIEs_element*)pnode0->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 0
        if(asn1PrtToStr_e2ap_RICsubscriptionStateControlRequest_protocolIEs_element(nameBuf, pdata0, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}


/*2 . RICsubscriptionStateControlRequest -> mẫu cũ ở seq_normal*/

int asn1PE_e2ap_RICsubscriptionStateControlRequest (OSCTXT* pctxt, e2ap_RICsubscriptionStateControlRequest* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RICsubscriptionStateControlRequest");
   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field protocolIEs - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
   stat = asn1PE_e2ap_RICsubscriptionStateControlRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if(stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RICsubscriptionStateControlRequest (OSCTXT* pctxt, e2ap_RICsubscriptionStateControlRequest* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME(pctxt, "RICsubscriptionStateControlRequest");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field protocolIEs */
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
      stat = asn1PD_e2ap_RICsubscriptionStateControlRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RICsubscriptionStateControlRequest (e2ap_RICsubscriptionStateControlRequest* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RICsubscriptionStateControlRequest_protocolIEs(&pvalue->protocolIEs);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RICsubscriptionStateControlRequest (OSCTXT* pctxt, e2ap_RICsubscriptionStateControlRequest* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_RICsubscriptionStateControlRequest_protocolIEs(pctxt, &pvalue->protocolIEs);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RICsubscriptionStateControlRequest (const char* name, e2ap_RICsubscriptionStateControlRequest* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }

   if(asn1PrtToStr_e2ap_RICsubscriptionStateControlRequest_protocolIEs("protocolIEs", &pvalue->protocolIEs, buffer, bufSize) <0){
      return -1;
   }

   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           RICsubscriptionSuspended_List                */
/*****************************************/
//seq_of_single_container


int asn1PE_e2ap_RICsubscriptionSuspended_List (OSCTXT* pctxt, e2ap_RICsubscriptionSuspended_List* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_RICsubscriptionList_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "RICsubscriptionSuspended-List");

   /* encode length determinant */
   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1024), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;
   for (xx1 = 0; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next, xx1++) {
      pdata = (e2ap_RICsubscriptionList_ItemIEs*) pnode->data;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_e2ap_RICsubscriptionList_ItemIEs (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      //xx1++;
      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}

int asn1PD_e2ap_RICsubscriptionSuspended_List (OSCTXT* pctxt, e2ap_RICsubscriptionSuspended_List* ppvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_RICsubscriptionList_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "RICsubscriptionSuspended-List");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1024), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (ppvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      pdata = rtxMemAllocType (pctxt, e2ap_RICsubscriptionList_ItemIEs);
      if (!pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);
      asn1Init_e2ap_RICsubscriptionList_ItemIEs (pdata);
      stat = asn1PD_e2ap_RICsubscriptionList_ItemIEs (pctxt, pdata);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         return LOG_RTERR (pctxt, stat);
      }

      rtxDListAppendNode (ppvalue, pdata);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

void asn1Init_e2ap_RICsubscriptionSuspended_List (e2ap_RICsubscriptionSuspended_List* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
}

void asn1Free_e2ap_RICsubscriptionSuspended_List (OSCTXT* pctxt, e2ap_RICsubscriptionSuspended_List* pvalue)
{
   if(pvalue==0) return;
   OSRTDListNode* pnode = pvalue->head;
   while (pnode) {
      e2ap_RICsubscriptionList_ItemIEs* pdata = (e2ap_RICsubscriptionList_ItemIEs*) pnode->data;
      if (pdata) {
         asn1Free_e2ap_RICsubscriptionList_ItemIEs (pctxt, pdata);
         rtxMemFreePtr (pctxt, pdata);
      }
      pnode = pnode->next;
   }
      rtxDListFreeAll(pctxt, pvalue);
}

#if 0
void asn1Free_e2ap_RICsubscriptionSuspended_List (OSCTXT* pctxt, e2ap_RICsubscriptionSuspended_List* pvalue){
   if(0==pvalue ) return;
   {
      e2ap_RICsubscriptionList_ItemIEs * pdata;
      OSRTDListNode *pnode = pvalue->head;
      while(0!=pnode){
         pdata = (e2ap_RICsubscriptionList_ItemIEs*)pnode->data;
         asn1Free_e2ap_RICsubscriptionList_ItemIEs(pctxt, pdata);
         pnode = pnode->next;
      }
      rtxDListFreeAll(pctxt, pvalue);
   }
}
#endif


int asn1PrtToStr_e2ap_RICsubscriptionSuspended_List(const char* name, e2ap_RICsubscriptionSuspended_List* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_RICsubscriptionList_ItemIEs* pdata;
    OSRTDListNode* pnode;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode = pvalue->head;  xx1 < pvalue->count && pnode != 0; pnode = pnode->next, xx1++){
        pdata = (e2ap_RICsubscriptionList_ItemIEs*)pnode->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 1
        if(asn1PrtToStr_e2ap_RICsubscriptionList_ItemIEs(nameBuf, pdata, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}/*****************************************/
/*           RICsubscriptionResumed_List                */
/*****************************************/
//seq_of_single_container


int asn1PE_e2ap_RICsubscriptionResumed_List (OSCTXT* pctxt, e2ap_RICsubscriptionResumed_List* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_RICsubscriptionList_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "RICsubscriptionResumed-List");

   /* encode length determinant */
   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1024), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;
   for (xx1 = 0; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next, xx1++) {
      pdata = (e2ap_RICsubscriptionList_ItemIEs*) pnode->data;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_e2ap_RICsubscriptionList_ItemIEs (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      //xx1++;
      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}

int asn1PD_e2ap_RICsubscriptionResumed_List (OSCTXT* pctxt, e2ap_RICsubscriptionResumed_List* ppvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_RICsubscriptionList_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "RICsubscriptionResumed-List");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1024), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (ppvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      pdata = rtxMemAllocType (pctxt, e2ap_RICsubscriptionList_ItemIEs);
      if (!pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);
      asn1Init_e2ap_RICsubscriptionList_ItemIEs (pdata);
      stat = asn1PD_e2ap_RICsubscriptionList_ItemIEs (pctxt, pdata);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         return LOG_RTERR (pctxt, stat);
      }

      rtxDListAppendNode (ppvalue, pdata);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

void asn1Init_e2ap_RICsubscriptionResumed_List (e2ap_RICsubscriptionResumed_List* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
}

void asn1Free_e2ap_RICsubscriptionResumed_List (OSCTXT* pctxt, e2ap_RICsubscriptionResumed_List* pvalue)
{
   if(pvalue==0) return;
   OSRTDListNode* pnode = pvalue->head;
   while (pnode) {
      e2ap_RICsubscriptionList_ItemIEs* pdata = (e2ap_RICsubscriptionList_ItemIEs*) pnode->data;
      if (pdata) {
         asn1Free_e2ap_RICsubscriptionList_ItemIEs (pctxt, pdata);
         rtxMemFreePtr (pctxt, pdata);
      }
      pnode = pnode->next;
   }
      rtxDListFreeAll(pctxt, pvalue);
}

#if 0
void asn1Free_e2ap_RICsubscriptionResumed_List (OSCTXT* pctxt, e2ap_RICsubscriptionResumed_List* pvalue){
   if(0==pvalue ) return;
   {
      e2ap_RICsubscriptionList_ItemIEs * pdata;
      OSRTDListNode *pnode = pvalue->head;
      while(0!=pnode){
         pdata = (e2ap_RICsubscriptionList_ItemIEs*)pnode->data;
         asn1Free_e2ap_RICsubscriptionList_ItemIEs(pctxt, pdata);
         pnode = pnode->next;
      }
      rtxDListFreeAll(pctxt, pvalue);
   }
}
#endif


int asn1PrtToStr_e2ap_RICsubscriptionResumed_List(const char* name, e2ap_RICsubscriptionResumed_List* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_RICsubscriptionList_ItemIEs* pdata;
    OSRTDListNode* pnode;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode = pvalue->head;  xx1 < pvalue->count && pnode != 0; pnode = pnode->next, xx1++){
        pdata = (e2ap_RICsubscriptionList_ItemIEs*)pnode->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 1
        if(asn1PrtToStr_e2ap_RICsubscriptionList_ItemIEs(nameBuf, pdata, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}
/*****************************************/
/*           RANfunctionStateConfirm-Item                */
/*****************************************/
//sequence normal
// Các nội dung cần thiết cho template seq_normal.c.j2

// Các phần còn lại của template seq_normal.c.j2
//contain extensition bit -> theo mau cua GlobalgNB-ID
int asn1PE_e2ap_RANfunctionStateConfirm_Item (OSCTXT* pctxt, e2ap_RANfunctionStateConfirm_Item* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RANfunctionStateConfirm-Item");

   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);

   /*optional bit for field ricSubscriptionSuspended_list*/
   stat = rtxEncBit (pctxt, pvalue->m_ricSubscriptionSuspended_listPresent);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   /*optional bit for field ricSubscriptionResumed_list*/
   stat = rtxEncBit (pctxt, pvalue->m_ricSubscriptionResumed_listPresent);
   if (stat != 0) return LOG_RTERR(pctxt, stat);

   /*encode root elements*/   
   /* encode field ranFunctionID - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "ranFunctionID");
   stat = asn1PE_e2ap_RANfunctionID (pctxt, pvalue->ranFunctionID);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /* encode field ricSubscriptionSuspended_list - id = -1*/  
   if (pvalue->m_ricSubscriptionSuspended_listPresent) {//OPTIONAL FIELD
   RTXCTXTPUSHELEMNAME(pctxt, "ricSubscriptionSuspended-list");
   stat = asn1PE_e2ap_RICsubscriptionSuspended_List (pctxt, pvalue->ricSubscriptionSuspended_list);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   }

   /* encode field ricSubscriptionResumed_list - id = -1*/  
   if (pvalue->m_ricSubscriptionResumed_listPresent) {//OPTIONAL FIELD
   RTXCTXTPUSHELEMNAME(pctxt, "ricSubscriptionResumed-list");
   stat = asn1PE_e2ap_RICsubscriptionResumed_List (pctxt, pvalue->ricSubscriptionResumed_list);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   }


   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RANfunctionStateConfirm_Item (OSCTXT* pctxt, e2ap_RANfunctionStateConfirm_Item* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[3];

   RTXCTXTPUSHTYPENAME(pctxt, "RANfunctionStateConfirm-Item");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field ranFunctionID */
   RTXCTXTPUSHELEMNAME(pctxt, "ranFunctionID");
      stat = asn1PD_e2ap_RANfunctionID (pctxt, &pvalue->ranFunctionID);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field ricSubscriptionSuspended_list */
   RTXCTXTPUSHELEMNAME(pctxt, "ricSubscriptionSuspended-list");
   if (optbits[0]) {
      pvalue->m_ricSubscriptionSuspended_listPresent = TRUE;
      stat = asn1PD_e2ap_RICsubscriptionSuspended_List (pctxt, &pvalue->ricSubscriptionSuspended_list);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   } else {
      pvalue->m_ricSubscriptionSuspended_listPresent = FALSE;
   }
   RTXCTXTPOPELEMNAME(pctxt);

   /* decode field ricSubscriptionResumed_list */
   RTXCTXTPUSHELEMNAME(pctxt, "ricSubscriptionResumed-list");
   if (optbits[0]) {
      pvalue->m_ricSubscriptionResumed_listPresent = TRUE;
      stat = asn1PD_e2ap_RICsubscriptionResumed_List (pctxt, &pvalue->ricSubscriptionResumed_list);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   } else {
      pvalue->m_ricSubscriptionResumed_listPresent = FALSE;
   }
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RANfunctionStateConfirm_Item (e2ap_RANfunctionStateConfirm_Item* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RANfunctionID (&pvalue->ranFunctionID);
   asn1Init_e2ap_RICsubscriptionSuspended_List (&pvalue->ricSubscriptionSuspended_list);
   asn1Init_e2ap_RICsubscriptionResumed_List (&pvalue->ricSubscriptionResumed_list);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RANfunctionStateConfirm_Item (OSCTXT* pctxt, e2ap_RANfunctionStateConfirm_Item* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_RANfunctionID (pctxt, &pvalue->ranFunctionID);
   asn1Free_e2ap_RICsubscriptionSuspended_List (pctxt, &pvalue->ricSubscriptionSuspended_list);
   asn1Free_e2ap_RICsubscriptionResumed_List (pctxt, &pvalue->ricSubscriptionResumed_list);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RANfunctionStateConfirm_Item (const char* name, e2ap_RANfunctionStateConfirm_Item* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }
   if(asn1PrtToStr_e2ap_RANfunctionID ("ranFunctionID", &pvalue->ranFunctionID, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_RICsubscriptionSuspended_List ("ricSubscriptionSuspended_list", &pvalue->ricSubscriptionSuspended_list, buffer, bufSize) < 0)
   {
      return -1;
   }


   if(asn1PrtToStr_e2ap_RICsubscriptionResumed_List ("ricSubscriptionResumed_list", &pvalue->ricSubscriptionResumed_list, buffer, bufSize) < 0)
   {
      return -1;
   }



   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           RANfunctionStateConfirm_ItemIEs                */
/*****************************************/
/* ie.c.j2 */
/*ie thường*/
int asn1PE_e2ap_RANfunctionStateConfirm_ItemIEs (OSCTXT* pctxt, e2ap_RANfunctionStateConfirm_ItemIEs* pvalue)
{
   int stat = 0;
   //RTXCTXTPUSHTYPENAME (pctxt, "RANfunctionStateConfirm-ItemIEs");

   /* encode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");
   stat = asn1PE_e2ap_ProtocolIE_ID (pctxt, pvalue->id);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");
   stat = asn1PE_e2ap_Criticality (pctxt, pvalue->criticality);//xoa con tro
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   {
      OSCTXT ictxt;
      OSOCTET* pDynamicEncodeBuffer;
      ASN1OpenType openType;
      OSBOOL  encoded = TRUE;

      openType.numocts = 0;
      openType.data = 0;

      rtxCopyContext (&ictxt, pctxt);
      pctxt->pStream = 0;

      stat = rtxInitContextBuffer (pctxt, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_RANfunctionStateConfirm_ItemIEs_id_RANfunctionStateConfirm_Item:
         
        // RTXCTXTPUSHELEMNAME (pctxt, "RANfunctionStateConfirm_ItemIEs_id_RANfunctionStateConfirm_Item");
         RTXCTXTPUSHELEMNAME (pctxt, "RANfunctionStateConfirm-Item");
         stat = asn1PE_e2ap_RANfunctionStateConfirm_Item (pctxt, pvalue->value.u._e2apRANfunctionStateConfirm_ItemIEs_id_RANfunctionStateConfirm_Item);
         RTXCTXTPOPELEMNAME (pctxt);
      
         break;

      case T_E2AP_PDU_Contents_e2ap_RANfunctionStateConfirm_ItemIEs_UNDEF_:
      {
          if(0!=pvalue->value.u.extElem1){
              openType.numocts = pvalue->value.u.extElem1->numocts;
              openType.data = pvalue->value.u.extElem1->data;
          } else {
              /* No extension element to encode */
          }
          encoded = FALSE;
          break;
      }
      default:
         encoded = FALSE;
         stat = RTERR_INVOPT;
      }

      if (encoded) {
         openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
         openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
      }
      rtxCopyContext (pctxt, &ictxt);
      if(stat ==0) stat = pe_OpenType(pctxt, openType.numocts, openType.data);
      /*free dynamic encode buffer*/
      if(encoded){
          rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
      }
   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPELEMNAME (pctxt);
   //RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

int asn1PD_e2ap_RANfunctionStateConfirm_ItemIEs (OSCTXT* pctxt, e2ap_RANfunctionStateConfirm_ItemIEs* pvalue)
{
   int stat =0;
   /*deode root element id*/
   RTXCTXTPUSHELEMNAME(pctxt, "id");
   stat = asn1PD_e2ap_ProtocolIE_ID (pctxt, &pvalue->id);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*decode root element criticality*/
   RTXCTXTPUSHELEMNAME(pctxt, "criticality");
   stat = asn1PD_e2ap_Criticality (pctxt, &pvalue->criticality);
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   /*decode root element value*/
   RTXCTXTPUSHELEMNAME(pctxt, "value");
   {
      OSUINT32 openTypeLen;
      size_t bitStartOffset, bitLength;
      stat = pd_UnconsLength(pctxt, &openTypeLen);
      if(stat <0) return LOG_RTERR(pctxt, stat);
      else if(stat == RT_OK_FRAG){
         rtxErrAddStrParm(pctxt, "open type with fragmented length use - perindef");
         return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
      }
      bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
      bitLength = openTypeLen * 8;
      switch (pvalue->id){
         case T_E2AP_PDU_Contents_e2ap_RANfunctionStateConfirm_ItemIEs_id_RANfunctionStateConfirm_Item:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RANfunctionStateConfirm_ItemIEs_id_RANfunctionStateConfirm_Item;
            RTXCTXTPUSHELEMNAME(pctxt, "RANfunctionStateConfirm-Item");
            //pvalue->value.u._e2ap_RANfunctionStateConfirm_ItemIEs_id_id_RANfunctionStateConfirm_Item 
             pvalue->value.u._e2apRANfunctionStateConfirm_ItemIEs_id_RANfunctionStateConfirm_Item 
                    = rtxMemAllocType(pctxt, e2ap_RANfunctionStateConfirm_Item);
            //asn1Init_e2ap_RANfunctionStateConfirm_Item(pvalue->value.u._e2ap_RANfunctionStateConfirm_ItemIEs_id_id_RANfunctionStateConfirm_Item);
            asn1Init_e2ap_RANfunctionStateConfirm_Item(pvalue->value.u._e2apRANfunctionStateConfirm_ItemIEs_id_RANfunctionStateConfirm_Item);
            stat = asn1PD_e2ap_RANfunctionStateConfirm_Item (pctxt,
                    (e2ap_RANfunctionStateConfirm_Item*)pvalue->value.
                    u._e2apRANfunctionStateConfirm_ItemIEs_id_RANfunctionStateConfirm_Item);
            if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RANfunctionStateConfirm_ItemIEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*)rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
      }
      {
      size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
      size_t bitsConsumed = bitEndOffset - bitStartOffset;
      if(bitsConsumed < bitLength){
         stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
      } else {
         stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
      }
      }
   }
   if(stat!=0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);
   return stat;
}

void asn1Init_e2ap_RANfunctionStateConfirm_ItemIEs (e2ap_RANfunctionStateConfirm_ItemIEs* pvalue)
{
   if (!pvalue) return;
   OSCRTLMEMSET (pvalue, 0, sizeof(e2ap_RANfunctionStateConfirm_ItemIEs));
}

#if 0
void asn1Free_e2ap_RANfunctionStateConfirm_ItemIEs (OSCTXT* pctxt, e2ap_RANfunctionStateConfirm_ItemIEs* pvalue)
{
   if (!pvalue) return;
   if (pvalue->extElem1) {
      rtxMemFreeArray (pctxt, pvalue->extElem1);
      pvalue->extElem1 = 0;
      pvalue->extElem1_n = 0;
   }
}
#endif
void asn1Free_e2ap_RANfunctionStateConfirm_ItemIEs (OSCTXT* pctxt, e2ap_RANfunctionStateConfirm_ItemIEs* pvalue)
{
   if(0==pvalue) return;
   switch(pvalue->value.t){
      case T_E2AP_PDU_Contents_e2ap_RANfunctionStateConfirm_ItemIEs_id_RANfunctionStateConfirm_Item:
         asn1Free_e2ap_RANfunctionStateConfirm_Item (pctxt, pvalue->value.u._e2apRANfunctionStateConfirm_ItemIEs_id_RANfunctionStateConfirm_Item);
         rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2apRANfunctionStateConfirm_ItemIEs_id_RANfunctionStateConfirm_Item);
         pvalue->value.u._e2apRANfunctionStateConfirm_ItemIEs_id_RANfunctionStateConfirm_Item = 0;
         break;
      case T_E2AP_PDU_Contents_e2ap_RANfunctionStateConfirm_ItemIEs_UNDEF_:
         if(0!=pvalue->value.u.extElem1){
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1->data);
             rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
             pvalue->value.u.extElem1 =0;
         }
         break;
         default:;
   }
}

int  asn1PrtToStr_e2ap_RANfunctionStateConfirm_ItemIEs (const char * name, e2ap_RANfunctionStateConfirm_ItemIEs* pvalue, char * buffer, OSSIZE bufSize){
   if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
       return -1;

      if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
         return -1;

      if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
         return -1;
      if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
         return -1;
      switch (pvalue->value.t) {
      case T_E2AP_PDU_Contents_e2ap_RANfunctionStateConfirm_ItemIEs_id_RANfunctionStateConfirm_Item:
         if(asn1PrtToStr_e2ap_RANfunctionStateConfirm_Item("RANfunctionStateConfirm-Item",
                pvalue->value.u._e2apRANfunctionStateConfirm_ItemIEs_id_RANfunctionStateConfirm_Item, buffer, bufSize)<0)// dungnm23 check lai nhe xem la
            return -1;
         break;
      default:
         if(0!=pvalue -> value.u.extElem1){
             rtPrintToStringIndent(buffer, bufSize);
             rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

         }
      }
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
      if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

      return 0;

}
 

/*****************************************/
/*           RANfunctionStateConfirm_List                */
/*****************************************/
//seq_of_single_container


int asn1PE_e2ap_RANfunctionStateConfirm_List (OSCTXT* pctxt, e2ap_RANfunctionStateConfirm_List* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_RANfunctionStateConfirm_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "RANfunctionStateConfirm-List");

   /* encode length determinant */
   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(256), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;
   for (xx1 = 0; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next, xx1++) {
      pdata = (e2ap_RANfunctionStateConfirm_ItemIEs*) pnode->data;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_e2ap_RANfunctionStateConfirm_ItemIEs (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      //xx1++;
      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}

int asn1PD_e2ap_RANfunctionStateConfirm_List (OSCTXT* pctxt, e2ap_RANfunctionStateConfirm_List* ppvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;
   OSSIZE count = 0;

   e2ap_RANfunctionStateConfirm_ItemIEs* pdata;

   RTXCTXTPUSHTYPENAME (pctxt, "RANfunctionStateConfirm-List");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(256), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (ppvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      pdata = rtxMemAllocType (pctxt, e2ap_RANfunctionStateConfirm_ItemIEs);
      if (!pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);
      asn1Init_e2ap_RANfunctionStateConfirm_ItemIEs (pdata);
      stat = asn1PD_e2ap_RANfunctionStateConfirm_ItemIEs (pctxt, pdata);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         return LOG_RTERR (pctxt, stat);
      }

      rtxDListAppendNode (ppvalue, pdata);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);
   return 0;
}

void asn1Init_e2ap_RANfunctionStateConfirm_List (e2ap_RANfunctionStateConfirm_List* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
}

void asn1Free_e2ap_RANfunctionStateConfirm_List (OSCTXT* pctxt, e2ap_RANfunctionStateConfirm_List* pvalue)
{
   if(pvalue==0) return;
   OSRTDListNode* pnode = pvalue->head;
   while (pnode) {
      e2ap_RANfunctionStateConfirm_ItemIEs* pdata = (e2ap_RANfunctionStateConfirm_ItemIEs*) pnode->data;
      if (pdata) {
         asn1Free_e2ap_RANfunctionStateConfirm_ItemIEs (pctxt, pdata);
         rtxMemFreePtr (pctxt, pdata);
      }
      pnode = pnode->next;
   }
      rtxDListFreeAll(pctxt, pvalue);
}

#if 0
void asn1Free_e2ap_RANfunctionStateConfirm_List (OSCTXT* pctxt, e2ap_RANfunctionStateConfirm_List* pvalue){
   if(0==pvalue ) return;
   {
      e2ap_RANfunctionStateConfirm_ItemIEs * pdata;
      OSRTDListNode *pnode = pvalue->head;
      while(0!=pnode){
         pdata = (e2ap_RANfunctionStateConfirm_ItemIEs*)pnode->data;
         asn1Free_e2ap_RANfunctionStateConfirm_ItemIEs(pctxt, pdata);
         pnode = pnode->next;
      }
      rtxDListFreeAll(pctxt, pvalue);
   }
}
#endif


int asn1PrtToStr_e2ap_RANfunctionStateConfirm_List(const char* name, e2ap_RANfunctionStateConfirm_List* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_RANfunctionStateConfirm_ItemIEs* pdata;
    OSRTDListNode* pnode;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode = pvalue->head;  xx1 < pvalue->count && pnode != 0; pnode = pnode->next, xx1++){
        pdata = (e2ap_RANfunctionStateConfirm_ItemIEs*)pnode->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 1
        if(asn1PrtToStr_e2ap_RANfunctionStateConfirm_ItemIEs(nameBuf, pdata, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}/*****************************************/
/*           RICsubscriptionStateControlResponse_IEs                */
/*****************************************/
/* ie.c.j2 */
 /* d là con của msg */
EXTERN int asn1PE_e2ap_RICsubscriptionStateControlResponse_protocolIEs_element (OSCTXT* pctxt, e2ap_RICsubscriptionStateControlResponse_protocolIEs_element* pvalue)
{
    int stat =0;

    /*encode id*/

    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PE_e2ap_ProtocolIE_ID(pctxt, pvalue->id);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PE_e2ap_Criticality(pctxt, pvalue->criticality);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
    {
        OSCTXT lctxt;
        OSOCTET *pDynamicEncodeBuffer;
        ASN1OpenType openType;
        OSBOOL encoded = TRUE;

        openType.numocts = 0;
        openType.data =0;

        rtxCopyContext(&lctxt, pctxt);
        pctxt->pStream =0;

        stat = rtxInitContextBuffer(pctxt, 0, 0);
        if(stat!=0) return LOG_RTERR(pctxt, stat);

        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionStateControlResponse_IEs_id_RICrequestID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICrequestID");
                    stat = asn1PE_e2ap_RICrequestID (pctxt, pvalue->value.u._e2ap_RICsubscriptionStateControlResponse_IEs_id_RICrequestID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionStateControlResponse_IEs_id_RANfunctionStateConfirm_List:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RANfunctionStateConfirm-List");
                    stat = asn1PE_e2ap_RANfunctionStateConfirm_List (pctxt, pvalue->value.u._e2ap_RICsubscriptionStateControlResponse_IEs_id_RANfunctionStateConfirm_List);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionStateControlResponse_IEs_UNDEF_:
            {
                if(0!=pvalue->value.u.extElem1){
                    openType.numocts = pvalue->value.u.extElem1->numocts;
                    openType.data = pvalue->value.u.extElem1->data;
                } else {
                    /* No extension element to encode */
                }
                encoded = FALSE;
                break;
            }

            default:
                encoded = FALSE;
                stat = RTERR_INVOPT;
                break;
        } 

        if(encoded){
            openType.numocts = (OSUINT32)pe_GetMsgLen(pctxt);
            openType.data = pDynamicEncodeBuffer = pctxt -> buffer.data;
        }
        rtxCopyContext(pctxt, &lctxt);

        if(stat == 0) {
            stat = pe_OpenType (pctxt, openType.numocts, openType.data);
        }
    #if 1
        if(encoded){//dungnm23 check lai nhe
            rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
        }
    #endif

    }

    if(stat!=0) return LOG_RTERR(pctxt, stat);  
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}

EXTERN int  asn1PD_e2ap_RICsubscriptionStateControlResponse_protocolIEs_element (OSCTXT* pctxt, e2ap_RICsubscriptionStateControlResponse_protocolIEs_element* pvalue){
    int stat =0;

    /*decode id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PD_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PD_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");

    {
        OSUINT32 openTypeLen;
        size_t bitStartOffset, bitLength;

        stat = pd_UnconsLength(pctxt, &openTypeLen);
        if(stat<0) return LOG_RTERR(pctxt, stat);
        else if(stat == RT_OK_FRAG){
            rtxErrAddStrParm(pctxt, "open type with fragment length");
            return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
        }
        bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
        bitLength = openTypeLen * 8;

        switch(pvalue->id){//dungnm23 check case lai nhe
        
            case ASN1V_e2ap_id_RICrequestID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionStateControlResponse_IEs_id_RICrequestID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICrequestID");
                pvalue->value.u._e2ap_RICsubscriptionStateControlResponse_IEs_id_RICrequestID 
                    = rtxMemAllocType(pctxt, e2ap_RICrequestID);

                asn1Init_e2ap_RICrequestID(pvalue->value.u._e2ap_RICsubscriptionStateControlResponse_IEs_id_RICrequestID);

                stat = asn1PD_e2ap_RICrequestID (pctxt,
                        (e2ap_RICrequestID*)pvalue->value.
                        u._e2ap_RICsubscriptionStateControlResponse_IEs_id_RICrequestID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RANfunctionStateConfirm_List:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionStateControlResponse_IEs_id_RANfunctionStateConfirm_List;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RANfunctionStateConfirm-List");
                pvalue->value.u._e2ap_RICsubscriptionStateControlResponse_IEs_id_RANfunctionStateConfirm_List 
                    = rtxMemAllocType(pctxt, e2ap_RANfunctionStateConfirm_List);

                asn1Init_e2ap_RANfunctionStateConfirm_List(pvalue->value.u._e2ap_RICsubscriptionStateControlResponse_IEs_id_RANfunctionStateConfirm_List);

                stat = asn1PD_e2ap_RANfunctionStateConfirm_List (pctxt,
                        (e2ap_RANfunctionStateConfirm_List*)pvalue->value.
                        u._e2ap_RICsubscriptionStateControlResponse_IEs_id_RANfunctionStateConfirm_List);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionStateControlResponse_IEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*) rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
    }
    {
    size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
    size_t bitsConsumed = bitEndOffset-bitStartOffset;
    if(bitsConsumed<bitLength){
        stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
    }
    else stat =(bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
    }}
    if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}


int asn1Init_e2ap_RICsubscriptionStateControlResponse_protocolIEs_element(e2ap_RICsubscriptionStateControlResponse_protocolIEs_element* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    OSCRTLMEMSET (&pvalue->value, 0, sizeof(pvalue->value));
    return 0;
}


//-----> chuaw có template rtxFreeASN1OpenType

#if 0
void asn1Free_e2ap_RICsubscriptionStateControlResponse_protocolIEs_element(OSCTXT* pctxt, e2ap_RICsubscriptionStateControlResponse_protocolIEs_element* pvalue)
{
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionStateControlResponse_IEs_id_id_RICrequestID:
            // rtxFreeE2ap_RICrequestID(pvalue->value.u._e2ap_RICsubscriptionStateControlResponse_IEs_id_id_RICrequestID);

            if(pvalue->value.i._e2ap_RICsubscriptionStateControlResponse_id_RICrequestID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICrequestID(pctxt, pvalue->value.u._e2ap_RICsubscriptionStateControlResponse_IEs_id_id_RICrequestID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionStateControlResponse_IEs_id_id_RICrequestID);
           // pvalue->value.u._e2ap_RICsubscriptionStateControlResponse_IEs_id_id_RICrequestID = NULL;
           pvalue->value.u._e2ap_RICsubscriptionStateControlResponse_IEs_id_RICrequestID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionStateControlResponse_IEs_id_id_RANfunctionStateConfirm_List:
            // rtxFreeE2ap_RANfunctionStateConfirm_List(pvalue->value.u._e2ap_RICsubscriptionStateControlResponse_IEs_id_id_RANfunctionStateConfirm_List);

            if(pvalue->value.i._e2ap_RICsubscriptionStateControlResponse_id_RANfunctionStateConfirm_List!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RANfunctionStateConfirm_List(pctxt, pvalue->value.u._e2ap_RICsubscriptionStateControlResponse_IEs_id_id_RANfunctionStateConfirm_List);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionStateControlResponse_IEs_id_id_RANfunctionStateConfirm_List);
           // pvalue->value.u._e2ap_RICsubscriptionStateControlResponse_IEs_id_id_RANfunctionStateConfirm_List = NULL;
           pvalue->value.u._e2ap_RICsubscriptionStateControlResponse_IEs_id_RANfunctionStateConfirm_List = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionStateControlResponse_IEs_UNDEF_:
            rtxFreeASN1OpenType(pvalue->value.u.extElem1);
            break;
        default:
            break;
    }
}

int asn1PrtToStr_e2ap_RICsubscriptionStateControlResponse_protocolIEs_element(OSCTXT* pctxt, e2ap_RICsubscriptionStateControlResponse_protocolIEs_element* pvalue)
{
    int stat =0;
    RTXCTXTPUSHELEMNAME(pctxt, "e2ap_RICsubscriptionStateControlResponse_protocolIEs_element");

    /*print id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PrtToStr_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PrtToStr_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionStateControlResponse_IEs_id_id_RICrequestID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICrequestID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICrequestID (pctxt, pvalue->value.u._e2ap_RICsubscriptionStateControlResponse_IEs_id_id_RICrequestID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionStateControlResponse_IEs_id_id_RANfunctionStateConfirm_List:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RANfunctionStateConfirm-List");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RANfunctionStateConfirm_List (pctxt, pvalue->value.u._e2ap_RICsubscriptionStateControlResponse_IEs_id_id_RANfunctionStateConfirm_List);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionStateControlResponse_IEs_UNDEF_:
            {
                rtxPLogMsg(pctxt, "Extension element present - raw data not printed.\n");
                break;
            }

            default:
                stat = RTERR_INVOPT;
                return LOG_RTERR(pctxt, stat);
        }
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);
}
#endif


int asn1PrtToStr_e2ap_RICsubscriptionStateControlResponse_protocolIEs_element (const char * name,
 e2ap_RICsubscriptionStateControlResponse_protocolIEs_element* pvalue, 
 char * buffer, OSSIZE bufSize){
    if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
        return -1;
    if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
        return -1;

    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionStateControlResponse_IEs_id_RICrequestID:
            if(asn1PrtToStr_e2ap_RICrequestID("RICrequestID", 
                    pvalue->value.u._e2ap_RICsubscriptionStateControlResponse_IEs_id_RICrequestID, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionStateControlResponse_IEs_id_RANfunctionStateConfirm_List:
            if(asn1PrtToStr_e2ap_RANfunctionStateConfirm_List("RANfunctionStateConfirm-List", 
                    pvalue->value.u._e2ap_RICsubscriptionStateControlResponse_IEs_id_RANfunctionStateConfirm_List, buffer, bufSize)<0)
                return -1;
            break;    
        default:
        if(0!=pvalue -> value.u.extElem1){
            rtPrintToStringIndent(buffer, bufSize);
            rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

        }
        }
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

    return 0;

 }

 void asn1Free_e2ap_RICsubscriptionStateControlResponse_protocolIEs_element(OSCTXT* pctxt, e2ap_RICsubscriptionStateControlResponse_protocolIEs_element* pvalue){
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionStateControlResponse_IEs_id_RICrequestID:
            if(pvalue->value.u._e2ap_RICsubscriptionStateControlResponse_IEs_id_RICrequestID!=NULL){
            asn1Free_e2ap_RICrequestID(pctxt, pvalue->value.u._e2ap_RICsubscriptionStateControlResponse_IEs_id_RICrequestID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionStateControlResponse_IEs_id_RICrequestID);
            pvalue->value.u._e2ap_RICsubscriptionStateControlResponse_IEs_id_RICrequestID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionStateControlResponse_IEs_id_RANfunctionStateConfirm_List:
            if(pvalue->value.u._e2ap_RICsubscriptionStateControlResponse_IEs_id_RANfunctionStateConfirm_List!=NULL){
            asn1Free_e2ap_RANfunctionStateConfirm_List(pctxt, pvalue->value.u._e2ap_RICsubscriptionStateControlResponse_IEs_id_RANfunctionStateConfirm_List);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionStateControlResponse_IEs_id_RANfunctionStateConfirm_List);
            pvalue->value.u._e2ap_RICsubscriptionStateControlResponse_IEs_id_RANfunctionStateConfirm_List = NULL;
            }
            break;
        default:
            break;


    }
 }

 

/*****************************************/
/*           RICsubscriptionStateControlResponse                */
/*****************************************/
//2_container.c
/* 1. xxx_ProtocolIE -> mẫu cũ ở ie_big_msg */
EXTERN int asn1PE_e2ap_RICsubscriptionStateControlResponse_protocolIEs (OSCTXT* pctxt, e2ap_RICsubscriptionStateControlResponse_protocolIEs* pvalue)
{
    int stat =0;
    OSRTDListNode* pnode;
    OSUINT32 xx1;

    /*encode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pe_Length(pctxt, pvalue->count);
    if(stat<0) return LOG_RTERR(pctxt, stat);

    /*encode each element*/
    xx1 =0;
    for(pnode = pvalue->head; pnode != 0 && xx1<pvalue->count; pnode = pnode->next){
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE", xx1);
        stat = asn1PE_e2ap_RICsubscriptionStateControlResponse_protocolIEs_element (pctxt, ((e2ap_RICsubscriptionStateControlResponse_protocolIEs_element*)pnode->data));
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        xx1++;
        RTXCTXTPOPARRAYELEMNAME(pctxt);
    }

    return (stat);
}

EXTERN int  asn1PD_e2ap_RICsubscriptionStateControlResponse_protocolIEs(OSCTXT* pctxt, e2ap_RICsubscriptionStateControlResponse_protocolIEs* pvalue)
{
     int stat =0;
     OSRTDListNode* pnode;
     OSSIZE count =0;
     OSSIZE xx1=0;


     /*decode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pd_Length64(pctxt, &count); //tai sao lai 64
    if(stat!=0) return LOG_RTERR(pctxt, stat);

    /*decode each element*/
    rtxDListInit(pvalue);

    for(xx1=0; xx1 < count; xx1++){
        e2ap_RICsubscriptionStateControlResponse_protocolIEs_element* pdata;
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE",xx1);

        if(pnode == NULL) return LOG_RTERR(pctxt, RTERR_NOMEM);

        asn1Init_e2ap_RICsubscriptionStateControlResponse_protocolIEs_element(pdata);
        rtxDListAppendNode(pvalue, pnode);
        stat = asn1PD_e2ap_RICsubscriptionStateControlResponse_protocolIEs_element (pctxt, pdata);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        RTXCTXTPOPARRAYELEMNAME(pctxt);

    }
    return (stat);
}


int asn1Init_e2ap_RICsubscriptionStateControlResponse_protocolIEs(e2ap_RICsubscriptionStateControlResponse_protocolIEs* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    rtxDListFastInit (pvalue);
    return 0;
}
#if 1 //ao that day
void asn1Free_e2ap_RICsubscriptionStateControlResponse_protocolIEs(OSCTXT* pctxt, e2ap_RICsubscriptionStateControlResponse_protocolIEs* pvalue)
{
    if(0==pvalue) return;   
    e2ap_RICsubscriptionStateControlResponse_protocolIEs_element* pdata;
    OSRTDListNode* pnode=pvalue->head;
    while(0!=pnode){
        pdata = (e2ap_RICsubscriptionStateControlResponse_protocolIEs_element*)pnode->data;
       // asn1Free_e2ap_RICsubscriptionStateControlResponse_protocolIEs_element(pctxt, pdata);
        pnode = pnode->next;
    }
    rtxDListFreeAll(pctxt, pvalue);
}
#endif


EXTERN int asn1PrtToStr_e2ap_RICsubscriptionStateControlResponse_protocolIEs(const char* name, e2ap_RICsubscriptionStateControlResponse_protocolIEs* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_RICsubscriptionStateControlResponse_protocolIEs_element* pdata0;
    OSRTDListNode* pnode0;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode0 = pvalue->head;  xx1 < pvalue->count && pnode0 != 0; pnode0 = pnode0->next, xx1++){
        pdata0 = (e2ap_RICsubscriptionStateControlResponse_protocolIEs_element*)pnode0->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 0
        if(asn1PrtToStr_e2ap_RICsubscriptionStateControlResponse_protocolIEs_element(nameBuf, pdata0, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}


/*2 . RICsubscriptionStateControlResponse -> mẫu cũ ở seq_normal*/

int asn1PE_e2ap_RICsubscriptionStateControlResponse (OSCTXT* pctxt, e2ap_RICsubscriptionStateControlResponse* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RICsubscriptionStateControlResponse");
   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field protocolIEs - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
   stat = asn1PE_e2ap_RICsubscriptionStateControlResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
   if(stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RICsubscriptionStateControlResponse (OSCTXT* pctxt, e2ap_RICsubscriptionStateControlResponse* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME(pctxt, "RICsubscriptionStateControlResponse");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field protocolIEs */
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
      stat = asn1PD_e2ap_RICsubscriptionStateControlResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RICsubscriptionStateControlResponse (e2ap_RICsubscriptionStateControlResponse* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RICsubscriptionStateControlResponse_protocolIEs(&pvalue->protocolIEs);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RICsubscriptionStateControlResponse (OSCTXT* pctxt, e2ap_RICsubscriptionStateControlResponse* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_RICsubscriptionStateControlResponse_protocolIEs(pctxt, &pvalue->protocolIEs);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RICsubscriptionStateControlResponse (const char* name, e2ap_RICsubscriptionStateControlResponse* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }

   if(asn1PrtToStr_e2ap_RICsubscriptionStateControlResponse_protocolIEs("protocolIEs", &pvalue->protocolIEs, buffer, bufSize) <0){
      return -1;
   }

   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           RICsubscriptionStateControlFailure_IEs                */
/*****************************************/
/* ie.c.j2 */
 /* d là con của msg */
EXTERN int asn1PE_e2ap_RICsubscriptionStateControlFailure_protocolIEs_element (OSCTXT* pctxt, e2ap_RICsubscriptionStateControlFailure_protocolIEs_element* pvalue)
{
    int stat =0;

    /*encode id*/

    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PE_e2ap_ProtocolIE_ID(pctxt, pvalue->id);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PE_e2ap_Criticality(pctxt, pvalue->criticality);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
    {
        OSCTXT lctxt;
        OSOCTET *pDynamicEncodeBuffer;
        ASN1OpenType openType;
        OSBOOL encoded = TRUE;

        openType.numocts = 0;
        openType.data =0;

        rtxCopyContext(&lctxt, pctxt);
        pctxt->pStream =0;

        stat = rtxInitContextBuffer(pctxt, 0, 0);
        if(stat!=0) return LOG_RTERR(pctxt, stat);

        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionStateControlFailure_IEs_id_RICrequestID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICrequestID");
                    stat = asn1PE_e2ap_RICrequestID (pctxt, pvalue->value.u._e2ap_RICsubscriptionStateControlFailure_IEs_id_RICrequestID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionStateControlFailure_IEs_id_Cause:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-Cause");
                    stat = asn1PE_e2ap_Cause (pctxt, pvalue->value.u._e2ap_RICsubscriptionStateControlFailure_IEs_id_Cause);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionStateControlFailure_IEs_id_CriticalityDiagnostics:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-CriticalityDiagnostics");
                    stat = asn1PE_e2ap_CriticalityDiagnostics (pctxt, pvalue->value.u._e2ap_RICsubscriptionStateControlFailure_IEs_id_CriticalityDiagnostics);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionStateControlFailure_IEs_UNDEF_:
            {
                if(0!=pvalue->value.u.extElem1){
                    openType.numocts = pvalue->value.u.extElem1->numocts;
                    openType.data = pvalue->value.u.extElem1->data;
                } else {
                    /* No extension element to encode */
                }
                encoded = FALSE;
                break;
            }

            default:
                encoded = FALSE;
                stat = RTERR_INVOPT;
                break;
        } 

        if(encoded){
            openType.numocts = (OSUINT32)pe_GetMsgLen(pctxt);
            openType.data = pDynamicEncodeBuffer = pctxt -> buffer.data;
        }
        rtxCopyContext(pctxt, &lctxt);

        if(stat == 0) {
            stat = pe_OpenType (pctxt, openType.numocts, openType.data);
        }
    #if 1
        if(encoded){//dungnm23 check lai nhe
            rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
        }
    #endif

    }

    if(stat!=0) return LOG_RTERR(pctxt, stat);  
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}

EXTERN int  asn1PD_e2ap_RICsubscriptionStateControlFailure_protocolIEs_element (OSCTXT* pctxt, e2ap_RICsubscriptionStateControlFailure_protocolIEs_element* pvalue){
    int stat =0;

    /*decode id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PD_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PD_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");

    {
        OSUINT32 openTypeLen;
        size_t bitStartOffset, bitLength;

        stat = pd_UnconsLength(pctxt, &openTypeLen);
        if(stat<0) return LOG_RTERR(pctxt, stat);
        else if(stat == RT_OK_FRAG){
            rtxErrAddStrParm(pctxt, "open type with fragment length");
            return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
        }
        bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
        bitLength = openTypeLen * 8;

        switch(pvalue->id){//dungnm23 check case lai nhe
        
            case ASN1V_e2ap_id_RICrequestID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionStateControlFailure_IEs_id_RICrequestID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICrequestID");
                pvalue->value.u._e2ap_RICsubscriptionStateControlFailure_IEs_id_RICrequestID 
                    = rtxMemAllocType(pctxt, e2ap_RICrequestID);

                asn1Init_e2ap_RICrequestID(pvalue->value.u._e2ap_RICsubscriptionStateControlFailure_IEs_id_RICrequestID);

                stat = asn1PD_e2ap_RICrequestID (pctxt,
                        (e2ap_RICrequestID*)pvalue->value.
                        u._e2ap_RICsubscriptionStateControlFailure_IEs_id_RICrequestID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_Cause:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionStateControlFailure_IEs_id_Cause;
            RTXCTXTPUSHELEMNAME(pctxt, "id-Cause");
                pvalue->value.u._e2ap_RICsubscriptionStateControlFailure_IEs_id_Cause 
                    = rtxMemAllocType(pctxt, e2ap_Cause);

                asn1Init_e2ap_Cause(pvalue->value.u._e2ap_RICsubscriptionStateControlFailure_IEs_id_Cause);

                stat = asn1PD_e2ap_Cause (pctxt,
                        (e2ap_Cause*)pvalue->value.
                        u._e2ap_RICsubscriptionStateControlFailure_IEs_id_Cause);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_CriticalityDiagnostics:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionStateControlFailure_IEs_id_CriticalityDiagnostics;
            RTXCTXTPUSHELEMNAME(pctxt, "id-CriticalityDiagnostics");
                pvalue->value.u._e2ap_RICsubscriptionStateControlFailure_IEs_id_CriticalityDiagnostics 
                    = rtxMemAllocType(pctxt, e2ap_CriticalityDiagnostics);

                asn1Init_e2ap_CriticalityDiagnostics(pvalue->value.u._e2ap_RICsubscriptionStateControlFailure_IEs_id_CriticalityDiagnostics);

                stat = asn1PD_e2ap_CriticalityDiagnostics (pctxt,
                        (e2ap_CriticalityDiagnostics*)pvalue->value.
                        u._e2ap_RICsubscriptionStateControlFailure_IEs_id_CriticalityDiagnostics);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICsubscriptionStateControlFailure_IEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*) rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
    }
    {
    size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
    size_t bitsConsumed = bitEndOffset-bitStartOffset;
    if(bitsConsumed<bitLength){
        stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
    }
    else stat =(bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
    }}
    if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}


int asn1Init_e2ap_RICsubscriptionStateControlFailure_protocolIEs_element(e2ap_RICsubscriptionStateControlFailure_protocolIEs_element* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    OSCRTLMEMSET (&pvalue->value, 0, sizeof(pvalue->value));
    return 0;
}


//-----> chuaw có template rtxFreeASN1OpenType

#if 0
void asn1Free_e2ap_RICsubscriptionStateControlFailure_protocolIEs_element(OSCTXT* pctxt, e2ap_RICsubscriptionStateControlFailure_protocolIEs_element* pvalue)
{
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionStateControlFailure_IEs_id_id_RICrequestID:
            // rtxFreeE2ap_RICrequestID(pvalue->value.u._e2ap_RICsubscriptionStateControlFailure_IEs_id_id_RICrequestID);

            if(pvalue->value.i._e2ap_RICsubscriptionStateControlFailure_id_RICrequestID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICrequestID(pctxt, pvalue->value.u._e2ap_RICsubscriptionStateControlFailure_IEs_id_id_RICrequestID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionStateControlFailure_IEs_id_id_RICrequestID);
           // pvalue->value.u._e2ap_RICsubscriptionStateControlFailure_IEs_id_id_RICrequestID = NULL;
           pvalue->value.u._e2ap_RICsubscriptionStateControlFailure_IEs_id_RICrequestID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionStateControlFailure_IEs_id_id_Cause:
            // rtxFreeE2ap_Cause(pvalue->value.u._e2ap_RICsubscriptionStateControlFailure_IEs_id_id_Cause);

            if(pvalue->value.i._e2ap_RICsubscriptionStateControlFailure_id_Cause!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_Cause(pctxt, pvalue->value.u._e2ap_RICsubscriptionStateControlFailure_IEs_id_id_Cause);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionStateControlFailure_IEs_id_id_Cause);
           // pvalue->value.u._e2ap_RICsubscriptionStateControlFailure_IEs_id_id_Cause = NULL;
           pvalue->value.u._e2ap_RICsubscriptionStateControlFailure_IEs_id_Cause = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionStateControlFailure_IEs_id_id_CriticalityDiagnostics:
            // rtxFreeE2ap_CriticalityDiagnostics(pvalue->value.u._e2ap_RICsubscriptionStateControlFailure_IEs_id_id_CriticalityDiagnostics);

            if(pvalue->value.i._e2ap_RICsubscriptionStateControlFailure_id_CriticalityDiagnostics!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_CriticalityDiagnostics(pctxt, pvalue->value.u._e2ap_RICsubscriptionStateControlFailure_IEs_id_id_CriticalityDiagnostics);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionStateControlFailure_IEs_id_id_CriticalityDiagnostics);
           // pvalue->value.u._e2ap_RICsubscriptionStateControlFailure_IEs_id_id_CriticalityDiagnostics = NULL;
           pvalue->value.u._e2ap_RICsubscriptionStateControlFailure_IEs_id_CriticalityDiagnostics = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionStateControlFailure_IEs_UNDEF_:
            rtxFreeASN1OpenType(pvalue->value.u.extElem1);
            break;
        default:
            break;
    }
}

int asn1PrtToStr_e2ap_RICsubscriptionStateControlFailure_protocolIEs_element(OSCTXT* pctxt, e2ap_RICsubscriptionStateControlFailure_protocolIEs_element* pvalue)
{
    int stat =0;
    RTXCTXTPUSHELEMNAME(pctxt, "e2ap_RICsubscriptionStateControlFailure_protocolIEs_element");

    /*print id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PrtToStr_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PrtToStr_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionStateControlFailure_IEs_id_id_RICrequestID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICrequestID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICrequestID (pctxt, pvalue->value.u._e2ap_RICsubscriptionStateControlFailure_IEs_id_id_RICrequestID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionStateControlFailure_IEs_id_id_Cause:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "Cause");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_Cause (pctxt, pvalue->value.u._e2ap_RICsubscriptionStateControlFailure_IEs_id_id_Cause);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionStateControlFailure_IEs_id_id_CriticalityDiagnostics:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "CriticalityDiagnostics");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_CriticalityDiagnostics (pctxt, pvalue->value.u._e2ap_RICsubscriptionStateControlFailure_IEs_id_id_CriticalityDiagnostics);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_RICsubscriptionStateControlFailure_IEs_UNDEF_:
            {
                rtxPLogMsg(pctxt, "Extension element present - raw data not printed.\n");
                break;
            }

            default:
                stat = RTERR_INVOPT;
                return LOG_RTERR(pctxt, stat);
        }
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);
}
#endif


int asn1PrtToStr_e2ap_RICsubscriptionStateControlFailure_protocolIEs_element (const char * name,
 e2ap_RICsubscriptionStateControlFailure_protocolIEs_element* pvalue, 
 char * buffer, OSSIZE bufSize){
    if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
        return -1;
    if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
        return -1;

    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionStateControlFailure_IEs_id_RICrequestID:
            if(asn1PrtToStr_e2ap_RICrequestID("RICrequestID", 
                    pvalue->value.u._e2ap_RICsubscriptionStateControlFailure_IEs_id_RICrequestID, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionStateControlFailure_IEs_id_Cause:
            if(asn1PrtToStr_e2ap_Cause("Cause", 
                    pvalue->value.u._e2ap_RICsubscriptionStateControlFailure_IEs_id_Cause, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionStateControlFailure_IEs_id_CriticalityDiagnostics:
            if(asn1PrtToStr_e2ap_CriticalityDiagnostics("CriticalityDiagnostics", 
                    pvalue->value.u._e2ap_RICsubscriptionStateControlFailure_IEs_id_CriticalityDiagnostics, buffer, bufSize)<0)
                return -1;
            break;    
        default:
        if(0!=pvalue -> value.u.extElem1){
            rtPrintToStringIndent(buffer, bufSize);
            rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

        }
        }
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

    return 0;

 }

 void asn1Free_e2ap_RICsubscriptionStateControlFailure_protocolIEs_element(OSCTXT* pctxt, e2ap_RICsubscriptionStateControlFailure_protocolIEs_element* pvalue){
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionStateControlFailure_IEs_id_RICrequestID:
            if(pvalue->value.u._e2ap_RICsubscriptionStateControlFailure_IEs_id_RICrequestID!=NULL){
            asn1Free_e2ap_RICrequestID(pctxt, pvalue->value.u._e2ap_RICsubscriptionStateControlFailure_IEs_id_RICrequestID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionStateControlFailure_IEs_id_RICrequestID);
            pvalue->value.u._e2ap_RICsubscriptionStateControlFailure_IEs_id_RICrequestID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionStateControlFailure_IEs_id_Cause:
            if(pvalue->value.u._e2ap_RICsubscriptionStateControlFailure_IEs_id_Cause!=NULL){
            asn1Free_e2ap_Cause(pctxt, pvalue->value.u._e2ap_RICsubscriptionStateControlFailure_IEs_id_Cause);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionStateControlFailure_IEs_id_Cause);
            pvalue->value.u._e2ap_RICsubscriptionStateControlFailure_IEs_id_Cause = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICsubscriptionStateControlFailure_IEs_id_CriticalityDiagnostics:
            if(pvalue->value.u._e2ap_RICsubscriptionStateControlFailure_IEs_id_CriticalityDiagnostics!=NULL){
            asn1Free_e2ap_CriticalityDiagnostics(pctxt, pvalue->value.u._e2ap_RICsubscriptionStateControlFailure_IEs_id_CriticalityDiagnostics);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICsubscriptionStateControlFailure_IEs_id_CriticalityDiagnostics);
            pvalue->value.u._e2ap_RICsubscriptionStateControlFailure_IEs_id_CriticalityDiagnostics = NULL;
            }
            break;
        default:
            break;


    }
 }

 

/*****************************************/
/*           RICsubscriptionStateControlFailure                */
/*****************************************/
//2_container.c
/* 1. xxx_ProtocolIE -> mẫu cũ ở ie_big_msg */
EXTERN int asn1PE_e2ap_RICsubscriptionStateControlFailure_protocolIEs (OSCTXT* pctxt, e2ap_RICsubscriptionStateControlFailure_protocolIEs* pvalue)
{
    int stat =0;
    OSRTDListNode* pnode;
    OSUINT32 xx1;

    /*encode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pe_Length(pctxt, pvalue->count);
    if(stat<0) return LOG_RTERR(pctxt, stat);

    /*encode each element*/
    xx1 =0;
    for(pnode = pvalue->head; pnode != 0 && xx1<pvalue->count; pnode = pnode->next){
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE", xx1);
        stat = asn1PE_e2ap_RICsubscriptionStateControlFailure_protocolIEs_element (pctxt, ((e2ap_RICsubscriptionStateControlFailure_protocolIEs_element*)pnode->data));
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        xx1++;
        RTXCTXTPOPARRAYELEMNAME(pctxt);
    }

    return (stat);
}

EXTERN int  asn1PD_e2ap_RICsubscriptionStateControlFailure_protocolIEs(OSCTXT* pctxt, e2ap_RICsubscriptionStateControlFailure_protocolIEs* pvalue)
{
     int stat =0;
     OSRTDListNode* pnode;
     OSSIZE count =0;
     OSSIZE xx1=0;


     /*decode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pd_Length64(pctxt, &count); //tai sao lai 64
    if(stat!=0) return LOG_RTERR(pctxt, stat);

    /*decode each element*/
    rtxDListInit(pvalue);

    for(xx1=0; xx1 < count; xx1++){
        e2ap_RICsubscriptionStateControlFailure_protocolIEs_element* pdata;
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE",xx1);

        if(pnode == NULL) return LOG_RTERR(pctxt, RTERR_NOMEM);

        asn1Init_e2ap_RICsubscriptionStateControlFailure_protocolIEs_element(pdata);
        rtxDListAppendNode(pvalue, pnode);
        stat = asn1PD_e2ap_RICsubscriptionStateControlFailure_protocolIEs_element (pctxt, pdata);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        RTXCTXTPOPARRAYELEMNAME(pctxt);

    }
    return (stat);
}


int asn1Init_e2ap_RICsubscriptionStateControlFailure_protocolIEs(e2ap_RICsubscriptionStateControlFailure_protocolIEs* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    rtxDListFastInit (pvalue);
    return 0;
}
#if 1 //ao that day
void asn1Free_e2ap_RICsubscriptionStateControlFailure_protocolIEs(OSCTXT* pctxt, e2ap_RICsubscriptionStateControlFailure_protocolIEs* pvalue)
{
    if(0==pvalue) return;   
    e2ap_RICsubscriptionStateControlFailure_protocolIEs_element* pdata;
    OSRTDListNode* pnode=pvalue->head;
    while(0!=pnode){
        pdata = (e2ap_RICsubscriptionStateControlFailure_protocolIEs_element*)pnode->data;
       // asn1Free_e2ap_RICsubscriptionStateControlFailure_protocolIEs_element(pctxt, pdata);
        pnode = pnode->next;
    }
    rtxDListFreeAll(pctxt, pvalue);
}
#endif


EXTERN int asn1PrtToStr_e2ap_RICsubscriptionStateControlFailure_protocolIEs(const char* name, e2ap_RICsubscriptionStateControlFailure_protocolIEs* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_RICsubscriptionStateControlFailure_protocolIEs_element* pdata0;
    OSRTDListNode* pnode0;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode0 = pvalue->head;  xx1 < pvalue->count && pnode0 != 0; pnode0 = pnode0->next, xx1++){
        pdata0 = (e2ap_RICsubscriptionStateControlFailure_protocolIEs_element*)pnode0->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 0
        if(asn1PrtToStr_e2ap_RICsubscriptionStateControlFailure_protocolIEs_element(nameBuf, pdata0, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}


/*2 . RICsubscriptionStateControlFailure -> mẫu cũ ở seq_normal*/

int asn1PE_e2ap_RICsubscriptionStateControlFailure (OSCTXT* pctxt, e2ap_RICsubscriptionStateControlFailure* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RICsubscriptionStateControlFailure");
   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field protocolIEs - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
   stat = asn1PE_e2ap_RICsubscriptionStateControlFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
   if(stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RICsubscriptionStateControlFailure (OSCTXT* pctxt, e2ap_RICsubscriptionStateControlFailure* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME(pctxt, "RICsubscriptionStateControlFailure");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field protocolIEs */
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
      stat = asn1PD_e2ap_RICsubscriptionStateControlFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RICsubscriptionStateControlFailure (e2ap_RICsubscriptionStateControlFailure* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RICsubscriptionStateControlFailure_protocolIEs(&pvalue->protocolIEs);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RICsubscriptionStateControlFailure (OSCTXT* pctxt, e2ap_RICsubscriptionStateControlFailure* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_RICsubscriptionStateControlFailure_protocolIEs(pctxt, &pvalue->protocolIEs);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RICsubscriptionStateControlFailure (const char* name, e2ap_RICsubscriptionStateControlFailure* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }

   if(asn1PrtToStr_e2ap_RICsubscriptionStateControlFailure_protocolIEs("protocolIEs", &pvalue->protocolIEs, buffer, bufSize) <0){
      return -1;
   }

   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           RICqueryHeader                */
/*****************************************/
//9 mau octet string
//type 9  mau la octet string no size mau la pdusessioncommonnetworkinstance

EXTERN int asn1PE_e2ap_RICqueryHeader (OSCTXT* pctxt, e2ap_RICqueryHeader value){
   int stat = 0
   RTXCTCXTPUSHTYPENAME (pctxt, "RICqueryHeader");
   stat = pe_OctetString(pctxt, value.numocts, value.data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPTYPENAME (pctxt);

}
EXTERN int asn1PD_e2ap_RICqueryHeader (OSCTXT* pctxt, e2ap_RICqueryHeader* pvalue){
   int stat = 0;
   RTXCTCXTPUSHTYPENAME (pctxt, "RICqueryHeader");
   stat = pd_DynOctetString(pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}
EXTERN int asn1PrtToStr_e2ap_RICqueryHeader (const char* name, e2ap_RICqueryHeader *pvalue, char* buffer, OSSIZE bufSize){
   if(rtPrintToStringIndent(buffer, bufSize) < 0) return -1;
   if(rtPrintToStringHexStr(name, pvalue->numocts, pvalue->data, buffer, bufSize) < 0) return -1;
   return 0;
}
EXTERN int asn1PrtToStrm_e2ap_RICqueryHeader (OSCTXT* pctxt, const char* name, const e2ap_RICqueryHeader* pvalue){
   int stat =0;
   stat = rtPrintToStreamIndent(pctxt);
   if(stat !=0) return LOG_RTERR(pctxt, stat);
   stat = rtPrintToStreamHexStr(pctxt, name, pvalue->numocts, pvalue->data);
   if(stat !=0) return LOG_RTERR(pctxt, stat);
   return stat;
}
//EXTERN int asn1Copy_e2ap_RICqueryHeader (OSCTXT* pctxt, const e2ap_RICqueryHeader* pSrcValue, e2ap_RICqueryHeader* pDstValue);
 int asn1Init_e2ap_RICqueryHeader (e2ap_RICqueryHeader* pvalue){
   if (pvalue == 0) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   pvalue->data = 0;
   return 0;
}
 void asn1Free_e2ap_RICqueryHeader (OSCTXT* pctxt, e2ap_RICqueryHeader* pvalue){
   if (pvalue == 0) return;
   if(pvalue->numocts>0){
       rtxMemFreePtr(pctxt, (void*)pvalue->data);
       pvalue->data = 0;
       pvalue->numocts = 0;
   }
}
int asn1Init_e2ap_RICqueryHeader (e2ap_RICqueryHeader* pvalue){
   if (pvalue == 0) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   pvalue->data = 0;
   return 0;
}
/*****************************************/
/*           RICqueryDefinition                */
/*****************************************/
//9 mau octet string
//type 9  mau la octet string no size mau la pdusessioncommonnetworkinstance

EXTERN int asn1PE_e2ap_RICqueryDefinition (OSCTXT* pctxt, e2ap_RICqueryDefinition value){
   int stat = 0
   RTXCTCXTPUSHTYPENAME (pctxt, "RICqueryDefinition");
   stat = pe_OctetString(pctxt, value.numocts, value.data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPTYPENAME (pctxt);

}
EXTERN int asn1PD_e2ap_RICqueryDefinition (OSCTXT* pctxt, e2ap_RICqueryDefinition* pvalue){
   int stat = 0;
   RTXCTCXTPUSHTYPENAME (pctxt, "RICqueryDefinition");
   stat = pd_DynOctetString(pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}
EXTERN int asn1PrtToStr_e2ap_RICqueryDefinition (const char* name, e2ap_RICqueryDefinition *pvalue, char* buffer, OSSIZE bufSize){
   if(rtPrintToStringIndent(buffer, bufSize) < 0) return -1;
   if(rtPrintToStringHexStr(name, pvalue->numocts, pvalue->data, buffer, bufSize) < 0) return -1;
   return 0;
}
EXTERN int asn1PrtToStrm_e2ap_RICqueryDefinition (OSCTXT* pctxt, const char* name, const e2ap_RICqueryDefinition* pvalue){
   int stat =0;
   stat = rtPrintToStreamIndent(pctxt);
   if(stat !=0) return LOG_RTERR(pctxt, stat);
   stat = rtPrintToStreamHexStr(pctxt, name, pvalue->numocts, pvalue->data);
   if(stat !=0) return LOG_RTERR(pctxt, stat);
   return stat;
}
//EXTERN int asn1Copy_e2ap_RICqueryDefinition (OSCTXT* pctxt, const e2ap_RICqueryDefinition* pSrcValue, e2ap_RICqueryDefinition* pDstValue);
 int asn1Init_e2ap_RICqueryDefinition (e2ap_RICqueryDefinition* pvalue){
   if (pvalue == 0) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   pvalue->data = 0;
   return 0;
}
 void asn1Free_e2ap_RICqueryDefinition (OSCTXT* pctxt, e2ap_RICqueryDefinition* pvalue){
   if (pvalue == 0) return;
   if(pvalue->numocts>0){
       rtxMemFreePtr(pctxt, (void*)pvalue->data);
       pvalue->data = 0;
       pvalue->numocts = 0;
   }
}
int asn1Init_e2ap_RICqueryDefinition (e2ap_RICqueryDefinition* pvalue){
   if (pvalue == 0) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   pvalue->data = 0;
   return 0;
}
/*****************************************/
/*           RICqueryRequest_IEs                */
/*****************************************/
/* ie.c.j2 */
 /* d là con của msg */
EXTERN int asn1PE_e2ap_RICqueryRequest_protocolIEs_element (OSCTXT* pctxt, e2ap_RICqueryRequest_protocolIEs_element* pvalue)
{
    int stat =0;

    /*encode id*/

    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PE_e2ap_ProtocolIE_ID(pctxt, pvalue->id);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PE_e2ap_Criticality(pctxt, pvalue->criticality);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
    {
        OSCTXT lctxt;
        OSOCTET *pDynamicEncodeBuffer;
        ASN1OpenType openType;
        OSBOOL encoded = TRUE;

        openType.numocts = 0;
        openType.data =0;

        rtxCopyContext(&lctxt, pctxt);
        pctxt->pStream =0;

        stat = rtxInitContextBuffer(pctxt, 0, 0);
        if(stat!=0) return LOG_RTERR(pctxt, stat);

        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_RICqueryRequest_IEs_id_RICrequestID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICrequestID");
                    stat = asn1PE_e2ap_RICrequestID (pctxt, pvalue->value.u._e2ap_RICqueryRequest_IEs_id_RICrequestID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICqueryRequest_IEs_id_RANfunctionID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RANfunctionID");
                    stat = asn1PE_e2ap_RANfunctionID (pctxt, pvalue->value.u._e2ap_RICqueryRequest_IEs_id_RANfunctionID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICqueryRequest_IEs_id_RICqueryHeader:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICqueryHeader");
                    stat = asn1PE_e2ap_RICqueryHeader (pctxt, pvalue->value.u._e2ap_RICqueryRequest_IEs_id_RICqueryHeader);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICqueryRequest_IEs_id_RICqueryDefinition:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICqueryDefinition");
                    stat = asn1PE_e2ap_RICqueryDefinition (pctxt, pvalue->value.u._e2ap_RICqueryRequest_IEs_id_RICqueryDefinition);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_RICqueryRequest_IEs_UNDEF_:
            {
                if(0!=pvalue->value.u.extElem1){
                    openType.numocts = pvalue->value.u.extElem1->numocts;
                    openType.data = pvalue->value.u.extElem1->data;
                } else {
                    /* No extension element to encode */
                }
                encoded = FALSE;
                break;
            }

            default:
                encoded = FALSE;
                stat = RTERR_INVOPT;
                break;
        } 

        if(encoded){
            openType.numocts = (OSUINT32)pe_GetMsgLen(pctxt);
            openType.data = pDynamicEncodeBuffer = pctxt -> buffer.data;
        }
        rtxCopyContext(pctxt, &lctxt);

        if(stat == 0) {
            stat = pe_OpenType (pctxt, openType.numocts, openType.data);
        }
    #if 1
        if(encoded){//dungnm23 check lai nhe
            rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
        }
    #endif

    }

    if(stat!=0) return LOG_RTERR(pctxt, stat);  
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}

EXTERN int  asn1PD_e2ap_RICqueryRequest_protocolIEs_element (OSCTXT* pctxt, e2ap_RICqueryRequest_protocolIEs_element* pvalue){
    int stat =0;

    /*decode id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PD_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PD_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");

    {
        OSUINT32 openTypeLen;
        size_t bitStartOffset, bitLength;

        stat = pd_UnconsLength(pctxt, &openTypeLen);
        if(stat<0) return LOG_RTERR(pctxt, stat);
        else if(stat == RT_OK_FRAG){
            rtxErrAddStrParm(pctxt, "open type with fragment length");
            return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
        }
        bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
        bitLength = openTypeLen * 8;

        switch(pvalue->id){//dungnm23 check case lai nhe
        
            case ASN1V_e2ap_id_RICrequestID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICqueryRequest_IEs_id_RICrequestID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICrequestID");
                pvalue->value.u._e2ap_RICqueryRequest_IEs_id_RICrequestID 
                    = rtxMemAllocType(pctxt, e2ap_RICrequestID);

                asn1Init_e2ap_RICrequestID(pvalue->value.u._e2ap_RICqueryRequest_IEs_id_RICrequestID);

                stat = asn1PD_e2ap_RICrequestID (pctxt,
                        (e2ap_RICrequestID*)pvalue->value.
                        u._e2ap_RICqueryRequest_IEs_id_RICrequestID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RANfunctionID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICqueryRequest_IEs_id_RANfunctionID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RANfunctionID");
                pvalue->value.u._e2ap_RICqueryRequest_IEs_id_RANfunctionID 
                    = rtxMemAllocType(pctxt, e2ap_RANfunctionID);

                asn1Init_e2ap_RANfunctionID(pvalue->value.u._e2ap_RICqueryRequest_IEs_id_RANfunctionID);

                stat = asn1PD_e2ap_RANfunctionID (pctxt,
                        (e2ap_RANfunctionID*)pvalue->value.
                        u._e2ap_RICqueryRequest_IEs_id_RANfunctionID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RICqueryHeader:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICqueryRequest_IEs_id_RICqueryHeader;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICqueryHeader");
                pvalue->value.u._e2ap_RICqueryRequest_IEs_id_RICqueryHeader 
                    = rtxMemAllocType(pctxt, e2ap_RICqueryHeader);

                asn1Init_e2ap_RICqueryHeader(pvalue->value.u._e2ap_RICqueryRequest_IEs_id_RICqueryHeader);

                stat = asn1PD_e2ap_RICqueryHeader (pctxt,
                        (e2ap_RICqueryHeader*)pvalue->value.
                        u._e2ap_RICqueryRequest_IEs_id_RICqueryHeader);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RICqueryDefinition:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICqueryRequest_IEs_id_RICqueryDefinition;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICqueryDefinition");
                pvalue->value.u._e2ap_RICqueryRequest_IEs_id_RICqueryDefinition 
                    = rtxMemAllocType(pctxt, e2ap_RICqueryDefinition);

                asn1Init_e2ap_RICqueryDefinition(pvalue->value.u._e2ap_RICqueryRequest_IEs_id_RICqueryDefinition);

                stat = asn1PD_e2ap_RICqueryDefinition (pctxt,
                        (e2ap_RICqueryDefinition*)pvalue->value.
                        u._e2ap_RICqueryRequest_IEs_id_RICqueryDefinition);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICqueryRequest_IEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*) rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
    }
    {
    size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
    size_t bitsConsumed = bitEndOffset-bitStartOffset;
    if(bitsConsumed<bitLength){
        stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
    }
    else stat =(bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
    }}
    if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}


int asn1Init_e2ap_RICqueryRequest_protocolIEs_element(e2ap_RICqueryRequest_protocolIEs_element* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    OSCRTLMEMSET (&pvalue->value, 0, sizeof(pvalue->value));
    return 0;
}


//-----> chuaw có template rtxFreeASN1OpenType

#if 0
void asn1Free_e2ap_RICqueryRequest_protocolIEs_element(OSCTXT* pctxt, e2ap_RICqueryRequest_protocolIEs_element* pvalue)
{
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICqueryRequest_IEs_id_id_RICrequestID:
            // rtxFreeE2ap_RICrequestID(pvalue->value.u._e2ap_RICqueryRequest_IEs_id_id_RICrequestID);

            if(pvalue->value.i._e2ap_RICqueryRequest_id_RICrequestID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICrequestID(pctxt, pvalue->value.u._e2ap_RICqueryRequest_IEs_id_id_RICrequestID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICqueryRequest_IEs_id_id_RICrequestID);
           // pvalue->value.u._e2ap_RICqueryRequest_IEs_id_id_RICrequestID = NULL;
           pvalue->value.u._e2ap_RICqueryRequest_IEs_id_RICrequestID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICqueryRequest_IEs_id_id_RANfunctionID:
            // rtxFreeE2ap_RANfunctionID(pvalue->value.u._e2ap_RICqueryRequest_IEs_id_id_RANfunctionID);

            if(pvalue->value.i._e2ap_RICqueryRequest_id_RANfunctionID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RANfunctionID(pctxt, pvalue->value.u._e2ap_RICqueryRequest_IEs_id_id_RANfunctionID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICqueryRequest_IEs_id_id_RANfunctionID);
           // pvalue->value.u._e2ap_RICqueryRequest_IEs_id_id_RANfunctionID = NULL;
           pvalue->value.u._e2ap_RICqueryRequest_IEs_id_RANfunctionID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICqueryRequest_IEs_id_id_RICqueryHeader:
            // rtxFreeE2ap_RICqueryHeader(pvalue->value.u._e2ap_RICqueryRequest_IEs_id_id_RICqueryHeader);

            if(pvalue->value.i._e2ap_RICqueryRequest_id_RICqueryHeader!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICqueryHeader(pctxt, pvalue->value.u._e2ap_RICqueryRequest_IEs_id_id_RICqueryHeader);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICqueryRequest_IEs_id_id_RICqueryHeader);
           // pvalue->value.u._e2ap_RICqueryRequest_IEs_id_id_RICqueryHeader = NULL;
           pvalue->value.u._e2ap_RICqueryRequest_IEs_id_RICqueryHeader = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICqueryRequest_IEs_id_id_RICqueryDefinition:
            // rtxFreeE2ap_RICqueryDefinition(pvalue->value.u._e2ap_RICqueryRequest_IEs_id_id_RICqueryDefinition);

            if(pvalue->value.i._e2ap_RICqueryRequest_id_RICqueryDefinition!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICqueryDefinition(pctxt, pvalue->value.u._e2ap_RICqueryRequest_IEs_id_id_RICqueryDefinition);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICqueryRequest_IEs_id_id_RICqueryDefinition);
           // pvalue->value.u._e2ap_RICqueryRequest_IEs_id_id_RICqueryDefinition = NULL;
           pvalue->value.u._e2ap_RICqueryRequest_IEs_id_RICqueryDefinition = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICqueryRequest_IEs_UNDEF_:
            rtxFreeASN1OpenType(pvalue->value.u.extElem1);
            break;
        default:
            break;
    }
}

int asn1PrtToStr_e2ap_RICqueryRequest_protocolIEs_element(OSCTXT* pctxt, e2ap_RICqueryRequest_protocolIEs_element* pvalue)
{
    int stat =0;
    RTXCTXTPUSHELEMNAME(pctxt, "e2ap_RICqueryRequest_protocolIEs_element");

    /*print id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PrtToStr_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PrtToStr_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_RICqueryRequest_IEs_id_id_RICrequestID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICrequestID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICrequestID (pctxt, pvalue->value.u._e2ap_RICqueryRequest_IEs_id_id_RICrequestID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICqueryRequest_IEs_id_id_RANfunctionID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RANfunctionID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RANfunctionID (pctxt, pvalue->value.u._e2ap_RICqueryRequest_IEs_id_id_RANfunctionID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICqueryRequest_IEs_id_id_RICqueryHeader:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICqueryHeader");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICqueryHeader (pctxt, pvalue->value.u._e2ap_RICqueryRequest_IEs_id_id_RICqueryHeader);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICqueryRequest_IEs_id_id_RICqueryDefinition:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICqueryDefinition");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICqueryDefinition (pctxt, pvalue->value.u._e2ap_RICqueryRequest_IEs_id_id_RICqueryDefinition);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_RICqueryRequest_IEs_UNDEF_:
            {
                rtxPLogMsg(pctxt, "Extension element present - raw data not printed.\n");
                break;
            }

            default:
                stat = RTERR_INVOPT;
                return LOG_RTERR(pctxt, stat);
        }
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);
}
#endif


int asn1PrtToStr_e2ap_RICqueryRequest_protocolIEs_element (const char * name,
 e2ap_RICqueryRequest_protocolIEs_element* pvalue, 
 char * buffer, OSSIZE bufSize){
    if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
        return -1;
    if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
        return -1;

    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICqueryRequest_IEs_id_RICrequestID:
            if(asn1PrtToStr_e2ap_RICrequestID("RICrequestID", 
                    pvalue->value.u._e2ap_RICqueryRequest_IEs_id_RICrequestID, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICqueryRequest_IEs_id_RANfunctionID:
            if(asn1PrtToStr_e2ap_RANfunctionID("RANfunctionID", 
                    pvalue->value.u._e2ap_RICqueryRequest_IEs_id_RANfunctionID, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICqueryRequest_IEs_id_RICqueryHeader:
            if(asn1PrtToStr_e2ap_RICqueryHeader("RICqueryHeader", 
                    pvalue->value.u._e2ap_RICqueryRequest_IEs_id_RICqueryHeader, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICqueryRequest_IEs_id_RICqueryDefinition:
            if(asn1PrtToStr_e2ap_RICqueryDefinition("RICqueryDefinition", 
                    pvalue->value.u._e2ap_RICqueryRequest_IEs_id_RICqueryDefinition, buffer, bufSize)<0)
                return -1;
            break;    
        default:
        if(0!=pvalue -> value.u.extElem1){
            rtPrintToStringIndent(buffer, bufSize);
            rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

        }
        }
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

    return 0;

 }

 void asn1Free_e2ap_RICqueryRequest_protocolIEs_element(OSCTXT* pctxt, e2ap_RICqueryRequest_protocolIEs_element* pvalue){
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICqueryRequest_IEs_id_RICrequestID:
            if(pvalue->value.u._e2ap_RICqueryRequest_IEs_id_RICrequestID!=NULL){
            asn1Free_e2ap_RICrequestID(pctxt, pvalue->value.u._e2ap_RICqueryRequest_IEs_id_RICrequestID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICqueryRequest_IEs_id_RICrequestID);
            pvalue->value.u._e2ap_RICqueryRequest_IEs_id_RICrequestID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICqueryRequest_IEs_id_RANfunctionID:
            if(pvalue->value.u._e2ap_RICqueryRequest_IEs_id_RANfunctionID!=NULL){
            asn1Free_e2ap_RANfunctionID(pctxt, pvalue->value.u._e2ap_RICqueryRequest_IEs_id_RANfunctionID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICqueryRequest_IEs_id_RANfunctionID);
            pvalue->value.u._e2ap_RICqueryRequest_IEs_id_RANfunctionID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICqueryRequest_IEs_id_RICqueryHeader:
            if(pvalue->value.u._e2ap_RICqueryRequest_IEs_id_RICqueryHeader!=NULL){
            asn1Free_e2ap_RICqueryHeader(pctxt, pvalue->value.u._e2ap_RICqueryRequest_IEs_id_RICqueryHeader);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICqueryRequest_IEs_id_RICqueryHeader);
            pvalue->value.u._e2ap_RICqueryRequest_IEs_id_RICqueryHeader = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICqueryRequest_IEs_id_RICqueryDefinition:
            if(pvalue->value.u._e2ap_RICqueryRequest_IEs_id_RICqueryDefinition!=NULL){
            asn1Free_e2ap_RICqueryDefinition(pctxt, pvalue->value.u._e2ap_RICqueryRequest_IEs_id_RICqueryDefinition);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICqueryRequest_IEs_id_RICqueryDefinition);
            pvalue->value.u._e2ap_RICqueryRequest_IEs_id_RICqueryDefinition = NULL;
            }
            break;
        default:
            break;


    }
 }

 

/*****************************************/
/*           RICqueryRequest                */
/*****************************************/
//2_container.c
/* 1. xxx_ProtocolIE -> mẫu cũ ở ie_big_msg */
EXTERN int asn1PE_e2ap_RICqueryRequest_protocolIEs (OSCTXT* pctxt, e2ap_RICqueryRequest_protocolIEs* pvalue)
{
    int stat =0;
    OSRTDListNode* pnode;
    OSUINT32 xx1;

    /*encode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pe_Length(pctxt, pvalue->count);
    if(stat<0) return LOG_RTERR(pctxt, stat);

    /*encode each element*/
    xx1 =0;
    for(pnode = pvalue->head; pnode != 0 && xx1<pvalue->count; pnode = pnode->next){
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE", xx1);
        stat = asn1PE_e2ap_RICqueryRequest_protocolIEs_element (pctxt, ((e2ap_RICqueryRequest_protocolIEs_element*)pnode->data));
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        xx1++;
        RTXCTXTPOPARRAYELEMNAME(pctxt);
    }

    return (stat);
}

EXTERN int  asn1PD_e2ap_RICqueryRequest_protocolIEs(OSCTXT* pctxt, e2ap_RICqueryRequest_protocolIEs* pvalue)
{
     int stat =0;
     OSRTDListNode* pnode;
     OSSIZE count =0;
     OSSIZE xx1=0;


     /*decode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pd_Length64(pctxt, &count); //tai sao lai 64
    if(stat!=0) return LOG_RTERR(pctxt, stat);

    /*decode each element*/
    rtxDListInit(pvalue);

    for(xx1=0; xx1 < count; xx1++){
        e2ap_RICqueryRequest_protocolIEs_element* pdata;
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE",xx1);

        if(pnode == NULL) return LOG_RTERR(pctxt, RTERR_NOMEM);

        asn1Init_e2ap_RICqueryRequest_protocolIEs_element(pdata);
        rtxDListAppendNode(pvalue, pnode);
        stat = asn1PD_e2ap_RICqueryRequest_protocolIEs_element (pctxt, pdata);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        RTXCTXTPOPARRAYELEMNAME(pctxt);

    }
    return (stat);
}


int asn1Init_e2ap_RICqueryRequest_protocolIEs(e2ap_RICqueryRequest_protocolIEs* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    rtxDListFastInit (pvalue);
    return 0;
}
#if 1 //ao that day
void asn1Free_e2ap_RICqueryRequest_protocolIEs(OSCTXT* pctxt, e2ap_RICqueryRequest_protocolIEs* pvalue)
{
    if(0==pvalue) return;   
    e2ap_RICqueryRequest_protocolIEs_element* pdata;
    OSRTDListNode* pnode=pvalue->head;
    while(0!=pnode){
        pdata = (e2ap_RICqueryRequest_protocolIEs_element*)pnode->data;
       // asn1Free_e2ap_RICqueryRequest_protocolIEs_element(pctxt, pdata);
        pnode = pnode->next;
    }
    rtxDListFreeAll(pctxt, pvalue);
}
#endif


EXTERN int asn1PrtToStr_e2ap_RICqueryRequest_protocolIEs(const char* name, e2ap_RICqueryRequest_protocolIEs* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_RICqueryRequest_protocolIEs_element* pdata0;
    OSRTDListNode* pnode0;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode0 = pvalue->head;  xx1 < pvalue->count && pnode0 != 0; pnode0 = pnode0->next, xx1++){
        pdata0 = (e2ap_RICqueryRequest_protocolIEs_element*)pnode0->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 0
        if(asn1PrtToStr_e2ap_RICqueryRequest_protocolIEs_element(nameBuf, pdata0, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}


/*2 . RICqueryRequest -> mẫu cũ ở seq_normal*/

int asn1PE_e2ap_RICqueryRequest (OSCTXT* pctxt, e2ap_RICqueryRequest* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RICqueryRequest");
   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field protocolIEs - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
   stat = asn1PE_e2ap_RICqueryRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if(stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RICqueryRequest (OSCTXT* pctxt, e2ap_RICqueryRequest* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME(pctxt, "RICqueryRequest");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field protocolIEs */
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
      stat = asn1PD_e2ap_RICqueryRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RICqueryRequest (e2ap_RICqueryRequest* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RICqueryRequest_protocolIEs(&pvalue->protocolIEs);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RICqueryRequest (OSCTXT* pctxt, e2ap_RICqueryRequest* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_RICqueryRequest_protocolIEs(pctxt, &pvalue->protocolIEs);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RICqueryRequest (const char* name, e2ap_RICqueryRequest* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }

   if(asn1PrtToStr_e2ap_RICqueryRequest_protocolIEs("protocolIEs", &pvalue->protocolIEs, buffer, bufSize) <0){
      return -1;
   }

   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           RICqueryOutcome                */
/*****************************************/
//9 mau octet string
//type 9  mau la octet string no size mau la pdusessioncommonnetworkinstance

EXTERN int asn1PE_e2ap_RICqueryOutcome (OSCTXT* pctxt, e2ap_RICqueryOutcome value){
   int stat = 0
   RTXCTCXTPUSHTYPENAME (pctxt, "RICqueryOutcome");
   stat = pe_OctetString(pctxt, value.numocts, value.data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPTYPENAME (pctxt);

}
EXTERN int asn1PD_e2ap_RICqueryOutcome (OSCTXT* pctxt, e2ap_RICqueryOutcome* pvalue){
   int stat = 0;
   RTXCTCXTPUSHTYPENAME (pctxt, "RICqueryOutcome");
   stat = pd_DynOctetString(pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   RTXCTXTPOPTYPENAME (pctxt);
   return stat;
}
EXTERN int asn1PrtToStr_e2ap_RICqueryOutcome (const char* name, e2ap_RICqueryOutcome *pvalue, char* buffer, OSSIZE bufSize){
   if(rtPrintToStringIndent(buffer, bufSize) < 0) return -1;
   if(rtPrintToStringHexStr(name, pvalue->numocts, pvalue->data, buffer, bufSize) < 0) return -1;
   return 0;
}
EXTERN int asn1PrtToStrm_e2ap_RICqueryOutcome (OSCTXT* pctxt, const char* name, const e2ap_RICqueryOutcome* pvalue){
   int stat =0;
   stat = rtPrintToStreamIndent(pctxt);
   if(stat !=0) return LOG_RTERR(pctxt, stat);
   stat = rtPrintToStreamHexStr(pctxt, name, pvalue->numocts, pvalue->data);
   if(stat !=0) return LOG_RTERR(pctxt, stat);
   return stat;
}
//EXTERN int asn1Copy_e2ap_RICqueryOutcome (OSCTXT* pctxt, const e2ap_RICqueryOutcome* pSrcValue, e2ap_RICqueryOutcome* pDstValue);
 int asn1Init_e2ap_RICqueryOutcome (e2ap_RICqueryOutcome* pvalue){
   if (pvalue == 0) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   pvalue->data = 0;
   return 0;
}
 void asn1Free_e2ap_RICqueryOutcome (OSCTXT* pctxt, e2ap_RICqueryOutcome* pvalue){
   if (pvalue == 0) return;
   if(pvalue->numocts>0){
       rtxMemFreePtr(pctxt, (void*)pvalue->data);
       pvalue->data = 0;
       pvalue->numocts = 0;
   }
}
int asn1Init_e2ap_RICqueryOutcome (e2ap_RICqueryOutcome* pvalue){
   if (pvalue == 0) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   pvalue->data = 0;
   return 0;
}
/*****************************************/
/*           RICqueryResponse_IEs                */
/*****************************************/
/* ie.c.j2 */
 /* d là con của msg */
EXTERN int asn1PE_e2ap_RICqueryResponse_protocolIEs_element (OSCTXT* pctxt, e2ap_RICqueryResponse_protocolIEs_element* pvalue)
{
    int stat =0;

    /*encode id*/

    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PE_e2ap_ProtocolIE_ID(pctxt, pvalue->id);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PE_e2ap_Criticality(pctxt, pvalue->criticality);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
    {
        OSCTXT lctxt;
        OSOCTET *pDynamicEncodeBuffer;
        ASN1OpenType openType;
        OSBOOL encoded = TRUE;

        openType.numocts = 0;
        openType.data =0;

        rtxCopyContext(&lctxt, pctxt);
        pctxt->pStream =0;

        stat = rtxInitContextBuffer(pctxt, 0, 0);
        if(stat!=0) return LOG_RTERR(pctxt, stat);

        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_RICqueryResponse_IEs_id_RICrequestID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICrequestID");
                    stat = asn1PE_e2ap_RICrequestID (pctxt, pvalue->value.u._e2ap_RICqueryResponse_IEs_id_RICrequestID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICqueryResponse_IEs_id_RANfunctionID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RANfunctionID");
                    stat = asn1PE_e2ap_RANfunctionID (pctxt, pvalue->value.u._e2ap_RICqueryResponse_IEs_id_RANfunctionID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICqueryResponse_IEs_id_RICqueryOutcome:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICqueryOutcome");
                    stat = asn1PE_e2ap_RICqueryOutcome (pctxt, pvalue->value.u._e2ap_RICqueryResponse_IEs_id_RICqueryOutcome);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_RICqueryResponse_IEs_UNDEF_:
            {
                if(0!=pvalue->value.u.extElem1){
                    openType.numocts = pvalue->value.u.extElem1->numocts;
                    openType.data = pvalue->value.u.extElem1->data;
                } else {
                    /* No extension element to encode */
                }
                encoded = FALSE;
                break;
            }

            default:
                encoded = FALSE;
                stat = RTERR_INVOPT;
                break;
        } 

        if(encoded){
            openType.numocts = (OSUINT32)pe_GetMsgLen(pctxt);
            openType.data = pDynamicEncodeBuffer = pctxt -> buffer.data;
        }
        rtxCopyContext(pctxt, &lctxt);

        if(stat == 0) {
            stat = pe_OpenType (pctxt, openType.numocts, openType.data);
        }
    #if 1
        if(encoded){//dungnm23 check lai nhe
            rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
        }
    #endif

    }

    if(stat!=0) return LOG_RTERR(pctxt, stat);  
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}

EXTERN int  asn1PD_e2ap_RICqueryResponse_protocolIEs_element (OSCTXT* pctxt, e2ap_RICqueryResponse_protocolIEs_element* pvalue){
    int stat =0;

    /*decode id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PD_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PD_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");

    {
        OSUINT32 openTypeLen;
        size_t bitStartOffset, bitLength;

        stat = pd_UnconsLength(pctxt, &openTypeLen);
        if(stat<0) return LOG_RTERR(pctxt, stat);
        else if(stat == RT_OK_FRAG){
            rtxErrAddStrParm(pctxt, "open type with fragment length");
            return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
        }
        bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
        bitLength = openTypeLen * 8;

        switch(pvalue->id){//dungnm23 check case lai nhe
        
            case ASN1V_e2ap_id_RICrequestID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICqueryResponse_IEs_id_RICrequestID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICrequestID");
                pvalue->value.u._e2ap_RICqueryResponse_IEs_id_RICrequestID 
                    = rtxMemAllocType(pctxt, e2ap_RICrequestID);

                asn1Init_e2ap_RICrequestID(pvalue->value.u._e2ap_RICqueryResponse_IEs_id_RICrequestID);

                stat = asn1PD_e2ap_RICrequestID (pctxt,
                        (e2ap_RICrequestID*)pvalue->value.
                        u._e2ap_RICqueryResponse_IEs_id_RICrequestID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RANfunctionID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICqueryResponse_IEs_id_RANfunctionID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RANfunctionID");
                pvalue->value.u._e2ap_RICqueryResponse_IEs_id_RANfunctionID 
                    = rtxMemAllocType(pctxt, e2ap_RANfunctionID);

                asn1Init_e2ap_RANfunctionID(pvalue->value.u._e2ap_RICqueryResponse_IEs_id_RANfunctionID);

                stat = asn1PD_e2ap_RANfunctionID (pctxt,
                        (e2ap_RANfunctionID*)pvalue->value.
                        u._e2ap_RICqueryResponse_IEs_id_RANfunctionID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RICqueryOutcome:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICqueryResponse_IEs_id_RICqueryOutcome;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICqueryOutcome");
                pvalue->value.u._e2ap_RICqueryResponse_IEs_id_RICqueryOutcome 
                    = rtxMemAllocType(pctxt, e2ap_RICqueryOutcome);

                asn1Init_e2ap_RICqueryOutcome(pvalue->value.u._e2ap_RICqueryResponse_IEs_id_RICqueryOutcome);

                stat = asn1PD_e2ap_RICqueryOutcome (pctxt,
                        (e2ap_RICqueryOutcome*)pvalue->value.
                        u._e2ap_RICqueryResponse_IEs_id_RICqueryOutcome);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICqueryResponse_IEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*) rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
    }
    {
    size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
    size_t bitsConsumed = bitEndOffset-bitStartOffset;
    if(bitsConsumed<bitLength){
        stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
    }
    else stat =(bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
    }}
    if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}


int asn1Init_e2ap_RICqueryResponse_protocolIEs_element(e2ap_RICqueryResponse_protocolIEs_element* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    OSCRTLMEMSET (&pvalue->value, 0, sizeof(pvalue->value));
    return 0;
}


//-----> chuaw có template rtxFreeASN1OpenType

#if 0
void asn1Free_e2ap_RICqueryResponse_protocolIEs_element(OSCTXT* pctxt, e2ap_RICqueryResponse_protocolIEs_element* pvalue)
{
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICqueryResponse_IEs_id_id_RICrequestID:
            // rtxFreeE2ap_RICrequestID(pvalue->value.u._e2ap_RICqueryResponse_IEs_id_id_RICrequestID);

            if(pvalue->value.i._e2ap_RICqueryResponse_id_RICrequestID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICrequestID(pctxt, pvalue->value.u._e2ap_RICqueryResponse_IEs_id_id_RICrequestID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICqueryResponse_IEs_id_id_RICrequestID);
           // pvalue->value.u._e2ap_RICqueryResponse_IEs_id_id_RICrequestID = NULL;
           pvalue->value.u._e2ap_RICqueryResponse_IEs_id_RICrequestID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICqueryResponse_IEs_id_id_RANfunctionID:
            // rtxFreeE2ap_RANfunctionID(pvalue->value.u._e2ap_RICqueryResponse_IEs_id_id_RANfunctionID);

            if(pvalue->value.i._e2ap_RICqueryResponse_id_RANfunctionID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RANfunctionID(pctxt, pvalue->value.u._e2ap_RICqueryResponse_IEs_id_id_RANfunctionID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICqueryResponse_IEs_id_id_RANfunctionID);
           // pvalue->value.u._e2ap_RICqueryResponse_IEs_id_id_RANfunctionID = NULL;
           pvalue->value.u._e2ap_RICqueryResponse_IEs_id_RANfunctionID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICqueryResponse_IEs_id_id_RICqueryOutcome:
            // rtxFreeE2ap_RICqueryOutcome(pvalue->value.u._e2ap_RICqueryResponse_IEs_id_id_RICqueryOutcome);

            if(pvalue->value.i._e2ap_RICqueryResponse_id_RICqueryOutcome!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICqueryOutcome(pctxt, pvalue->value.u._e2ap_RICqueryResponse_IEs_id_id_RICqueryOutcome);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICqueryResponse_IEs_id_id_RICqueryOutcome);
           // pvalue->value.u._e2ap_RICqueryResponse_IEs_id_id_RICqueryOutcome = NULL;
           pvalue->value.u._e2ap_RICqueryResponse_IEs_id_RICqueryOutcome = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICqueryResponse_IEs_UNDEF_:
            rtxFreeASN1OpenType(pvalue->value.u.extElem1);
            break;
        default:
            break;
    }
}

int asn1PrtToStr_e2ap_RICqueryResponse_protocolIEs_element(OSCTXT* pctxt, e2ap_RICqueryResponse_protocolIEs_element* pvalue)
{
    int stat =0;
    RTXCTXTPUSHELEMNAME(pctxt, "e2ap_RICqueryResponse_protocolIEs_element");

    /*print id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PrtToStr_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PrtToStr_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_RICqueryResponse_IEs_id_id_RICrequestID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICrequestID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICrequestID (pctxt, pvalue->value.u._e2ap_RICqueryResponse_IEs_id_id_RICrequestID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICqueryResponse_IEs_id_id_RANfunctionID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RANfunctionID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RANfunctionID (pctxt, pvalue->value.u._e2ap_RICqueryResponse_IEs_id_id_RANfunctionID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICqueryResponse_IEs_id_id_RICqueryOutcome:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICqueryOutcome");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICqueryOutcome (pctxt, pvalue->value.u._e2ap_RICqueryResponse_IEs_id_id_RICqueryOutcome);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_RICqueryResponse_IEs_UNDEF_:
            {
                rtxPLogMsg(pctxt, "Extension element present - raw data not printed.\n");
                break;
            }

            default:
                stat = RTERR_INVOPT;
                return LOG_RTERR(pctxt, stat);
        }
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);
}
#endif


int asn1PrtToStr_e2ap_RICqueryResponse_protocolIEs_element (const char * name,
 e2ap_RICqueryResponse_protocolIEs_element* pvalue, 
 char * buffer, OSSIZE bufSize){
    if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
        return -1;
    if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
        return -1;

    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICqueryResponse_IEs_id_RICrequestID:
            if(asn1PrtToStr_e2ap_RICrequestID("RICrequestID", 
                    pvalue->value.u._e2ap_RICqueryResponse_IEs_id_RICrequestID, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICqueryResponse_IEs_id_RANfunctionID:
            if(asn1PrtToStr_e2ap_RANfunctionID("RANfunctionID", 
                    pvalue->value.u._e2ap_RICqueryResponse_IEs_id_RANfunctionID, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICqueryResponse_IEs_id_RICqueryOutcome:
            if(asn1PrtToStr_e2ap_RICqueryOutcome("RICqueryOutcome", 
                    pvalue->value.u._e2ap_RICqueryResponse_IEs_id_RICqueryOutcome, buffer, bufSize)<0)
                return -1;
            break;    
        default:
        if(0!=pvalue -> value.u.extElem1){
            rtPrintToStringIndent(buffer, bufSize);
            rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

        }
        }
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

    return 0;

 }

 void asn1Free_e2ap_RICqueryResponse_protocolIEs_element(OSCTXT* pctxt, e2ap_RICqueryResponse_protocolIEs_element* pvalue){
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICqueryResponse_IEs_id_RICrequestID:
            if(pvalue->value.u._e2ap_RICqueryResponse_IEs_id_RICrequestID!=NULL){
            asn1Free_e2ap_RICrequestID(pctxt, pvalue->value.u._e2ap_RICqueryResponse_IEs_id_RICrequestID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICqueryResponse_IEs_id_RICrequestID);
            pvalue->value.u._e2ap_RICqueryResponse_IEs_id_RICrequestID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICqueryResponse_IEs_id_RANfunctionID:
            if(pvalue->value.u._e2ap_RICqueryResponse_IEs_id_RANfunctionID!=NULL){
            asn1Free_e2ap_RANfunctionID(pctxt, pvalue->value.u._e2ap_RICqueryResponse_IEs_id_RANfunctionID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICqueryResponse_IEs_id_RANfunctionID);
            pvalue->value.u._e2ap_RICqueryResponse_IEs_id_RANfunctionID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICqueryResponse_IEs_id_RICqueryOutcome:
            if(pvalue->value.u._e2ap_RICqueryResponse_IEs_id_RICqueryOutcome!=NULL){
            asn1Free_e2ap_RICqueryOutcome(pctxt, pvalue->value.u._e2ap_RICqueryResponse_IEs_id_RICqueryOutcome);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICqueryResponse_IEs_id_RICqueryOutcome);
            pvalue->value.u._e2ap_RICqueryResponse_IEs_id_RICqueryOutcome = NULL;
            }
            break;
        default:
            break;


    }
 }

 

/*****************************************/
/*           RICqueryResponse                */
/*****************************************/
//2_container.c
/* 1. xxx_ProtocolIE -> mẫu cũ ở ie_big_msg */
EXTERN int asn1PE_e2ap_RICqueryResponse_protocolIEs (OSCTXT* pctxt, e2ap_RICqueryResponse_protocolIEs* pvalue)
{
    int stat =0;
    OSRTDListNode* pnode;
    OSUINT32 xx1;

    /*encode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pe_Length(pctxt, pvalue->count);
    if(stat<0) return LOG_RTERR(pctxt, stat);

    /*encode each element*/
    xx1 =0;
    for(pnode = pvalue->head; pnode != 0 && xx1<pvalue->count; pnode = pnode->next){
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE", xx1);
        stat = asn1PE_e2ap_RICqueryResponse_protocolIEs_element (pctxt, ((e2ap_RICqueryResponse_protocolIEs_element*)pnode->data));
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        xx1++;
        RTXCTXTPOPARRAYELEMNAME(pctxt);
    }

    return (stat);
}

EXTERN int  asn1PD_e2ap_RICqueryResponse_protocolIEs(OSCTXT* pctxt, e2ap_RICqueryResponse_protocolIEs* pvalue)
{
     int stat =0;
     OSRTDListNode* pnode;
     OSSIZE count =0;
     OSSIZE xx1=0;


     /*decode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pd_Length64(pctxt, &count); //tai sao lai 64
    if(stat!=0) return LOG_RTERR(pctxt, stat);

    /*decode each element*/
    rtxDListInit(pvalue);

    for(xx1=0; xx1 < count; xx1++){
        e2ap_RICqueryResponse_protocolIEs_element* pdata;
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE",xx1);

        if(pnode == NULL) return LOG_RTERR(pctxt, RTERR_NOMEM);

        asn1Init_e2ap_RICqueryResponse_protocolIEs_element(pdata);
        rtxDListAppendNode(pvalue, pnode);
        stat = asn1PD_e2ap_RICqueryResponse_protocolIEs_element (pctxt, pdata);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        RTXCTXTPOPARRAYELEMNAME(pctxt);

    }
    return (stat);
}


int asn1Init_e2ap_RICqueryResponse_protocolIEs(e2ap_RICqueryResponse_protocolIEs* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    rtxDListFastInit (pvalue);
    return 0;
}
#if 1 //ao that day
void asn1Free_e2ap_RICqueryResponse_protocolIEs(OSCTXT* pctxt, e2ap_RICqueryResponse_protocolIEs* pvalue)
{
    if(0==pvalue) return;   
    e2ap_RICqueryResponse_protocolIEs_element* pdata;
    OSRTDListNode* pnode=pvalue->head;
    while(0!=pnode){
        pdata = (e2ap_RICqueryResponse_protocolIEs_element*)pnode->data;
       // asn1Free_e2ap_RICqueryResponse_protocolIEs_element(pctxt, pdata);
        pnode = pnode->next;
    }
    rtxDListFreeAll(pctxt, pvalue);
}
#endif


EXTERN int asn1PrtToStr_e2ap_RICqueryResponse_protocolIEs(const char* name, e2ap_RICqueryResponse_protocolIEs* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_RICqueryResponse_protocolIEs_element* pdata0;
    OSRTDListNode* pnode0;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode0 = pvalue->head;  xx1 < pvalue->count && pnode0 != 0; pnode0 = pnode0->next, xx1++){
        pdata0 = (e2ap_RICqueryResponse_protocolIEs_element*)pnode0->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 0
        if(asn1PrtToStr_e2ap_RICqueryResponse_protocolIEs_element(nameBuf, pdata0, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}


/*2 . RICqueryResponse -> mẫu cũ ở seq_normal*/

int asn1PE_e2ap_RICqueryResponse (OSCTXT* pctxt, e2ap_RICqueryResponse* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RICqueryResponse");
   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field protocolIEs - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
   stat = asn1PE_e2ap_RICqueryResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
   if(stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RICqueryResponse (OSCTXT* pctxt, e2ap_RICqueryResponse* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME(pctxt, "RICqueryResponse");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field protocolIEs */
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
      stat = asn1PD_e2ap_RICqueryResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RICqueryResponse (e2ap_RICqueryResponse* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RICqueryResponse_protocolIEs(&pvalue->protocolIEs);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RICqueryResponse (OSCTXT* pctxt, e2ap_RICqueryResponse* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_RICqueryResponse_protocolIEs(pctxt, &pvalue->protocolIEs);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RICqueryResponse (const char* name, e2ap_RICqueryResponse* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }

   if(asn1PrtToStr_e2ap_RICqueryResponse_protocolIEs("protocolIEs", &pvalue->protocolIEs, buffer, bufSize) <0){
      return -1;
   }

   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}/*****************************************/
/*           RICqueryFailure_IEs                */
/*****************************************/
/* ie.c.j2 */
 /* d là con của msg */
EXTERN int asn1PE_e2ap_RICqueryFailure_protocolIEs_element (OSCTXT* pctxt, e2ap_RICqueryFailure_protocolIEs_element* pvalue)
{
    int stat =0;

    /*encode id*/

    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PE_e2ap_ProtocolIE_ID(pctxt, pvalue->id);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PE_e2ap_Criticality(pctxt, pvalue->criticality);//xoa con tro
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*encode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
    {
        OSCTXT lctxt;
        OSOCTET *pDynamicEncodeBuffer;
        ASN1OpenType openType;
        OSBOOL encoded = TRUE;

        openType.numocts = 0;
        openType.data =0;

        rtxCopyContext(&lctxt, pctxt);
        pctxt->pStream =0;

        stat = rtxInitContextBuffer(pctxt, 0, 0);
        if(stat!=0) return LOG_RTERR(pctxt, stat);

        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_RICqueryFailure_IEs_id_RICrequestID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RICrequestID");
                    stat = asn1PE_e2ap_RICrequestID (pctxt, pvalue->value.u._e2ap_RICqueryFailure_IEs_id_RICrequestID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICqueryFailure_IEs_id_RANfunctionID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-RANfunctionID");
                    stat = asn1PE_e2ap_RANfunctionID (pctxt, pvalue->value.u._e2ap_RICqueryFailure_IEs_id_RANfunctionID);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICqueryFailure_IEs_id_Cause:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-Cause");
                    stat = asn1PE_e2ap_Cause (pctxt, pvalue->value.u._e2ap_RICqueryFailure_IEs_id_Cause);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICqueryFailure_IEs_id_CriticalityDiagnostics:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "id-CriticalityDiagnostics");
                    stat = asn1PE_e2ap_CriticalityDiagnostics (pctxt, pvalue->value.u._e2ap_RICqueryFailure_IEs_id_CriticalityDiagnostics);
                    if (stat != 0) return LOG_RTERR (pctxt, stat);
                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_RICqueryFailure_IEs_UNDEF_:
            {
                if(0!=pvalue->value.u.extElem1){
                    openType.numocts = pvalue->value.u.extElem1->numocts;
                    openType.data = pvalue->value.u.extElem1->data;
                } else {
                    /* No extension element to encode */
                }
                encoded = FALSE;
                break;
            }

            default:
                encoded = FALSE;
                stat = RTERR_INVOPT;
                break;
        } 

        if(encoded){
            openType.numocts = (OSUINT32)pe_GetMsgLen(pctxt);
            openType.data = pDynamicEncodeBuffer = pctxt -> buffer.data;
        }
        rtxCopyContext(pctxt, &lctxt);

        if(stat == 0) {
            stat = pe_OpenType (pctxt, openType.numocts, openType.data);
        }
    #if 1
        if(encoded){//dungnm23 check lai nhe
            rtxMemFreePtr(pctxt, pDynamicEncodeBuffer);
        }
    #endif

    }

    if(stat!=0) return LOG_RTERR(pctxt, stat);  
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}

EXTERN int  asn1PD_e2ap_RICqueryFailure_protocolIEs_element (OSCTXT* pctxt, e2ap_RICqueryFailure_protocolIEs_element* pvalue){
    int stat =0;

    /*decode id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PD_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PD_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*decode value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");

    {
        OSUINT32 openTypeLen;
        size_t bitStartOffset, bitLength;

        stat = pd_UnconsLength(pctxt, &openTypeLen);
        if(stat<0) return LOG_RTERR(pctxt, stat);
        else if(stat == RT_OK_FRAG){
            rtxErrAddStrParm(pctxt, "open type with fragment length");
            return LOG_RTERRNEW(pctxt, RTERR_NOTSUPP);
        }
        bitStartOffset = PU_GETCTXTBITOFFSET(pctxt);
        bitLength = openTypeLen * 8;

        switch(pvalue->id){//dungnm23 check case lai nhe
        
            case ASN1V_e2ap_id_RICrequestID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICqueryFailure_IEs_id_RICrequestID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RICrequestID");
                pvalue->value.u._e2ap_RICqueryFailure_IEs_id_RICrequestID 
                    = rtxMemAllocType(pctxt, e2ap_RICrequestID);

                asn1Init_e2ap_RICrequestID(pvalue->value.u._e2ap_RICqueryFailure_IEs_id_RICrequestID);

                stat = asn1PD_e2ap_RICrequestID (pctxt,
                        (e2ap_RICrequestID*)pvalue->value.
                        u._e2ap_RICqueryFailure_IEs_id_RICrequestID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_RANfunctionID:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICqueryFailure_IEs_id_RANfunctionID;
            RTXCTXTPUSHELEMNAME(pctxt, "id-RANfunctionID");
                pvalue->value.u._e2ap_RICqueryFailure_IEs_id_RANfunctionID 
                    = rtxMemAllocType(pctxt, e2ap_RANfunctionID);

                asn1Init_e2ap_RANfunctionID(pvalue->value.u._e2ap_RICqueryFailure_IEs_id_RANfunctionID);

                stat = asn1PD_e2ap_RANfunctionID (pctxt,
                        (e2ap_RANfunctionID*)pvalue->value.
                        u._e2ap_RICqueryFailure_IEs_id_RANfunctionID);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_Cause:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICqueryFailure_IEs_id_Cause;
            RTXCTXTPUSHELEMNAME(pctxt, "id-Cause");
                pvalue->value.u._e2ap_RICqueryFailure_IEs_id_Cause 
                    = rtxMemAllocType(pctxt, e2ap_Cause);

                asn1Init_e2ap_Cause(pvalue->value.u._e2ap_RICqueryFailure_IEs_id_Cause);

                stat = asn1PD_e2ap_Cause (pctxt,
                        (e2ap_Cause*)pvalue->value.
                        u._e2ap_RICqueryFailure_IEs_id_Cause);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    
        
            case ASN1V_e2ap_id_CriticalityDiagnostics:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICqueryFailure_IEs_id_CriticalityDiagnostics;
            RTXCTXTPUSHELEMNAME(pctxt, "id-CriticalityDiagnostics");
                pvalue->value.u._e2ap_RICqueryFailure_IEs_id_CriticalityDiagnostics 
                    = rtxMemAllocType(pctxt, e2ap_CriticalityDiagnostics);

                asn1Init_e2ap_CriticalityDiagnostics(pvalue->value.u._e2ap_RICqueryFailure_IEs_id_CriticalityDiagnostics);

                stat = asn1PD_e2ap_CriticalityDiagnostics (pctxt,
                        (e2ap_CriticalityDiagnostics*)pvalue->value.
                        u._e2ap_RICqueryFailure_IEs_id_CriticalityDiagnostics);
                        
                if(stat!=0) return LOG_RTERR(pctxt, stat);
            RTXCTXTPOPELEMNAME(pctxt);
            break;
    

        default:
            pvalue->value.t = T_E2AP_PDU_Contents_e2ap_RICqueryFailure_IEs_UNDEF_;
            pvalue->value.u.extElem1 = rtxMemAllocType(pctxt, ASN1OpenType);
            if(0==pvalue->value.u.extElem1){
                return LOG_RTERR(pctxt, RTERR_NOMEM);
            }

            {
                OSOCTET *pdata =(OSOCTET*) rtxMemAlloc(pctxt, openTypeLen);
                if(0==pdata){
                    return LOG_RTERR(pctxt, RTERR_NOMEM);
                }
                stat = rtxDecBitsToByteArray(pctxt, pdata, openTypeLen, openTypeLen*8);
                if(stat!=0){
                    rtxMemFreePtr(pctxt, pdata);
                    rtxMemFreePtr(pctxt, pvalue->value.u.extElem1);
                    return LOG_RTERR(pctxt, stat);
                }

                pvalue->value.u.extElem1->numocts = openTypeLen;
                pvalue->value.u.extElem1->data = pdata;
            }
            break;
    }
    {
    size_t bitEndOffset = PU_GETCTXTBITOFFSET(pctxt);
    size_t bitsConsumed = bitEndOffset-bitStartOffset;
    if(bitsConsumed<bitLength){
        stat = pd_moveBitCursor(pctxt, (int)(bitLength - bitsConsumed));
    }
    else stat =(bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
    }}
    if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);

}


int asn1Init_e2ap_RICqueryFailure_protocolIEs_element(e2ap_RICqueryFailure_protocolIEs_element* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    OSCRTLMEMSET (&pvalue->value, 0, sizeof(pvalue->value));
    return 0;
}


//-----> chuaw có template rtxFreeASN1OpenType

#if 0
void asn1Free_e2ap_RICqueryFailure_protocolIEs_element(OSCTXT* pctxt, e2ap_RICqueryFailure_protocolIEs_element* pvalue)
{
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICqueryFailure_IEs_id_id_RICrequestID:
            // rtxFreeE2ap_RICrequestID(pvalue->value.u._e2ap_RICqueryFailure_IEs_id_id_RICrequestID);

            if(pvalue->value.i._e2ap_RICqueryFailure_id_RICrequestID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RICrequestID(pctxt, pvalue->value.u._e2ap_RICqueryFailure_IEs_id_id_RICrequestID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICqueryFailure_IEs_id_id_RICrequestID);
           // pvalue->value.u._e2ap_RICqueryFailure_IEs_id_id_RICrequestID = NULL;
           pvalue->value.u._e2ap_RICqueryFailure_IEs_id_RICrequestID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICqueryFailure_IEs_id_id_RANfunctionID:
            // rtxFreeE2ap_RANfunctionID(pvalue->value.u._e2ap_RICqueryFailure_IEs_id_id_RANfunctionID);

            if(pvalue->value.i._e2ap_RICqueryFailure_id_RANfunctionID!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_RANfunctionID(pctxt, pvalue->value.u._e2ap_RICqueryFailure_IEs_id_id_RANfunctionID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICqueryFailure_IEs_id_id_RANfunctionID);
           // pvalue->value.u._e2ap_RICqueryFailure_IEs_id_id_RANfunctionID = NULL;
           pvalue->value.u._e2ap_RICqueryFailure_IEs_id_RANfunctionID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICqueryFailure_IEs_id_id_Cause:
            // rtxFreeE2ap_Cause(pvalue->value.u._e2ap_RICqueryFailure_IEs_id_id_Cause);

            if(pvalue->value.i._e2ap_RICqueryFailure_id_Cause!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_Cause(pctxt, pvalue->value.u._e2ap_RICqueryFailure_IEs_id_id_Cause);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICqueryFailure_IEs_id_id_Cause);
           // pvalue->value.u._e2ap_RICqueryFailure_IEs_id_id_Cause = NULL;
           pvalue->value.u._e2ap_RICqueryFailure_IEs_id_Cause = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICqueryFailure_IEs_id_id_CriticalityDiagnostics:
            // rtxFreeE2ap_CriticalityDiagnostics(pvalue->value.u._e2ap_RICqueryFailure_IEs_id_id_CriticalityDiagnostics);

            if(pvalue->value.i._e2ap_RICqueryFailure_id_CriticalityDiagnostics!=NULL){// dungnm23 check lai nhe
            asn1Free_e2ap_CriticalityDiagnostics(pctxt, pvalue->value.u._e2ap_RICqueryFailure_IEs_id_id_CriticalityDiagnostics);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICqueryFailure_IEs_id_id_CriticalityDiagnostics);
           // pvalue->value.u._e2ap_RICqueryFailure_IEs_id_id_CriticalityDiagnostics = NULL;
           pvalue->value.u._e2ap_RICqueryFailure_IEs_id_CriticalityDiagnostics = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICqueryFailure_IEs_UNDEF_:
            rtxFreeASN1OpenType(pvalue->value.u.extElem1);
            break;
        default:
            break;
    }
}

int asn1PrtToStr_e2ap_RICqueryFailure_protocolIEs_element(OSCTXT* pctxt, e2ap_RICqueryFailure_protocolIEs_element* pvalue)
{
    int stat =0;
    RTXCTXTPUSHELEMNAME(pctxt, "e2ap_RICqueryFailure_protocolIEs_element");

    /*print id*/
    RTXCTXTPUSHELEMNAME(pctxt, "id");
        stat = asn1PrtToStr_e2ap_ProtocolIE_ID(pctxt, &pvalue->id);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print criticality*/
    RTXCTXTPUSHELEMNAME(pctxt, "criticality");
        stat = asn1PrtToStr_e2ap_Criticality(pctxt, &pvalue->criticality);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
    RTXCTXTPOPELEMNAME(pctxt);

    /*print value*/
    RTXCTXTPUSHELEMNAME(pctxt, "value");
        
        switch(pvalue->value.t){
            case T_E2AP_PDU_Contents_e2ap_RICqueryFailure_IEs_id_id_RICrequestID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RICrequestID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RICrequestID (pctxt, pvalue->value.u._e2ap_RICqueryFailure_IEs_id_id_RICrequestID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICqueryFailure_IEs_id_id_RANfunctionID:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "RANfunctionID");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_RANfunctionID (pctxt, pvalue->value.u._e2ap_RICqueryFailure_IEs_id_id_RANfunctionID);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICqueryFailure_IEs_id_id_Cause:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "Cause");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_Cause (pctxt, pvalue->value.u._e2ap_RICqueryFailure_IEs_id_id_Cause);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }
            case T_E2AP_PDU_Contents_e2ap_RICqueryFailure_IEs_id_id_CriticalityDiagnostics:
            {
                RTXCTXTPUSHELEMNAME (pctxt, "CriticalityDiagnostics");// dungnm23 check lai nhe -> xem là item_type hay field_name

                stat = asn1PrtToStr_e2ap_CriticalityDiagnostics (pctxt, pvalue->value.u._e2ap_RICqueryFailure_IEs_id_id_CriticalityDiagnostics);//dungnm23 check lai nhe
                if (stat != 0) return LOG_RTERR (pctxt, stat);

                RTXCTXTPOPELEMNAME (pctxt);
                break;
            }

            case T_E2AP_PDU_Contents_e2ap_RICqueryFailure_IEs_UNDEF_:
            {
                rtxPLogMsg(pctxt, "Extension element present - raw data not printed.\n");
                break;
            }

            default:
                stat = RTERR_INVOPT;
                return LOG_RTERR(pctxt, stat);
        }
    RTXCTXTPOPELEMNAME(pctxt);
    return (stat);
}
#endif


int asn1PrtToStr_e2ap_RICqueryFailure_protocolIEs_element (const char * name,
 e2ap_RICqueryFailure_protocolIEs_element* pvalue, 
 char * buffer, OSSIZE bufSize){
    if(rtPrintToStringOpenBrace(name, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_ProtocolIE_ID("id", &pvalue->id, buffer, bufSize)<0)
        return -1;
    if(asn1PrtToStr_e2ap_Criticality("criticality", &pvalue->criticality, buffer, bufSize)<0)
        return -1;
    if(rtPrintToStringOpenBrace("value", buffer, bufSize)<0)
        return -1;

    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICqueryFailure_IEs_id_RICrequestID:
            if(asn1PrtToStr_e2ap_RICrequestID("RICrequestID", 
                    pvalue->value.u._e2ap_RICqueryFailure_IEs_id_RICrequestID, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICqueryFailure_IEs_id_RANfunctionID:
            if(asn1PrtToStr_e2ap_RANfunctionID("RANfunctionID", 
                    pvalue->value.u._e2ap_RICqueryFailure_IEs_id_RANfunctionID, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICqueryFailure_IEs_id_Cause:
            if(asn1PrtToStr_e2ap_Cause("Cause", 
                    pvalue->value.u._e2ap_RICqueryFailure_IEs_id_Cause, buffer, bufSize)<0)
                return -1;
            break;    
        case T_E2AP_PDU_Contents_e2ap_RICqueryFailure_IEs_id_CriticalityDiagnostics:
            if(asn1PrtToStr_e2ap_CriticalityDiagnostics("CriticalityDiagnostics", 
                    pvalue->value.u._e2ap_RICqueryFailure_IEs_id_CriticalityDiagnostics, buffer, bufSize)<0)
                return -1;
            break;    
        default:
        if(0!=pvalue -> value.u.extElem1){
            rtPrintToStringIndent(buffer, bufSize);
            rtPrintToStringHexStr("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);

        }
        }
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;
    if(rtPrintToStringCloseBrace( buffer, bufSize)<0) return -1;

    return 0;

 }

 void asn1Free_e2ap_RICqueryFailure_protocolIEs_element(OSCTXT* pctxt, e2ap_RICqueryFailure_protocolIEs_element* pvalue){
    if(NULL==pvalue) return;
    switch(pvalue->value.t){
        case T_E2AP_PDU_Contents_e2ap_RICqueryFailure_IEs_id_RICrequestID:
            if(pvalue->value.u._e2ap_RICqueryFailure_IEs_id_RICrequestID!=NULL){
            asn1Free_e2ap_RICrequestID(pctxt, pvalue->value.u._e2ap_RICqueryFailure_IEs_id_RICrequestID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICqueryFailure_IEs_id_RICrequestID);
            pvalue->value.u._e2ap_RICqueryFailure_IEs_id_RICrequestID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICqueryFailure_IEs_id_RANfunctionID:
            if(pvalue->value.u._e2ap_RICqueryFailure_IEs_id_RANfunctionID!=NULL){
            asn1Free_e2ap_RANfunctionID(pctxt, pvalue->value.u._e2ap_RICqueryFailure_IEs_id_RANfunctionID);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICqueryFailure_IEs_id_RANfunctionID);
            pvalue->value.u._e2ap_RICqueryFailure_IEs_id_RANfunctionID = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICqueryFailure_IEs_id_Cause:
            if(pvalue->value.u._e2ap_RICqueryFailure_IEs_id_Cause!=NULL){
            asn1Free_e2ap_Cause(pctxt, pvalue->value.u._e2ap_RICqueryFailure_IEs_id_Cause);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICqueryFailure_IEs_id_Cause);
            pvalue->value.u._e2ap_RICqueryFailure_IEs_id_Cause = NULL;
            }
            break;
        case T_E2AP_PDU_Contents_e2ap_RICqueryFailure_IEs_id_CriticalityDiagnostics:
            if(pvalue->value.u._e2ap_RICqueryFailure_IEs_id_CriticalityDiagnostics!=NULL){
            asn1Free_e2ap_CriticalityDiagnostics(pctxt, pvalue->value.u._e2ap_RICqueryFailure_IEs_id_CriticalityDiagnostics);
            rtxMemFreePtr(pctxt, (void*)pvalue->value.u._e2ap_RICqueryFailure_IEs_id_CriticalityDiagnostics);
            pvalue->value.u._e2ap_RICqueryFailure_IEs_id_CriticalityDiagnostics = NULL;
            }
            break;
        default:
            break;


    }
 }

 

/*****************************************/
/*           RICqueryFailure                */
/*****************************************/
//2_container.c
/* 1. xxx_ProtocolIE -> mẫu cũ ở ie_big_msg */
EXTERN int asn1PE_e2ap_RICqueryFailure_protocolIEs (OSCTXT* pctxt, e2ap_RICqueryFailure_protocolIEs* pvalue)
{
    int stat =0;
    OSRTDListNode* pnode;
    OSUINT32 xx1;

    /*encode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pe_Length(pctxt, pvalue->count);
    if(stat<0) return LOG_RTERR(pctxt, stat);

    /*encode each element*/
    xx1 =0;
    for(pnode = pvalue->head; pnode != 0 && xx1<pvalue->count; pnode = pnode->next){
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE", xx1);
        stat = asn1PE_e2ap_RICqueryFailure_protocolIEs_element (pctxt, ((e2ap_RICqueryFailure_protocolIEs_element*)pnode->data));
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        xx1++;
        RTXCTXTPOPARRAYELEMNAME(pctxt);
    }

    return (stat);
}

EXTERN int  asn1PD_e2ap_RICqueryFailure_protocolIEs(OSCTXT* pctxt, e2ap_RICqueryFailure_protocolIEs* pvalue)
{
     int stat =0;
     OSRTDListNode* pnode;
     OSSIZE count =0;
     OSSIZE xx1=0;


     /*decode length determinant */
    PU_SETSIZECONSTRAINT(pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);
    stat = pd_Length64(pctxt, &count); //tai sao lai 64
    if(stat!=0) return LOG_RTERR(pctxt, stat);

    /*decode each element*/
    rtxDListInit(pvalue);

    for(xx1=0; xx1 < count; xx1++){
        e2ap_RICqueryFailure_protocolIEs_element* pdata;
        RTXCTXTPUSHARRAYELEMNAME(pctxt, "SEQUENCE",xx1);

        if(pnode == NULL) return LOG_RTERR(pctxt, RTERR_NOMEM);

        asn1Init_e2ap_RICqueryFailure_protocolIEs_element(pdata);
        rtxDListAppendNode(pvalue, pnode);
        stat = asn1PD_e2ap_RICqueryFailure_protocolIEs_element (pctxt, pdata);
        if(stat!=0) return LOG_RTERR(pctxt, stat);
        RTXCTXTPOPARRAYELEMNAME(pctxt);

    }
    return (stat);
}


int asn1Init_e2ap_RICqueryFailure_protocolIEs(e2ap_RICqueryFailure_protocolIEs* pvalue)
{
    if(0==pvalue) return RTERR_NULLPTR;
    rtxDListFastInit (pvalue);
    return 0;
}
#if 1 //ao that day
void asn1Free_e2ap_RICqueryFailure_protocolIEs(OSCTXT* pctxt, e2ap_RICqueryFailure_protocolIEs* pvalue)
{
    if(0==pvalue) return;   
    e2ap_RICqueryFailure_protocolIEs_element* pdata;
    OSRTDListNode* pnode=pvalue->head;
    while(0!=pnode){
        pdata = (e2ap_RICqueryFailure_protocolIEs_element*)pnode->data;
       // asn1Free_e2ap_RICqueryFailure_protocolIEs_element(pctxt, pdata);
        pnode = pnode->next;
    }
    rtxDListFreeAll(pctxt, pvalue);
}
#endif


EXTERN int asn1PrtToStr_e2ap_RICqueryFailure_protocolIEs(const char* name, e2ap_RICqueryFailure_protocolIEs* pvalue, char* buffer, OSSIZE bufSize)
{
    e2ap_RICqueryFailure_protocolIEs_element* pdata0;
    OSRTDListNode* pnode0;
    char nameBuf[256];
    char numBuf[32];
    OSUINT32 xx1=0;
    for(pnode0 = pvalue->head;  xx1 < pvalue->count && pnode0 != 0; pnode0 = pnode0->next, xx1++){
        pdata0 = (e2ap_RICqueryFailure_protocolIEs_element*)pnode0->data;
        rtxUIntToCharStr(xx1, numBuf, sizeof(numBuf), 0);
        rtxStrJoin(nameBuf, sizeof(nameBuf), name, "[", numBuf, "]", 0);
        #if 0
        if(asn1PrtToStr_e2ap_RICqueryFailure_protocolIEs_element(nameBuf, pdata0, buffer, bufSize) <0){
            return -1;
        }
        #endif
    }
    return 0;
}


/*2 . RICqueryFailure -> mẫu cũ ở seq_normal*/

int asn1PE_e2ap_RICqueryFailure (OSCTXT* pctxt, e2ap_RICqueryFailure* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   RTXCTXTPUSHTYPENAME(pctxt, "RICqueryFailure");
   /*extension bit*/
   extbit = (OSBOOL)(pvalue->extElem1.count > 0);
   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);


   /*encode root elements*/   
   /* encode field protocolIEs - id = -1*/  
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
   stat = asn1PE_e2ap_RICqueryFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
   if(stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);

   /*
   if (pvalue->extElem1Present) {
      stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }
   */

   if(extbit) {
      /*encode extension optional bits length */
      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode optional bit*/
      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*encode extension elements*/
      if (pvalue->extElem1.count > 0) {
         //stat = pe_OpenType (pctxt, pvalue->extElem1.numocts, pvalue->extElem1.data);
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR(pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME(pctxt);
   return (stat);
}

int asn1PD_e2ap_RICqueryFailure (OSCTXT* pctxt, e2ap_RICqueryFailure* pvalue)
{
   int stat =0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME(pctxt, "RICqueryFailure");

   /*extension bit*/
   stat = DEC_BIT(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR(pctxt, stat);
   rtxDListInit(&pvalue->extElem1); 

   /*optional bits*/
   for(i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT(pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   }

   /*decode root elements*/
   /* decode field protocolIEs */
   RTXCTXTPUSHELEMNAME(pctxt, "protocolIEs");
      stat = asn1PD_e2ap_RICqueryFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
      if (stat != 0) return LOG_RTERR(pctxt, stat);
   RTXCTXTPOPELEMNAME(pctxt);


   /*decode extension elements*/
   if(extbit) {
      OSOCTET *poptbits;
      /*decode optional bits length */
      stat = pd_SmallLength(pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR(pctxt, stat);

      /*decode optional bits*/
      poptbits = (OSOCTET*)rtxMemAlloc(pctxt, bitcnt);
      if(0==poptbits) return LOG_RTERR(pctxt, RTERR_NOMEM);

      for(i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT(pctxt, &poptbits[i_]);
         if (stat != 0) {
            rtxMemFreePtr(pctxt, poptbits);
            return LOG_RTERR(pctxt, stat);
         }
      }

      for(i_ = 0; i_ < bitcnt; i_++) {
         if(stat != 0) break;
         if(poptbits[i_]) {
            /*decode extension element*/
            stat = pd_OpenType (pctxt, &openType, &openType.numocts);

            if(0==stat){
               pOpenType = rtxMemAllocType(pctxt, ASN1OpenType);
               if(0!=pOpenType){
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend(pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else{
               LOG_RTERR(pctxt, stat);
               break;
            }
         }
         else{//unknown element
            rtxDListAppend(pctxt, &pvalue->extElem1, 0);
         }
      }
      rtxMemFreePtr(pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME(pctxt);

   return (stat);

}

int asn1Init_e2ap_RICqueryFailure (e2ap_RICqueryFailure* pvalue)
{
   if(0==pvalue) return RTERR_NULLPTR;
   asn1Init_e2ap_RICqueryFailure_protocolIEs(&pvalue->protocolIEs);
   rtxDListFastInit(&pvalue->extElem1);
   return 0;
}

void asn1Free_e2ap_RICqueryFailure (OSCTXT* pctxt, e2ap_RICqueryFailure* pvalue)
{
   if(0==pvalue) return;
   asn1Free_e2ap_RICqueryFailure_protocolIEs(pctxt, &pvalue->protocolIEs);
   rtxMemFreeOpenSeqExt(pctxt, &pvalue->extElem1);
}

int asn1PrtToStr_e2ap_RICqueryFailure (const char* name, e2ap_RICqueryFailure* pvalue, char* buffer, OSSIZE bufSize)
{
   if(rtPrintToStringOpenBrace(name, buffer, bufSize) < 0) 
   {
      return -1;
   }

   if(asn1PrtToStr_e2ap_RICqueryFailure_protocolIEs("protocolIEs", &pvalue->protocolIEs, buffer, bufSize) <0){
      return -1;
   }

   /*assum there is an extension*/
   if(rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringCloseBrace(buffer, bufSize) < 0) return -1;
   return 0;
}